var toaster = (function (exports) {
	'use strict';

	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function commonjsRequire () {
		throw new Error('Dynamic requires are not currently supported by rollup-plugin-commonjs');
	}

	function unwrapExports (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
	}

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	var check = function (it) {
	  return it && it.Math == Math && it;
	};

	// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
	var global_1 =
	  // eslint-disable-next-line no-undef
	  check(typeof globalThis == 'object' && globalThis) ||
	  check(typeof window == 'object' && window) ||
	  check(typeof self == 'object' && self) ||
	  check(typeof commonjsGlobal == 'object' && commonjsGlobal) ||
	  // eslint-disable-next-line no-new-func
	  (function () { return this; })() || Function('return this')();

	var fails = function (exec) {
	  try {
	    return !!exec();
	  } catch (error) {
	    return true;
	  }
	};

	// Thank's IE8 for his funny defineProperty
	var descriptors = !fails(function () {
	  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] != 7;
	});

	var nativePropertyIsEnumerable$1 = {}.propertyIsEnumerable;
	var getOwnPropertyDescriptor$5 = Object.getOwnPropertyDescriptor;

	// Nashorn ~ JDK8 bug
	var NASHORN_BUG = getOwnPropertyDescriptor$5 && !nativePropertyIsEnumerable$1.call({ 1: 2 }, 1);

	// `Object.prototype.propertyIsEnumerable` method implementation
	// https://tc39.github.io/ecma262/#sec-object.prototype.propertyisenumerable
	var f$7 = NASHORN_BUG ? function propertyIsEnumerable(V) {
	  var descriptor = getOwnPropertyDescriptor$5(this, V);
	  return !!descriptor && descriptor.enumerable;
	} : nativePropertyIsEnumerable$1;

	var objectPropertyIsEnumerable = {
		f: f$7
	};

	var createPropertyDescriptor = function (bitmap, value) {
	  return {
	    enumerable: !(bitmap & 1),
	    configurable: !(bitmap & 2),
	    writable: !(bitmap & 4),
	    value: value
	  };
	};

	var toString$3 = {}.toString;

	var classofRaw = function (it) {
	  return toString$3.call(it).slice(8, -1);
	};

	var split = ''.split;

	// fallback for non-array-like ES3 and non-enumerable old V8 strings
	var indexedObject = fails(function () {
	  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
	  // eslint-disable-next-line no-prototype-builtins
	  return !Object('z').propertyIsEnumerable(0);
	}) ? function (it) {
	  return classofRaw(it) == 'String' ? split.call(it, '') : Object(it);
	} : Object;

	// `RequireObjectCoercible` abstract operation
	// https://tc39.github.io/ecma262/#sec-requireobjectcoercible
	var requireObjectCoercible = function (it) {
	  if (it == undefined) throw TypeError("Can't call method on " + it);
	  return it;
	};

	// toObject with fallback for non-array-like ES3 strings



	var toIndexedObject = function (it) {
	  return indexedObject(requireObjectCoercible(it));
	};

	var isObject$3 = function (it) {
	  return typeof it === 'object' ? it !== null : typeof it === 'function';
	};

	// `ToPrimitive` abstract operation
	// https://tc39.github.io/ecma262/#sec-toprimitive
	// instead of the ES6 spec version, we didn't implement @@toPrimitive case
	// and the second argument - flag - preferred type is a string
	var toPrimitive = function (input, PREFERRED_STRING) {
	  if (!isObject$3(input)) return input;
	  var fn, val;
	  if (PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject$3(val = fn.call(input))) return val;
	  if (typeof (fn = input.valueOf) == 'function' && !isObject$3(val = fn.call(input))) return val;
	  if (!PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject$3(val = fn.call(input))) return val;
	  throw TypeError("Can't convert object to primitive value");
	};

	var hasOwnProperty$i = {}.hasOwnProperty;

	var has$1 = function (it, key) {
	  return hasOwnProperty$i.call(it, key);
	};

	var document$3 = global_1.document;
	// typeof document.createElement is 'object' in old IE
	var EXISTS = isObject$3(document$3) && isObject$3(document$3.createElement);

	var documentCreateElement = function (it) {
	  return EXISTS ? document$3.createElement(it) : {};
	};

	// Thank's IE8 for his funny defineProperty
	var ie8DomDefine = !descriptors && !fails(function () {
	  return Object.defineProperty(documentCreateElement('div'), 'a', {
	    get: function () { return 7; }
	  }).a != 7;
	});

	var nativeGetOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor;

	// `Object.getOwnPropertyDescriptor` method
	// https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptor
	var f$6 = descriptors ? nativeGetOwnPropertyDescriptor$1 : function getOwnPropertyDescriptor(O, P) {
	  O = toIndexedObject(O);
	  P = toPrimitive(P, true);
	  if (ie8DomDefine) try {
	    return nativeGetOwnPropertyDescriptor$1(O, P);
	  } catch (error) { /* empty */ }
	  if (has$1(O, P)) return createPropertyDescriptor(!objectPropertyIsEnumerable.f.call(O, P), O[P]);
	};

	var objectGetOwnPropertyDescriptor = {
		f: f$6
	};

	var anObject = function (it) {
	  if (!isObject$3(it)) {
	    throw TypeError(String(it) + ' is not an object');
	  } return it;
	};

	var nativeDefineProperty$1 = Object.defineProperty;

	// `Object.defineProperty` method
	// https://tc39.github.io/ecma262/#sec-object.defineproperty
	var f$5 = descriptors ? nativeDefineProperty$1 : function defineProperty(O, P, Attributes) {
	  anObject(O);
	  P = toPrimitive(P, true);
	  anObject(Attributes);
	  if (ie8DomDefine) try {
	    return nativeDefineProperty$1(O, P, Attributes);
	  } catch (error) { /* empty */ }
	  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported');
	  if ('value' in Attributes) O[P] = Attributes.value;
	  return O;
	};

	var objectDefineProperty = {
		f: f$5
	};

	var createNonEnumerableProperty = descriptors ? function (object, key, value) {
	  return objectDefineProperty.f(object, key, createPropertyDescriptor(1, value));
	} : function (object, key, value) {
	  object[key] = value;
	  return object;
	};

	var setGlobal = function (key, value) {
	  try {
	    createNonEnumerableProperty(global_1, key, value);
	  } catch (error) {
	    global_1[key] = value;
	  } return value;
	};

	var SHARED = '__core-js_shared__';
	var store$1 = global_1[SHARED] || setGlobal(SHARED, {});

	var sharedStore = store$1;

	var functionToString = Function.toString;

	// this helper broken in `3.4.1-3.4.4`, so we can't use `shared` helper
	if (typeof sharedStore.inspectSource != 'function') {
	  sharedStore.inspectSource = function (it) {
	    return functionToString.call(it);
	  };
	}

	var inspectSource = sharedStore.inspectSource;

	var WeakMap$3 = global_1.WeakMap;

	var nativeWeakMap = typeof WeakMap$3 === 'function' && /native code/.test(inspectSource(WeakMap$3));

	var shared = createCommonjsModule(function (module) {
	(module.exports = function (key, value) {
	  return sharedStore[key] || (sharedStore[key] = value !== undefined ? value : {});
	})('versions', []).push({
	  version: '3.7.0',
	  mode: 'global',
	  copyright: 'Â© 2020 Denis Pushkarev (zloirock.ru)'
	});
	});

	var id$1 = 0;
	var postfix = Math.random();

	var uid = function (key) {
	  return 'Symbol(' + String(key === undefined ? '' : key) + ')_' + (++id$1 + postfix).toString(36);
	};

	var keys$3 = shared('keys');

	var sharedKey = function (key) {
	  return keys$3[key] || (keys$3[key] = uid(key));
	};

	var hiddenKeys$1 = {};

	var WeakMap$2 = global_1.WeakMap;
	var set$3, get$4, has;

	var enforce = function (it) {
	  return has(it) ? get$4(it) : set$3(it, {});
	};

	var getterFor = function (TYPE) {
	  return function (it) {
	    var state;
	    if (!isObject$3(it) || (state = get$4(it)).type !== TYPE) {
	      throw TypeError('Incompatible receiver, ' + TYPE + ' required');
	    } return state;
	  };
	};

	if (nativeWeakMap) {
	  var store = sharedStore.state || (sharedStore.state = new WeakMap$2());
	  var wmget = store.get;
	  var wmhas = store.has;
	  var wmset = store.set;
	  set$3 = function (it, metadata) {
	    metadata.facade = it;
	    wmset.call(store, it, metadata);
	    return metadata;
	  };
	  get$4 = function (it) {
	    return wmget.call(store, it) || {};
	  };
	  has = function (it) {
	    return wmhas.call(store, it);
	  };
	} else {
	  var STATE = sharedKey('state');
	  hiddenKeys$1[STATE] = true;
	  set$3 = function (it, metadata) {
	    metadata.facade = it;
	    createNonEnumerableProperty(it, STATE, metadata);
	    return metadata;
	  };
	  get$4 = function (it) {
	    return has$1(it, STATE) ? it[STATE] : {};
	  };
	  has = function (it) {
	    return has$1(it, STATE);
	  };
	}

	var internalState = {
	  set: set$3,
	  get: get$4,
	  has: has,
	  enforce: enforce,
	  getterFor: getterFor
	};

	var redefine = createCommonjsModule(function (module) {
	var getInternalState = internalState.get;
	var enforceInternalState = internalState.enforce;
	var TEMPLATE = String(String).split('String');

	(module.exports = function (O, key, value, options) {
	  var unsafe = options ? !!options.unsafe : false;
	  var simple = options ? !!options.enumerable : false;
	  var noTargetGet = options ? !!options.noTargetGet : false;
	  var state;
	  if (typeof value == 'function') {
	    if (typeof key == 'string' && !has$1(value, 'name')) {
	      createNonEnumerableProperty(value, 'name', key);
	    }
	    state = enforceInternalState(value);
	    if (!state.source) {
	      state.source = TEMPLATE.join(typeof key == 'string' ? key : '');
	    }
	  }
	  if (O === global_1) {
	    if (simple) O[key] = value;
	    else setGlobal(key, value);
	    return;
	  } else if (!unsafe) {
	    delete O[key];
	  } else if (!noTargetGet && O[key]) {
	    simple = true;
	  }
	  if (simple) O[key] = value;
	  else createNonEnumerableProperty(O, key, value);
	// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
	})(Function.prototype, 'toString', function toString() {
	  return typeof this == 'function' && getInternalState(this).source || inspectSource(this);
	});
	});

	var path$1 = global_1;

	var aFunction$1 = function (variable) {
	  return typeof variable == 'function' ? variable : undefined;
	};

	var getBuiltIn = function (namespace, method) {
	  return arguments.length < 2 ? aFunction$1(path$1[namespace]) || aFunction$1(global_1[namespace])
	    : path$1[namespace] && path$1[namespace][method] || global_1[namespace] && global_1[namespace][method];
	};

	var ceil = Math.ceil;
	var floor$2 = Math.floor;

	// `ToInteger` abstract operation
	// https://tc39.github.io/ecma262/#sec-tointeger
	var toInteger$1 = function (argument) {
	  return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor$2 : ceil)(argument);
	};

	var min$9 = Math.min;

	// `ToLength` abstract operation
	// https://tc39.github.io/ecma262/#sec-tolength
	var toLength = function (argument) {
	  return argument > 0 ? min$9(toInteger$1(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
	};

	var max$5 = Math.max;
	var min$8 = Math.min;

	// Helper for a popular repeating case of the spec:
	// Let integer be ? ToInteger(index).
	// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
	var toAbsoluteIndex = function (index, length) {
	  var integer = toInteger$1(index);
	  return integer < 0 ? max$5(integer + length, 0) : min$8(integer, length);
	};

	// `Array.prototype.{ indexOf, includes }` methods implementation
	var createMethod$5 = function (IS_INCLUDES) {
	  return function ($this, el, fromIndex) {
	    var O = toIndexedObject($this);
	    var length = toLength(O.length);
	    var index = toAbsoluteIndex(fromIndex, length);
	    var value;
	    // Array#includes uses SameValueZero equality algorithm
	    // eslint-disable-next-line no-self-compare
	    if (IS_INCLUDES && el != el) while (length > index) {
	      value = O[index++];
	      // eslint-disable-next-line no-self-compare
	      if (value != value) return true;
	    // Array#indexOf ignores holes, Array#includes - not
	    } else for (;length > index; index++) {
	      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
	    } return !IS_INCLUDES && -1;
	  };
	};

	var arrayIncludes = {
	  // `Array.prototype.includes` method
	  // https://tc39.github.io/ecma262/#sec-array.prototype.includes
	  includes: createMethod$5(true),
	  // `Array.prototype.indexOf` method
	  // https://tc39.github.io/ecma262/#sec-array.prototype.indexof
	  indexOf: createMethod$5(false)
	};

	var indexOf = arrayIncludes.indexOf;


	var objectKeysInternal = function (object, names) {
	  var O = toIndexedObject(object);
	  var i = 0;
	  var result = [];
	  var key;
	  for (key in O) !has$1(hiddenKeys$1, key) && has$1(O, key) && result.push(key);
	  // Don't enum bug & hidden keys
	  while (names.length > i) if (has$1(O, key = names[i++])) {
	    ~indexOf(result, key) || result.push(key);
	  }
	  return result;
	};

	// IE8- don't enum bug keys
	var enumBugKeys = [
	  'constructor',
	  'hasOwnProperty',
	  'isPrototypeOf',
	  'propertyIsEnumerable',
	  'toLocaleString',
	  'toString',
	  'valueOf'
	];

	var hiddenKeys = enumBugKeys.concat('length', 'prototype');

	// `Object.getOwnPropertyNames` method
	// https://tc39.github.io/ecma262/#sec-object.getownpropertynames
	var f$4 = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
	  return objectKeysInternal(O, hiddenKeys);
	};

	var objectGetOwnPropertyNames = {
		f: f$4
	};

	var f$3 = Object.getOwnPropertySymbols;

	var objectGetOwnPropertySymbols = {
		f: f$3
	};

	// all object keys, includes non-enumerable and symbols
	var ownKeys$1 = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
	  var keys = objectGetOwnPropertyNames.f(anObject(it));
	  var getOwnPropertySymbols = objectGetOwnPropertySymbols.f;
	  return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;
	};

	var copyConstructorProperties = function (target, source) {
	  var keys = ownKeys$1(source);
	  var defineProperty = objectDefineProperty.f;
	  var getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;
	  for (var i = 0; i < keys.length; i++) {
	    var key = keys[i];
	    if (!has$1(target, key)) defineProperty(target, key, getOwnPropertyDescriptor(source, key));
	  }
	};

	var replacement = /#|\.prototype\./;

	var isForced = function (feature, detection) {
	  var value = data[normalize$1(feature)];
	  return value == POLYFILL ? true
	    : value == NATIVE ? false
	    : typeof detection == 'function' ? fails(detection)
	    : !!detection;
	};

	var normalize$1 = isForced.normalize = function (string) {
	  return String(string).replace(replacement, '.').toLowerCase();
	};

	var data = isForced.data = {};
	var NATIVE = isForced.NATIVE = 'N';
	var POLYFILL = isForced.POLYFILL = 'P';

	var isForced_1 = isForced;

	var getOwnPropertyDescriptor$4 = objectGetOwnPropertyDescriptor.f;






	/*
	  options.target      - name of the target object
	  options.global      - target is the global object
	  options.stat        - export as static methods of target
	  options.proto       - export as prototype methods of target
	  options.real        - real prototype method for the `pure` version
	  options.forced      - export even if the native feature is available
	  options.bind        - bind methods to the target, required for the `pure` version
	  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version
	  options.unsafe      - use the simple assignment of property instead of delete + defineProperty
	  options.sham        - add a flag to not completely full polyfills
	  options.enumerable  - export as enumerable property
	  options.noTargetGet - prevent calling a getter on target
	*/
	var _export = function (options, source) {
	  var TARGET = options.target;
	  var GLOBAL = options.global;
	  var STATIC = options.stat;
	  var FORCED, target, key, targetProperty, sourceProperty, descriptor;
	  if (GLOBAL) {
	    target = global_1;
	  } else if (STATIC) {
	    target = global_1[TARGET] || setGlobal(TARGET, {});
	  } else {
	    target = (global_1[TARGET] || {}).prototype;
	  }
	  if (target) for (key in source) {
	    sourceProperty = source[key];
	    if (options.noTargetGet) {
	      descriptor = getOwnPropertyDescriptor$4(target, key);
	      targetProperty = descriptor && descriptor.value;
	    } else targetProperty = target[key];
	    FORCED = isForced_1(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
	    // contained in target
	    if (!FORCED && targetProperty !== undefined) {
	      if (typeof sourceProperty === typeof targetProperty) continue;
	      copyConstructorProperties(sourceProperty, targetProperty);
	    }
	    // add a flag to not completely full polyfills
	    if (options.sham || (targetProperty && targetProperty.sham)) {
	      createNonEnumerableProperty(sourceProperty, 'sham', true);
	    }
	    // extend global
	    redefine(target, key, sourceProperty, options);
	  }
	};

	var aFunction = function (it) {
	  if (typeof it != 'function') {
	    throw TypeError(String(it) + ' is not a function');
	  } return it;
	};

	// `ToObject` abstract operation
	// https://tc39.github.io/ecma262/#sec-toobject
	var toObject = function (argument) {
	  return Object(requireObjectCoercible(argument));
	};

	// `Array.prototype.{ reduce, reduceRight }` methods implementation
	var createMethod$4 = function (IS_RIGHT) {
	  return function (that, callbackfn, argumentsLength, memo) {
	    aFunction(callbackfn);
	    var O = toObject(that);
	    var self = indexedObject(O);
	    var length = toLength(O.length);
	    var index = IS_RIGHT ? length - 1 : 0;
	    var i = IS_RIGHT ? -1 : 1;
	    if (argumentsLength < 2) while (true) {
	      if (index in self) {
	        memo = self[index];
	        index += i;
	        break;
	      }
	      index += i;
	      if (IS_RIGHT ? index < 0 : length <= index) {
	        throw TypeError('Reduce of empty array with no initial value');
	      }
	    }
	    for (;IS_RIGHT ? index >= 0 : length > index; index += i) if (index in self) {
	      memo = callbackfn(memo, self[index], index, O);
	    }
	    return memo;
	  };
	};

	var arrayReduce = {
	  // `Array.prototype.reduce` method
	  // https://tc39.github.io/ecma262/#sec-array.prototype.reduce
	  left: createMethod$4(false),
	  // `Array.prototype.reduceRight` method
	  // https://tc39.github.io/ecma262/#sec-array.prototype.reduceright
	  right: createMethod$4(true)
	};

	var arrayMethodIsStrict = function (METHOD_NAME, argument) {
	  var method = [][METHOD_NAME];
	  return !!method && fails(function () {
	    // eslint-disable-next-line no-useless-call,no-throw-literal
	    method.call(null, argument || function () { throw 1; }, 1);
	  });
	};

	var defineProperty$9 = Object.defineProperty;
	var cache = {};

	var thrower = function (it) { throw it; };

	var arrayMethodUsesToLength = function (METHOD_NAME, options) {
	  if (has$1(cache, METHOD_NAME)) return cache[METHOD_NAME];
	  if (!options) options = {};
	  var method = [][METHOD_NAME];
	  var ACCESSORS = has$1(options, 'ACCESSORS') ? options.ACCESSORS : false;
	  var argument0 = has$1(options, 0) ? options[0] : thrower;
	  var argument1 = has$1(options, 1) ? options[1] : undefined;

	  return cache[METHOD_NAME] = !!method && !fails(function () {
	    if (ACCESSORS && !descriptors) return true;
	    var O = { length: -1 };

	    if (ACCESSORS) defineProperty$9(O, 1, { enumerable: true, get: thrower });
	    else O[1] = 1;

	    method.call(O, argument0, argument1);
	  });
	};

	var engineUserAgent = getBuiltIn('navigator', 'userAgent') || '';

	var process$4 = global_1.process;
	var versions = process$4 && process$4.versions;
	var v8 = versions && versions.v8;
	var match, version$1;

	if (v8) {
	  match = v8.split('.');
	  version$1 = match[0] + match[1];
	} else if (engineUserAgent) {
	  match = engineUserAgent.match(/Edge\/(\d+)/);
	  if (!match || match[1] >= 74) {
	    match = engineUserAgent.match(/Chrome\/(\d+)/);
	    if (match) version$1 = match[1];
	  }
	}

	var engineV8Version = version$1 && +version$1;

	var engineIsNode = classofRaw(global_1.process) == 'process';

	var $reduce = arrayReduce.left;





	var STRICT_METHOD$6 = arrayMethodIsStrict('reduce');
	var USES_TO_LENGTH$b = arrayMethodUsesToLength('reduce', { 1: 0 });
	// Chrome 80-82 has a critical bug
	// https://bugs.chromium.org/p/chromium/issues/detail?id=1049982
	var CHROME_BUG = !engineIsNode && engineV8Version > 79 && engineV8Version < 83;

	// `Array.prototype.reduce` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.reduce
	_export({ target: 'Array', proto: true, forced: !STRICT_METHOD$6 || !USES_TO_LENGTH$b || CHROME_BUG }, {
	  reduce: function reduce(callbackfn /* , initialValue */) {
	    return $reduce(this, callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	// `Object.keys` method
	// https://tc39.github.io/ecma262/#sec-object.keys
	var objectKeys = Object.keys || function keys(O) {
	  return objectKeysInternal(O, enumBugKeys);
	};

	var FAILS_ON_PRIMITIVES = fails(function () { objectKeys(1); });

	// `Object.keys` method
	// https://tc39.github.io/ecma262/#sec-object.keys
	_export({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES }, {
	  keys: function keys(it) {
	    return objectKeys(toObject(it));
	  }
	});

	// optional / simple context binding
	var functionBindContext = function (fn, that, length) {
	  aFunction(fn);
	  if (that === undefined) return fn;
	  switch (length) {
	    case 0: return function () {
	      return fn.call(that);
	    };
	    case 1: return function (a) {
	      return fn.call(that, a);
	    };
	    case 2: return function (a, b) {
	      return fn.call(that, a, b);
	    };
	    case 3: return function (a, b, c) {
	      return fn.call(that, a, b, c);
	    };
	  }
	  return function (/* ...args */) {
	    return fn.apply(that, arguments);
	  };
	};

	// `IsArray` abstract operation
	// https://tc39.github.io/ecma262/#sec-isarray
	var isArray$3 = Array.isArray || function isArray(arg) {
	  return classofRaw(arg) == 'Array';
	};

	var nativeSymbol = !!Object.getOwnPropertySymbols && !fails(function () {
	  // Chrome 38 Symbol has incorrect toString conversion
	  // eslint-disable-next-line no-undef
	  return !String(Symbol());
	});

	var useSymbolAsUid = nativeSymbol
	  // eslint-disable-next-line no-undef
	  && !Symbol.sham
	  // eslint-disable-next-line no-undef
	  && typeof Symbol.iterator == 'symbol';

	var WellKnownSymbolsStore$1 = shared('wks');
	var Symbol$4 = global_1.Symbol;
	var createWellKnownSymbol = useSymbolAsUid ? Symbol$4 : Symbol$4 && Symbol$4.withoutSetter || uid;

	var wellKnownSymbol = function (name) {
	  if (!has$1(WellKnownSymbolsStore$1, name)) {
	    if (nativeSymbol && has$1(Symbol$4, name)) WellKnownSymbolsStore$1[name] = Symbol$4[name];
	    else WellKnownSymbolsStore$1[name] = createWellKnownSymbol('Symbol.' + name);
	  } return WellKnownSymbolsStore$1[name];
	};

	var SPECIES$6 = wellKnownSymbol('species');

	// `ArraySpeciesCreate` abstract operation
	// https://tc39.github.io/ecma262/#sec-arrayspeciescreate
	var arraySpeciesCreate = function (originalArray, length) {
	  var C;
	  if (isArray$3(originalArray)) {
	    C = originalArray.constructor;
	    // cross-realm fallback
	    if (typeof C == 'function' && (C === Array || isArray$3(C.prototype))) C = undefined;
	    else if (isObject$3(C)) {
	      C = C[SPECIES$6];
	      if (C === null) C = undefined;
	    }
	  } return new (C === undefined ? Array : C)(length === 0 ? 0 : length);
	};

	var push = [].push;

	// `Array.prototype.{ forEach, map, filter, some, every, find, findIndex }` methods implementation
	var createMethod$3 = function (TYPE) {
	  var IS_MAP = TYPE == 1;
	  var IS_FILTER = TYPE == 2;
	  var IS_SOME = TYPE == 3;
	  var IS_EVERY = TYPE == 4;
	  var IS_FIND_INDEX = TYPE == 6;
	  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
	  return function ($this, callbackfn, that, specificCreate) {
	    var O = toObject($this);
	    var self = indexedObject(O);
	    var boundFunction = functionBindContext(callbackfn, that, 3);
	    var length = toLength(self.length);
	    var index = 0;
	    var create = specificCreate || arraySpeciesCreate;
	    var target = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
	    var value, result;
	    for (;length > index; index++) if (NO_HOLES || index in self) {
	      value = self[index];
	      result = boundFunction(value, index, O);
	      if (TYPE) {
	        if (IS_MAP) target[index] = result; // map
	        else if (result) switch (TYPE) {
	          case 3: return true;              // some
	          case 5: return value;             // find
	          case 6: return index;             // findIndex
	          case 2: push.call(target, value); // filter
	        } else if (IS_EVERY) return false;  // every
	      }
	    }
	    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
	  };
	};

	var arrayIteration = {
	  // `Array.prototype.forEach` method
	  // https://tc39.github.io/ecma262/#sec-array.prototype.foreach
	  forEach: createMethod$3(0),
	  // `Array.prototype.map` method
	  // https://tc39.github.io/ecma262/#sec-array.prototype.map
	  map: createMethod$3(1),
	  // `Array.prototype.filter` method
	  // https://tc39.github.io/ecma262/#sec-array.prototype.filter
	  filter: createMethod$3(2),
	  // `Array.prototype.some` method
	  // https://tc39.github.io/ecma262/#sec-array.prototype.some
	  some: createMethod$3(3),
	  // `Array.prototype.every` method
	  // https://tc39.github.io/ecma262/#sec-array.prototype.every
	  every: createMethod$3(4),
	  // `Array.prototype.find` method
	  // https://tc39.github.io/ecma262/#sec-array.prototype.find
	  find: createMethod$3(5),
	  // `Array.prototype.findIndex` method
	  // https://tc39.github.io/ecma262/#sec-array.prototype.findIndex
	  findIndex: createMethod$3(6)
	};

	var $forEach$1 = arrayIteration.forEach;



	var STRICT_METHOD$5 = arrayMethodIsStrict('forEach');
	var USES_TO_LENGTH$a = arrayMethodUsesToLength('forEach');

	// `Array.prototype.forEach` method implementation
	// https://tc39.github.io/ecma262/#sec-array.prototype.foreach
	var arrayForEach = (!STRICT_METHOD$5 || !USES_TO_LENGTH$a) ? function forEach(callbackfn /* , thisArg */) {
	  return $forEach$1(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	} : [].forEach;

	// `Array.prototype.forEach` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.foreach
	_export({ target: 'Array', proto: true, forced: [].forEach != arrayForEach }, {
	  forEach: arrayForEach
	});

	var MATCH$2 = wellKnownSymbol('match');

	// `IsRegExp` abstract operation
	// https://tc39.github.io/ecma262/#sec-isregexp
	var isRegexp = function (it) {
	  var isRegExp;
	  return isObject$3(it) && ((isRegExp = it[MATCH$2]) !== undefined ? !!isRegExp : classofRaw(it) == 'RegExp');
	};

	var notARegexp = function (it) {
	  if (isRegexp(it)) {
	    throw TypeError("The method doesn't accept regular expressions");
	  } return it;
	};

	var MATCH$1 = wellKnownSymbol('match');

	var correctIsRegexpLogic = function (METHOD_NAME) {
	  var regexp = /./;
	  try {
	    '/./'[METHOD_NAME](regexp);
	  } catch (error1) {
	    try {
	      regexp[MATCH$1] = false;
	      return '/./'[METHOD_NAME](regexp);
	    } catch (error2) { /* empty */ }
	  } return false;
	};

	var getOwnPropertyDescriptor$3 = objectGetOwnPropertyDescriptor.f;






	var nativeStartsWith = ''.startsWith;
	var min$7 = Math.min;

	var CORRECT_IS_REGEXP_LOGIC$1 = correctIsRegexpLogic('startsWith');
	// https://github.com/zloirock/core-js/pull/702
	var MDN_POLYFILL_BUG$1 = !CORRECT_IS_REGEXP_LOGIC$1 && !!function () {
	  var descriptor = getOwnPropertyDescriptor$3(String.prototype, 'startsWith');
	  return descriptor && !descriptor.writable;
	}();

	// `String.prototype.startsWith` method
	// https://tc39.github.io/ecma262/#sec-string.prototype.startswith
	_export({ target: 'String', proto: true, forced: !MDN_POLYFILL_BUG$1 && !CORRECT_IS_REGEXP_LOGIC$1 }, {
	  startsWith: function startsWith(searchString /* , position = 0 */) {
	    var that = String(requireObjectCoercible(this));
	    notARegexp(searchString);
	    var index = toLength(min$7(arguments.length > 1 ? arguments[1] : undefined, that.length));
	    var search = String(searchString);
	    return nativeStartsWith
	      ? nativeStartsWith.call(that, search, index)
	      : that.slice(index, index + search.length) === search;
	  }
	});

	// iterable DOM collections
	// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods
	var domIterables = {
	  CSSRuleList: 0,
	  CSSStyleDeclaration: 0,
	  CSSValueList: 0,
	  ClientRectList: 0,
	  DOMRectList: 0,
	  DOMStringList: 0,
	  DOMTokenList: 1,
	  DataTransferItemList: 0,
	  FileList: 0,
	  HTMLAllCollection: 0,
	  HTMLCollection: 0,
	  HTMLFormElement: 0,
	  HTMLSelectElement: 0,
	  MediaList: 0,
	  MimeTypeArray: 0,
	  NamedNodeMap: 0,
	  NodeList: 1,
	  PaintRequestList: 0,
	  Plugin: 0,
	  PluginArray: 0,
	  SVGLengthList: 0,
	  SVGNumberList: 0,
	  SVGPathSegList: 0,
	  SVGPointList: 0,
	  SVGStringList: 0,
	  SVGTransformList: 0,
	  SourceBufferList: 0,
	  StyleSheetList: 0,
	  TextTrackCueList: 0,
	  TextTrackList: 0,
	  TouchList: 0
	};

	for (var COLLECTION_NAME$1 in domIterables) {
	  var Collection$1 = global_1[COLLECTION_NAME$1];
	  var CollectionPrototype$1 = Collection$1 && Collection$1.prototype;
	  // some Chrome versions have non-configurable methods on DOMTokenList
	  if (CollectionPrototype$1 && CollectionPrototype$1.forEach !== arrayForEach) try {
	    createNonEnumerableProperty(CollectionPrototype$1, 'forEach', arrayForEach);
	  } catch (error) {
	    CollectionPrototype$1.forEach = arrayForEach;
	  }
	}

	function _typeof(obj) {
	  "@babel/helpers - typeof";

	  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
	    _typeof = function (obj) {
	      return typeof obj;
	    };
	  } else {
	    _typeof = function (obj) {
	      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
	    };
	  }

	  return _typeof(obj);
	}

	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	}

	function _defineProperties(target, props) {
	  for (var i = 0; i < props.length; i++) {
	    var descriptor = props[i];
	    descriptor.enumerable = descriptor.enumerable || false;
	    descriptor.configurable = true;
	    if ("value" in descriptor) descriptor.writable = true;
	    Object.defineProperty(target, descriptor.key, descriptor);
	  }
	}

	function _createClass(Constructor, protoProps, staticProps) {
	  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
	  if (staticProps) _defineProperties(Constructor, staticProps);
	  return Constructor;
	}

	function _defineProperty(obj, key, value) {
	  if (key in obj) {
	    Object.defineProperty(obj, key, {
	      value: value,
	      enumerable: true,
	      configurable: true,
	      writable: true
	    });
	  } else {
	    obj[key] = value;
	  }

	  return obj;
	}

	function _extends() {
	  _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	      var source = arguments[i];

	      for (var key in source) {
	        if (Object.prototype.hasOwnProperty.call(source, key)) {
	          target[key] = source[key];
	        }
	      }
	    }

	    return target;
	  };

	  return _extends.apply(this, arguments);
	}

	function ownKeys(object, enumerableOnly) {
	  var keys = Object.keys(object);

	  if (Object.getOwnPropertySymbols) {
	    var symbols = Object.getOwnPropertySymbols(object);
	    if (enumerableOnly) symbols = symbols.filter(function (sym) {
	      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
	    });
	    keys.push.apply(keys, symbols);
	  }

	  return keys;
	}

	function _objectSpread2(target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i] != null ? arguments[i] : {};

	    if (i % 2) {
	      ownKeys(Object(source), true).forEach(function (key) {
	        _defineProperty(target, key, source[key]);
	      });
	    } else if (Object.getOwnPropertyDescriptors) {
	      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
	    } else {
	      ownKeys(Object(source)).forEach(function (key) {
	        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
	      });
	    }
	  }

	  return target;
	}

	function _inherits(subClass, superClass) {
	  if (typeof superClass !== "function" && superClass !== null) {
	    throw new TypeError("Super expression must either be null or a function");
	  }

	  subClass.prototype = Object.create(superClass && superClass.prototype, {
	    constructor: {
	      value: subClass,
	      writable: true,
	      configurable: true
	    }
	  });
	  if (superClass) _setPrototypeOf(subClass, superClass);
	}

	function _getPrototypeOf(o) {
	  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
	    return o.__proto__ || Object.getPrototypeOf(o);
	  };
	  return _getPrototypeOf(o);
	}

	function _setPrototypeOf(o, p) {
	  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
	    o.__proto__ = p;
	    return o;
	  };

	  return _setPrototypeOf(o, p);
	}

	function _isNativeReflectConstruct() {
	  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
	  if (Reflect.construct.sham) return false;
	  if (typeof Proxy === "function") return true;

	  try {
	    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
	    return true;
	  } catch (e) {
	    return false;
	  }
	}

	function _assertThisInitialized(self) {
	  if (self === void 0) {
	    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	  }

	  return self;
	}

	function _possibleConstructorReturn(self, call) {
	  if (call && (typeof call === "object" || typeof call === "function")) {
	    return call;
	  }

	  return _assertThisInitialized(self);
	}

	function _createSuper(Derived) {
	  var hasNativeReflectConstruct = _isNativeReflectConstruct();

	  return function _createSuperInternal() {
	    var Super = _getPrototypeOf(Derived),
	        result;

	    if (hasNativeReflectConstruct) {
	      var NewTarget = _getPrototypeOf(this).constructor;

	      result = Reflect.construct(Super, arguments, NewTarget);
	    } else {
	      result = Super.apply(this, arguments);
	    }

	    return _possibleConstructorReturn(this, result);
	  };
	}

	function _slicedToArray(arr, i) {
	  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
	}

	function _toConsumableArray(arr) {
	  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
	}

	function _arrayWithoutHoles(arr) {
	  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
	}

	function _arrayWithHoles(arr) {
	  if (Array.isArray(arr)) return arr;
	}

	function _iterableToArray(iter) {
	  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
	}

	function _iterableToArrayLimit(arr, i) {
	  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
	  var _arr = [];
	  var _n = true;
	  var _d = false;
	  var _e = undefined;

	  try {
	    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
	      _arr.push(_s.value);

	      if (i && _arr.length === i) break;
	    }
	  } catch (err) {
	    _d = true;
	    _e = err;
	  } finally {
	    try {
	      if (!_n && _i["return"] != null) _i["return"]();
	    } finally {
	      if (_d) throw _e;
	    }
	  }

	  return _arr;
	}

	function _unsupportedIterableToArray(o, minLen) {
	  if (!o) return;
	  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
	  var n = Object.prototype.toString.call(o).slice(8, -1);
	  if (n === "Object" && o.constructor) n = o.constructor.name;
	  if (n === "Map" || n === "Set") return Array.from(o);
	  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
	}

	function _arrayLikeToArray(arr, len) {
	  if (len == null || len > arr.length) len = arr.length;

	  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

	  return arr2;
	}

	function _nonIterableSpread() {
	  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
	}

	function _nonIterableRest() {
	  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
	}

	function _createForOfIteratorHelper(o, allowArrayLike) {
	  var it;

	  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
	    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
	      if (it) o = it;
	      var i = 0;

	      var F = function () {};

	      return {
	        s: F,
	        n: function () {
	          if (i >= o.length) return {
	            done: true
	          };
	          return {
	            done: false,
	            value: o[i++]
	          };
	        },
	        e: function (e) {
	          throw e;
	        },
	        f: F
	      };
	    }

	    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
	  }

	  var normalCompletion = true,
	      didErr = false,
	      err;
	  return {
	    s: function () {
	      it = o[Symbol.iterator]();
	    },
	    n: function () {
	      var step = it.next();
	      normalCompletion = step.done;
	      return step;
	    },
	    e: function (e) {
	      didErr = true;
	      err = e;
	    },
	    f: function () {
	      try {
	        if (!normalCompletion && it.return != null) it.return();
	      } finally {
	        if (didErr) throw err;
	      }
	    }
	  };
	}

	var aPossiblePrototype = function (it) {
	  if (!isObject$3(it) && it !== null) {
	    throw TypeError("Can't set " + String(it) + ' as a prototype');
	  } return it;
	};

	// `Object.setPrototypeOf` method
	// https://tc39.github.io/ecma262/#sec-object.setprototypeof
	// Works with __proto__ only. Old v8 can't work with null proto objects.
	/* eslint-disable no-proto */
	var objectSetPrototypeOf = Object.setPrototypeOf || ('__proto__' in {} ? function () {
	  var CORRECT_SETTER = false;
	  var test = {};
	  var setter;
	  try {
	    setter = Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set;
	    setter.call(test, []);
	    CORRECT_SETTER = test instanceof Array;
	  } catch (error) { /* empty */ }
	  return function setPrototypeOf(O, proto) {
	    anObject(O);
	    aPossiblePrototype(proto);
	    if (CORRECT_SETTER) setter.call(O, proto);
	    else O.__proto__ = proto;
	    return O;
	  };
	}() : undefined);

	// makes subclassing work correct for wrapped built-ins
	var inheritIfRequired = function ($this, dummy, Wrapper) {
	  var NewTarget, NewTargetPrototype;
	  if (
	    // it can work only with native `setPrototypeOf`
	    objectSetPrototypeOf &&
	    // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
	    typeof (NewTarget = dummy.constructor) == 'function' &&
	    NewTarget !== Wrapper &&
	    isObject$3(NewTargetPrototype = NewTarget.prototype) &&
	    NewTargetPrototype !== Wrapper.prototype
	  ) objectSetPrototypeOf($this, NewTargetPrototype);
	  return $this;
	};

	// `Object.defineProperties` method
	// https://tc39.github.io/ecma262/#sec-object.defineproperties
	var objectDefineProperties = descriptors ? Object.defineProperties : function defineProperties(O, Properties) {
	  anObject(O);
	  var keys = objectKeys(Properties);
	  var length = keys.length;
	  var index = 0;
	  var key;
	  while (length > index) objectDefineProperty.f(O, key = keys[index++], Properties[key]);
	  return O;
	};

	var html = getBuiltIn('document', 'documentElement');

	var GT = '>';
	var LT = '<';
	var PROTOTYPE$1 = 'prototype';
	var SCRIPT = 'script';
	var IE_PROTO$1 = sharedKey('IE_PROTO');

	var EmptyConstructor = function () { /* empty */ };

	var scriptTag = function (content) {
	  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
	};

	// Create object with fake `null` prototype: use ActiveX Object with cleared prototype
	var NullProtoObjectViaActiveX = function (activeXDocument) {
	  activeXDocument.write(scriptTag(''));
	  activeXDocument.close();
	  var temp = activeXDocument.parentWindow.Object;
	  activeXDocument = null; // avoid memory leak
	  return temp;
	};

	// Create object with fake `null` prototype: use iframe Object with cleared prototype
	var NullProtoObjectViaIFrame = function () {
	  // Thrash, waste and sodomy: IE GC bug
	  var iframe = documentCreateElement('iframe');
	  var JS = 'java' + SCRIPT + ':';
	  var iframeDocument;
	  iframe.style.display = 'none';
	  html.appendChild(iframe);
	  // https://github.com/zloirock/core-js/issues/475
	  iframe.src = String(JS);
	  iframeDocument = iframe.contentWindow.document;
	  iframeDocument.open();
	  iframeDocument.write(scriptTag('document.F=Object'));
	  iframeDocument.close();
	  return iframeDocument.F;
	};

	// Check for document.domain and active x support
	// No need to use active x approach when document.domain is not set
	// see https://github.com/es-shims/es5-shim/issues/150
	// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
	// avoid IE GC bug
	var activeXDocument;
	var NullProtoObject = function () {
	  try {
	    /* global ActiveXObject */
	    activeXDocument = document.domain && new ActiveXObject('htmlfile');
	  } catch (error) { /* ignore */ }
	  NullProtoObject = activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame();
	  var length = enumBugKeys.length;
	  while (length--) delete NullProtoObject[PROTOTYPE$1][enumBugKeys[length]];
	  return NullProtoObject();
	};

	hiddenKeys$1[IE_PROTO$1] = true;

	// `Object.create` method
	// https://tc39.github.io/ecma262/#sec-object.create
	var objectCreate$1 = Object.create || function create(O, Properties) {
	  var result;
	  if (O !== null) {
	    EmptyConstructor[PROTOTYPE$1] = anObject(O);
	    result = new EmptyConstructor();
	    EmptyConstructor[PROTOTYPE$1] = null;
	    // add "__proto__" for Object.getPrototypeOf polyfill
	    result[IE_PROTO$1] = O;
	  } else result = NullProtoObject();
	  return Properties === undefined ? result : objectDefineProperties(result, Properties);
	};

	// a string of all valid unicode whitespaces
	// eslint-disable-next-line max-len
	var whitespaces = '\u0009\u000A\u000B\u000C\u000D\u0020\u00A0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';

	var whitespace = '[' + whitespaces + ']';
	var ltrim = RegExp('^' + whitespace + whitespace + '*');
	var rtrim = RegExp(whitespace + whitespace + '*$');

	// `String.prototype.{ trim, trimStart, trimEnd, trimLeft, trimRight }` methods implementation
	var createMethod$2 = function (TYPE) {
	  return function ($this) {
	    var string = String(requireObjectCoercible($this));
	    if (TYPE & 1) string = string.replace(ltrim, '');
	    if (TYPE & 2) string = string.replace(rtrim, '');
	    return string;
	  };
	};

	var stringTrim = {
	  // `String.prototype.{ trimLeft, trimStart }` methods
	  // https://tc39.github.io/ecma262/#sec-string.prototype.trimstart
	  start: createMethod$2(1),
	  // `String.prototype.{ trimRight, trimEnd }` methods
	  // https://tc39.github.io/ecma262/#sec-string.prototype.trimend
	  end: createMethod$2(2),
	  // `String.prototype.trim` method
	  // https://tc39.github.io/ecma262/#sec-string.prototype.trim
	  trim: createMethod$2(3)
	};

	var getOwnPropertyNames$1 = objectGetOwnPropertyNames.f;
	var getOwnPropertyDescriptor$2 = objectGetOwnPropertyDescriptor.f;
	var defineProperty$8 = objectDefineProperty.f;
	var trim = stringTrim.trim;

	var NUMBER = 'Number';
	var NativeNumber = global_1[NUMBER];
	var NumberPrototype = NativeNumber.prototype;

	// Opera ~12 has broken Object#toString
	var BROKEN_CLASSOF = classofRaw(objectCreate$1(NumberPrototype)) == NUMBER;

	// `ToNumber` abstract operation
	// https://tc39.github.io/ecma262/#sec-tonumber
	var toNumber$2 = function (argument) {
	  var it = toPrimitive(argument, false);
	  var first, third, radix, maxCode, digits, length, index, code;
	  if (typeof it == 'string' && it.length > 2) {
	    it = trim(it);
	    first = it.charCodeAt(0);
	    if (first === 43 || first === 45) {
	      third = it.charCodeAt(2);
	      if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
	    } else if (first === 48) {
	      switch (it.charCodeAt(1)) {
	        case 66: case 98: radix = 2; maxCode = 49; break; // fast equal of /^0b[01]+$/i
	        case 79: case 111: radix = 8; maxCode = 55; break; // fast equal of /^0o[0-7]+$/i
	        default: return +it;
	      }
	      digits = it.slice(2);
	      length = digits.length;
	      for (index = 0; index < length; index++) {
	        code = digits.charCodeAt(index);
	        // parseInt parses a string to a first unavailable symbol
	        // but ToNumber should return NaN if a string contains unavailable symbols
	        if (code < 48 || code > maxCode) return NaN;
	      } return parseInt(digits, radix);
	    }
	  } return +it;
	};

	// `Number` constructor
	// https://tc39.github.io/ecma262/#sec-number-constructor
	if (isForced_1(NUMBER, !NativeNumber(' 0o1') || !NativeNumber('0b1') || NativeNumber('+0x1'))) {
	  var NumberWrapper = function Number(value) {
	    var it = arguments.length < 1 ? 0 : value;
	    var dummy = this;
	    return dummy instanceof NumberWrapper
	      // check on 1..constructor(foo) case
	      && (BROKEN_CLASSOF ? fails(function () { NumberPrototype.valueOf.call(dummy); }) : classofRaw(dummy) != NUMBER)
	        ? inheritIfRequired(new NativeNumber(toNumber$2(it)), dummy, NumberWrapper) : toNumber$2(it);
	  };
	  for (var keys$2 = descriptors ? getOwnPropertyNames$1(NativeNumber) : (
	    // ES3:
	    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
	    // ES2015 (in case, if modules with ES2015 Number statics required before):
	    'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +
	    'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger'
	  ).split(','), j = 0, key; keys$2.length > j; j++) {
	    if (has$1(NativeNumber, key = keys$2[j]) && !has$1(NumberWrapper, key)) {
	      defineProperty$8(NumberWrapper, key, getOwnPropertyDescriptor$2(NativeNumber, key));
	    }
	  }
	  NumberWrapper.prototype = NumberPrototype;
	  NumberPrototype.constructor = NumberWrapper;
	  redefine(global_1, NUMBER, NumberWrapper);
	}

	var SPECIES$5 = wellKnownSymbol('species');

	var arrayMethodHasSpeciesSupport = function (METHOD_NAME) {
	  // We can't use this feature detection in V8 since it causes
	  // deoptimization and serious performance degradation
	  // https://github.com/zloirock/core-js/issues/677
	  return engineV8Version >= 51 || !fails(function () {
	    var array = [];
	    var constructor = array.constructor = {};
	    constructor[SPECIES$5] = function () {
	      return { foo: 1 };
	    };
	    return array[METHOD_NAME](Boolean).foo !== 1;
	  });
	};

	var $filter = arrayIteration.filter;



	var HAS_SPECIES_SUPPORT$3 = arrayMethodHasSpeciesSupport('filter');
	// Edge 14- issue
	var USES_TO_LENGTH$9 = arrayMethodUsesToLength('filter');

	// `Array.prototype.filter` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.filter
	// with adding support of @@species
	_export({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT$3 || !USES_TO_LENGTH$9 }, {
	  filter: function filter(callbackfn /* , thisArg */) {
	    return $filter(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	var iteratorClose = function (iterator) {
	  var returnMethod = iterator['return'];
	  if (returnMethod !== undefined) {
	    return anObject(returnMethod.call(iterator)).value;
	  }
	};

	// call something on iterator step with safe closing on error
	var callWithSafeIterationClosing = function (iterator, fn, value, ENTRIES) {
	  try {
	    return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value);
	  // 7.4.6 IteratorClose(iterator, completion)
	  } catch (error) {
	    iteratorClose(iterator);
	    throw error;
	  }
	};

	var iterators = {};

	var ITERATOR$5 = wellKnownSymbol('iterator');
	var ArrayPrototype$1 = Array.prototype;

	// check on default Array iterator
	var isArrayIteratorMethod = function (it) {
	  return it !== undefined && (iterators.Array === it || ArrayPrototype$1[ITERATOR$5] === it);
	};

	var createProperty = function (object, key, value) {
	  var propertyKey = toPrimitive(key);
	  if (propertyKey in object) objectDefineProperty.f(object, propertyKey, createPropertyDescriptor(0, value));
	  else object[propertyKey] = value;
	};

	var TO_STRING_TAG$3 = wellKnownSymbol('toStringTag');
	var test = {};

	test[TO_STRING_TAG$3] = 'z';

	var toStringTagSupport = String(test) === '[object z]';

	var TO_STRING_TAG$2 = wellKnownSymbol('toStringTag');
	// ES3 wrong here
	var CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == 'Arguments';

	// fallback for IE11 Script Access Denied error
	var tryGet = function (it, key) {
	  try {
	    return it[key];
	  } catch (error) { /* empty */ }
	};

	// getting tag from ES6+ `Object.prototype.toString`
	var classof = toStringTagSupport ? classofRaw : function (it) {
	  var O, tag, result;
	  return it === undefined ? 'Undefined' : it === null ? 'Null'
	    // @@toStringTag case
	    : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG$2)) == 'string' ? tag
	    // builtinTag case
	    : CORRECT_ARGUMENTS ? classofRaw(O)
	    // ES3 arguments fallback
	    : (result = classofRaw(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : result;
	};

	var ITERATOR$4 = wellKnownSymbol('iterator');

	var getIteratorMethod = function (it) {
	  if (it != undefined) return it[ITERATOR$4]
	    || it['@@iterator']
	    || iterators[classof(it)];
	};

	// `Array.from` method implementation
	// https://tc39.github.io/ecma262/#sec-array.from
	var arrayFrom = function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
	  var O = toObject(arrayLike);
	  var C = typeof this == 'function' ? this : Array;
	  var argumentsLength = arguments.length;
	  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
	  var mapping = mapfn !== undefined;
	  var iteratorMethod = getIteratorMethod(O);
	  var index = 0;
	  var length, result, step, iterator, next, value;
	  if (mapping) mapfn = functionBindContext(mapfn, argumentsLength > 2 ? arguments[2] : undefined, 2);
	  // if the target is not iterable or it's an array with the default iterator - use a simple case
	  if (iteratorMethod != undefined && !(C == Array && isArrayIteratorMethod(iteratorMethod))) {
	    iterator = iteratorMethod.call(O);
	    next = iterator.next;
	    result = new C();
	    for (;!(step = next.call(iterator)).done; index++) {
	      value = mapping ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index], true) : step.value;
	      createProperty(result, index, value);
	    }
	  } else {
	    length = toLength(O.length);
	    result = new C(length);
	    for (;length > index; index++) {
	      value = mapping ? mapfn(O[index], index) : O[index];
	      createProperty(result, index, value);
	    }
	  }
	  result.length = index;
	  return result;
	};

	var ITERATOR$3 = wellKnownSymbol('iterator');
	var SAFE_CLOSING = false;

	try {
	  var called = 0;
	  var iteratorWithReturn = {
	    next: function () {
	      return { done: !!called++ };
	    },
	    'return': function () {
	      SAFE_CLOSING = true;
	    }
	  };
	  iteratorWithReturn[ITERATOR$3] = function () {
	    return this;
	  };
	  // eslint-disable-next-line no-throw-literal
	  Array.from(iteratorWithReturn, function () { throw 2; });
	} catch (error) { /* empty */ }

	var checkCorrectnessOfIteration = function (exec, SKIP_CLOSING) {
	  if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
	  var ITERATION_SUPPORT = false;
	  try {
	    var object = {};
	    object[ITERATOR$3] = function () {
	      return {
	        next: function () {
	          return { done: ITERATION_SUPPORT = true };
	        }
	      };
	    };
	    exec(object);
	  } catch (error) { /* empty */ }
	  return ITERATION_SUPPORT;
	};

	var INCORRECT_ITERATION$1 = !checkCorrectnessOfIteration(function (iterable) {
	  Array.from(iterable);
	});

	// `Array.from` method
	// https://tc39.github.io/ecma262/#sec-array.from
	_export({ target: 'Array', stat: true, forced: INCORRECT_ITERATION$1 }, {
	  from: arrayFrom
	});

	var $indexOf = arrayIncludes.indexOf;



	var nativeIndexOf = [].indexOf;

	var NEGATIVE_ZERO$1 = !!nativeIndexOf && 1 / [1].indexOf(1, -0) < 0;
	var STRICT_METHOD$4 = arrayMethodIsStrict('indexOf');
	var USES_TO_LENGTH$8 = arrayMethodUsesToLength('indexOf', { ACCESSORS: true, 1: 0 });

	// `Array.prototype.indexOf` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.indexof
	_export({ target: 'Array', proto: true, forced: NEGATIVE_ZERO$1 || !STRICT_METHOD$4 || !USES_TO_LENGTH$8 }, {
	  indexOf: function indexOf(searchElement /* , fromIndex = 0 */) {
	    return NEGATIVE_ZERO$1
	      // convert -0 to +0
	      ? nativeIndexOf.apply(this, arguments) || 0
	      : $indexOf(this, searchElement, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	var $map = arrayIteration.map;



	var HAS_SPECIES_SUPPORT$2 = arrayMethodHasSpeciesSupport('map');
	// FF49- issue
	var USES_TO_LENGTH$7 = arrayMethodUsesToLength('map');

	// `Array.prototype.map` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.map
	// with adding support of @@species
	_export({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT$2 || !USES_TO_LENGTH$7 }, {
	  map: function map(callbackfn /* , thisArg */) {
	    return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	var HAS_SPECIES_SUPPORT$1 = arrayMethodHasSpeciesSupport('slice');
	var USES_TO_LENGTH$6 = arrayMethodUsesToLength('slice', { ACCESSORS: true, 0: 0, 1: 2 });

	var SPECIES$4 = wellKnownSymbol('species');
	var nativeSlice = [].slice;
	var max$4 = Math.max;

	// `Array.prototype.slice` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.slice
	// fallback for not array-like ES3 strings and DOM objects
	_export({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT$1 || !USES_TO_LENGTH$6 }, {
	  slice: function slice(start, end) {
	    var O = toIndexedObject(this);
	    var length = toLength(O.length);
	    var k = toAbsoluteIndex(start, length);
	    var fin = toAbsoluteIndex(end === undefined ? length : end, length);
	    // inline `ArraySpeciesCreate` for usage native `Array#slice` where it's possible
	    var Constructor, result, n;
	    if (isArray$3(O)) {
	      Constructor = O.constructor;
	      // cross-realm fallback
	      if (typeof Constructor == 'function' && (Constructor === Array || isArray$3(Constructor.prototype))) {
	        Constructor = undefined;
	      } else if (isObject$3(Constructor)) {
	        Constructor = Constructor[SPECIES$4];
	        if (Constructor === null) Constructor = undefined;
	      }
	      if (Constructor === Array || Constructor === undefined) {
	        return nativeSlice.call(O, k, fin);
	      }
	    }
	    result = new (Constructor === undefined ? Array : Constructor)(max$4(fin - k, 0));
	    for (n = 0; k < fin; k++, n++) if (k in O) createProperty(result, n, O[k]);
	    result.length = n;
	    return result;
	  }
	});

	var defineProperty$7 = objectDefineProperty.f;

	var FunctionPrototype = Function.prototype;
	var FunctionPrototypeToString = FunctionPrototype.toString;
	var nameRE = /^\s*function ([^ (]*)/;
	var NAME = 'name';

	// Function instances `.name` property
	// https://tc39.github.io/ecma262/#sec-function-instances-name
	if (descriptors && !(NAME in FunctionPrototype)) {
	  defineProperty$7(FunctionPrototype, NAME, {
	    configurable: true,
	    get: function () {
	      try {
	        return FunctionPrototypeToString.call(this).match(nameRE)[1];
	      } catch (error) {
	        return '';
	      }
	    }
	  });
	}

	// `RegExp.prototype.flags` getter implementation
	// https://tc39.github.io/ecma262/#sec-get-regexp.prototype.flags
	var regexpFlags = function () {
	  var that = anObject(this);
	  var result = '';
	  if (that.global) result += 'g';
	  if (that.ignoreCase) result += 'i';
	  if (that.multiline) result += 'm';
	  if (that.dotAll) result += 's';
	  if (that.unicode) result += 'u';
	  if (that.sticky) result += 'y';
	  return result;
	};

	// babel-minify transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError,
	// so we use an intermediate function.
	function RE(s, f) {
	  return RegExp(s, f);
	}

	var UNSUPPORTED_Y$2 = fails(function () {
	  // babel-minify transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError
	  var re = RE('a', 'y');
	  re.lastIndex = 2;
	  return re.exec('abcd') != null;
	});

	var BROKEN_CARET = fails(function () {
	  // https://bugzilla.mozilla.org/show_bug.cgi?id=773687
	  var re = RE('^r', 'gy');
	  re.lastIndex = 2;
	  return re.exec('str') != null;
	});

	var regexpStickyHelpers = {
		UNSUPPORTED_Y: UNSUPPORTED_Y$2,
		BROKEN_CARET: BROKEN_CARET
	};

	var nativeExec = RegExp.prototype.exec;
	// This always refers to the native implementation, because the
	// String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js,
	// which loads this file before patching the method.
	var nativeReplace = String.prototype.replace;

	var patchedExec = nativeExec;

	var UPDATES_LAST_INDEX_WRONG = (function () {
	  var re1 = /a/;
	  var re2 = /b*/g;
	  nativeExec.call(re1, 'a');
	  nativeExec.call(re2, 'a');
	  return re1.lastIndex !== 0 || re2.lastIndex !== 0;
	})();

	var UNSUPPORTED_Y$1 = regexpStickyHelpers.UNSUPPORTED_Y || regexpStickyHelpers.BROKEN_CARET;

	// nonparticipating capturing group, copied from es5-shim's String#split patch.
	var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;

	var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y$1;

	if (PATCH) {
	  patchedExec = function exec(str) {
	    var re = this;
	    var lastIndex, reCopy, match, i;
	    var sticky = UNSUPPORTED_Y$1 && re.sticky;
	    var flags = regexpFlags.call(re);
	    var source = re.source;
	    var charsAdded = 0;
	    var strCopy = str;

	    if (sticky) {
	      flags = flags.replace('y', '');
	      if (flags.indexOf('g') === -1) {
	        flags += 'g';
	      }

	      strCopy = String(str).slice(re.lastIndex);
	      // Support anchored sticky behavior.
	      if (re.lastIndex > 0 && (!re.multiline || re.multiline && str[re.lastIndex - 1] !== '\n')) {
	        source = '(?: ' + source + ')';
	        strCopy = ' ' + strCopy;
	        charsAdded++;
	      }
	      // ^(? + rx + ) is needed, in combination with some str slicing, to
	      // simulate the 'y' flag.
	      reCopy = new RegExp('^(?:' + source + ')', flags);
	    }

	    if (NPCG_INCLUDED) {
	      reCopy = new RegExp('^' + source + '$(?!\\s)', flags);
	    }
	    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re.lastIndex;

	    match = nativeExec.call(sticky ? reCopy : re, strCopy);

	    if (sticky) {
	      if (match) {
	        match.input = match.input.slice(charsAdded);
	        match[0] = match[0].slice(charsAdded);
	        match.index = re.lastIndex;
	        re.lastIndex += match[0].length;
	      } else re.lastIndex = 0;
	    } else if (UPDATES_LAST_INDEX_WRONG && match) {
	      re.lastIndex = re.global ? match.index + match[0].length : lastIndex;
	    }
	    if (NPCG_INCLUDED && match && match.length > 1) {
	      // Fix browsers whose `exec` methods don't consistently return `undefined`
	      // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
	      nativeReplace.call(match[0], reCopy, function () {
	        for (i = 1; i < arguments.length - 2; i++) {
	          if (arguments[i] === undefined) match[i] = undefined;
	        }
	      });
	    }

	    return match;
	  };
	}

	var regexpExec = patchedExec;

	_export({ target: 'RegExp', proto: true, forced: /./.exec !== regexpExec }, {
	  exec: regexpExec
	});

	// `String.prototype.{ codePointAt, at }` methods implementation
	var createMethod$1 = function (CONVERT_TO_STRING) {
	  return function ($this, pos) {
	    var S = String(requireObjectCoercible($this));
	    var position = toInteger$1(pos);
	    var size = S.length;
	    var first, second;
	    if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;
	    first = S.charCodeAt(position);
	    return first < 0xD800 || first > 0xDBFF || position + 1 === size
	      || (second = S.charCodeAt(position + 1)) < 0xDC00 || second > 0xDFFF
	        ? CONVERT_TO_STRING ? S.charAt(position) : first
	        : CONVERT_TO_STRING ? S.slice(position, position + 2) : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
	  };
	};

	var stringMultibyte = {
	  // `String.prototype.codePointAt` method
	  // https://tc39.github.io/ecma262/#sec-string.prototype.codepointat
	  codeAt: createMethod$1(false),
	  // `String.prototype.at` method
	  // https://github.com/mathiasbynens/String.prototype.at
	  charAt: createMethod$1(true)
	};

	var correctPrototypeGetter = !fails(function () {
	  function F() { /* empty */ }
	  F.prototype.constructor = null;
	  return Object.getPrototypeOf(new F()) !== F.prototype;
	});

	var IE_PROTO = sharedKey('IE_PROTO');
	var ObjectPrototype$1 = Object.prototype;

	// `Object.getPrototypeOf` method
	// https://tc39.github.io/ecma262/#sec-object.getprototypeof
	var objectGetPrototypeOf = correctPrototypeGetter ? Object.getPrototypeOf : function (O) {
	  O = toObject(O);
	  if (has$1(O, IE_PROTO)) return O[IE_PROTO];
	  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
	    return O.constructor.prototype;
	  } return O instanceof Object ? ObjectPrototype$1 : null;
	};

	var ITERATOR$2 = wellKnownSymbol('iterator');
	var BUGGY_SAFARI_ITERATORS$1 = false;

	var returnThis$2 = function () { return this; };

	// `%IteratorPrototype%` object
	// https://tc39.github.io/ecma262/#sec-%iteratorprototype%-object
	var IteratorPrototype$2, PrototypeOfArrayIteratorPrototype, arrayIterator;

	if ([].keys) {
	  arrayIterator = [].keys();
	  // Safari 8 has buggy iterators w/o `next`
	  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS$1 = true;
	  else {
	    PrototypeOfArrayIteratorPrototype = objectGetPrototypeOf(objectGetPrototypeOf(arrayIterator));
	    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype$2 = PrototypeOfArrayIteratorPrototype;
	  }
	}

	if (IteratorPrototype$2 == undefined) IteratorPrototype$2 = {};

	// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
	if (!has$1(IteratorPrototype$2, ITERATOR$2)) {
	  createNonEnumerableProperty(IteratorPrototype$2, ITERATOR$2, returnThis$2);
	}

	var iteratorsCore = {
	  IteratorPrototype: IteratorPrototype$2,
	  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS$1
	};

	var defineProperty$6 = objectDefineProperty.f;



	var TO_STRING_TAG$1 = wellKnownSymbol('toStringTag');

	var setToStringTag = function (it, TAG, STATIC) {
	  if (it && !has$1(it = STATIC ? it : it.prototype, TO_STRING_TAG$1)) {
	    defineProperty$6(it, TO_STRING_TAG$1, { configurable: true, value: TAG });
	  }
	};

	var IteratorPrototype$1 = iteratorsCore.IteratorPrototype;





	var returnThis$1 = function () { return this; };

	var createIteratorConstructor = function (IteratorConstructor, NAME, next) {
	  var TO_STRING_TAG = NAME + ' Iterator';
	  IteratorConstructor.prototype = objectCreate$1(IteratorPrototype$1, { next: createPropertyDescriptor(1, next) });
	  setToStringTag(IteratorConstructor, TO_STRING_TAG, false);
	  iterators[TO_STRING_TAG] = returnThis$1;
	  return IteratorConstructor;
	};

	var IteratorPrototype = iteratorsCore.IteratorPrototype;
	var BUGGY_SAFARI_ITERATORS = iteratorsCore.BUGGY_SAFARI_ITERATORS;
	var ITERATOR$1 = wellKnownSymbol('iterator');
	var KEYS = 'keys';
	var VALUES = 'values';
	var ENTRIES = 'entries';

	var returnThis = function () { return this; };

	var defineIterator = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
	  createIteratorConstructor(IteratorConstructor, NAME, next);

	  var getIterationMethod = function (KIND) {
	    if (KIND === DEFAULT && defaultIterator) return defaultIterator;
	    if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND];
	    switch (KIND) {
	      case KEYS: return function keys() { return new IteratorConstructor(this, KIND); };
	      case VALUES: return function values() { return new IteratorConstructor(this, KIND); };
	      case ENTRIES: return function entries() { return new IteratorConstructor(this, KIND); };
	    } return function () { return new IteratorConstructor(this); };
	  };

	  var TO_STRING_TAG = NAME + ' Iterator';
	  var INCORRECT_VALUES_NAME = false;
	  var IterablePrototype = Iterable.prototype;
	  var nativeIterator = IterablePrototype[ITERATOR$1]
	    || IterablePrototype['@@iterator']
	    || DEFAULT && IterablePrototype[DEFAULT];
	  var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
	  var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
	  var CurrentIteratorPrototype, methods, KEY;

	  // fix native
	  if (anyNativeIterator) {
	    CurrentIteratorPrototype = objectGetPrototypeOf(anyNativeIterator.call(new Iterable()));
	    if (IteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
	      if (objectGetPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
	        if (objectSetPrototypeOf) {
	          objectSetPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
	        } else if (typeof CurrentIteratorPrototype[ITERATOR$1] != 'function') {
	          createNonEnumerableProperty(CurrentIteratorPrototype, ITERATOR$1, returnThis);
	        }
	      }
	      // Set @@toStringTag to native iterators
	      setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true);
	    }
	  }

	  // fix Array#{values, @@iterator}.name in V8 / FF
	  if (DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
	    INCORRECT_VALUES_NAME = true;
	    defaultIterator = function values() { return nativeIterator.call(this); };
	  }

	  // define iterator
	  if (IterablePrototype[ITERATOR$1] !== defaultIterator) {
	    createNonEnumerableProperty(IterablePrototype, ITERATOR$1, defaultIterator);
	  }
	  iterators[NAME] = defaultIterator;

	  // export additional methods
	  if (DEFAULT) {
	    methods = {
	      values: getIterationMethod(VALUES),
	      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
	      entries: getIterationMethod(ENTRIES)
	    };
	    if (FORCED) for (KEY in methods) {
	      if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
	        redefine(IterablePrototype, KEY, methods[KEY]);
	      }
	    } else _export({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
	  }

	  return methods;
	};

	var charAt$1 = stringMultibyte.charAt;



	var STRING_ITERATOR = 'String Iterator';
	var setInternalState$5 = internalState.set;
	var getInternalState$3 = internalState.getterFor(STRING_ITERATOR);

	// `String.prototype[@@iterator]` method
	// https://tc39.github.io/ecma262/#sec-string.prototype-@@iterator
	defineIterator(String, 'String', function (iterated) {
	  setInternalState$5(this, {
	    type: STRING_ITERATOR,
	    string: String(iterated),
	    index: 0
	  });
	// `%StringIteratorPrototype%.next` method
	// https://tc39.github.io/ecma262/#sec-%stringiteratorprototype%.next
	}, function next() {
	  var state = getInternalState$3(this);
	  var string = state.string;
	  var index = state.index;
	  var point;
	  if (index >= string.length) return { value: undefined, done: true };
	  point = charAt$1(string, index);
	  state.index += point.length;
	  return { value: point, done: false };
	});

	// TODO: Remove from `core-js@4` since it's moved to entry points







	var SPECIES$3 = wellKnownSymbol('species');

	var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {
	  // #replace needs built-in support for named groups.
	  // #match works fine because it just return the exec results, even if it has
	  // a "grops" property.
	  var re = /./;
	  re.exec = function () {
	    var result = [];
	    result.groups = { a: '7' };
	    return result;
	  };
	  return ''.replace(re, '$<a>') !== '7';
	});

	// IE <= 11 replaces $0 with the whole match, as if it was $&
	// https://stackoverflow.com/questions/6024666/getting-ie-to-replace-a-regex-with-the-literal-string-0
	var REPLACE_KEEPS_$0 = (function () {
	  return 'a'.replace(/./, '$0') === '$0';
	})();

	var REPLACE = wellKnownSymbol('replace');
	// Safari <= 13.0.3(?) substitutes nth capture where n>m with an empty string
	var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = (function () {
	  if (/./[REPLACE]) {
	    return /./[REPLACE]('a', '$0') === '';
	  }
	  return false;
	})();

	// Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
	// Weex JS has frozen built-in prototypes, so use try / catch wrapper
	var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails(function () {
	  var re = /(?:)/;
	  var originalExec = re.exec;
	  re.exec = function () { return originalExec.apply(this, arguments); };
	  var result = 'ab'.split(re);
	  return result.length !== 2 || result[0] !== 'a' || result[1] !== 'b';
	});

	var fixRegexpWellKnownSymbolLogic = function (KEY, length, exec, sham) {
	  var SYMBOL = wellKnownSymbol(KEY);

	  var DELEGATES_TO_SYMBOL = !fails(function () {
	    // String methods call symbol-named RegEp methods
	    var O = {};
	    O[SYMBOL] = function () { return 7; };
	    return ''[KEY](O) != 7;
	  });

	  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails(function () {
	    // Symbol-named RegExp methods call .exec
	    var execCalled = false;
	    var re = /a/;

	    if (KEY === 'split') {
	      // We can't use real regex here since it causes deoptimization
	      // and serious performance degradation in V8
	      // https://github.com/zloirock/core-js/issues/306
	      re = {};
	      // RegExp[@@split] doesn't call the regex's exec method, but first creates
	      // a new one. We need to return the patched regex when creating the new one.
	      re.constructor = {};
	      re.constructor[SPECIES$3] = function () { return re; };
	      re.flags = '';
	      re[SYMBOL] = /./[SYMBOL];
	    }

	    re.exec = function () { execCalled = true; return null; };

	    re[SYMBOL]('');
	    return !execCalled;
	  });

	  if (
	    !DELEGATES_TO_SYMBOL ||
	    !DELEGATES_TO_EXEC ||
	    (KEY === 'replace' && !(
	      REPLACE_SUPPORTS_NAMED_GROUPS &&
	      REPLACE_KEEPS_$0 &&
	      !REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE
	    )) ||
	    (KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC)
	  ) {
	    var nativeRegExpMethod = /./[SYMBOL];
	    var methods = exec(SYMBOL, ''[KEY], function (nativeMethod, regexp, str, arg2, forceStringMethod) {
	      if (regexp.exec === regexpExec) {
	        if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
	          // The native String method already delegates to @@method (this
	          // polyfilled function), leasing to infinite recursion.
	          // We avoid it by directly calling the native @@method method.
	          return { done: true, value: nativeRegExpMethod.call(regexp, str, arg2) };
	        }
	        return { done: true, value: nativeMethod.call(str, regexp, arg2) };
	      }
	      return { done: false };
	    }, {
	      REPLACE_KEEPS_$0: REPLACE_KEEPS_$0,
	      REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE: REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE
	    });
	    var stringMethod = methods[0];
	    var regexMethod = methods[1];

	    redefine(String.prototype, KEY, stringMethod);
	    redefine(RegExp.prototype, SYMBOL, length == 2
	      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
	      // 21.2.5.11 RegExp.prototype[@@split](string, limit)
	      ? function (string, arg) { return regexMethod.call(string, this, arg); }
	      // 21.2.5.6 RegExp.prototype[@@match](string)
	      // 21.2.5.9 RegExp.prototype[@@search](string)
	      : function (string) { return regexMethod.call(string, this); }
	    );
	  }

	  if (sham) createNonEnumerableProperty(RegExp.prototype[SYMBOL], 'sham', true);
	};

	var SPECIES$2 = wellKnownSymbol('species');

	// `SpeciesConstructor` abstract operation
	// https://tc39.github.io/ecma262/#sec-speciesconstructor
	var speciesConstructor = function (O, defaultConstructor) {
	  var C = anObject(O).constructor;
	  var S;
	  return C === undefined || (S = anObject(C)[SPECIES$2]) == undefined ? defaultConstructor : aFunction(S);
	};

	var charAt = stringMultibyte.charAt;

	// `AdvanceStringIndex` abstract operation
	// https://tc39.github.io/ecma262/#sec-advancestringindex
	var advanceStringIndex = function (S, index, unicode) {
	  return index + (unicode ? charAt(S, index).length : 1);
	};

	// `RegExpExec` abstract operation
	// https://tc39.github.io/ecma262/#sec-regexpexec
	var regexpExecAbstract = function (R, S) {
	  var exec = R.exec;
	  if (typeof exec === 'function') {
	    var result = exec.call(R, S);
	    if (typeof result !== 'object') {
	      throw TypeError('RegExp exec method returned something other than an Object or null');
	    }
	    return result;
	  }

	  if (classofRaw(R) !== 'RegExp') {
	    throw TypeError('RegExp#exec called on incompatible receiver');
	  }

	  return regexpExec.call(R, S);
	};

	var arrayPush$1 = [].push;
	var min$6 = Math.min;
	var MAX_UINT32 = 0xFFFFFFFF;

	// babel-minify transpiles RegExp('x', 'y') -> /x/y and it causes SyntaxError
	var SUPPORTS_Y = !fails(function () { return !RegExp(MAX_UINT32, 'y'); });

	// @@split logic
	fixRegexpWellKnownSymbolLogic('split', 2, function (SPLIT, nativeSplit, maybeCallNative) {
	  var internalSplit;
	  if (
	    'abbc'.split(/(b)*/)[1] == 'c' ||
	    'test'.split(/(?:)/, -1).length != 4 ||
	    'ab'.split(/(?:ab)*/).length != 2 ||
	    '.'.split(/(.?)(.?)/).length != 4 ||
	    '.'.split(/()()/).length > 1 ||
	    ''.split(/.?/).length
	  ) {
	    // based on es5-shim implementation, need to rework it
	    internalSplit = function (separator, limit) {
	      var string = String(requireObjectCoercible(this));
	      var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
	      if (lim === 0) return [];
	      if (separator === undefined) return [string];
	      // If `separator` is not a regex, use native split
	      if (!isRegexp(separator)) {
	        return nativeSplit.call(string, separator, lim);
	      }
	      var output = [];
	      var flags = (separator.ignoreCase ? 'i' : '') +
	                  (separator.multiline ? 'm' : '') +
	                  (separator.unicode ? 'u' : '') +
	                  (separator.sticky ? 'y' : '');
	      var lastLastIndex = 0;
	      // Make `global` and avoid `lastIndex` issues by working with a copy
	      var separatorCopy = new RegExp(separator.source, flags + 'g');
	      var match, lastIndex, lastLength;
	      while (match = regexpExec.call(separatorCopy, string)) {
	        lastIndex = separatorCopy.lastIndex;
	        if (lastIndex > lastLastIndex) {
	          output.push(string.slice(lastLastIndex, match.index));
	          if (match.length > 1 && match.index < string.length) arrayPush$1.apply(output, match.slice(1));
	          lastLength = match[0].length;
	          lastLastIndex = lastIndex;
	          if (output.length >= lim) break;
	        }
	        if (separatorCopy.lastIndex === match.index) separatorCopy.lastIndex++; // Avoid an infinite loop
	      }
	      if (lastLastIndex === string.length) {
	        if (lastLength || !separatorCopy.test('')) output.push('');
	      } else output.push(string.slice(lastLastIndex));
	      return output.length > lim ? output.slice(0, lim) : output;
	    };
	  // Chakra, V8
	  } else if ('0'.split(undefined, 0).length) {
	    internalSplit = function (separator, limit) {
	      return separator === undefined && limit === 0 ? [] : nativeSplit.call(this, separator, limit);
	    };
	  } else internalSplit = nativeSplit;

	  return [
	    // `String.prototype.split` method
	    // https://tc39.github.io/ecma262/#sec-string.prototype.split
	    function split(separator, limit) {
	      var O = requireObjectCoercible(this);
	      var splitter = separator == undefined ? undefined : separator[SPLIT];
	      return splitter !== undefined
	        ? splitter.call(separator, O, limit)
	        : internalSplit.call(String(O), separator, limit);
	    },
	    // `RegExp.prototype[@@split]` method
	    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@split
	    //
	    // NOTE: This cannot be properly polyfilled in engines that don't support
	    // the 'y' flag.
	    function (regexp, limit) {
	      var res = maybeCallNative(internalSplit, regexp, this, limit, internalSplit !== nativeSplit);
	      if (res.done) return res.value;

	      var rx = anObject(regexp);
	      var S = String(this);
	      var C = speciesConstructor(rx, RegExp);

	      var unicodeMatching = rx.unicode;
	      var flags = (rx.ignoreCase ? 'i' : '') +
	                  (rx.multiline ? 'm' : '') +
	                  (rx.unicode ? 'u' : '') +
	                  (SUPPORTS_Y ? 'y' : 'g');

	      // ^(? + rx + ) is needed, in combination with some S slicing, to
	      // simulate the 'y' flag.
	      var splitter = new C(SUPPORTS_Y ? rx : '^(?:' + rx.source + ')', flags);
	      var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
	      if (lim === 0) return [];
	      if (S.length === 0) return regexpExecAbstract(splitter, S) === null ? [S] : [];
	      var p = 0;
	      var q = 0;
	      var A = [];
	      while (q < S.length) {
	        splitter.lastIndex = SUPPORTS_Y ? q : 0;
	        var z = regexpExecAbstract(splitter, SUPPORTS_Y ? S : S.slice(q));
	        var e;
	        if (
	          z === null ||
	          (e = min$6(toLength(splitter.lastIndex + (SUPPORTS_Y ? 0 : q)), S.length)) === p
	        ) {
	          q = advanceStringIndex(S, q, unicodeMatching);
	        } else {
	          A.push(S.slice(p, q));
	          if (A.length === lim) return A;
	          for (var i = 1; i <= z.length - 1; i++) {
	            A.push(z[i]);
	            if (A.length === lim) return A;
	          }
	          q = p = e;
	        }
	      }
	      A.push(S.slice(p));
	      return A;
	    }
	  ];
	}, !SUPPORTS_Y);

	var non = '\u200B\u0085\u180E';

	// check that a method works with the correct list
	// of whitespaces and has a correct name
	var stringTrimForced = function (METHOD_NAME) {
	  return fails(function () {
	    return !!whitespaces[METHOD_NAME]() || non[METHOD_NAME]() != non || whitespaces[METHOD_NAME].name !== METHOD_NAME;
	  });
	};

	var $trim = stringTrim.trim;


	// `String.prototype.trim` method
	// https://tc39.github.io/ecma262/#sec-string.prototype.trim
	_export({ target: 'String', proto: true, forced: stringTrimForced('trim') }, {
	  trim: function trim() {
	    return $trim(this);
	  }
	});

	var min$5 = Math.min;
	var nativeLastIndexOf = [].lastIndexOf;
	var NEGATIVE_ZERO = !!nativeLastIndexOf && 1 / [1].lastIndexOf(1, -0) < 0;
	var STRICT_METHOD$3 = arrayMethodIsStrict('lastIndexOf');
	// For preventing possible almost infinite loop in non-standard implementations, test the forward version of the method
	var USES_TO_LENGTH$5 = arrayMethodUsesToLength('indexOf', { ACCESSORS: true, 1: 0 });
	var FORCED$4 = NEGATIVE_ZERO || !STRICT_METHOD$3 || !USES_TO_LENGTH$5;

	// `Array.prototype.lastIndexOf` method implementation
	// https://tc39.github.io/ecma262/#sec-array.prototype.lastindexof
	var arrayLastIndexOf = FORCED$4 ? function lastIndexOf(searchElement /* , fromIndex = @[*-1] */) {
	  // convert -0 to +0
	  if (NEGATIVE_ZERO) return nativeLastIndexOf.apply(this, arguments) || 0;
	  var O = toIndexedObject(this);
	  var length = toLength(O.length);
	  var index = length - 1;
	  if (arguments.length > 1) index = min$5(index, toInteger$1(arguments[1]));
	  if (index < 0) index = length + index;
	  for (;index >= 0; index--) if (index in O && O[index] === searchElement) return index || 0;
	  return -1;
	} : nativeLastIndexOf;

	// `Array.prototype.lastIndexOf` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.lastindexof
	_export({ target: 'Array', proto: true, forced: arrayLastIndexOf !== [].lastIndexOf }, {
	  lastIndexOf: arrayLastIndexOf
	});

	// `Object.prototype.toString` method implementation
	// https://tc39.github.io/ecma262/#sec-object.prototype.tostring
	var objectToString$3 = toStringTagSupport ? {}.toString : function toString() {
	  return '[object ' + classof(this) + ']';
	};

	// `Object.prototype.toString` method
	// https://tc39.github.io/ecma262/#sec-object.prototype.tostring
	if (!toStringTagSupport) {
	  redefine(Object.prototype, 'toString', objectToString$3, { unsafe: true });
	}

	var nativePromiseConstructor = global_1.Promise;

	var redefineAll = function (target, src, options) {
	  for (var key in src) redefine(target, key, src[key], options);
	  return target;
	};

	var SPECIES$1 = wellKnownSymbol('species');

	var setSpecies = function (CONSTRUCTOR_NAME) {
	  var Constructor = getBuiltIn(CONSTRUCTOR_NAME);
	  var defineProperty = objectDefineProperty.f;

	  if (descriptors && Constructor && !Constructor[SPECIES$1]) {
	    defineProperty(Constructor, SPECIES$1, {
	      configurable: true,
	      get: function () { return this; }
	    });
	  }
	};

	var anInstance = function (it, Constructor, name) {
	  if (!(it instanceof Constructor)) {
	    throw TypeError('Incorrect ' + (name ? name + ' ' : '') + 'invocation');
	  } return it;
	};

	var Result = function (stopped, result) {
	  this.stopped = stopped;
	  this.result = result;
	};

	var iterate = function (iterable, unboundFunction, options) {
	  var that = options && options.that;
	  var AS_ENTRIES = !!(options && options.AS_ENTRIES);
	  var IS_ITERATOR = !!(options && options.IS_ITERATOR);
	  var INTERRUPTED = !!(options && options.INTERRUPTED);
	  var fn = functionBindContext(unboundFunction, that, 1 + AS_ENTRIES + INTERRUPTED);
	  var iterator, iterFn, index, length, result, next, step;

	  var stop = function (condition) {
	    if (iterator) iteratorClose(iterator);
	    return new Result(true, condition);
	  };

	  var callFn = function (value) {
	    if (AS_ENTRIES) {
	      anObject(value);
	      return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
	    } return INTERRUPTED ? fn(value, stop) : fn(value);
	  };

	  if (IS_ITERATOR) {
	    iterator = iterable;
	  } else {
	    iterFn = getIteratorMethod(iterable);
	    if (typeof iterFn != 'function') throw TypeError('Target is not iterable');
	    // optimisation for array iterators
	    if (isArrayIteratorMethod(iterFn)) {
	      for (index = 0, length = toLength(iterable.length); length > index; index++) {
	        result = callFn(iterable[index]);
	        if (result && result instanceof Result) return result;
	      } return new Result(false);
	    }
	    iterator = iterFn.call(iterable);
	  }

	  next = iterator.next;
	  while (!(step = next.call(iterator)).done) {
	    try {
	      result = callFn(step.value);
	    } catch (error) {
	      iteratorClose(iterator);
	      throw error;
	    }
	    if (typeof result == 'object' && result && result instanceof Result) return result;
	  } return new Result(false);
	};

	var engineIsIos = /(iphone|ipod|ipad).*applewebkit/i.test(engineUserAgent);

	var location = global_1.location;
	var set$2 = global_1.setImmediate;
	var clear = global_1.clearImmediate;
	var process$3 = global_1.process;
	var MessageChannel = global_1.MessageChannel;
	var Dispatch$1 = global_1.Dispatch;
	var counter = 0;
	var queue = {};
	var ONREADYSTATECHANGE = 'onreadystatechange';
	var defer, channel, port;

	var run$1 = function (id) {
	  // eslint-disable-next-line no-prototype-builtins
	  if (queue.hasOwnProperty(id)) {
	    var fn = queue[id];
	    delete queue[id];
	    fn();
	  }
	};

	var runner = function (id) {
	  return function () {
	    run$1(id);
	  };
	};

	var listener = function (event) {
	  run$1(event.data);
	};

	var post = function (id) {
	  // old engines have not location.origin
	  global_1.postMessage(id + '', location.protocol + '//' + location.host);
	};

	// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
	if (!set$2 || !clear) {
	  set$2 = function setImmediate(fn) {
	    var args = [];
	    var i = 1;
	    while (arguments.length > i) args.push(arguments[i++]);
	    queue[++counter] = function () {
	      // eslint-disable-next-line no-new-func
	      (typeof fn == 'function' ? fn : Function(fn)).apply(undefined, args);
	    };
	    defer(counter);
	    return counter;
	  };
	  clear = function clearImmediate(id) {
	    delete queue[id];
	  };
	  // Node.js 0.8-
	  if (engineIsNode) {
	    defer = function (id) {
	      process$3.nextTick(runner(id));
	    };
	  // Sphere (JS game engine) Dispatch API
	  } else if (Dispatch$1 && Dispatch$1.now) {
	    defer = function (id) {
	      Dispatch$1.now(runner(id));
	    };
	  // Browsers with MessageChannel, includes WebWorkers
	  // except iOS - https://github.com/zloirock/core-js/issues/624
	  } else if (MessageChannel && !engineIsIos) {
	    channel = new MessageChannel();
	    port = channel.port2;
	    channel.port1.onmessage = listener;
	    defer = functionBindContext(port.postMessage, port, 1);
	  // Browsers with postMessage, skip WebWorkers
	  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
	  } else if (
	    global_1.addEventListener &&
	    typeof postMessage == 'function' &&
	    !global_1.importScripts &&
	    location && location.protocol !== 'file:' &&
	    !fails(post)
	  ) {
	    defer = post;
	    global_1.addEventListener('message', listener, false);
	  // IE8-
	  } else if (ONREADYSTATECHANGE in documentCreateElement('script')) {
	    defer = function (id) {
	      html.appendChild(documentCreateElement('script'))[ONREADYSTATECHANGE] = function () {
	        html.removeChild(this);
	        run$1(id);
	      };
	    };
	  // Rest old browsers
	  } else {
	    defer = function (id) {
	      setTimeout(runner(id), 0);
	    };
	  }
	}

	var task$1 = {
	  set: set$2,
	  clear: clear
	};

	var getOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;
	var macrotask = task$1.set;



	var MutationObserver = global_1.MutationObserver || global_1.WebKitMutationObserver;
	var document$2 = global_1.document;
	var process$2 = global_1.process;
	var Promise$3 = global_1.Promise;
	// Node.js 11 shows ExperimentalWarning on getting `queueMicrotask`
	var queueMicrotaskDescriptor = getOwnPropertyDescriptor$1(global_1, 'queueMicrotask');
	var queueMicrotask = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;

	var flush$1, head, last, notify$1, toggle, node, promise, then;

	// modern engines have queueMicrotask method
	if (!queueMicrotask) {
	  flush$1 = function () {
	    var parent, fn;
	    if (engineIsNode && (parent = process$2.domain)) parent.exit();
	    while (head) {
	      fn = head.fn;
	      head = head.next;
	      try {
	        fn();
	      } catch (error) {
	        if (head) notify$1();
	        else last = undefined;
	        throw error;
	      }
	    } last = undefined;
	    if (parent) parent.enter();
	  };

	  // browsers with MutationObserver, except iOS - https://github.com/zloirock/core-js/issues/339
	  if (!engineIsIos && !engineIsNode && MutationObserver && document$2) {
	    toggle = true;
	    node = document$2.createTextNode('');
	    new MutationObserver(flush$1).observe(node, { characterData: true });
	    notify$1 = function () {
	      node.data = toggle = !toggle;
	    };
	  // environments with maybe non-completely correct, but existent Promise
	  } else if (Promise$3 && Promise$3.resolve) {
	    // Promise.resolve without an argument throws an error in LG WebOS 2
	    promise = Promise$3.resolve(undefined);
	    then = promise.then;
	    notify$1 = function () {
	      then.call(promise, flush$1);
	    };
	  // Node.js without promises
	  } else if (engineIsNode) {
	    notify$1 = function () {
	      process$2.nextTick(flush$1);
	    };
	  // for other environments - macrotask based on:
	  // - setImmediate
	  // - MessageChannel
	  // - window.postMessag
	  // - onreadystatechange
	  // - setTimeout
	  } else {
	    notify$1 = function () {
	      // strange IE + webpack dev server bug - use .call(global)
	      macrotask.call(global_1, flush$1);
	    };
	  }
	}

	var microtask = queueMicrotask || function (fn) {
	  var task = { fn: fn, next: undefined };
	  if (last) last.next = task;
	  if (!head) {
	    head = task;
	    notify$1();
	  } last = task;
	};

	var PromiseCapability = function (C) {
	  var resolve, reject;
	  this.promise = new C(function ($$resolve, $$reject) {
	    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
	    resolve = $$resolve;
	    reject = $$reject;
	  });
	  this.resolve = aFunction(resolve);
	  this.reject = aFunction(reject);
	};

	// 25.4.1.5 NewPromiseCapability(C)
	var f$2 = function (C) {
	  return new PromiseCapability(C);
	};

	var newPromiseCapability$1 = {
		f: f$2
	};

	var promiseResolve = function (C, x) {
	  anObject(C);
	  if (isObject$3(x) && x.constructor === C) return x;
	  var promiseCapability = newPromiseCapability$1.f(C);
	  var resolve = promiseCapability.resolve;
	  resolve(x);
	  return promiseCapability.promise;
	};

	var hostReportErrors = function (a, b) {
	  var console = global_1.console;
	  if (console && console.error) {
	    arguments.length === 1 ? console.error(a) : console.error(a, b);
	  }
	};

	var perform = function (exec) {
	  try {
	    return { error: false, value: exec() };
	  } catch (error) {
	    return { error: true, value: error };
	  }
	};

	var task = task$1.set;











	var SPECIES = wellKnownSymbol('species');
	var PROMISE = 'Promise';
	var getInternalState$2 = internalState.get;
	var setInternalState$4 = internalState.set;
	var getInternalPromiseState = internalState.getterFor(PROMISE);
	var PromiseConstructor = nativePromiseConstructor;
	var TypeError$1 = global_1.TypeError;
	var document$1 = global_1.document;
	var process$1 = global_1.process;
	var $fetch = getBuiltIn('fetch');
	var newPromiseCapability = newPromiseCapability$1.f;
	var newGenericPromiseCapability = newPromiseCapability;
	var DISPATCH_EVENT = !!(document$1 && document$1.createEvent && global_1.dispatchEvent);
	var NATIVE_REJECTION_EVENT = typeof PromiseRejectionEvent == 'function';
	var UNHANDLED_REJECTION = 'unhandledrejection';
	var REJECTION_HANDLED = 'rejectionhandled';
	var PENDING = 0;
	var FULFILLED = 1;
	var REJECTED = 2;
	var HANDLED = 1;
	var UNHANDLED = 2;
	var Internal, OwnPromiseCapability, PromiseWrapper, nativeThen;

	var FORCED$3 = isForced_1(PROMISE, function () {
	  var GLOBAL_CORE_JS_PROMISE = inspectSource(PromiseConstructor) !== String(PromiseConstructor);
	  if (!GLOBAL_CORE_JS_PROMISE) {
	    // V8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
	    // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
	    // We can't detect it synchronously, so just check versions
	    if (engineV8Version === 66) return true;
	    // Unhandled rejections tracking support, NodeJS Promise without it fails @@species test
	    if (!engineIsNode && !NATIVE_REJECTION_EVENT) return true;
	  }
	  // We can't use @@species feature detection in V8 since it causes
	  // deoptimization and performance degradation
	  // https://github.com/zloirock/core-js/issues/679
	  if (engineV8Version >= 51 && /native code/.test(PromiseConstructor)) return false;
	  // Detect correctness of subclassing with @@species support
	  var promise = PromiseConstructor.resolve(1);
	  var FakePromise = function (exec) {
	    exec(function () { /* empty */ }, function () { /* empty */ });
	  };
	  var constructor = promise.constructor = {};
	  constructor[SPECIES] = FakePromise;
	  return !(promise.then(function () { /* empty */ }) instanceof FakePromise);
	});

	var INCORRECT_ITERATION = FORCED$3 || !checkCorrectnessOfIteration(function (iterable) {
	  PromiseConstructor.all(iterable)['catch'](function () { /* empty */ });
	});

	// helpers
	var isThenable = function (it) {
	  var then;
	  return isObject$3(it) && typeof (then = it.then) == 'function' ? then : false;
	};

	var notify = function (state, isReject) {
	  if (state.notified) return;
	  state.notified = true;
	  var chain = state.reactions;
	  microtask(function () {
	    var value = state.value;
	    var ok = state.state == FULFILLED;
	    var index = 0;
	    // variable length - can't use forEach
	    while (chain.length > index) {
	      var reaction = chain[index++];
	      var handler = ok ? reaction.ok : reaction.fail;
	      var resolve = reaction.resolve;
	      var reject = reaction.reject;
	      var domain = reaction.domain;
	      var result, then, exited;
	      try {
	        if (handler) {
	          if (!ok) {
	            if (state.rejection === UNHANDLED) onHandleUnhandled(state);
	            state.rejection = HANDLED;
	          }
	          if (handler === true) result = value;
	          else {
	            if (domain) domain.enter();
	            result = handler(value); // can throw
	            if (domain) {
	              domain.exit();
	              exited = true;
	            }
	          }
	          if (result === reaction.promise) {
	            reject(TypeError$1('Promise-chain cycle'));
	          } else if (then = isThenable(result)) {
	            then.call(result, resolve, reject);
	          } else resolve(result);
	        } else reject(value);
	      } catch (error) {
	        if (domain && !exited) domain.exit();
	        reject(error);
	      }
	    }
	    state.reactions = [];
	    state.notified = false;
	    if (isReject && !state.rejection) onUnhandled(state);
	  });
	};

	var dispatchEvent$1 = function (name, promise, reason) {
	  var event, handler;
	  if (DISPATCH_EVENT) {
	    event = document$1.createEvent('Event');
	    event.promise = promise;
	    event.reason = reason;
	    event.initEvent(name, false, true);
	    global_1.dispatchEvent(event);
	  } else event = { promise: promise, reason: reason };
	  if (!NATIVE_REJECTION_EVENT && (handler = global_1['on' + name])) handler(event);
	  else if (name === UNHANDLED_REJECTION) hostReportErrors('Unhandled promise rejection', reason);
	};

	var onUnhandled = function (state) {
	  task.call(global_1, function () {
	    var promise = state.facade;
	    var value = state.value;
	    var IS_UNHANDLED = isUnhandled(state);
	    var result;
	    if (IS_UNHANDLED) {
	      result = perform(function () {
	        if (engineIsNode) {
	          process$1.emit('unhandledRejection', value, promise);
	        } else dispatchEvent$1(UNHANDLED_REJECTION, promise, value);
	      });
	      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
	      state.rejection = engineIsNode || isUnhandled(state) ? UNHANDLED : HANDLED;
	      if (result.error) throw result.value;
	    }
	  });
	};

	var isUnhandled = function (state) {
	  return state.rejection !== HANDLED && !state.parent;
	};

	var onHandleUnhandled = function (state) {
	  task.call(global_1, function () {
	    var promise = state.facade;
	    if (engineIsNode) {
	      process$1.emit('rejectionHandled', promise);
	    } else dispatchEvent$1(REJECTION_HANDLED, promise, state.value);
	  });
	};

	var bind = function (fn, state, unwrap) {
	  return function (value) {
	    fn(state, value, unwrap);
	  };
	};

	var internalReject = function (state, value, unwrap) {
	  if (state.done) return;
	  state.done = true;
	  if (unwrap) state = unwrap;
	  state.value = value;
	  state.state = REJECTED;
	  notify(state, true);
	};

	var internalResolve = function (state, value, unwrap) {
	  if (state.done) return;
	  state.done = true;
	  if (unwrap) state = unwrap;
	  try {
	    if (state.facade === value) throw TypeError$1("Promise can't be resolved itself");
	    var then = isThenable(value);
	    if (then) {
	      microtask(function () {
	        var wrapper = { done: false };
	        try {
	          then.call(value,
	            bind(internalResolve, wrapper, state),
	            bind(internalReject, wrapper, state)
	          );
	        } catch (error) {
	          internalReject(wrapper, error, state);
	        }
	      });
	    } else {
	      state.value = value;
	      state.state = FULFILLED;
	      notify(state, false);
	    }
	  } catch (error) {
	    internalReject({ done: false }, error, state);
	  }
	};

	// constructor polyfill
	if (FORCED$3) {
	  // 25.4.3.1 Promise(executor)
	  PromiseConstructor = function Promise(executor) {
	    anInstance(this, PromiseConstructor, PROMISE);
	    aFunction(executor);
	    Internal.call(this);
	    var state = getInternalState$2(this);
	    try {
	      executor(bind(internalResolve, state), bind(internalReject, state));
	    } catch (error) {
	      internalReject(state, error);
	    }
	  };
	  // eslint-disable-next-line no-unused-vars
	  Internal = function Promise(executor) {
	    setInternalState$4(this, {
	      type: PROMISE,
	      done: false,
	      notified: false,
	      parent: false,
	      reactions: [],
	      rejection: false,
	      state: PENDING,
	      value: undefined
	    });
	  };
	  Internal.prototype = redefineAll(PromiseConstructor.prototype, {
	    // `Promise.prototype.then` method
	    // https://tc39.github.io/ecma262/#sec-promise.prototype.then
	    then: function then(onFulfilled, onRejected) {
	      var state = getInternalPromiseState(this);
	      var reaction = newPromiseCapability(speciesConstructor(this, PromiseConstructor));
	      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
	      reaction.fail = typeof onRejected == 'function' && onRejected;
	      reaction.domain = engineIsNode ? process$1.domain : undefined;
	      state.parent = true;
	      state.reactions.push(reaction);
	      if (state.state != PENDING) notify(state, false);
	      return reaction.promise;
	    },
	    // `Promise.prototype.catch` method
	    // https://tc39.github.io/ecma262/#sec-promise.prototype.catch
	    'catch': function (onRejected) {
	      return this.then(undefined, onRejected);
	    }
	  });
	  OwnPromiseCapability = function () {
	    var promise = new Internal();
	    var state = getInternalState$2(promise);
	    this.promise = promise;
	    this.resolve = bind(internalResolve, state);
	    this.reject = bind(internalReject, state);
	  };
	  newPromiseCapability$1.f = newPromiseCapability = function (C) {
	    return C === PromiseConstructor || C === PromiseWrapper
	      ? new OwnPromiseCapability(C)
	      : newGenericPromiseCapability(C);
	  };

	  if (typeof nativePromiseConstructor == 'function') {
	    nativeThen = nativePromiseConstructor.prototype.then;

	    // wrap native Promise#then for native async functions
	    redefine(nativePromiseConstructor.prototype, 'then', function then(onFulfilled, onRejected) {
	      var that = this;
	      return new PromiseConstructor(function (resolve, reject) {
	        nativeThen.call(that, resolve, reject);
	      }).then(onFulfilled, onRejected);
	    // https://github.com/zloirock/core-js/issues/640
	    }, { unsafe: true });

	    // wrap fetch result
	    if (typeof $fetch == 'function') _export({ global: true, enumerable: true, forced: true }, {
	      // eslint-disable-next-line no-unused-vars
	      fetch: function fetch(input /* , init */) {
	        return promiseResolve(PromiseConstructor, $fetch.apply(global_1, arguments));
	      }
	    });
	  }
	}

	_export({ global: true, wrap: true, forced: FORCED$3 }, {
	  Promise: PromiseConstructor
	});

	setToStringTag(PromiseConstructor, PROMISE, false);
	setSpecies(PROMISE);

	PromiseWrapper = getBuiltIn(PROMISE);

	// statics
	_export({ target: PROMISE, stat: true, forced: FORCED$3 }, {
	  // `Promise.reject` method
	  // https://tc39.github.io/ecma262/#sec-promise.reject
	  reject: function reject(r) {
	    var capability = newPromiseCapability(this);
	    capability.reject.call(undefined, r);
	    return capability.promise;
	  }
	});

	_export({ target: PROMISE, stat: true, forced: FORCED$3 }, {
	  // `Promise.resolve` method
	  // https://tc39.github.io/ecma262/#sec-promise.resolve
	  resolve: function resolve(x) {
	    return promiseResolve(this, x);
	  }
	});

	_export({ target: PROMISE, stat: true, forced: INCORRECT_ITERATION }, {
	  // `Promise.all` method
	  // https://tc39.github.io/ecma262/#sec-promise.all
	  all: function all(iterable) {
	    var C = this;
	    var capability = newPromiseCapability(C);
	    var resolve = capability.resolve;
	    var reject = capability.reject;
	    var result = perform(function () {
	      var $promiseResolve = aFunction(C.resolve);
	      var values = [];
	      var counter = 0;
	      var remaining = 1;
	      iterate(iterable, function (promise) {
	        var index = counter++;
	        var alreadyCalled = false;
	        values.push(undefined);
	        remaining++;
	        $promiseResolve.call(C, promise).then(function (value) {
	          if (alreadyCalled) return;
	          alreadyCalled = true;
	          values[index] = value;
	          --remaining || resolve(values);
	        }, reject);
	      });
	      --remaining || resolve(values);
	    });
	    if (result.error) reject(result.value);
	    return capability.promise;
	  },
	  // `Promise.race` method
	  // https://tc39.github.io/ecma262/#sec-promise.race
	  race: function race(iterable) {
	    var C = this;
	    var capability = newPromiseCapability(C);
	    var reject = capability.reject;
	    var result = perform(function () {
	      var $promiseResolve = aFunction(C.resolve);
	      iterate(iterable, function (promise) {
	        $promiseResolve.call(C, promise).then(capability.resolve, reject);
	      });
	    });
	    if (result.error) reject(result.value);
	    return capability.promise;
	  }
	});

	var TO_STRING = 'toString';
	var RegExpPrototype$1 = RegExp.prototype;
	var nativeToString = RegExpPrototype$1[TO_STRING];

	var NOT_GENERIC = fails(function () { return nativeToString.call({ source: 'a', flags: 'b' }) != '/a/b'; });
	// FF44- RegExp#toString has a wrong name
	var INCORRECT_NAME = nativeToString.name != TO_STRING;

	// `RegExp.prototype.toString` method
	// https://tc39.github.io/ecma262/#sec-regexp.prototype.tostring
	if (NOT_GENERIC || INCORRECT_NAME) {
	  redefine(RegExp.prototype, TO_STRING, function toString() {
	    var R = anObject(this);
	    var p = String(R.source);
	    var rf = R.flags;
	    var f = String(rf === undefined && R instanceof RegExp && !('flags' in RegExpPrototype$1) ? regexpFlags.call(R) : rf);
	    return '/' + p + '/' + f;
	  }, { unsafe: true });
	}

	var max$3 = Math.max;
	var min$4 = Math.min;
	var floor$1 = Math.floor;
	var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d\d?|<[^>]*>)/g;
	var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d\d?)/g;

	var maybeToString = function (it) {
	  return it === undefined ? it : String(it);
	};

	// @@replace logic
	fixRegexpWellKnownSymbolLogic('replace', 2, function (REPLACE, nativeReplace, maybeCallNative, reason) {
	  var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = reason.REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE;
	  var REPLACE_KEEPS_$0 = reason.REPLACE_KEEPS_$0;
	  var UNSAFE_SUBSTITUTE = REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE ? '$' : '$0';

	  return [
	    // `String.prototype.replace` method
	    // https://tc39.github.io/ecma262/#sec-string.prototype.replace
	    function replace(searchValue, replaceValue) {
	      var O = requireObjectCoercible(this);
	      var replacer = searchValue == undefined ? undefined : searchValue[REPLACE];
	      return replacer !== undefined
	        ? replacer.call(searchValue, O, replaceValue)
	        : nativeReplace.call(String(O), searchValue, replaceValue);
	    },
	    // `RegExp.prototype[@@replace]` method
	    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@replace
	    function (regexp, replaceValue) {
	      if (
	        (!REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE && REPLACE_KEEPS_$0) ||
	        (typeof replaceValue === 'string' && replaceValue.indexOf(UNSAFE_SUBSTITUTE) === -1)
	      ) {
	        var res = maybeCallNative(nativeReplace, regexp, this, replaceValue);
	        if (res.done) return res.value;
	      }

	      var rx = anObject(regexp);
	      var S = String(this);

	      var functionalReplace = typeof replaceValue === 'function';
	      if (!functionalReplace) replaceValue = String(replaceValue);

	      var global = rx.global;
	      if (global) {
	        var fullUnicode = rx.unicode;
	        rx.lastIndex = 0;
	      }
	      var results = [];
	      while (true) {
	        var result = regexpExecAbstract(rx, S);
	        if (result === null) break;

	        results.push(result);
	        if (!global) break;

	        var matchStr = String(result[0]);
	        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
	      }

	      var accumulatedResult = '';
	      var nextSourcePosition = 0;
	      for (var i = 0; i < results.length; i++) {
	        result = results[i];

	        var matched = String(result[0]);
	        var position = max$3(min$4(toInteger$1(result.index), S.length), 0);
	        var captures = [];
	        // NOTE: This is equivalent to
	        //   captures = result.slice(1).map(maybeToString)
	        // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
	        // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
	        // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.
	        for (var j = 1; j < result.length; j++) captures.push(maybeToString(result[j]));
	        var namedCaptures = result.groups;
	        if (functionalReplace) {
	          var replacerArgs = [matched].concat(captures, position, S);
	          if (namedCaptures !== undefined) replacerArgs.push(namedCaptures);
	          var replacement = String(replaceValue.apply(undefined, replacerArgs));
	        } else {
	          replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
	        }
	        if (position >= nextSourcePosition) {
	          accumulatedResult += S.slice(nextSourcePosition, position) + replacement;
	          nextSourcePosition = position + matched.length;
	        }
	      }
	      return accumulatedResult + S.slice(nextSourcePosition);
	    }
	  ];

	  // https://tc39.github.io/ecma262/#sec-getsubstitution
	  function getSubstitution(matched, str, position, captures, namedCaptures, replacement) {
	    var tailPos = position + matched.length;
	    var m = captures.length;
	    var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
	    if (namedCaptures !== undefined) {
	      namedCaptures = toObject(namedCaptures);
	      symbols = SUBSTITUTION_SYMBOLS;
	    }
	    return nativeReplace.call(replacement, symbols, function (match, ch) {
	      var capture;
	      switch (ch.charAt(0)) {
	        case '$': return '$';
	        case '&': return matched;
	        case '`': return str.slice(0, position);
	        case "'": return str.slice(tailPos);
	        case '<':
	          capture = namedCaptures[ch.slice(1, -1)];
	          break;
	        default: // \d\d?
	          var n = +ch;
	          if (n === 0) return match;
	          if (n > m) {
	            var f = floor$1(n / 10);
	            if (f === 0) return match;
	            if (f <= m) return captures[f - 1] === undefined ? ch.charAt(1) : captures[f - 1] + ch.charAt(1);
	            return match;
	          }
	          capture = captures[n - 1];
	      }
	      return capture === undefined ? '' : capture;
	    });
	  }
	});

	// keep nulls in tact but
	function numberOrNull(val) {
	  if (val === null) return null;
	  var v = Number(val);
	  if (isNaN(v)) return null;
	  return v;
	} // trim whitespace from a number

	function trimNumber(val) {
	  if (val === null) return null;
	  return val.toString().replace(/\s/g, '').replace(/,/g, '');
	}
	function camelCase(inStr) {
	  return inStr.replace(/_([a-z])/g, function (g) {
	    return g[1].toUpperCase();
	  });
	}
	function valueOrNull(val) {
	  if (val == null) return null;
	  if (val === 'null' || val === 'na' || val === 'n/a' || val === '') return null;
	  return val;
	} // in case the array is sparse we can't just grab the first index
	// include index will return the index number as well

	function getFirstValue(values, from, includeIndex) {
	  var firstValue;
	  var foundIndex;
	  var fromIndex = from || 0;

	  for (var i = fromIndex; i < values.length; i++) {
	    if (valueOrNull(values[i]) != null) {
	      firstValue = values[i];
	      foundIndex = i;
	      break;
	    }
	  }

	  if (includeIndex) return [foundIndex, firstValue];
	  return firstValue;
	}
	function getLastValue(values, from, includeIndex) {
	  var lastValue;
	  var foundIndex;
	  if (from === 0) return [null, null];
	  var fromIndex = from || values.length - 1;

	  for (var i = fromIndex; i >= 0; i--) {
	    if (valueOrNull(values[i]) != null) {
	      lastValue = values[i];
	      foundIndex = i;
	      break;
	    }
	  }

	  if (includeIndex) return [foundIndex, lastValue];
	  return lastValue;
	}
	function isDefined(val) {
	  if (isNaN(val)) return false;
	  if (val === null || val === undefined) return false;
	  return true;
	} // does d3 have an inverse interpolate function? can't find one
	// provide the sum

	function stackedSum(data) {
	  var total = data.reduce(function (sum, val) {
	    if (val == null) return sum;
	    return val > 0 ? sum + val : sum;
	  }, 0); // only read negative stack if sum is zero

	  if (total === 0) {
	    total = data.reduce(function (sum, val) {
	      if (val == null) return sum;
	      return val > 0 ? sum : sum + val;
	    }, 0);
	  }

	  return total;
	} // because d3.ticks is awful sometimes

	function greatestCommonDivisor(a, b) {
	  a = Math.abs(a);
	  b = Math.abs(b);

	  while (b) {
	    var t = b;
	    b = a % b;
	    a = t;
	  }

	  return a;
	}
	function hasDuplicates(array) {
	  var valuesSoFar = Object.create(null);

	  for (var i = 0; i < array.length; ++i) {
	    var value = array[i];

	    if (value in valuesSoFar) {
	      return true;
	    }

	    valuesSoFar[value] = true;
	  }

	  return false;
	} // StandardJS linter removed uses of .hasOwnProperty to
	// use the class function instead

	function hasOwnProperty$h(obj, property) {
	  return Object.prototype.hasOwnProperty.call(obj, property);
	}
	function isPrototypeOf(obj, proto) {
	  return Object.prototype.isPrototypeOf.call(obj, proto);
	} // is the chart published or not? rely on presence of avmmId property
	// was created prior to V3
	// this allows us to sunset features

	function isCreatedPriorToV3(chartData) {
	  if (!chartData) return true;
	  if (!chartData.updatedAt) return true;
	  var d = new Date(chartData.updatedAt);
	  return d.getFullYear() < 2023;
	} // a general function to enable centered header, footer, and legend
	// when not in screenshot mode and not overridden by options

	function isBodyCopyCentered(options) {
	  if (options.isTerminalClient) return false;
	  if (options.screenshotMode && options.screenshotMode === 'avmm') return false;
	  if (options.leftAlignedHeaders) return false;
	  if (options.centeredHeaders === false || options.centeredHeaders === 'false') return false;
	  if (options.centeredLegend === false || options.centeredLegend === 'false') return false;
	  return true;
	}

	// dom nodes

	function addListener(els, eventName, listener, capture) {
	  var typenames = parseTypenames$2(eventName + '');
	  nodeArray(els).forEach(function (node) {
	    typenames.forEach(function (typename) {
	      addListenerTo(node, typename, listener, capture);
	    });
	  });
	}
	function removeListener(els, eventName) {
	  var typenames = parseTypenames$2(eventName + '');
	  nodeArray(els).forEach(function (node) {
	    typenames.forEach(function (typename) {
	      if (node.__on && node.__on.forEach) {
	        node.__on = node.__on.filter(function (key) {
	          var match = key.type === typename.type && key.name === typename.name;

	          if (match) {
	            node.removeEventListener(key.type, key.listener, key.capture);
	          }

	          return match;
	        });
	      }
	    });
	  });
	}

	function addListenerTo(el, typename, listener, capture) {
	  var on = el.__on; // override event listener and return if it exists

	  if (on) {
	    for (var i = 0; i < on.length; i++) {
	      var _key = on[i];

	      if (_key.type === typename.type && _key.name === typename.name) {
	        el.removeEventListener(_key.type, _key.listener, _key.capture);
	        el.addEventListener(_key.type, listener, capture);

	        _extends(_key, {
	          listener: listener,
	          capture: capture
	        });

	        return;
	      }
	    }
	  }

	  el.addEventListener(typename.type, listener, capture);
	  var key = {
	    type: typename.type,
	    name: typename.name,
	    value: listener,
	    // match d3
	    listener: listener,
	    capture: capture
	  };
	  if (!on) el.__on = [key];else on.push(key);
	} // this allows multiple event types like:
	// mouseover.toaster, mouseenter.toaster


	function parseTypenames$2(typenames) {
	  return typenames.trim().split(/^|\s+/).map(function (t) {
	    var name = '';
	    var i = t.indexOf('.');

	    if (i >= 0) {
	      name = t.slice(i + 1);
	      t = t.slice(0, i);
	    }

	    return {
	      type: t,
	      name: name
	    };
	  });
	} // convert every type of dom selector input into an array of nodes


	function nodeArray(els) {
	  if (els.nodes) return els.nodes();
	  if (isPrototypeOf(els, window.NodeList)) return Array.from(els);
	  if (Array.isArray(els)) return els;
	  return [els];
	} // normalize position as point x,y


	function eventPosition(node, event) {
	  var svg = node.ownerSVGElement || node;

	  if (svg.createSVGPoint) {
	    var point = svg.createSVGPoint();
	    point.x = event.clientX;
	    point.y = event.clientY;
	    point = point.matrixTransform(node.getScreenCTM().inverse());
	    return [point.x, point.y];
	  }

	  var rect = node.getBoundingClientRect();
	  return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
	}

	var IS_CONCAT_SPREADABLE = wellKnownSymbol('isConcatSpreadable');
	var MAX_SAFE_INTEGER$3 = 0x1FFFFFFFFFFFFF;
	var MAXIMUM_ALLOWED_INDEX_EXCEEDED = 'Maximum allowed index exceeded';

	// We can't use this feature detection in V8 since it causes
	// deoptimization and serious performance degradation
	// https://github.com/zloirock/core-js/issues/679
	var IS_CONCAT_SPREADABLE_SUPPORT = engineV8Version >= 51 || !fails(function () {
	  var array = [];
	  array[IS_CONCAT_SPREADABLE] = false;
	  return array.concat()[0] !== array;
	});

	var SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('concat');

	var isConcatSpreadable = function (O) {
	  if (!isObject$3(O)) return false;
	  var spreadable = O[IS_CONCAT_SPREADABLE];
	  return spreadable !== undefined ? !!spreadable : isArray$3(O);
	};

	var FORCED$2 = !IS_CONCAT_SPREADABLE_SUPPORT || !SPECIES_SUPPORT;

	// `Array.prototype.concat` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.concat
	// with adding support of @@isConcatSpreadable and @@species
	_export({ target: 'Array', proto: true, forced: FORCED$2 }, {
	  concat: function concat(arg) { // eslint-disable-line no-unused-vars
	    var O = toObject(this);
	    var A = arraySpeciesCreate(O, 0);
	    var n = 0;
	    var i, k, length, len, E;
	    for (i = -1, length = arguments.length; i < length; i++) {
	      E = i === -1 ? O : arguments[i];
	      if (isConcatSpreadable(E)) {
	        len = toLength(E.length);
	        if (n + len > MAX_SAFE_INTEGER$3) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
	        for (k = 0; k < len; k++, n++) if (k in E) createProperty(A, n, E[k]);
	      } else {
	        if (n >= MAX_SAFE_INTEGER$3) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
	        createProperty(A, n++, E);
	      }
	    }
	    A.length = n;
	    return A;
	  }
	});

	var UNSCOPABLES = wellKnownSymbol('unscopables');
	var ArrayPrototype = Array.prototype;

	// Array.prototype[@@unscopables]
	// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
	if (ArrayPrototype[UNSCOPABLES] == undefined) {
	  objectDefineProperty.f(ArrayPrototype, UNSCOPABLES, {
	    configurable: true,
	    value: objectCreate$1(null)
	  });
	}

	// add a key to Array.prototype[@@unscopables]
	var addToUnscopables = function (key) {
	  ArrayPrototype[UNSCOPABLES][key] = true;
	};

	var $find = arrayIteration.find;



	var FIND = 'find';
	var SKIPS_HOLES = true;

	var USES_TO_LENGTH$4 = arrayMethodUsesToLength(FIND);

	// Shouldn't skip holes
	if (FIND in []) Array(1)[FIND](function () { SKIPS_HOLES = false; });

	// `Array.prototype.find` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.find
	_export({ target: 'Array', proto: true, forced: SKIPS_HOLES || !USES_TO_LENGTH$4 }, {
	  find: function find(callbackfn /* , that = undefined */) {
	    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
	addToUnscopables(FIND);

	var $includes = arrayIncludes.includes;



	var USES_TO_LENGTH$3 = arrayMethodUsesToLength('indexOf', { ACCESSORS: true, 1: 0 });

	// `Array.prototype.includes` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.includes
	_export({ target: 'Array', proto: true, forced: !USES_TO_LENGTH$3 }, {
	  includes: function includes(el /* , fromIndex = 0 */) {
	    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
	addToUnscopables('includes');

	var defineProperty$5 = objectDefineProperty.f;
	var getOwnPropertyNames = objectGetOwnPropertyNames.f;





	var setInternalState$3 = internalState.set;



	var MATCH = wellKnownSymbol('match');
	var NativeRegExp = global_1.RegExp;
	var RegExpPrototype = NativeRegExp.prototype;
	var re1 = /a/g;
	var re2 = /a/g;

	// "new" should create a new object, old webkit bug
	var CORRECT_NEW = new NativeRegExp(re1) !== re1;

	var UNSUPPORTED_Y = regexpStickyHelpers.UNSUPPORTED_Y;

	var FORCED$1 = descriptors && isForced_1('RegExp', (!CORRECT_NEW || UNSUPPORTED_Y || fails(function () {
	  re2[MATCH] = false;
	  // RegExp constructor can alter flags and IsRegExp works correct with @@match
	  return NativeRegExp(re1) != re1 || NativeRegExp(re2) == re2 || NativeRegExp(re1, 'i') != '/a/i';
	})));

	// `RegExp` constructor
	// https://tc39.github.io/ecma262/#sec-regexp-constructor
	if (FORCED$1) {
	  var RegExpWrapper = function RegExp(pattern, flags) {
	    var thisIsRegExp = this instanceof RegExpWrapper;
	    var patternIsRegExp = isRegexp(pattern);
	    var flagsAreUndefined = flags === undefined;
	    var sticky;

	    if (!thisIsRegExp && patternIsRegExp && pattern.constructor === RegExpWrapper && flagsAreUndefined) {
	      return pattern;
	    }

	    if (CORRECT_NEW) {
	      if (patternIsRegExp && !flagsAreUndefined) pattern = pattern.source;
	    } else if (pattern instanceof RegExpWrapper) {
	      if (flagsAreUndefined) flags = regexpFlags.call(pattern);
	      pattern = pattern.source;
	    }

	    if (UNSUPPORTED_Y) {
	      sticky = !!flags && flags.indexOf('y') > -1;
	      if (sticky) flags = flags.replace(/y/g, '');
	    }

	    var result = inheritIfRequired(
	      CORRECT_NEW ? new NativeRegExp(pattern, flags) : NativeRegExp(pattern, flags),
	      thisIsRegExp ? this : RegExpPrototype,
	      RegExpWrapper
	    );

	    if (UNSUPPORTED_Y && sticky) setInternalState$3(result, { sticky: sticky });

	    return result;
	  };
	  var proxy = function (key) {
	    key in RegExpWrapper || defineProperty$5(RegExpWrapper, key, {
	      configurable: true,
	      get: function () { return NativeRegExp[key]; },
	      set: function (it) { NativeRegExp[key] = it; }
	    });
	  };
	  var keys$1 = getOwnPropertyNames(NativeRegExp);
	  var index$1 = 0;
	  while (keys$1.length > index$1) proxy(keys$1[index$1++]);
	  RegExpPrototype.constructor = RegExpWrapper;
	  RegExpWrapper.prototype = RegExpPrototype;
	  redefine(global_1, 'RegExp', RegExpWrapper);
	}

	// https://tc39.github.io/ecma262/#sec-get-regexp-@@species
	setSpecies('RegExp');

	// `String.prototype.includes` method
	// https://tc39.github.io/ecma262/#sec-string.prototype.includes
	_export({ target: 'String', proto: true, forced: !correctIsRegexpLogic('includes') }, {
	  includes: function includes(searchString /* , position = 0 */) {
	    return !!~String(requireObjectCoercible(this))
	      .indexOf(notARegexp(searchString), arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	// `SameValue` abstract operation
	// https://tc39.github.io/ecma262/#sec-samevalue
	var sameValue = Object.is || function is(x, y) {
	  // eslint-disable-next-line no-self-compare
	  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
	};

	// @@search logic
	fixRegexpWellKnownSymbolLogic('search', 1, function (SEARCH, nativeSearch, maybeCallNative) {
	  return [
	    // `String.prototype.search` method
	    // https://tc39.github.io/ecma262/#sec-string.prototype.search
	    function search(regexp) {
	      var O = requireObjectCoercible(this);
	      var searcher = regexp == undefined ? undefined : regexp[SEARCH];
	      return searcher !== undefined ? searcher.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
	    },
	    // `RegExp.prototype[@@search]` method
	    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@search
	    function (regexp) {
	      var res = maybeCallNative(nativeSearch, regexp, this);
	      if (res.done) return res.value;

	      var rx = anObject(regexp);
	      var S = String(this);

	      var previousLastIndex = rx.lastIndex;
	      if (!sameValue(previousLastIndex, 0)) rx.lastIndex = 0;
	      var result = regexpExecAbstract(rx, S);
	      if (!sameValue(rx.lastIndex, previousLastIndex)) rx.lastIndex = previousLastIndex;
	      return result === null ? -1 : result.index;
	    }
	  ];
	});

	/**
	 * Removes all key-value entries from the list cache.
	 *
	 * @private
	 * @name clear
	 * @memberOf ListCache
	 */
	function listCacheClear$1() {
	  this.__data__ = [];
	  this.size = 0;
	}

	/**
	 * Performs a
	 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * comparison between two values to determine if they are equivalent.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 * var other = { 'a': 1 };
	 *
	 * _.eq(object, object);
	 * // => true
	 *
	 * _.eq(object, other);
	 * // => false
	 *
	 * _.eq('a', 'a');
	 * // => true
	 *
	 * _.eq('a', Object('a'));
	 * // => false
	 *
	 * _.eq(NaN, NaN);
	 * // => true
	 */
	function eq$1(value, other) {
	  return value === other || (value !== value && other !== other);
	}

	/**
	 * Gets the index at which the `key` is found in `array` of key-value pairs.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} key The key to search for.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function assocIndexOf$1(array, key) {
	  var length = array.length;
	  while (length--) {
	    if (eq$1(array[length][0], key)) {
	      return length;
	    }
	  }
	  return -1;
	}

	/** Used for built-in method references. */
	var arrayProto$1 = Array.prototype;

	/** Built-in value references. */
	var splice$1 = arrayProto$1.splice;

	/**
	 * Removes `key` and its value from the list cache.
	 *
	 * @private
	 * @name delete
	 * @memberOf ListCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function listCacheDelete$1(key) {
	  var data = this.__data__,
	      index = assocIndexOf$1(data, key);

	  if (index < 0) {
	    return false;
	  }
	  var lastIndex = data.length - 1;
	  if (index == lastIndex) {
	    data.pop();
	  } else {
	    splice$1.call(data, index, 1);
	  }
	  --this.size;
	  return true;
	}

	/**
	 * Gets the list cache value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf ListCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function listCacheGet$1(key) {
	  var data = this.__data__,
	      index = assocIndexOf$1(data, key);

	  return index < 0 ? undefined : data[index][1];
	}

	/**
	 * Checks if a list cache value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf ListCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function listCacheHas$1(key) {
	  return assocIndexOf$1(this.__data__, key) > -1;
	}

	/**
	 * Sets the list cache `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf ListCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the list cache instance.
	 */
	function listCacheSet$1(key, value) {
	  var data = this.__data__,
	      index = assocIndexOf$1(data, key);

	  if (index < 0) {
	    ++this.size;
	    data.push([key, value]);
	  } else {
	    data[index][1] = value;
	  }
	  return this;
	}

	/**
	 * Creates an list cache object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function ListCache$1(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `ListCache`.
	ListCache$1.prototype.clear = listCacheClear$1;
	ListCache$1.prototype['delete'] = listCacheDelete$1;
	ListCache$1.prototype.get = listCacheGet$1;
	ListCache$1.prototype.has = listCacheHas$1;
	ListCache$1.prototype.set = listCacheSet$1;

	/**
	 * Removes all key-value entries from the stack.
	 *
	 * @private
	 * @name clear
	 * @memberOf Stack
	 */
	function stackClear() {
	  this.__data__ = new ListCache$1;
	  this.size = 0;
	}

	/**
	 * Removes `key` and its value from the stack.
	 *
	 * @private
	 * @name delete
	 * @memberOf Stack
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function stackDelete(key) {
	  var data = this.__data__,
	      result = data['delete'](key);

	  this.size = data.size;
	  return result;
	}

	/**
	 * Gets the stack value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Stack
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function stackGet(key) {
	  return this.__data__.get(key);
	}

	/**
	 * Checks if a stack value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Stack
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function stackHas(key) {
	  return this.__data__.has(key);
	}

	/** Detect free variable `global` from Node.js. */
	var freeGlobal$2 = typeof global == 'object' && global && global.Object === Object && global;

	var freeGlobal$3 = freeGlobal$2;

	/** Detect free variable `self`. */
	var freeSelf$2 = typeof self == 'object' && self && self.Object === Object && self;

	/** Used as a reference to the global object. */
	var root$3 = freeGlobal$3 || freeSelf$2 || Function('return this')();

	var root$4 = root$3;

	/** Built-in value references. */
	var Symbol$2 = root$4.Symbol;

	var Symbol$3 = Symbol$2;

	/** Used for built-in method references. */
	var objectProto$l = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$g = objectProto$l.hasOwnProperty;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString$3 = objectProto$l.toString;

	/** Built-in value references. */
	var symToStringTag$3 = Symbol$3 ? Symbol$3.toStringTag : undefined;

	/**
	 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the raw `toStringTag`.
	 */
	function getRawTag$1(value) {
	  var isOwn = hasOwnProperty$g.call(value, symToStringTag$3),
	      tag = value[symToStringTag$3];

	  try {
	    value[symToStringTag$3] = undefined;
	    var unmasked = true;
	  } catch (e) {}

	  var result = nativeObjectToString$3.call(value);
	  if (unmasked) {
	    if (isOwn) {
	      value[symToStringTag$3] = tag;
	    } else {
	      delete value[symToStringTag$3];
	    }
	  }
	  return result;
	}

	/** Used for built-in method references. */
	var objectProto$k = Object.prototype;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString$2 = objectProto$k.toString;

	/**
	 * Converts `value` to a string using `Object.prototype.toString`.
	 *
	 * @private
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 */
	function objectToString$2(value) {
	  return nativeObjectToString$2.call(value);
	}

	/** `Object#toString` result references. */
	var nullTag$1 = '[object Null]',
	    undefinedTag$1 = '[object Undefined]';

	/** Built-in value references. */
	var symToStringTag$2 = Symbol$3 ? Symbol$3.toStringTag : undefined;

	/**
	 * The base implementation of `getTag` without fallbacks for buggy environments.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	function baseGetTag$1(value) {
	  if (value == null) {
	    return value === undefined ? undefinedTag$1 : nullTag$1;
	  }
	  return (symToStringTag$2 && symToStringTag$2 in Object(value))
	    ? getRawTag$1(value)
	    : objectToString$2(value);
	}

	/**
	 * Checks if `value` is the
	 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(_.noop);
	 * // => true
	 *
	 * _.isObject(null);
	 * // => false
	 */
	function isObject$2(value) {
	  var type = typeof value;
	  return value != null && (type == 'object' || type == 'function');
	}

	/** `Object#toString` result references. */
	var asyncTag$1 = '[object AsyncFunction]',
	    funcTag$3 = '[object Function]',
	    genTag$2 = '[object GeneratorFunction]',
	    proxyTag$1 = '[object Proxy]';

	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction$1(value) {
	  if (!isObject$2(value)) {
	    return false;
	  }
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in Safari 9 which returns 'object' for typed arrays and other constructors.
	  var tag = baseGetTag$1(value);
	  return tag == funcTag$3 || tag == genTag$2 || tag == asyncTag$1 || tag == proxyTag$1;
	}

	/** Used to detect overreaching core-js shims. */
	var coreJsData$1 = root$4['__core-js_shared__'];

	var coreJsData$2 = coreJsData$1;

	/** Used to detect methods masquerading as native. */
	var maskSrcKey$1 = (function() {
	  var uid = /[^.]+$/.exec(coreJsData$2 && coreJsData$2.keys && coreJsData$2.keys.IE_PROTO || '');
	  return uid ? ('Symbol(src)_1.' + uid) : '';
	}());

	/**
	 * Checks if `func` has its source masked.
	 *
	 * @private
	 * @param {Function} func The function to check.
	 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
	 */
	function isMasked$1(func) {
	  return !!maskSrcKey$1 && (maskSrcKey$1 in func);
	}

	/** Used for built-in method references. */
	var funcProto$4 = Function.prototype;

	/** Used to resolve the decompiled source of functions. */
	var funcToString$4 = funcProto$4.toString;

	/**
	 * Converts `func` to its source code.
	 *
	 * @private
	 * @param {Function} func The function to convert.
	 * @returns {string} Returns the source code.
	 */
	function toSource$1(func) {
	  if (func != null) {
	    try {
	      return funcToString$4.call(func);
	    } catch (e) {}
	    try {
	      return (func + '');
	    } catch (e) {}
	  }
	  return '';
	}

	/**
	 * Used to match `RegExp`
	 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
	 */
	var reRegExpChar$1 = /[\\^$.*+?()[\]{}|]/g;

	/** Used to detect host constructors (Safari). */
	var reIsHostCtor$1 = /^\[object .+?Constructor\]$/;

	/** Used for built-in method references. */
	var funcProto$3 = Function.prototype,
	    objectProto$j = Object.prototype;

	/** Used to resolve the decompiled source of functions. */
	var funcToString$3 = funcProto$3.toString;

	/** Used to check objects for own properties. */
	var hasOwnProperty$f = objectProto$j.hasOwnProperty;

	/** Used to detect if a method is native. */
	var reIsNative$1 = RegExp('^' +
	  funcToString$3.call(hasOwnProperty$f).replace(reRegExpChar$1, '\\$&')
	  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	);

	/**
	 * The base implementation of `_.isNative` without bad shim checks.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a native function,
	 *  else `false`.
	 */
	function baseIsNative$1(value) {
	  if (!isObject$2(value) || isMasked$1(value)) {
	    return false;
	  }
	  var pattern = isFunction$1(value) ? reIsNative$1 : reIsHostCtor$1;
	  return pattern.test(toSource$1(value));
	}

	/**
	 * Gets the value at `key` of `object`.
	 *
	 * @private
	 * @param {Object} [object] The object to query.
	 * @param {string} key The key of the property to get.
	 * @returns {*} Returns the property value.
	 */
	function getValue$1(object, key) {
	  return object == null ? undefined : object[key];
	}

	/**
	 * Gets the native function at `key` of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the method to get.
	 * @returns {*} Returns the function if it's native, else `undefined`.
	 */
	function getNative$1(object, key) {
	  var value = getValue$1(object, key);
	  return baseIsNative$1(value) ? value : undefined;
	}

	/* Built-in method references that are verified to be native. */
	var Map$3 = getNative$1(root$4, 'Map');

	var Map$4 = Map$3;

	/* Built-in method references that are verified to be native. */
	var nativeCreate$1 = getNative$1(Object, 'create');

	var nativeCreate$2 = nativeCreate$1;

	/**
	 * Removes all key-value entries from the hash.
	 *
	 * @private
	 * @name clear
	 * @memberOf Hash
	 */
	function hashClear$1() {
	  this.__data__ = nativeCreate$2 ? nativeCreate$2(null) : {};
	  this.size = 0;
	}

	/**
	 * Removes `key` and its value from the hash.
	 *
	 * @private
	 * @name delete
	 * @memberOf Hash
	 * @param {Object} hash The hash to modify.
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function hashDelete$1(key) {
	  var result = this.has(key) && delete this.__data__[key];
	  this.size -= result ? 1 : 0;
	  return result;
	}

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED$4 = '__lodash_hash_undefined__';

	/** Used for built-in method references. */
	var objectProto$i = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$e = objectProto$i.hasOwnProperty;

	/**
	 * Gets the hash value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Hash
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function hashGet$1(key) {
	  var data = this.__data__;
	  if (nativeCreate$2) {
	    var result = data[key];
	    return result === HASH_UNDEFINED$4 ? undefined : result;
	  }
	  return hasOwnProperty$e.call(data, key) ? data[key] : undefined;
	}

	/** Used for built-in method references. */
	var objectProto$h = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$d = objectProto$h.hasOwnProperty;

	/**
	 * Checks if a hash value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Hash
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function hashHas$1(key) {
	  var data = this.__data__;
	  return nativeCreate$2 ? (data[key] !== undefined) : hasOwnProperty$d.call(data, key);
	}

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED$3 = '__lodash_hash_undefined__';

	/**
	 * Sets the hash `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Hash
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the hash instance.
	 */
	function hashSet$1(key, value) {
	  var data = this.__data__;
	  this.size += this.has(key) ? 0 : 1;
	  data[key] = (nativeCreate$2 && value === undefined) ? HASH_UNDEFINED$3 : value;
	  return this;
	}

	/**
	 * Creates a hash object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Hash$1(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `Hash`.
	Hash$1.prototype.clear = hashClear$1;
	Hash$1.prototype['delete'] = hashDelete$1;
	Hash$1.prototype.get = hashGet$1;
	Hash$1.prototype.has = hashHas$1;
	Hash$1.prototype.set = hashSet$1;

	/**
	 * Removes all key-value entries from the map.
	 *
	 * @private
	 * @name clear
	 * @memberOf MapCache
	 */
	function mapCacheClear$1() {
	  this.size = 0;
	  this.__data__ = {
	    'hash': new Hash$1,
	    'map': new (Map$4 || ListCache$1),
	    'string': new Hash$1
	  };
	}

	/**
	 * Checks if `value` is suitable for use as unique object key.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
	 */
	function isKeyable$1(value) {
	  var type = typeof value;
	  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
	    ? (value !== '__proto__')
	    : (value === null);
	}

	/**
	 * Gets the data for `map`.
	 *
	 * @private
	 * @param {Object} map The map to query.
	 * @param {string} key The reference key.
	 * @returns {*} Returns the map data.
	 */
	function getMapData$1(map, key) {
	  var data = map.__data__;
	  return isKeyable$1(key)
	    ? data[typeof key == 'string' ? 'string' : 'hash']
	    : data.map;
	}

	/**
	 * Removes `key` and its value from the map.
	 *
	 * @private
	 * @name delete
	 * @memberOf MapCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function mapCacheDelete$1(key) {
	  var result = getMapData$1(this, key)['delete'](key);
	  this.size -= result ? 1 : 0;
	  return result;
	}

	/**
	 * Gets the map value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf MapCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function mapCacheGet$1(key) {
	  return getMapData$1(this, key).get(key);
	}

	/**
	 * Checks if a map value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf MapCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function mapCacheHas$1(key) {
	  return getMapData$1(this, key).has(key);
	}

	/**
	 * Sets the map `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf MapCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the map cache instance.
	 */
	function mapCacheSet$1(key, value) {
	  var data = getMapData$1(this, key),
	      size = data.size;

	  data.set(key, value);
	  this.size += data.size == size ? 0 : 1;
	  return this;
	}

	/**
	 * Creates a map cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function MapCache$1(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `MapCache`.
	MapCache$1.prototype.clear = mapCacheClear$1;
	MapCache$1.prototype['delete'] = mapCacheDelete$1;
	MapCache$1.prototype.get = mapCacheGet$1;
	MapCache$1.prototype.has = mapCacheHas$1;
	MapCache$1.prototype.set = mapCacheSet$1;

	/** Used as the size to enable large array optimizations. */
	var LARGE_ARRAY_SIZE = 200;

	/**
	 * Sets the stack `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Stack
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the stack cache instance.
	 */
	function stackSet(key, value) {
	  var data = this.__data__;
	  if (data instanceof ListCache$1) {
	    var pairs = data.__data__;
	    if (!Map$4 || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
	      pairs.push([key, value]);
	      this.size = ++data.size;
	      return this;
	    }
	    data = this.__data__ = new MapCache$1(pairs);
	  }
	  data.set(key, value);
	  this.size = data.size;
	  return this;
	}

	/**
	 * Creates a stack cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Stack(entries) {
	  var data = this.__data__ = new ListCache$1(entries);
	  this.size = data.size;
	}

	// Add methods to `Stack`.
	Stack.prototype.clear = stackClear;
	Stack.prototype['delete'] = stackDelete;
	Stack.prototype.get = stackGet;
	Stack.prototype.has = stackHas;
	Stack.prototype.set = stackSet;

	/**
	 * A specialized version of `_.forEach` for arrays without support for
	 * iteratee shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns `array`.
	 */
	function arrayEach(array, iteratee) {
	  var index = -1,
	      length = array == null ? 0 : array.length;

	  while (++index < length) {
	    if (iteratee(array[index], index, array) === false) {
	      break;
	    }
	  }
	  return array;
	}

	var defineProperty$3 = (function() {
	  try {
	    var func = getNative$1(Object, 'defineProperty');
	    func({}, '', {});
	    return func;
	  } catch (e) {}
	}());

	var defineProperty$4 = defineProperty$3;

	/**
	 * The base implementation of `assignValue` and `assignMergeValue` without
	 * value checks.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {string} key The key of the property to assign.
	 * @param {*} value The value to assign.
	 */
	function baseAssignValue(object, key, value) {
	  if (key == '__proto__' && defineProperty$4) {
	    defineProperty$4(object, key, {
	      'configurable': true,
	      'enumerable': true,
	      'value': value,
	      'writable': true
	    });
	  } else {
	    object[key] = value;
	  }
	}

	/** Used for built-in method references. */
	var objectProto$g = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$c = objectProto$g.hasOwnProperty;

	/**
	 * Assigns `value` to `key` of `object` if the existing value is not equivalent
	 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * for equality comparisons.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {string} key The key of the property to assign.
	 * @param {*} value The value to assign.
	 */
	function assignValue(object, key, value) {
	  var objValue = object[key];
	  if (!(hasOwnProperty$c.call(object, key) && eq$1(objValue, value)) ||
	      (value === undefined && !(key in object))) {
	    baseAssignValue(object, key, value);
	  }
	}

	/**
	 * Copies properties of `source` to `object`.
	 *
	 * @private
	 * @param {Object} source The object to copy properties from.
	 * @param {Array} props The property identifiers to copy.
	 * @param {Object} [object={}] The object to copy properties to.
	 * @param {Function} [customizer] The function to customize copied values.
	 * @returns {Object} Returns `object`.
	 */
	function copyObject(source, props, object, customizer) {
	  var isNew = !object;
	  object || (object = {});

	  var index = -1,
	      length = props.length;

	  while (++index < length) {
	    var key = props[index];

	    var newValue = customizer
	      ? customizer(object[key], source[key], key, object, source)
	      : undefined;

	    if (newValue === undefined) {
	      newValue = source[key];
	    }
	    if (isNew) {
	      baseAssignValue(object, key, newValue);
	    } else {
	      assignValue(object, key, newValue);
	    }
	  }
	  return object;
	}

	/**
	 * The base implementation of `_.times` without support for iteratee shorthands
	 * or max array length checks.
	 *
	 * @private
	 * @param {number} n The number of times to invoke `iteratee`.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the array of results.
	 */
	function baseTimes(n, iteratee) {
	  var index = -1,
	      result = Array(n);

	  while (++index < n) {
	    result[index] = iteratee(index);
	  }
	  return result;
	}

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike$2(value) {
	  return value != null && typeof value == 'object';
	}

	/** `Object#toString` result references. */
	var argsTag$3 = '[object Arguments]';

	/**
	 * The base implementation of `_.isArguments`.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 */
	function baseIsArguments(value) {
	  return isObjectLike$2(value) && baseGetTag$1(value) == argsTag$3;
	}

	/** Used for built-in method references. */
	var objectProto$f = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$b = objectProto$f.hasOwnProperty;

	/** Built-in value references. */
	var propertyIsEnumerable$2 = objectProto$f.propertyIsEnumerable;

	/**
	 * Checks if `value` is likely an `arguments` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArguments(function() { return arguments; }());
	 * // => true
	 *
	 * _.isArguments([1, 2, 3]);
	 * // => false
	 */
	var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
	  return isObjectLike$2(value) && hasOwnProperty$b.call(value, 'callee') &&
	    !propertyIsEnumerable$2.call(value, 'callee');
	};

	var isArguments$1 = isArguments;

	/**
	 * Checks if `value` is classified as an `Array` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
	 * @example
	 *
	 * _.isArray([1, 2, 3]);
	 * // => true
	 *
	 * _.isArray(document.body.children);
	 * // => false
	 *
	 * _.isArray('abc');
	 * // => false
	 *
	 * _.isArray(_.noop);
	 * // => false
	 */
	var isArray$1 = Array.isArray;

	var isArray$2 = isArray$1;

	/**
	 * This method returns `false`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.13.0
	 * @category Util
	 * @returns {boolean} Returns `false`.
	 * @example
	 *
	 * _.times(2, _.stubFalse);
	 * // => [false, false]
	 */
	function stubFalse() {
	  return false;
	}

	/** Detect free variable `exports`. */
	var freeExports$2 = typeof exports == 'object' && exports && !exports.nodeType && exports;

	/** Detect free variable `module`. */
	var freeModule$2 = freeExports$2 && typeof module == 'object' && module && !module.nodeType && module;

	/** Detect the popular CommonJS extension `module.exports`. */
	var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;

	/** Built-in value references. */
	var Buffer$1 = moduleExports$2 ? root$4.Buffer : undefined;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeIsBuffer = Buffer$1 ? Buffer$1.isBuffer : undefined;

	/**
	 * Checks if `value` is a buffer.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.3.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
	 * @example
	 *
	 * _.isBuffer(new Buffer(2));
	 * // => true
	 *
	 * _.isBuffer(new Uint8Array(2));
	 * // => false
	 */
	var isBuffer$1 = nativeIsBuffer || stubFalse;

	var isBuffer$2 = isBuffer$1;

	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER$2 = 9007199254740991;

	/** Used to detect unsigned integer values. */
	var reIsUint = /^(?:0|[1-9]\d*)$/;

	/**
	 * Checks if `value` is a valid array-like index.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	 */
	function isIndex(value, length) {
	  var type = typeof value;
	  length = length == null ? MAX_SAFE_INTEGER$2 : length;

	  return !!length &&
	    (type == 'number' ||
	      (type != 'symbol' && reIsUint.test(value))) &&
	        (value > -1 && value % 1 == 0 && value < length);
	}

	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER$1 = 9007199254740991;

	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This method is loosely based on
	 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 * @example
	 *
	 * _.isLength(3);
	 * // => true
	 *
	 * _.isLength(Number.MIN_VALUE);
	 * // => false
	 *
	 * _.isLength(Infinity);
	 * // => false
	 *
	 * _.isLength('3');
	 * // => false
	 */
	function isLength(value) {
	  return typeof value == 'number' &&
	    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$1;
	}

	/** `Object#toString` result references. */
	var argsTag$2 = '[object Arguments]',
	    arrayTag$2 = '[object Array]',
	    boolTag$3 = '[object Boolean]',
	    dateTag$3 = '[object Date]',
	    errorTag$2 = '[object Error]',
	    funcTag$2 = '[object Function]',
	    mapTag$5 = '[object Map]',
	    numberTag$3 = '[object Number]',
	    objectTag$4 = '[object Object]',
	    regexpTag$3 = '[object RegExp]',
	    setTag$5 = '[object Set]',
	    stringTag$4 = '[object String]',
	    weakMapTag$2 = '[object WeakMap]';

	var arrayBufferTag$3 = '[object ArrayBuffer]',
	    dataViewTag$4 = '[object DataView]',
	    float32Tag$2 = '[object Float32Array]',
	    float64Tag$2 = '[object Float64Array]',
	    int8Tag$2 = '[object Int8Array]',
	    int16Tag$2 = '[object Int16Array]',
	    int32Tag$2 = '[object Int32Array]',
	    uint8Tag$2 = '[object Uint8Array]',
	    uint8ClampedTag$2 = '[object Uint8ClampedArray]',
	    uint16Tag$2 = '[object Uint16Array]',
	    uint32Tag$2 = '[object Uint32Array]';

	/** Used to identify `toStringTag` values of typed arrays. */
	var typedArrayTags = {};
	typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] =
	typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] =
	typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] =
	typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] =
	typedArrayTags[uint32Tag$2] = true;
	typedArrayTags[argsTag$2] = typedArrayTags[arrayTag$2] =
	typedArrayTags[arrayBufferTag$3] = typedArrayTags[boolTag$3] =
	typedArrayTags[dataViewTag$4] = typedArrayTags[dateTag$3] =
	typedArrayTags[errorTag$2] = typedArrayTags[funcTag$2] =
	typedArrayTags[mapTag$5] = typedArrayTags[numberTag$3] =
	typedArrayTags[objectTag$4] = typedArrayTags[regexpTag$3] =
	typedArrayTags[setTag$5] = typedArrayTags[stringTag$4] =
	typedArrayTags[weakMapTag$2] = false;

	/**
	 * The base implementation of `_.isTypedArray` without Node.js optimizations.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 */
	function baseIsTypedArray(value) {
	  return isObjectLike$2(value) &&
	    isLength(value.length) && !!typedArrayTags[baseGetTag$1(value)];
	}

	/**
	 * The base implementation of `_.unary` without support for storing metadata.
	 *
	 * @private
	 * @param {Function} func The function to cap arguments for.
	 * @returns {Function} Returns the new capped function.
	 */
	function baseUnary(func) {
	  return function(value) {
	    return func(value);
	  };
	}

	/** Detect free variable `exports`. */
	var freeExports$1 = typeof exports == 'object' && exports && !exports.nodeType && exports;

	/** Detect free variable `module`. */
	var freeModule$1 = freeExports$1 && typeof module == 'object' && module && !module.nodeType && module;

	/** Detect the popular CommonJS extension `module.exports`. */
	var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;

	/** Detect free variable `process` from Node.js. */
	var freeProcess = moduleExports$1 && freeGlobal$3.process;

	/** Used to access faster Node.js helpers. */
	var nodeUtil = (function() {
	  try {
	    // Use `util.types` for Node.js 10+.
	    var types = freeModule$1 && freeModule$1.require && freeModule$1.require('util').types;

	    if (types) {
	      return types;
	    }

	    // Legacy `process.binding('util')` for Node.js < 10.
	    return freeProcess && freeProcess.binding && freeProcess.binding('util');
	  } catch (e) {}
	}());

	var nodeUtil$1 = nodeUtil;

	/* Node.js helper references. */
	var nodeIsTypedArray = nodeUtil$1 && nodeUtil$1.isTypedArray;

	/**
	 * Checks if `value` is classified as a typed array.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 * @example
	 *
	 * _.isTypedArray(new Uint8Array);
	 * // => true
	 *
	 * _.isTypedArray([]);
	 * // => false
	 */
	var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

	var isTypedArray$1 = isTypedArray;

	/** Used for built-in method references. */
	var objectProto$e = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$a = objectProto$e.hasOwnProperty;

	/**
	 * Creates an array of the enumerable property names of the array-like `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @param {boolean} inherited Specify returning inherited property names.
	 * @returns {Array} Returns the array of property names.
	 */
	function arrayLikeKeys(value, inherited) {
	  var isArr = isArray$2(value),
	      isArg = !isArr && isArguments$1(value),
	      isBuff = !isArr && !isArg && isBuffer$2(value),
	      isType = !isArr && !isArg && !isBuff && isTypedArray$1(value),
	      skipIndexes = isArr || isArg || isBuff || isType,
	      result = skipIndexes ? baseTimes(value.length, String) : [],
	      length = result.length;

	  for (var key in value) {
	    if ((inherited || hasOwnProperty$a.call(value, key)) &&
	        !(skipIndexes && (
	           // Safari 9 has enumerable `arguments.length` in strict mode.
	           key == 'length' ||
	           // Node.js 0.10 has enumerable non-index properties on buffers.
	           (isBuff && (key == 'offset' || key == 'parent')) ||
	           // PhantomJS 2 has enumerable non-index properties on typed arrays.
	           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
	           // Skip index properties.
	           isIndex(key, length)
	        ))) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	/** Used for built-in method references. */
	var objectProto$d = Object.prototype;

	/**
	 * Checks if `value` is likely a prototype object.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
	 */
	function isPrototype(value) {
	  var Ctor = value && value.constructor,
	      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto$d;

	  return value === proto;
	}

	/**
	 * Creates a unary function that invokes `func` with its argument transformed.
	 *
	 * @private
	 * @param {Function} func The function to wrap.
	 * @param {Function} transform The argument transform.
	 * @returns {Function} Returns the new function.
	 */
	function overArg(func, transform) {
	  return function(arg) {
	    return func(transform(arg));
	  };
	}

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeKeys = overArg(Object.keys, Object);

	var nativeKeys$1 = nativeKeys;

	/** Used for built-in method references. */
	var objectProto$c = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$9 = objectProto$c.hasOwnProperty;

	/**
	 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function baseKeys(object) {
	  if (!isPrototype(object)) {
	    return nativeKeys$1(object);
	  }
	  var result = [];
	  for (var key in Object(object)) {
	    if (hasOwnProperty$9.call(object, key) && key != 'constructor') {
	      result.push(key);
	    }
	  }
	  return result;
	}

	/**
	 * Checks if `value` is array-like. A value is considered array-like if it's
	 * not a function and has a `value.length` that's an integer greater than or
	 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	 * @example
	 *
	 * _.isArrayLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLike(document.body.children);
	 * // => true
	 *
	 * _.isArrayLike('abc');
	 * // => true
	 *
	 * _.isArrayLike(_.noop);
	 * // => false
	 */
	function isArrayLike(value) {
	  return value != null && isLength(value.length) && !isFunction$1(value);
	}

	/**
	 * Creates an array of the own enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects. See the
	 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	 * for more details.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keys(new Foo);
	 * // => ['a', 'b'] (iteration order is not guaranteed)
	 *
	 * _.keys('hi');
	 * // => ['0', '1']
	 */
	function keys(object) {
	  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
	}

	/**
	 * The base implementation of `_.assign` without support for multiple sources
	 * or `customizer` functions.
	 *
	 * @private
	 * @param {Object} object The destination object.
	 * @param {Object} source The source object.
	 * @returns {Object} Returns `object`.
	 */
	function baseAssign(object, source) {
	  return object && copyObject(source, keys(source), object);
	}

	/**
	 * This function is like
	 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	 * except that it includes inherited enumerable properties.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function nativeKeysIn(object) {
	  var result = [];
	  if (object != null) {
	    for (var key in Object(object)) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	/** Used for built-in method references. */
	var objectProto$b = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$8 = objectProto$b.hasOwnProperty;

	/**
	 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function baseKeysIn(object) {
	  if (!isObject$2(object)) {
	    return nativeKeysIn(object);
	  }
	  var isProto = isPrototype(object),
	      result = [];

	  for (var key in object) {
	    if (!(key == 'constructor' && (isProto || !hasOwnProperty$8.call(object, key)))) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	/**
	 * Creates an array of the own and inherited enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keysIn(new Foo);
	 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
	 */
	function keysIn$1(object) {
	  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
	}

	/**
	 * The base implementation of `_.assignIn` without support for multiple sources
	 * or `customizer` functions.
	 *
	 * @private
	 * @param {Object} object The destination object.
	 * @param {Object} source The source object.
	 * @returns {Object} Returns `object`.
	 */
	function baseAssignIn(object, source) {
	  return object && copyObject(source, keysIn$1(source), object);
	}

	/** Detect free variable `exports`. */
	var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

	/** Detect free variable `module`. */
	var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

	/** Detect the popular CommonJS extension `module.exports`. */
	var moduleExports = freeModule && freeModule.exports === freeExports;

	/** Built-in value references. */
	var Buffer = moduleExports ? root$4.Buffer : undefined,
	    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

	/**
	 * Creates a clone of  `buffer`.
	 *
	 * @private
	 * @param {Buffer} buffer The buffer to clone.
	 * @param {boolean} [isDeep] Specify a deep clone.
	 * @returns {Buffer} Returns the cloned buffer.
	 */
	function cloneBuffer(buffer, isDeep) {
	  if (isDeep) {
	    return buffer.slice();
	  }
	  var length = buffer.length,
	      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

	  buffer.copy(result);
	  return result;
	}

	/**
	 * Copies the values of `source` to `array`.
	 *
	 * @private
	 * @param {Array} source The array to copy values from.
	 * @param {Array} [array=[]] The array to copy values to.
	 * @returns {Array} Returns `array`.
	 */
	function copyArray(source, array) {
	  var index = -1,
	      length = source.length;

	  array || (array = Array(length));
	  while (++index < length) {
	    array[index] = source[index];
	  }
	  return array;
	}

	/**
	 * A specialized version of `_.filter` for arrays without support for
	 * iteratee shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {Array} Returns the new filtered array.
	 */
	function arrayFilter(array, predicate) {
	  var index = -1,
	      length = array == null ? 0 : array.length,
	      resIndex = 0,
	      result = [];

	  while (++index < length) {
	    var value = array[index];
	    if (predicate(value, index, array)) {
	      result[resIndex++] = value;
	    }
	  }
	  return result;
	}

	/**
	 * This method returns a new empty array.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.13.0
	 * @category Util
	 * @returns {Array} Returns the new empty array.
	 * @example
	 *
	 * var arrays = _.times(2, _.stubArray);
	 *
	 * console.log(arrays);
	 * // => [[], []]
	 *
	 * console.log(arrays[0] === arrays[1]);
	 * // => false
	 */
	function stubArray() {
	  return [];
	}

	/** Used for built-in method references. */
	var objectProto$a = Object.prototype;

	/** Built-in value references. */
	var propertyIsEnumerable$1 = objectProto$a.propertyIsEnumerable;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeGetSymbols$1 = Object.getOwnPropertySymbols;

	/**
	 * Creates an array of the own enumerable symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of symbols.
	 */
	var getSymbols = !nativeGetSymbols$1 ? stubArray : function(object) {
	  if (object == null) {
	    return [];
	  }
	  object = Object(object);
	  return arrayFilter(nativeGetSymbols$1(object), function(symbol) {
	    return propertyIsEnumerable$1.call(object, symbol);
	  });
	};

	var getSymbols$1 = getSymbols;

	/**
	 * Copies own symbols of `source` to `object`.
	 *
	 * @private
	 * @param {Object} source The object to copy symbols from.
	 * @param {Object} [object={}] The object to copy symbols to.
	 * @returns {Object} Returns `object`.
	 */
	function copySymbols(source, object) {
	  return copyObject(source, getSymbols$1(source), object);
	}

	/**
	 * Appends the elements of `values` to `array`.
	 *
	 * @private
	 * @param {Array} array The array to modify.
	 * @param {Array} values The values to append.
	 * @returns {Array} Returns `array`.
	 */
	function arrayPush(array, values) {
	  var index = -1,
	      length = values.length,
	      offset = array.length;

	  while (++index < length) {
	    array[offset + index] = values[index];
	  }
	  return array;
	}

	/** Built-in value references. */
	var getPrototype = overArg(Object.getPrototypeOf, Object);

	var getPrototype$1 = getPrototype;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeGetSymbols = Object.getOwnPropertySymbols;

	/**
	 * Creates an array of the own and inherited enumerable symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of symbols.
	 */
	var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
	  var result = [];
	  while (object) {
	    arrayPush(result, getSymbols$1(object));
	    object = getPrototype$1(object);
	  }
	  return result;
	};

	var getSymbolsIn$1 = getSymbolsIn;

	/**
	 * Copies own and inherited symbols of `source` to `object`.
	 *
	 * @private
	 * @param {Object} source The object to copy symbols from.
	 * @param {Object} [object={}] The object to copy symbols to.
	 * @returns {Object} Returns `object`.
	 */
	function copySymbolsIn(source, object) {
	  return copyObject(source, getSymbolsIn$1(source), object);
	}

	/**
	 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
	 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
	 * symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Function} keysFunc The function to get the keys of `object`.
	 * @param {Function} symbolsFunc The function to get the symbols of `object`.
	 * @returns {Array} Returns the array of property names and symbols.
	 */
	function baseGetAllKeys(object, keysFunc, symbolsFunc) {
	  var result = keysFunc(object);
	  return isArray$2(object) ? result : arrayPush(result, symbolsFunc(object));
	}

	/**
	 * Creates an array of own enumerable property names and symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names and symbols.
	 */
	function getAllKeys(object) {
	  return baseGetAllKeys(object, keys, getSymbols$1);
	}

	/**
	 * Creates an array of own and inherited enumerable property names and
	 * symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names and symbols.
	 */
	function getAllKeysIn(object) {
	  return baseGetAllKeys(object, keysIn$1, getSymbolsIn$1);
	}

	/* Built-in method references that are verified to be native. */
	var DataView$1 = getNative$1(root$4, 'DataView');

	var DataView$2 = DataView$1;

	/* Built-in method references that are verified to be native. */
	var Promise$1 = getNative$1(root$4, 'Promise');

	var Promise$2 = Promise$1;

	/* Built-in method references that are verified to be native. */
	var Set$2 = getNative$1(root$4, 'Set');

	var Set$3 = Set$2;

	/* Built-in method references that are verified to be native. */
	var WeakMap = getNative$1(root$4, 'WeakMap');

	var WeakMap$1 = WeakMap;

	/** `Object#toString` result references. */
	var mapTag$4 = '[object Map]',
	    objectTag$3 = '[object Object]',
	    promiseTag = '[object Promise]',
	    setTag$4 = '[object Set]',
	    weakMapTag$1 = '[object WeakMap]';

	var dataViewTag$3 = '[object DataView]';

	/** Used to detect maps, sets, and weakmaps. */
	var dataViewCtorString = toSource$1(DataView$2),
	    mapCtorString = toSource$1(Map$4),
	    promiseCtorString = toSource$1(Promise$2),
	    setCtorString = toSource$1(Set$3),
	    weakMapCtorString = toSource$1(WeakMap$1);

	/**
	 * Gets the `toStringTag` of `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	var getTag = baseGetTag$1;

	// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
	if ((DataView$2 && getTag(new DataView$2(new ArrayBuffer(1))) != dataViewTag$3) ||
	    (Map$4 && getTag(new Map$4) != mapTag$4) ||
	    (Promise$2 && getTag(Promise$2.resolve()) != promiseTag) ||
	    (Set$3 && getTag(new Set$3) != setTag$4) ||
	    (WeakMap$1 && getTag(new WeakMap$1) != weakMapTag$1)) {
	  getTag = function(value) {
	    var result = baseGetTag$1(value),
	        Ctor = result == objectTag$3 ? value.constructor : undefined,
	        ctorString = Ctor ? toSource$1(Ctor) : '';

	    if (ctorString) {
	      switch (ctorString) {
	        case dataViewCtorString: return dataViewTag$3;
	        case mapCtorString: return mapTag$4;
	        case promiseCtorString: return promiseTag;
	        case setCtorString: return setTag$4;
	        case weakMapCtorString: return weakMapTag$1;
	      }
	    }
	    return result;
	  };
	}

	var getTag$1 = getTag;

	/** Used for built-in method references. */
	var objectProto$9 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$7 = objectProto$9.hasOwnProperty;

	/**
	 * Initializes an array clone.
	 *
	 * @private
	 * @param {Array} array The array to clone.
	 * @returns {Array} Returns the initialized clone.
	 */
	function initCloneArray(array) {
	  var length = array.length,
	      result = new array.constructor(length);

	  // Add properties assigned by `RegExp#exec`.
	  if (length && typeof array[0] == 'string' && hasOwnProperty$7.call(array, 'index')) {
	    result.index = array.index;
	    result.input = array.input;
	  }
	  return result;
	}

	/** Built-in value references. */
	var Uint8Array$1 = root$4.Uint8Array;

	var Uint8Array$2 = Uint8Array$1;

	/**
	 * Creates a clone of `arrayBuffer`.
	 *
	 * @private
	 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
	 * @returns {ArrayBuffer} Returns the cloned array buffer.
	 */
	function cloneArrayBuffer(arrayBuffer) {
	  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
	  new Uint8Array$2(result).set(new Uint8Array$2(arrayBuffer));
	  return result;
	}

	/**
	 * Creates a clone of `dataView`.
	 *
	 * @private
	 * @param {Object} dataView The data view to clone.
	 * @param {boolean} [isDeep] Specify a deep clone.
	 * @returns {Object} Returns the cloned data view.
	 */
	function cloneDataView(dataView, isDeep) {
	  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
	  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
	}

	/** Used to match `RegExp` flags from their coerced string values. */
	var reFlags = /\w*$/;

	/**
	 * Creates a clone of `regexp`.
	 *
	 * @private
	 * @param {Object} regexp The regexp to clone.
	 * @returns {Object} Returns the cloned regexp.
	 */
	function cloneRegExp(regexp) {
	  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
	  result.lastIndex = regexp.lastIndex;
	  return result;
	}

	/** Used to convert symbols to primitives and strings. */
	var symbolProto$3 = Symbol$3 ? Symbol$3.prototype : undefined,
	    symbolValueOf$1 = symbolProto$3 ? symbolProto$3.valueOf : undefined;

	/**
	 * Creates a clone of the `symbol` object.
	 *
	 * @private
	 * @param {Object} symbol The symbol object to clone.
	 * @returns {Object} Returns the cloned symbol object.
	 */
	function cloneSymbol(symbol) {
	  return symbolValueOf$1 ? Object(symbolValueOf$1.call(symbol)) : {};
	}

	/**
	 * Creates a clone of `typedArray`.
	 *
	 * @private
	 * @param {Object} typedArray The typed array to clone.
	 * @param {boolean} [isDeep] Specify a deep clone.
	 * @returns {Object} Returns the cloned typed array.
	 */
	function cloneTypedArray(typedArray, isDeep) {
	  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
	  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
	}

	/** `Object#toString` result references. */
	var boolTag$2 = '[object Boolean]',
	    dateTag$2 = '[object Date]',
	    mapTag$3 = '[object Map]',
	    numberTag$2 = '[object Number]',
	    regexpTag$2 = '[object RegExp]',
	    setTag$3 = '[object Set]',
	    stringTag$3 = '[object String]',
	    symbolTag$5 = '[object Symbol]';

	var arrayBufferTag$2 = '[object ArrayBuffer]',
	    dataViewTag$2 = '[object DataView]',
	    float32Tag$1 = '[object Float32Array]',
	    float64Tag$1 = '[object Float64Array]',
	    int8Tag$1 = '[object Int8Array]',
	    int16Tag$1 = '[object Int16Array]',
	    int32Tag$1 = '[object Int32Array]',
	    uint8Tag$1 = '[object Uint8Array]',
	    uint8ClampedTag$1 = '[object Uint8ClampedArray]',
	    uint16Tag$1 = '[object Uint16Array]',
	    uint32Tag$1 = '[object Uint32Array]';

	/**
	 * Initializes an object clone based on its `toStringTag`.
	 *
	 * **Note:** This function only supports cloning values with tags of
	 * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
	 *
	 * @private
	 * @param {Object} object The object to clone.
	 * @param {string} tag The `toStringTag` of the object to clone.
	 * @param {boolean} [isDeep] Specify a deep clone.
	 * @returns {Object} Returns the initialized clone.
	 */
	function initCloneByTag(object, tag, isDeep) {
	  var Ctor = object.constructor;
	  switch (tag) {
	    case arrayBufferTag$2:
	      return cloneArrayBuffer(object);

	    case boolTag$2:
	    case dateTag$2:
	      return new Ctor(+object);

	    case dataViewTag$2:
	      return cloneDataView(object, isDeep);

	    case float32Tag$1: case float64Tag$1:
	    case int8Tag$1: case int16Tag$1: case int32Tag$1:
	    case uint8Tag$1: case uint8ClampedTag$1: case uint16Tag$1: case uint32Tag$1:
	      return cloneTypedArray(object, isDeep);

	    case mapTag$3:
	      return new Ctor;

	    case numberTag$2:
	    case stringTag$3:
	      return new Ctor(object);

	    case regexpTag$2:
	      return cloneRegExp(object);

	    case setTag$3:
	      return new Ctor;

	    case symbolTag$5:
	      return cloneSymbol(object);
	  }
	}

	/** Built-in value references. */
	var objectCreate = Object.create;

	/**
	 * The base implementation of `_.create` without support for assigning
	 * properties to the created object.
	 *
	 * @private
	 * @param {Object} proto The object to inherit from.
	 * @returns {Object} Returns the new object.
	 */
	var baseCreate = (function() {
	  function object() {}
	  return function(proto) {
	    if (!isObject$2(proto)) {
	      return {};
	    }
	    if (objectCreate) {
	      return objectCreate(proto);
	    }
	    object.prototype = proto;
	    var result = new object;
	    object.prototype = undefined;
	    return result;
	  };
	}());

	var baseCreate$1 = baseCreate;

	/**
	 * Initializes an object clone.
	 *
	 * @private
	 * @param {Object} object The object to clone.
	 * @returns {Object} Returns the initialized clone.
	 */
	function initCloneObject(object) {
	  return (typeof object.constructor == 'function' && !isPrototype(object))
	    ? baseCreate$1(getPrototype$1(object))
	    : {};
	}

	/** `Object#toString` result references. */
	var mapTag$2 = '[object Map]';

	/**
	 * The base implementation of `_.isMap` without Node.js optimizations.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
	 */
	function baseIsMap(value) {
	  return isObjectLike$2(value) && getTag$1(value) == mapTag$2;
	}

	/* Node.js helper references. */
	var nodeIsMap = nodeUtil$1 && nodeUtil$1.isMap;

	/**
	 * Checks if `value` is classified as a `Map` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.3.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
	 * @example
	 *
	 * _.isMap(new Map);
	 * // => true
	 *
	 * _.isMap(new WeakMap);
	 * // => false
	 */
	var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

	var isMap$1 = isMap;

	/** `Object#toString` result references. */
	var setTag$2 = '[object Set]';

	/**
	 * The base implementation of `_.isSet` without Node.js optimizations.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
	 */
	function baseIsSet(value) {
	  return isObjectLike$2(value) && getTag$1(value) == setTag$2;
	}

	/* Node.js helper references. */
	var nodeIsSet = nodeUtil$1 && nodeUtil$1.isSet;

	/**
	 * Checks if `value` is classified as a `Set` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.3.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
	 * @example
	 *
	 * _.isSet(new Set);
	 * // => true
	 *
	 * _.isSet(new WeakSet);
	 * // => false
	 */
	var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

	var isSet$1 = isSet;

	/** Used to compose bitmasks for cloning. */
	var CLONE_DEEP_FLAG$1 = 1,
	    CLONE_FLAT_FLAG = 2,
	    CLONE_SYMBOLS_FLAG$2 = 4;

	/** `Object#toString` result references. */
	var argsTag$1 = '[object Arguments]',
	    arrayTag$1 = '[object Array]',
	    boolTag$1 = '[object Boolean]',
	    dateTag$1 = '[object Date]',
	    errorTag$1 = '[object Error]',
	    funcTag$1 = '[object Function]',
	    genTag$1 = '[object GeneratorFunction]',
	    mapTag$1 = '[object Map]',
	    numberTag$1 = '[object Number]',
	    objectTag$2 = '[object Object]',
	    regexpTag$1 = '[object RegExp]',
	    setTag$1 = '[object Set]',
	    stringTag$2 = '[object String]',
	    symbolTag$4 = '[object Symbol]',
	    weakMapTag = '[object WeakMap]';

	var arrayBufferTag$1 = '[object ArrayBuffer]',
	    dataViewTag$1 = '[object DataView]',
	    float32Tag = '[object Float32Array]',
	    float64Tag = '[object Float64Array]',
	    int8Tag = '[object Int8Array]',
	    int16Tag = '[object Int16Array]',
	    int32Tag = '[object Int32Array]',
	    uint8Tag = '[object Uint8Array]',
	    uint8ClampedTag = '[object Uint8ClampedArray]',
	    uint16Tag = '[object Uint16Array]',
	    uint32Tag = '[object Uint32Array]';

	/** Used to identify `toStringTag` values supported by `_.clone`. */
	var cloneableTags = {};
	cloneableTags[argsTag$1] = cloneableTags[arrayTag$1] =
	cloneableTags[arrayBufferTag$1] = cloneableTags[dataViewTag$1] =
	cloneableTags[boolTag$1] = cloneableTags[dateTag$1] =
	cloneableTags[float32Tag] = cloneableTags[float64Tag] =
	cloneableTags[int8Tag] = cloneableTags[int16Tag] =
	cloneableTags[int32Tag] = cloneableTags[mapTag$1] =
	cloneableTags[numberTag$1] = cloneableTags[objectTag$2] =
	cloneableTags[regexpTag$1] = cloneableTags[setTag$1] =
	cloneableTags[stringTag$2] = cloneableTags[symbolTag$4] =
	cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
	cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
	cloneableTags[errorTag$1] = cloneableTags[funcTag$1] =
	cloneableTags[weakMapTag] = false;

	/**
	 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
	 * traversed objects.
	 *
	 * @private
	 * @param {*} value The value to clone.
	 * @param {boolean} bitmask The bitmask flags.
	 *  1 - Deep clone
	 *  2 - Flatten inherited properties
	 *  4 - Clone symbols
	 * @param {Function} [customizer] The function to customize cloning.
	 * @param {string} [key] The key of `value`.
	 * @param {Object} [object] The parent object of `value`.
	 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
	 * @returns {*} Returns the cloned value.
	 */
	function baseClone(value, bitmask, customizer, key, object, stack) {
	  var result,
	      isDeep = bitmask & CLONE_DEEP_FLAG$1,
	      isFlat = bitmask & CLONE_FLAT_FLAG,
	      isFull = bitmask & CLONE_SYMBOLS_FLAG$2;

	  if (customizer) {
	    result = object ? customizer(value, key, object, stack) : customizer(value);
	  }
	  if (result !== undefined) {
	    return result;
	  }
	  if (!isObject$2(value)) {
	    return value;
	  }
	  var isArr = isArray$2(value);
	  if (isArr) {
	    result = initCloneArray(value);
	    if (!isDeep) {
	      return copyArray(value, result);
	    }
	  } else {
	    var tag = getTag$1(value),
	        isFunc = tag == funcTag$1 || tag == genTag$1;

	    if (isBuffer$2(value)) {
	      return cloneBuffer(value, isDeep);
	    }
	    if (tag == objectTag$2 || tag == argsTag$1 || (isFunc && !object)) {
	      result = (isFlat || isFunc) ? {} : initCloneObject(value);
	      if (!isDeep) {
	        return isFlat
	          ? copySymbolsIn(value, baseAssignIn(result, value))
	          : copySymbols(value, baseAssign(result, value));
	      }
	    } else {
	      if (!cloneableTags[tag]) {
	        return object ? value : {};
	      }
	      result = initCloneByTag(value, tag, isDeep);
	    }
	  }
	  // Check for circular references and return its corresponding clone.
	  stack || (stack = new Stack);
	  var stacked = stack.get(value);
	  if (stacked) {
	    return stacked;
	  }
	  stack.set(value, result);

	  if (isSet$1(value)) {
	    value.forEach(function(subValue) {
	      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
	    });
	  } else if (isMap$1(value)) {
	    value.forEach(function(subValue, key) {
	      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
	    });
	  }

	  var keysFunc = isFull
	    ? (isFlat ? getAllKeysIn : getAllKeys)
	    : (isFlat ? keysIn : keys);

	  var props = isArr ? undefined : keysFunc(value);
	  arrayEach(props || value, function(subValue, key) {
	    if (props) {
	      key = subValue;
	      subValue = value[key];
	    }
	    // Recursively populate clone (susceptible to call stack limits).
	    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
	  });
	  return result;
	}

	/** Used to compose bitmasks for cloning. */
	var CLONE_SYMBOLS_FLAG$1 = 4;

	/**
	 * Creates a shallow clone of `value`.
	 *
	 * **Note:** This method is loosely based on the
	 * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
	 * and supports cloning arrays, array buffers, booleans, date objects, maps,
	 * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
	 * arrays. The own enumerable properties of `arguments` objects are cloned
	 * as plain objects. An empty object is returned for uncloneable values such
	 * as error objects, functions, DOM nodes, and WeakMaps.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to clone.
	 * @returns {*} Returns the cloned value.
	 * @see _.cloneDeep
	 * @example
	 *
	 * var objects = [{ 'a': 1 }, { 'b': 2 }];
	 *
	 * var shallow = _.clone(objects);
	 * console.log(shallow[0] === objects[0]);
	 * // => true
	 */
	function clone(value) {
	  return baseClone(value, CLONE_SYMBOLS_FLAG$1);
	}

	var SCREENSHOT_MIN_HEIGHT = 240;

	function guessValueType(value) {
	  if (value === 'true' || value === 'false' || value === 'True' || value === 'False') {
	    return JSON.parse(value.toLowerCase());
	  } else if (!isNaN(parseFloat(value)) && isFinite(value)) {
	    return Number(value);
	  } else {
	    return value;
	  }
	}
	/**
	 * Are we in the editor
	 * @returns boolean
	 */

	function isEditor() {
	  return window.location.search.includes('IS_EDITOR');
	}
	/**
	 * Converts a query string into an object, .e.g, ?option=true becomes { option: true }
	 * @param {string} query query string
	 * @returns {object} the query object
	 * https://stackoverflow.com/questions/901115/how-can-i-get-query-string-values-in-javascript
	 */

	function getQueryParams(query) {
	  if (!query) {
	    return {};
	  }

	  return (/^[?#]/.test(query) ? query.slice(1) : query).split('&').reduce(function (params, param) {
	    var _param$split = param.split('='),
	        _param$split2 = _slicedToArray(_param$split, 2),
	        key = _param$split2[0],
	        value = _param$split2[1]; // allow query params with depth like foo.blah=val


	    if (key.includes('.')) {
	      var tokens = key.split('.');
	      var currentParams = params;
	      tokens.forEach(function (token, i) {
	        if (tokens[i + 1]) {
	          currentParams[token] = currentParams[token] || {};
	          currentParams = currentParams[token];
	        } else {
	          currentParams[token] = value;
	        }
	      });
	    } else {
	      params[key] = value ? guessValueType(decodeURIComponent(value.replace(/\+/g, ' '))) : '';
	    }

	    return params;
	  }, {});
	}
	/**
	 * Checks if the parameter is boolean or string 'True'
	 * @param {number | string} val
	 * @returns boolean
	 */

	function isOptionTrue(val) {
	  return val && (val === 'true' || val === true);
	}
	/**
	 * Checks if the parameter is boolean or string 'False
	 * @param {number | string} val
	 * @returns boolean
	 */

	function isOptionFalse(val) {
	  return val !== undefined && (!val || val === 'false');
	}
	/**
	 * Checks if the parameter is NOI the string 'False'
	 * @param {string} val
	 * @returns boolean
	 */

	function isOptionNotFalse(val) {
	  return val === undefined || val && val !== 'false';
	}
	/**
	 * Merges options from (1) toasterFactor call (2) query parameters as options object (3) override options from chartData
	 * @param {object} inOptions incoming options from the toasterFactor method
	 * @param {object} chartData chartData object
	 * @returns object merged options
	 */

	function makeOptions(inOptions, chartData) {
	  var options = inOptions || {}; // allow query parameters to drive chart options

	  options = clone(_extends(getQueryParams(window.location.search), options)); // allow for advanced users to set options directly in the editor

	  if (chartData && chartData.config && chartData.config.override_options) {
	    try {
	      if (_typeof(chartData.config.override_options) === 'object') {
	        var userOptions = chartData.config.override_options;
	        options = _extends(userOptions, options);
	      } else if (typeof chartData.config.override_options === 'string') {
	        var _userOptions = JSON.parse(chartData.config.override_options);

	        options = _extends(_userOptions, options);
	      }
	    } catch (err) {
	      console.log('INVALID JSON OPTIONS');
	    }
	  } // hideTitles=true is used for iframe charts to hide footer and title


	  if (isOptionTrue(options.hideTitles)) {
	    options.hideTitle = true;
	    options.hideFooter = true;
	  } // Widget mode disables certain features


	  if (isOptionTrue(options.widget)) {
	    options.disableScaffold = true; // options.customScaffold = widgetScaffold

	    options.disableGrid = true;
	    options.disableTooltip = true;
	    options.disableAxis = true;
	    options.disableLabels = true;
	    options.disablePieLabels = true;
	    options.disableAnnotations = true;
	    options.forceVerticalColumns = true;
	    options.noPadding = true;
	    options.interaction = false;
	    options.hideTitles = true;
	    options.hideTitle = true;
	    options.hideFooter = true;
	    options.screenshotMinHeight = 0;
	    options.layoutManager = {
	      minHeight: 0
	    };
	  } // embedType drives layout manager to fill the container
	  // until resize is fully supported on singleStory we now disable
	  // the postMessage propagation


	  if (options.embedType && options.embedType !== 'standalone' && !options.embedAspectRatio) {
	    options.layoutManager = _extends({}, options.layoutManager || {}, {
	      fitToContainer: true
	    });
	    options.noResizePropagation = true;
	  }

	  if (options.screenshotMode && options.screenshotMode !== 'false') {
	    options.layoutManager = _extends({}, options.layoutManager || {}, {
	      minHeight: SCREENSHOT_MIN_HEIGHT
	    });
	  }

	  return options;
	} // allow options that exist on the data.config object or
	// defined as a local option

	function getOption(name, data, options) {
	  if (options[name] != null) return options[name];
	  if (data.config && data.config[name] != null) return data.config[name];
	  return null;
	} // options to data
	// basicaly the same as form to chart from choropleth
	// this is a specific operation for taking flat options
	// and pulling it into chartOptions, primaryAxis etc.

	function applyOptionsToData(chartData, options) {
	  var valField = 1; // first series data

	  chartData.secondaryAxis = chartData.secondaryAxis || {};

	  if (hasOwnProperty$h(options, 'precision')) {
	    chartData.chartOptions.decimalPlaces = options.precision;
	    chartData.secondaryAxis.decimal_places = options.precision;
	  }

	  if (hasOwnProperty$h(options, 'tooltipPrecision')) {
	    chartData.chartOptions.tooltipDecimals = options.tooltipPrecision;
	    chartData.secondaryAxis.tooltip_decimals = options.tooltipPrecision;
	  }

	  if (hasOwnProperty$h(options, 'prefix')) {
	    chartData.fields[valField].unit_before = options.prefix;
	    chartData.secondaryAxis.unit_before = options.prefix;
	  }

	  if (hasOwnProperty$h(options, 'postfix')) {
	    chartData.fields[valField].unit_after = options.postfix;
	    chartData.secondaryAxis.unit_after = options.postfix;
	  }

	  if (hasOwnProperty$h(options, 'unitBefore')) {
	    chartData.fields[valField].unitBefore = options.unitBefore;
	    chartData.secondaryAxis.unit_before = options.unitBefore;
	    chartData.chartOptions.unitBefore = options.unitBefore;
	  }

	  if (hasOwnProperty$h(options, 'unitAfter')) {
	    chartData.fields[valField].unitAfter = options.unitAfter;
	    chartData.secondaryAxis.unit_after = options.unitAfter;
	    chartData.chartOptions.unitAfter = options.unitAfter;
	  }

	  if (hasOwnProperty$h(options, 'isPercent')) {
	    chartData.fields[valField].display_as = options.isPercent ? '%' : '';
	    chartData.secondaryAxis.display_as = options.isPercent ? '%' : '';
	  } // add any properties that are 1:1 named


	  ['scaleEnd', 'scaleStart', 'scaleStep', 'label'].forEach(function (key) {
	    if (hasOwnProperty$h(options, key)) {
	      chartData.chartOptions[key] = options[key];
	    }
	  });
	  return chartData;
	}

	/**
	 * We need a way to store a value for reference between editor
	 * and viewer context. Currently the window is the best place to do this
	 * but other interfaces can be explored.
	 * @param {string} id named storage object
	 * @param {string} key key identifier in your storage
	 * @param {any} val value to enter in storage. If missing, this function acts as a getter
	 * @param {globalThis} stateManager default state manager to use; defaults to window
	 */

	function globalState() {
	  var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'default';
	  var key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
	  var val = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
	  var stateManager = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : window;
	  if (!stateManager._globalState) stateManager._globalState = {};
	  if (!stateManager._globalState[id]) stateManager._globalState[id] = {};
	  var _globalState = stateManager._globalState;

	  if (val === undefined) {
	    return _globalState[id][key];
	  } else {
	    _globalState[id][key] = val;
	    return val;
	  }
	}
	/**
	 * We need a way to store a value for reference between editor
	 * and viewer context. Currently the window is the best place to do this
	 * but other interfaces can be explored.
	 * @param {string} id named storage object
	 * @param {string} key key identifier in your storage
	 */

	function destroyState() {
	  var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'default';
	  var key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
	  var _window = window,
	      _globalState = _window._globalState;

	  if (_globalState && _globalState[id] && _globalState[id][key] != null) {
	    delete _globalState[id][key];
	  }
	}
	/**
	 * For convenience: global state specifically for annotations
	 * return a get/set function for the current state
	 * @param {string} id chart or component id
	 */

	function annotationState(id) {
	  var provider = function provider(val) {
	    return globalState(id, 'annotations', val);
	  };

	  provider.destroy = function () {
	    return destroyState(id, 'annotations');
	  };

	  return provider;
	}

	/**
	 *  provide the necessary javelin iframe hooks for resizing etc.
	 */

	function noNan(v, defaultVal) {
	  if (isNaN(Number(v))) return defaultVal;
	  return Number(v);
	} // create callback closure for postResize


	function createResizeCallback() {
	  var windowId = window._toasterWindowId || '';
	  var useString = window._toasterIframeUseString || false;

	  var callback = function callback(el) {
	    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	    var height = noNan(el.offsetHeight, 0) + noNan(el.getBoundingClientRect().top, 0);

	    if (!options.noResizePropagation && window.parent && withinIframe()) {
	      window.parent.postMessage({
	        sentinel: 'amp',
	        type: 'embed-size',
	        height: height
	      }, '*'); // if we've recieved a windowId from javelin, pass through height

	      if (windowId !== '') {
	        var message = {
	          method: 'resize',
	          windowId: windowId,
	          height: height
	        };
	        window.parent.postMessage(useString ? JSON.stringify(message) : message, '*');
	      }
	    } // this triggers the phantomjs resizer


	    el.setAttribute('phantomheight', height + 'px');
	    return windowId;
	  };

	  callback.setWindowId = function (id) {
	    windowId = id;
	    window._toasterWindowId = id; // for multiple renders
	  };

	  callback.setUseString = function (val) {
	    useString = val;
	    window._toasterIframeUseString = val; // for multiple renders
	  };

	  return callback;
	}
	/**
	*  This is necessary for compatability with the javelin iframe setup
	*  BUMP
	*/

	function bindMessageHandlers(el, postResize, options) {
	  addListener(window, 'message.toaster', function (event) {
	    var data = event.data;

	    if (data.substring) {
	      postResize.setUseString(true);

	      try {
	        data = JSON.parse(data);
	      } catch (e) {
	        return;
	      }
	    }

	    if (data.method === 'register') {
	      postResize.setWindowId(data.windowId);
	      postResize(el, options);
	    }
	  });
	}
	/**
	*  We need a method to prevent an infinite loop with a resize sending message
	*  to parent container, triggering further resize, etc.
	*/

	function bindResizeHandlers(el, render, postResize, data, options) {
	  var lastWidth = null;
	  var lastHeight = null;
	  var id = data.id;
	  var _options$resizeTimout = options.resizeTimout,
	      resizeTimout = _options$resizeTimout === void 0 ? 0 : _options$resizeTimout; // allow a forceRender argument for the font load operation
	  // otherwise there fonts get cutoff

	  var resize = function resize(forceRender) {
	    var currentHeight = noNan(el.offsetHeight, 0) + noNan(el.getBoundingClientRect().top, 0);
	    var currentWidth = window.innerWidth;

	    if (!forceRender && !options.alwaysResize && lastWidth === currentWidth && lastHeight === currentHeight) {
	      return;
	    }

	    render('renderAfterResize');
	    postResize(el, options);
	    lastWidth = currentWidth;
	    lastHeight = currentHeight;
	  };

	  addListener(window, "resize.toaster-".concat(id), function () {
	    return setTimeout(function () {
	      return resize();
	    }, resizeTimout);
	  });

	  var forceResizeRender = function forceResizeRender() {
	    if (options.addAfterRenderCallback) {
	      options.addAfterRenderCallback(function () {
	        return resize('forceRender');
	      });
	    } else {
	      resize('forceRender');
	    }
	  }; // used in the editor to force a resize event with new data


	  if (options.alwaysResize) {
	    forceResizeRender();
	  } // modern browsers support the ability to check if fonts are ready
	  // but we have to have a fallback for older browsers
	  // we add one more resize to check if top el class changed during render


	  try {
	    if (globalState(id, 'fontsHaveLoaded')) return;
	    globalState(id, 'awaitingSecondaryRender', true);

	    if (document.fonts && document.fonts.ready && document.fonts.status === 'loading') {
	      document.fonts.ready.then(function () {
	        globalState(id, 'fontsHaveLoaded', true);
	        globalState(id, 'awaitingSecondaryRender', false);
	        resize('forceRender');
	      });
	    } else {
	      setTimeout(function () {
	        globalState(id, 'fontsHaveLoaded', true);
	        globalState(id, 'awaitingSecondaryRender', false);
	        forceResizeRender();
	      }, 1000);
	    }
	  } catch (err) {
	    setTimeout(function () {
	      globalState(id, 'fontsHaveLoaded', true);
	      globalState(id, 'awaitingSecondaryRender', false);
	      resize('forceRender');
	    }, 1000);
	  }
	}
	function destroyResizeHandlers(el, render, postResize, data, options) {
	  var id = data.id;
	  removeListener(window, "resize.toaster-".concat(id));
	} // triggers a global resize event for actions inside of a chart
	function withinIframe() {
	  try {
	    return window.self !== window.top;
	  } catch (e) {
	    return true;
	  }
	}

	// The whole goal here is to make sure we can
	// have utilities that escape the import dependency tree
	// that brings in all of d3 for projects that don't need it
	// get series from chartData
	// TODO:: allow chartData to specify series breakdown other than default
	function getSeries$1(chartData) {
	  return chartData.fields.length > 1 ? chartData.fields.slice(1) : chartData.fields;
	}

	// https://stackoverflow.com/a/3955238
	// much faster than innerHTML = ''
	function emptyElement(el) {
	  while (el.firstChild) {
	    el.removeChild(el.lastChild);
	  }
	}
	function classed(el, className, setValue) {
	  if (setValue != null) {
	    if (setValue) {
	      el.classList.add(className);
	    } else {
	      el.classList.remove(className);
	    }
	  } else {
	    return el.classList.contains(className);
	  }
	} // THIS is very specific to _one_ type of selectAppend
	// which is: div.class-name  ie a selector made up of
	// an element type and then a className... but this is the only

	function selectAppend$1(el, type, className) {
	  var selector = "".concat(type, ".").concat(className);
	  var child = el.querySelector(selector);

	  if (!child) {
	    child = document.createElement(type);
	    el.appendChild(child);
	    child.classList.add(className);
	  }

	  return child;
	} // ensure single element

	function styleSingle(el, prop, value) {
	  if (value != null) {
	    el.style[prop] = value;
	  } else {
	    return el.style[prop];
	  }
	} // allow a style interface to replace d3 select().style()


	function style(els, prop, value) {
	  if (els.length == null) return styleSingle(els, prop, value);

	  for (var _i = 0, _arr = _toConsumableArray(els); _i < _arr.length; _i++) {
	    var el = _arr[_i];
	    styleSingle(el, prop, value);
	  }
	}
	function select$1(selector) {
	  return document.querySelectorAll(selector);
	}

	function simpleLegend(el, chartData, options) {
	  var _chartData$config = chartData.config,
	      config = _chartData$config === void 0 ? {} : _chartData$config; // filter out any series items with no field names

	  var series = getSeries$1(chartData).map(function (f, index) {
	    f.index = index;
	    return f;
	  }).filter(function (s) {
	    return s.name && s.name !== '';
	  }); // allow highlight label added as a legend item

	  if (config.highlight_label) {
	    series.push({
	      name: config.highlight_label,
	      isHighlight: true
	    });
	  } // highlight ranges also allow a legend label


	  if (config.highlightRanges && config.highlightRanges.label) {
	    series.push({
	      name: config.highlightRanges.label,
	      rangeHighlight: true
	    });
	  }

	  var ul = selectAppend$1(el, 'ul', 'simple-legend');
	  emptyElement(ul); // clear element

	  series.forEach(function (field, i) {
	    var li = document.createElement('li');
	    var span = document.createElement('span');
	    var label = document.createElement('label');
	    ul.appendChild(li);
	    li.appendChild(span);
	    li.appendChild(label);
	    label.innerHTML = field.name;
	    span.className = "swatch bg series-".concat(field.index);
	    classed(span, 'highlight-legend', field.isHighlight);
	    classed(span, 'highlight-range-legend', field.rangeHighlight);
	  });
	  classed(el, 'hidden', series.length === 0);
	}

	// mouse click on the chart to go to the parent container

	function clickThroughURL(el, data, options) {
	  var url = options.clickThroughURL || options.clickthroughurl;
	  classed(el, 'embed-click-through', true);

	  el.onclick = function (e) {
	    e.stopPropagation();
	    e.preventDefault(); // if within iframe

	    if (window.self !== window.top) {
	      window.parent.location.href = url;
	    } else {
	      window.location.href = url;
	    }
	  };
	}

	// container - this can be disabled and overriden by the client

	function scaffold(el, data, options) {
	  var variantLogo = getOption('variant_logo', data, options);
	  var variantColor = getOption('variant_color', data, options); // clear the chart when there is a change of ids

	  if (data.id !== undefined && el.hasAttribute('toaster-id') && el.getAttribute('toaster-id') !== data.id) {
	    emptyElement(el);
	  }

	  el.setAttribute('toaster-id', data.id); // clear previous color variants

	  el.className = el.className.replace(/variant-/g, 'x-');
	  classed(el, "variant-color-".concat(variantColor), true);
	  classed(el, 'no-titles', options.hideTitle);
	  var header = selectAppend$1(el, 'div', 'header');
	  classed(header, 'hide', options.hideTitle);
	  classed(header, 'centered', isBodyCopyCentered(options));

	  if (!options.hideTitle) {
	    selectAppend$1(header, 'h1', 'title').innerHTML = data.title || '';
	    selectAppend$1(header, 'h2', 'subtitle').innerHTML = data.subtitle || '';
	  }

	  if (!options.hideLegend) {
	    var legendEl = selectAppend$1(el, 'div', 'legend');
	    classed(legendEl, 'centered', isBodyCopyCentered(options)); // trying to move away from the "simpleLegend" and towards
	    // a component based config where each type determines
	    // what swatches to show in the legend

	    if (options.legendConfig && options.customLegend) {
	      options.customLegend(legendEl, options.legendConfig);
	    } else {
	      simpleLegend(legendEl, data);
	    }
	  }

	  selectAppend$1(el, 'div', 'chart');
	  var noPad = options.noPadding || options.hideTitle && options.hideFooter;
	  classed(el, 'no-padding', noPad);
	  classed(el, 'no-interaction', isOptionFalse(options.interactive));
	  var screenshotMode = options.screenshotMode && options.screenshotMode !== 'false';
	  classed(el, 'screenshot-mode', screenshotMode);
	  var footer = selectAppend$1(el, 'div', 'footer');
	  classed(footer, 'hide', options.hideFooter);
	  classed(footer, 'centered', isBodyCopyCentered(options));

	  if (!options.hideFooter) {
	    selectAppend$1(footer, 'p', 'source').innerHTML = data.source || '';
	    selectAppend$1(footer, 'p', 'footnote').innerHTML = data.footnote || '';

	    if (!options.hideLogo) {
	      selectAppend$1(footer, 'div', 'logo');
	    } // clear previous logo variants


	    var logo = footer.querySelector('div.logo');

	    if (logo) {
	      logo.className = logo.className.replace(/variant-/g, 'x-');
	      classed(logo, "variant-logo-".concat(variantLogo), true);
	    }
	  }

	  if (options.clickThroughURL || options.clickthroughurl) {
	    clickThroughURL(el, data, options);
	  }
	}

	// There are no media query breakpoints
	var LARGE_BREAKPOINT = 880;
	var MOBILE_BREAKPOINT = 480;
	function setBreakpointClasses(el) {
	  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	  var breakLarge = options.largeBreakpoint || LARGE_BREAKPOINT;
	  var breakMobile = options.mobileBreakpoint || MOBILE_BREAKPOINT;
	  classed(el, 'large', el.offsetWidth > breakLarge);
	  classed(el, 'large', el.offsetWidth > breakLarge);
	  classed(el, 'phablet', el.offsetWidth <= breakLarge && (el.offsetWidth > breakMobile || options.preventMobileFont));
	  classed(el, 'mobile', el.offsetWidth <= breakMobile && !options.preventMobileFont);
	}
	/**
	 * Checks for mobile breakpoint
	 * @param {number} w
	 * @param {{mobileBreakpoint: number}} options
	 * @returns boolean
	 */

	function isMobileWidth(w) {
	  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	  var breakMobile = options.mobileBreakpoint || MOBILE_BREAKPOINT;
	  return w < breakMobile;
	}

	/** Used to compose bitmasks for cloning. */
	var CLONE_DEEP_FLAG = 1,
	    CLONE_SYMBOLS_FLAG = 4;

	/**
	 * This method is like `_.clone` except that it recursively clones `value`.
	 *
	 * @static
	 * @memberOf _
	 * @since 1.0.0
	 * @category Lang
	 * @param {*} value The value to recursively clone.
	 * @returns {*} Returns the deep cloned value.
	 * @see _.clone
	 * @example
	 *
	 * var objects = [{ 'a': 1 }, { 'b': 2 }];
	 *
	 * var deep = _.cloneDeep(objects);
	 * console.log(deep[0] === objects[0]);
	 * // => false
	 */
	function cloneDeep(value) {
	  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
	}

	var black = '#000000';
	var white = '#ffffff';
	var cyan = '#00aeff';
	var honey = '#ffc400';
	var magenta = '#ff008c';
	var mint = '#3ef794';
	var blue = '#0037ff';
	var orange = '#ff6200';

	var greenUp = '#00c88a';
	var redDown = '#ff415f';
	var cyanD3 = '#00577f';
	var cyanD2 = '#0079b2';
	var cyanD1 = '#0094d9';
	var cyanL1 = '#44c4ff';
	var cyanL2 = '#89d9fe';
	var cyanL3 = '#cdeffe';
	var honeyD3 = '#7f6200';
	var honeyD2 = '#b28900';
	var honeyD1 = '#d9a700';
	var honeyL1 = '#ffd345';
	var honeyL2 = '#ffe389';
	var honeyL3 = '#fff2ce';
	var bwBlue = '#0078ff';
	var bwRed = '#ff0000';
	var bwGreen = '#008800';
	var bwLilac = '#dca0ff';
	var bwYellow = '#ffff00';
	var bwBlueD1 = '#0052d9';
	var bwBlueD2 = '#003eb2';
	var bwBlueD3 = '#002a7f';
	var bwBlueL1 = '#4499ff';
	var bwBlueL2 = '#89baff';
	var bwBlueL3 = '#cddcff';
	var bwRedD1 = '#d90000';
	var bwRedD2 = '#b20000';
	var bwRedD3 = '#7f0000';
	var bwRedL1 = '#ff4141';
	var bwRedL2 = '#ff8282';
	var bwRedL3 = '#ffc3c3';
	var gray1 = '#efefef';
	var gray2 = '#cccccc';
	var gray3 = '#999999';

	var honeyGray = '#999999';
	var cyanGray = '#cccccc'; // line order

	var tBlue = '#0073ff';
	var tOrange = '#fa5a28';
	var tAmber = '#ffa028';
	var tcAmber = '#db8922';
	var tcGray = '#bebebe';
	var tcBlue = '#0051ba';
	var tcOrange = '#b3401d';
	var tcPurple = '#8f52b6';
	var tcYellow = '#d7be00';
	var tcTeal = '#009eb0';
	var tcGreen = '#1bbc3c';
	var tcMagenta = '#ae1d86';
	var gGreen = '#14eb1e';
	var gDiscrete = ['#14eb1e', '#000000', '#aaaaaa', '#00b4d2', '#2d82a5', '#ffbe1e', '#ffeb50', '#ff4f00', '#e1a05a'];
	var gSeries = ['#14eb1e', '#14d21e', '#14b919', '#14a014', '#148714', '#147819', '#196919', '#195a19', '#0f4b0f']; // citylab base oranges

	var clOrangeB6 = '#7f3100';
	var clOrangeB5 = '#b24400';
	var clOrangeB4 = '#d95300';
	var clOrangeB3 = '#ff6200';
	var clOrangeB2 = '#ff8d46';
	var clOrangeB1 = '#feb98d';
	var clOrangeB0 = '#fee4d3';
	var clGray = '#cccccc'; // citylab contrast teals
	var clTealC3 = '#00f3e5';
	var clCyanC3 = '#00AEFF';
	var performanceChartCyanOrange = ['#00aeff', '#44c4ff', '#89d9fe', '#d4d4d4', '#feb98d', '#ff8d46', '#ff6200'];
	var performanceChartRedGreen = ['#e41443', '#fe456f', '#fe8ca5', '#d4d4d4', '#a1fdac', '#00ff29', '#02b21e'];

	function excludeFromLine(vals) {
	  var arr = _toConsumableArray(vals);

	  arr.excludeFromLine = true;
	  return arr;
	}

	function assetPath() {
	  var path = 'https://www.bloomberg.com/graphics/toaster/toaster-client-packages/assets';

	  if (window.location.hostname === 'localhost') {
	    var localOrigin = window.location.origin;
	    if (localOrigin === 'http://localhost:4000') localOrigin = 'http://localhost:8088';
	    path = "".concat(localOrigin, "/assets");
	  } else if (window.location.hostname === 'toaster-staging.bloomberg.com') {
	    path = 'https://www.bloomberg.com/graphics/toaster/toaster-client-packages/assets';
	  }

	  return path;
	}

	function patternFile(key, theme) {
	  var firstPart = key.split(' ')[0];
	  var bareKey = firstPart.replace('url(#', '').replace(')', '');
	  var pIndex = bareKey[bareKey.length - 1]; // 0-9

	  var isDark = bareKey.indexOf('dark') !== -1;
	  var fileName = "".concat(theme, "_").concat(isDark ? 'dark' : 'light', "_pattern_").concat(pIndex, ".png");
	  return {
	    fileName: fileName,
	    bareKey: bareKey,
	    pIndex: pIndex,
	    isDark: isDark
	  };
	} // this maps the <svg> defs to a gradient
	// pattern asset path -- I don't think there is a


	function defs(key) {
	  if (key.indexOf('pattern-green') !== -1) {
	    var _patternFile = patternFile(key, 'green'),
	        fileName = _patternFile.fileName,
	        bareKey = _patternFile.bareKey;

	    return "\n      <pattern id=\"".concat(bareKey, "\" patternUnits=\"userSpaceOnUse\" width=\"50\" height=\"50\">\n        <image xlink:href=\"").concat(assetPath(), "/patterns/green/").concat(fileName, "\" x=\"0\" y=\"0\" width=\"50\" height=\"50\" />\n      </pattern>\n    ");
	  }

	  var definitions = {
	    'url(#gGradient1)': "\n    <linearGradient id=\"gGradient1\" x1=\"0%\" y1=\"0%\" x2=\"0%\" y2=\"100%\">\n      <stop offset=\"0%\" stop-color=\"#ffffff\"></stop>\n      <stop offset=\"80%\" stop-color=\"#14eb1e\"></stop>\n    </linearGradient>\n    <linearGradient id=\"gGradientHorizontal1\" x1=\"0%\" y1=\"0%\" x2=\"100%\" y2=\"0%\">\n      <stop offset=\"0%\" stop-color=\"#ffffff\"></stop>\n      <stop offset=\"80%\" stop-color=\"#14eb1e\"></stop>\n    </linearGradient>\n    ",
	    'url(#gGradient2)': "\n    <linearGradient id=\"gGradient2\" x1=\"0%\" y1=\"0%\" x2=\"0%\" y2=\"100%\">\n      <stop offset=\"0%\" stop-color=\"#000000\"></stop>\n      <stop offset=\"80%\" stop-color=\"#14eb1e\"></stop>\n    </linearGradient>\n    <linearGradient id=\"gGradientHorizontal2\" x1=\"0%\" y1=\"0%\" x2=\"100%\" y2=\"0%\">\n      <stop offset=\"0%\" stop-color=\"#000000\"></stop>\n      <stop offset=\"80%\" stop-color=\"#14eb1e\"></stop>\n    </linearGradient>\n    "
	  };
	  return definitions[key];
	}
	function domBackground(key) {
	  if (key.indexOf('gPattern') !== -1) {
	    var _patternFile2 = patternFile(key, 'green'),
	        fileName = _patternFile2.fileName;

	    return "url(".concat(assetPath(), "/patterns/green/").concat(fileName, ") repeat;");
	  }

	  var backgrounds = {
	    'url(#gGradient1)': 'linear-gradient(180deg, rgba(255,255,255,1) 0%, rgba(20,235,30,1) 66%, rgba(20,235,30,1) 100%);',
	    'url(#gGradient2)': 'linear-gradient(180deg, rgba(0,0,0,1) 0%, rgba(20,235,30,1) 66%, rgba(20,235,30,1) 100%);'
	  };
	  return backgrounds[key];
	} //, #, #009eb0, #1bbc3c, #ae1d86

	var terminalColors = {
	  1: [[tAmber], [tBlue], [tOrange], [tcAmber]],
	  2: [[tAmber, tBlue], [tOrange, tcBlue], [tOrange, tcGray], [tBlue, tcGray]],
	  3: [[tAmber, tcGray, tcBlue], [tAmber, tcBlue, tcOrange]],
	  4: [[tBlue, tAmber, tcBlue, tcOrange], [tcGray, honeyL1, honeyD1, honeyD3]],
	  5: [[tBlue, tAmber, tcBlue, tcOrange, tcGreen], [tcGray, honeyL1, honey, honeyD1, honeyD3]],
	  6: [[tcAmber, tcGray, tcBlue, tcOrange, tcPurple, tcYellow], [tcGray, honeyD3, honeyD1, honey, honeyL1, honeyL2, honeyL3]],
	  all: [[tcAmber, tcGray, tcBlue, tcOrange, tcPurple, tcYellow, tcTeal, tcGreen, tcMagenta], [tcGray, honeyD3, honeyD1, honey, honeyL1, honeyL2, honeyL3]]
	}; // const terminalLineColors = {
	//   1: [
	//     [tAmber],
	//     [tOrange],
	//     [tBlue],
	//     [white]
	//   ],
	//   2: [
	//     [white, tBlue],
	//     [tOrange, white],
	//     [tAmber, tBlue]
	//   ],
	//   3: [
	//     [tOrange, white, tBlue],
	//     [tAmber, tBlue, tGreen]
	//   ],
	//   4: [
	//     [tAmber, tBlue, tMagenta, white]
	//   ],
	//   5: [
	//     [tBlue, tOrange, tPurple, tYellow, tGreen]
	//   ],
	//   6: [
	//     [tBlue, tOrange, tPurple, tYellow, tTeal, tAmber]
	//   ],
	//   all: [
	//     [tBlue, tOrange, tPurple, tYellow, tTeal, tAmber, tMagenta, tGreen]
	//   ]
	// }
	// color series for business theme
	// now ensure that you have proper series matching between the
	// light and dark themes -- ie option #2 should be same style
	// on light and dark

	var businessBarSeries = {
	  1: [[black], excludeFromLine([{
	    color: white,
	    stroke: black
	  }]), [cyan], [honey]],
	  2: [[black, cyan], excludeFromLine([{
	    color: black,
	    stroke: black
	  }, {
	    color: white,
	    stroke: black
	  }]), [black, honey], [black, honey], // an option only to mirror dark theme
	  [black, cyan]],
	  3: [[black, magenta, honey], [black, cyanD2, cyan], [black, honeyD2, honey], [black, gray3, honey]],
	  4: [[black, magenta, cyan, honey], [black, cyanD3, cyanD1, cyanL1], [black, honeyD3, honeyD1, honeyL1]],
	  5: [[black, magenta, cyan, honey, mint], [black, cyanD3, cyanD1, cyan, cyanL1], [black, honeyD3, honeyD1, honey, honeyL1]],
	  6: [[black, magenta, gray2, cyan, honey, mint], [black, cyanD3, cyanD1, cyan, cyanL1, cyanL2], [black, honeyD3, honeyD1, honey, honeyL1, honeyL2]],
	  all: [[black, magenta, gray2, cyan, honey, mint, blue], [black, cyanD3, cyanD1, cyan, cyanL1, cyanL2, cyanL3], [black, honeyD3, honeyD1, honey, honeyL1, honeyL2, honeyL3]]
	};
	var businessLineSeries = {
	  1: [[black], [cyan], [honey]],
	  2: [[black, honey], [black, cyan]],
	  3: [[black, magenta, honey], [black, cyanD2, cyan], [black, honeyD2, honey]],
	  4: [[black, magenta, cyan, honey], [black, cyanD3, cyanD1, cyanL1], [black, honeyD3, honeyD1, honeyL1]],
	  5: [[black, magenta, cyan, honey, mint], [black, cyanD3, cyanD1, cyan, cyanL1], [black, honeyD3, honeyD1, honey, honeyL1]],
	  6: [[black, magenta, gray2, cyan, honey, mint], [black, cyanD3, cyanD1, cyan, cyanL1, cyanL2], [black, honeyD3, honeyD1, honey, honeyL1, honeyL2]],
	  all: [[black, magenta, gray2, cyan, honey, mint, blue], [black, cyanD3, cyanD1, cyan, cyanL1, cyanL2, cyanL3], [black, honeyD3, honeyD1, honey, honeyL1, honeyL2, honeyL3]]
	}; // dark version of business separate from terminal and split into line vs
	// bar colors

	var businessDarkBarSeries = {
	  1: [[honey], excludeFromLine([{
	    color: black,
	    stroke: white
	  }]), [cyan], [white]],
	  2: [[honeyGray, honey], excludeFromLine([{
	    color: white,
	    stroke: white
	  }, {
	    color: black,
	    stroke: white
	  }]), [cyanGray, cyan], [white, honey], [white, cyan]],
	  3: [[honeyGray, honey, cyan], [gray3, cyanL2, cyan], [gray3, honeyL2, honey], [white, honeyGray, honey]],
	  4: [[white, magenta, cyan, honey], [white, cyanL3, cyanL1, cyanD1], [white, honeyL3, honeyL1, honeyD1]],
	  5: [[white, magenta, cyan, honey, mint], [white, cyanL3, cyanL1, cyan, cyanD1], [white, honeyL3, honeyL1, honey, honeyD1]],
	  6: [[white, magenta, gray3, cyan, honey, mint], [white, cyanL3, cyanL1, cyan, cyanD1, cyanD2], [white, honeyL3, honeyL1, honey, honeyD1, honeyD2]],
	  all: [[white, magenta, gray3, cyan, honey, mint, blue], [white, cyanL3, cyanL1, cyan, cyanD1, cyanD2, cyanD3], [white, honeyL3, honeyL1, honey, honeyD1, honeyD2, honeyD3]]
	};
	var businessDarkLineSeries = {
	  1: [[honey], [cyan], [white]],
	  2: [[honey, white], [cyan, white]],
	  3: [[white, cyan, honey], [white, honeyGray, cyan], [white, honeyGray, honey]],
	  4: [[white, magenta, cyan, honey], [white, cyanL3, cyanL1, cyanD1], [white, honeyL3, honeyL1, honeyD1]],
	  5: [[white, magenta, cyan, honey, mint], [white, cyanL3, cyanL1, cyan, cyanD1], [white, honeyL3, honeyL1, honey, honeyD1]],
	  6: [[white, magenta, honeyGray, cyan, honey, mint], [white, cyanL3, cyanL1, cyan, cyanD1, cyanD2], [white, honeyL3, honeyL1, honey, honeyD1, honeyD2]],
	  all: [[white, magenta, honeyGray, cyan, honey, mint, blue], [white, cyanL3, cyanL1, cyan, cyanD1, cyanD2, cyanD3], [white, honeyL3, honeyL1, honey, honeyD1, honeyD2, honeyD3]]
	}; // For scatterPlot and other types we just don't want the default
	// color to be black for one and two series charts, so we revise the order

	var businessColorfulSeries = _objectSpread2(_objectSpread2({}, businessBarSeries), {}, {
	  1: [[cyan], [honey], [magenta]],
	  2: [[cyan, orange], [cyan, honey], [magenta, cyan], [magenta, black], // an option only to mirror dark theme
	  [cyan, black]]
	}); // For scatterPlot and other types we just don't want the default
	// color to be black for one and two series charts, so we revise the order


	var businessDarkColorfulSeries = _objectSpread2(_objectSpread2({}, businessBarSeries), {}, {
	  1: [[cyan], [honey], [magenta]],
	  2: [[cyan, orange], [cyan, honey], [magenta, cyan], [magenta, black], // an option only to mirror dark theme
	  [honeyGray, honey]]
	});

	var bizweekColors = {
	  1: [[black], excludeFromLine([{
	    color: white,
	    stroke: black
	  }]), [{
	    color: bwBlue,
	    stroke: black
	  }], [{
	    color: bwRed,
	    stroke: black
	  }], [{
	    color: bwLilac,
	    stroke: black
	  }]],
	  2: [[white, black], [black, bwBlue], [black, bwRed]],
	  3: [[black, bwGreen, bwLilac], [black, bwBlueD2, bwBlue], [black, bwRedD2, bwRed]],
	  4: [[black, bwBlue, bwRed, bwGreen], [black, bwBlueD2, bwBlue, bwBlueL2], [black, bwRedD2, bwRed, bwRedL2]],
	  5: [[black, bwBlue, bwRed, bwGreen, bwLilac], [black, bwBlueD3, bwBlueD1, bwBlue, bwBlueL2], [black, bwRedD3, bwRedD1, bwRed, bwRedL2]],
	  6: [[black, bwBlue, bwRed, bwGreen, bwLilac, bwYellow], [black, bwBlueD3, bwBlueD1, bwBlue, bwBlueL1, bwBlueL3], [black, bwRedD3, bwRedD1, bwRed, bwRedL1, bwRedL3]],
	  all: [[black, bwBlue, bwRed, bwGreen, bwLilac, bwYellow, white], [black, bwBlueD2, bwBlueD1, bwBlue, bwBlueL1, bwBlueL2, bwBlueL3], [black, bwRedD2, bwRedD1, bwRed, bwRedL1, bwRedL2, bwRedL3]]
	};
	var bizweekDarkColors = {
	  1: [[white], excludeFromLine([{
	    color: black,
	    stroke: white
	  }]), [{
	    color: bwBlue,
	    stroke: white
	  }], [{
	    color: bwRed,
	    stroke: white
	  }], [{
	    color: bwLilac,
	    stroke: white
	  }]],
	  2: [[black, white], [white, bwBlue], [white, bwRed]],
	  3: [[white, bwGreen, bwLilac], [white, bwBlueD2, bwBlue], [white, bwRedD2, bwRed]],
	  4: [[white, bwBlue, bwRed, bwGreen], [white, bwBlueD2, bwBlue, bwBlueL2], [white, bwRedD2, bwRed, bwRedL2]],
	  5: [[white, bwBlue, bwRed, bwGreen, bwLilac], [white, bwBlueD3, bwBlueD1, bwBlue, bwBlueL2], [white, bwRedD3, bwRedD1, bwRed, bwRedL2]],
	  6: [[white, bwBlue, bwRed, bwGreen, bwLilac, bwYellow], [white, bwBlueD3, bwBlueD1, bwBlue, bwBlueL1, bwBlueL3], [white, bwRedD3, bwRedD1, bwRed, bwRedL1, bwRedL3]],
	  all: [[white, bwBlue, bwRed, bwGreen, bwLilac, bwYellow, black], [white, bwBlueD2, bwBlueD1, bwBlue, bwBlueL1, bwBlueL2, bwBlueL3], [white, bwRedD2, bwRedD1, bwRed, bwRedL1, bwRedL2, bwRedL3]]
	}; // color series for business theme

	var greenColors = {
	  1: [[gGreen], [black], [gDiscrete[3]], [{
	    color: gGreen,
	    stroke: black
	  }]],
	  2: [[gDiscrete[1], gDiscrete[0]], [gDiscrete[0], gDiscrete[1]], [gDiscrete[1], gDiscrete[3]], [{
	    color: white,
	    stroke: black
	  }, {
	    color: gGreen,
	    stroke: black
	  }]],
	  3: [[gDiscrete[1], gDiscrete[0], gDiscrete[2]], [gDiscrete[1], gDiscrete[3], gDiscrete[2]], [gDiscrete[0], gDiscrete[1], gDiscrete[2]], [gDiscrete[2], gDiscrete[0], gDiscrete[1]], [{
	    color: gSeries[0],
	    stroke: black
	  }, {
	    color: gSeries[2],
	    stroke: black
	  }, {
	    color: gSeries[4],
	    stroke: black
	  }]],
	  4: [[gDiscrete[0], gDiscrete[1], gDiscrete[2], gDiscrete[3]], [gDiscrete[1], gDiscrete[2], gDiscrete[3], gDiscrete[4]], [gDiscrete[1], gDiscrete[0], gDiscrete[2], gDiscrete[3]], [{
	    color: gSeries[0],
	    stroke: black
	  }, {
	    color: gSeries[2],
	    stroke: black
	  }, {
	    color: gSeries[4],
	    stroke: black
	  }, {
	    color: gSeries[6],
	    stroke: black
	  }]],
	  5: [[gDiscrete[0], gDiscrete[1], gDiscrete[2], gDiscrete[3], gDiscrete[4]], [gDiscrete[1], gDiscrete[0], gDiscrete[2], gDiscrete[3], gDiscrete[4]], [{
	    color: gSeries[0],
	    stroke: black
	  }, {
	    color: gSeries[2],
	    stroke: black
	  }, {
	    color: gSeries[4],
	    stroke: black
	  }, {
	    color: gSeries[6],
	    stroke: black
	  }, {
	    color: gSeries[8],
	    stroke: black
	  }]],
	  6: [[gDiscrete[0], gDiscrete[1], gDiscrete[2], gDiscrete[3], gDiscrete[4], gDiscrete[5]], [gDiscrete[1], gDiscrete[0], gDiscrete[2], gDiscrete[3], gDiscrete[4], gDiscrete[5]], [{
	    color: gSeries[0],
	    stroke: black
	  }, {
	    color: gSeries[2],
	    stroke: black
	  }, {
	    color: gSeries[3],
	    stroke: black
	  }, {
	    color: gSeries[5],
	    stroke: black
	  }, {
	    color: gSeries[6],
	    stroke: black
	  }, {
	    color: gSeries[8],
	    stroke: black
	  }]],
	  all: [[gDiscrete[0], gDiscrete[1], gDiscrete[2], gDiscrete[3], gDiscrete[4], gDiscrete[5], gDiscrete[6], gDiscrete[7], gDiscrete[8]], [gDiscrete[1], gDiscrete[0], gDiscrete[2], gDiscrete[3], gDiscrete[4], gDiscrete[5], gDiscrete[6], gDiscrete[7], gDiscrete[8]], [{
	    color: gSeries[0],
	    stroke: black
	  }, {
	    color: gSeries[1],
	    stroke: black
	  }, {
	    color: gSeries[2],
	    stroke: black
	  }, {
	    color: gSeries[3],
	    stroke: black
	  }, {
	    color: gSeries[4],
	    stroke: black
	  }, {
	    color: gSeries[5],
	    stroke: black
	  }, {
	    color: gSeries[6],
	    stroke: black
	  }, {
	    color: gSeries[7],
	    stroke: black
	  }, {
	    color: gSeries[8],
	    stroke: black
	  }]]
	};
	var greenDarkColors = {
	  1: [[gGreen], [white], [gDiscrete[3]], [{
	    color: gGreen,
	    stroke: white
	  }]],
	  2: [[white, gDiscrete[0]], [gDiscrete[0], white], [white, gDiscrete[3]], [{
	    color: black,
	    stroke: white
	  }, {
	    color: gGreen,
	    stroke: white
	  }]],
	  3: [[white, gDiscrete[0], gDiscrete[2]], [white, gDiscrete[3], gDiscrete[2]], [gDiscrete[0], white, gDiscrete[2]], [gDiscrete[2], gDiscrete[0], white], [{
	    color: gSeries[0],
	    stroke: white
	  }, {
	    color: gSeries[2],
	    stroke: white
	  }, {
	    color: gSeries[4],
	    stroke: white
	  }]],
	  4: [[gDiscrete[0], white, gDiscrete[2], gDiscrete[3]], [white, gDiscrete[2], gDiscrete[3], gDiscrete[4]], [white, gDiscrete[0], gDiscrete[2], gDiscrete[3]], [{
	    color: gSeries[0],
	    stroke: white
	  }, {
	    color: gSeries[2],
	    stroke: white
	  }, {
	    color: gSeries[4],
	    stroke: white
	  }, {
	    color: gSeries[6],
	    stroke: white
	  }]],
	  5: [[gDiscrete[0], white, gDiscrete[2], gDiscrete[3], gDiscrete[4]], [white, gDiscrete[0], gDiscrete[2], gDiscrete[3], gDiscrete[4]], [{
	    color: gSeries[0],
	    stroke: white
	  }, {
	    color: gSeries[2],
	    stroke: white
	  }, {
	    color: gSeries[4],
	    stroke: white
	  }, {
	    color: gSeries[6],
	    stroke: white
	  }, {
	    color: gSeries[8],
	    stroke: white
	  }]],
	  6: [[gDiscrete[0], white, gDiscrete[2], gDiscrete[3], gDiscrete[4], gDiscrete[5]], [white, gDiscrete[0], gDiscrete[2], gDiscrete[3], gDiscrete[4], gDiscrete[5]], [{
	    color: gSeries[0],
	    stroke: white
	  }, {
	    color: gSeries[2],
	    stroke: white
	  }, {
	    color: gSeries[3],
	    stroke: white
	  }, {
	    color: gSeries[5],
	    stroke: white
	  }, {
	    color: gSeries[6],
	    stroke: white
	  }, {
	    color: gSeries[8],
	    stroke: white
	  }]],
	  all: [[gDiscrete[0], white, gDiscrete[2], gDiscrete[3], gDiscrete[4], gDiscrete[5], gDiscrete[6], gDiscrete[7], gDiscrete[8]], [white, gDiscrete[0], gDiscrete[2], gDiscrete[3], gDiscrete[4], gDiscrete[5], gDiscrete[6], gDiscrete[7], gDiscrete[8]], [{
	    color: gSeries[0],
	    stroke: white
	  }, {
	    color: gSeries[1],
	    stroke: white
	  }, {
	    color: gSeries[2],
	    stroke: white
	  }, {
	    color: gSeries[3],
	    stroke: white
	  }, {
	    color: gSeries[4],
	    stroke: white
	  }, {
	    color: gSeries[5],
	    stroke: white
	  }, {
	    color: gSeries[6],
	    stroke: white
	  }, {
	    color: gSeries[7],
	    stroke: white
	  }, {
	    color: gSeries[8],
	    stroke: white
	  }]]
	};
	var greenPatterns = {
	  1: [[{
	    color: gPattern(1),
	    stroke: black
	  }]],
	  2: [[{
	    color: gPattern(1),
	    stroke: black
	  }, {
	    color: gPattern(2),
	    stroke: black
	  }]],
	  3: [[{
	    color: gPattern(1),
	    stroke: black
	  }, {
	    color: gPattern(2),
	    stroke: black
	  }, {
	    color: gPattern(3),
	    stroke: black
	  }]],
	  4: [[{
	    color: gPattern(1),
	    stroke: black
	  }, {
	    color: gPattern(2),
	    stroke: black
	  }, {
	    color: gPattern(3),
	    stroke: black
	  }, {
	    color: gPattern(4),
	    stroke: black
	  }]],
	  5: [[{
	    color: gPattern(1),
	    stroke: black
	  }, {
	    color: gPattern(2),
	    stroke: black
	  }, {
	    color: gPattern(3),
	    stroke: black
	  }, {
	    color: gPattern(4),
	    stroke: black
	  }, {
	    color: gPattern(5),
	    stroke: black
	  }]],
	  6: [[{
	    color: gPattern(1),
	    stroke: black
	  }, {
	    color: gPattern(2),
	    stroke: black
	  }, {
	    color: gPattern(3),
	    stroke: black
	  }, {
	    color: gPattern(4),
	    stroke: black
	  }, {
	    color: gPattern(5),
	    stroke: black
	  }, {
	    color: gPattern(6),
	    stroke: black
	  }]],
	  all: [[{
	    color: gPattern(1),
	    stroke: black
	  }, {
	    color: gPattern(2),
	    stroke: black
	  }, {
	    color: gPattern(3),
	    stroke: black
	  }, {
	    color: gPattern(4),
	    stroke: black
	  }, {
	    color: gPattern(5),
	    stroke: black
	  }, {
	    color: gPattern(6),
	    stroke: black
	  }, {
	    color: gPattern(7),
	    stroke: black
	  }]]
	};
	var greenDarkPatterns = {
	  1: [[{
	    color: gPatternDark(1),
	    stroke: gGreen
	  }]],
	  2: [[{
	    color: gPatternDark(1),
	    stroke: gGreen
	  }, {
	    color: gPatternDark(2),
	    stroke: gGreen
	  }]],
	  3: [[{
	    color: gPatternDark(1),
	    stroke: gGreen
	  }, {
	    color: gPatternDark(2),
	    stroke: gGreen
	  }, {
	    color: gPatternDark(3),
	    stroke: gGreen
	  }]],
	  4: [[{
	    color: gPatternDark(1),
	    stroke: gGreen
	  }, {
	    color: gPatternDark(2),
	    stroke: gGreen
	  }, {
	    color: gPatternDark(3),
	    stroke: gGreen
	  }, {
	    color: gPatternDark(4),
	    stroke: gGreen
	  }]],
	  5: [[{
	    color: gPatternDark(1),
	    stroke: gGreen
	  }, {
	    color: gPatternDark(2),
	    stroke: gGreen
	  }, {
	    color: gPatternDark(3),
	    stroke: gGreen
	  }, {
	    color: gPatternDark(4),
	    stroke: gGreen
	  }, {
	    color: gPatternDark(5),
	    stroke: gGreen
	  }]],
	  6: [[{
	    color: gPatternDark(1),
	    stroke: gGreen
	  }, {
	    color: gPatternDark(2),
	    stroke: gGreen
	  }, {
	    color: gPatternDark(3),
	    stroke: gGreen
	  }, {
	    color: gPatternDark(4),
	    stroke: gGreen
	  }, {
	    color: gPatternDark(5),
	    stroke: gGreen
	  }, {
	    color: gPatternDark(6),
	    stroke: gGreen
	  }]],
	  all: [[{
	    color: gPatternDark(1),
	    stroke: gGreen
	  }, {
	    color: gPatternDark(2),
	    stroke: gGreen
	  }, {
	    color: gPatternDark(3),
	    stroke: gGreen
	  }, {
	    color: gPatternDark(4),
	    stroke: gGreen
	  }, {
	    color: gPatternDark(5),
	    stroke: gGreen
	  }, {
	    color: gPatternDark(6),
	    stroke: gGreen
	  }, {
	    color: gPatternDark(7),
	    stroke: gGreen
	  }]]
	};
	var citylabColumnColors = {
	  1: [[clOrangeB3], [black], [{
	    color: white,
	    stroke: black
	  }]],
	  2: [[{
	    color: black,
	    stroke: black
	  }, {
	    color: white,
	    stroke: black
	  }], // TODO check X-axis appearance
	  [black, clGray], [black, clOrangeB1], [clOrangeB3, clOrangeB1], [clOrangeB3, clCyanC3], [clOrangeB3, clTealC3]],
	  3: [// TODO check these colors
	  [black, clOrangeB5, clOrangeB1], [black, clOrangeB3, clCyanC3], [black, clOrangeB3, clTealC3]],
	  4: [[black, clOrangeB5, clOrangeB3, clOrangeB1], [black, clGray, clOrangeB3, clCyanC3], [black, clOrangeB3, clOrangeB1, clCyanC3], [black, clOrangeB3, clOrangeB1, clTealC3]],
	  5: [[black, clOrangeB5, clOrangeB3, clOrangeB1, clOrangeB0], [black, clGray, clOrangeB3, clOrangeB1, clCyanC3], [black, clGray, clOrangeB3, clOrangeB1, clTealC3], [clOrangeB6, clOrangeB4, clOrangeB0, clOrangeB3, clOrangeB1]],
	  6: [// TODO check colors
	  [black, clOrangeB6, clOrangeB5, clOrangeB3, clOrangeB1, clOrangeB0], [black, clGray, clOrangeB6, clOrangeB3, clOrangeB1, clCyanC3], [black, clGray, clOrangeB6, clOrangeB3, clOrangeB1, clTealC3]],
	  all: [[black, clOrangeB5, clOrangeB4, clOrangeB3, clOrangeB2, clOrangeB1, clOrangeB0], [black, clGray, clOrangeB3, clCyanC3, clOrangeB2, clTealC3, clOrangeB1], [clOrangeB6, clOrangeB5, clOrangeB4, clOrangeB3, clOrangeB2, clOrangeB1, clOrangeB0]]
	};
	var citylabLineColors = {
	  // no white
	  1: [[clOrangeB3], [black]],
	  2: [[black, clGray], [black, clOrangeB1], [clOrangeB3, clOrangeB1], [clOrangeB3, clCyanC3], [clOrangeB3, clTealC3]],
	  3: [// TODO check colors
	  [black, clOrangeB5, clOrangeB1], [black, clOrangeB3, clCyanC3], [black, clOrangeB3, clTealC3]],
	  4: [[black, clOrangeB5, clOrangeB3, clOrangeB1], [black, clGray, clOrangeB3, clCyanC3], [black, clOrangeB3, clOrangeB1, clCyanC3], [black, clOrangeB3, clOrangeB1, clTealC3]],
	  5: [[black, clOrangeB5, clOrangeB3, clOrangeB1, clOrangeB0], [black, clGray, clOrangeB3, clOrangeB1, clCyanC3], [black, clGray, clOrangeB3, clOrangeB1, clTealC3], [clOrangeB6, clOrangeB4, clOrangeB0, clOrangeB3, clOrangeB1]],
	  6: [// TODO check colors
	  [black, clOrangeB6, clOrangeB5, clOrangeB3, clOrangeB1, clOrangeB0], [black, clGray, clOrangeB6, clOrangeB3, clOrangeB1, clCyanC3], [black, clGray, clOrangeB6, clOrangeB3, clOrangeB1, clTealC3]],
	  all: [[black, clOrangeB5, clOrangeB4, clOrangeB3, clOrangeB2, clOrangeB1, clOrangeB0], [black, clGray, clOrangeB3, clCyanC3, clOrangeB2, clTealC3, clOrangeB1], [clOrangeB6, clOrangeB5, clOrangeB4, clOrangeB3, clOrangeB2, clOrangeB1, clOrangeB0]]
	};
	var citylabDarkColumnColors = {
	  1: [[clOrangeB3], [{
	    color: black,
	    stroke: white
	  }], [white]],
	  2: [[{
	    color: black,
	    stroke: white
	  }, {
	    color: white,
	    stroke: white
	  }], [white, clOrangeB1], [clOrangeB1, clOrangeB3], [clOrangeB3, clCyanC3], [clOrangeB3, clTealC3]],
	  3: [// TODO check colors
	  [white, clOrangeB1, clOrangeB5], [white, clOrangeB3, clCyanC3], [white, clOrangeB3, clTealC3]],
	  4: [[white, clOrangeB1, clOrangeB3, clOrangeB5], [white, clOrangeB1, clOrangeB3, clCyanC3], [white, clOrangeB1, clOrangeB3, clTealC3]],
	  5: [[white, clOrangeB0, clOrangeB1, clOrangeB3, clOrangeB5], [white, clOrangeB0, clOrangeB1, clOrangeB3, clCyanC3], [white, clOrangeB0, clOrangeB1, clOrangeB3, clTealC3], [clOrangeB6, clOrangeB4, clOrangeB0, clOrangeB3, clOrangeB1]],
	  6: [// TODO check colors
	  [white, clOrangeB0, clOrangeB1, clOrangeB3, clOrangeB5, clOrangeB6], [white, clOrangeB0, clOrangeB1, clOrangeB3, clOrangeB6, clCyanC3], [white, clOrangeB0, clOrangeB1, clOrangeB3, clOrangeB6, clTealC3]],
	  all: [[white, clOrangeB0, clOrangeB1, clOrangeB2, clOrangeB3, clOrangeB4, clOrangeB5], [white, clCyanC3, clOrangeB2, clTealC3, clOrangeB3, clOrangeB1, clOrangeB0], [clOrangeB6, clOrangeB5, clOrangeB4, clOrangeB3, clOrangeB2, clOrangeB1, clOrangeB0]]
	};
	var citylabDarkLineColors = {
	  // no black
	  1: [[clOrangeB3], [white]],
	  2: [[white, clOrangeB1], [clOrangeB1, clOrangeB3], [clOrangeB3, clCyanC3], [clOrangeB3, clTealC3]],
	  3: [// TODO check colors
	  [white, clOrangeB1, clOrangeB5], [white, clOrangeB3, clCyanC3], [white, clOrangeB3, clTealC3]],
	  4: [[white, clOrangeB1, clOrangeB3, clOrangeB5], [white, clOrangeB1, clOrangeB3, clCyanC3], [white, clOrangeB1, clOrangeB3, clTealC3]],
	  5: [[white, clOrangeB0, clOrangeB1, clOrangeB3, clOrangeB5], [white, clOrangeB0, clOrangeB1, clOrangeB3, clCyanC3], [white, clOrangeB0, clOrangeB1, clOrangeB3, clTealC3], [clOrangeB6, clOrangeB4, clOrangeB0, clOrangeB3, clOrangeB1]],
	  6: [// TODO check colors
	  [white, clOrangeB0, clOrangeB1, clOrangeB3, clOrangeB5, clOrangeB6], [white, clOrangeB0, clOrangeB1, clOrangeB3, clOrangeB6, clCyanC3], [white, clOrangeB0, clOrangeB1, clOrangeB3, clOrangeB6, clTealC3]],
	  all: [[white, clOrangeB0, clOrangeB1, clOrangeB2, clOrangeB3, clOrangeB4, clOrangeB5], [white, clCyanC3, clOrangeB2, clTealC3, clOrangeB3, clOrangeB1, clOrangeB0], [clOrangeB6, clOrangeB5, clOrangeB4, clOrangeB3, clOrangeB2, clOrangeB1, clOrangeB0]]
	};
	var bnefColors = {
	  1: [['#0D9DDB'], ['#00D2B3'], ['#8A5DB5']],
	  2: [['#0D9DDB', '#00D2B3'], ['#0D9DDB', '#C19BE6'], ['#0D9DDB', '#8A5DB5'], ['#0D9DDB', '#AAE5FF'], ['#8A5DB5', '#DDBAFF'], ['#00D2B3', '#93FFEF']],
	  3: [['#0D9DDB', '#3B3B3B', '#00D2B3'], ['#0D9DDB', '#8A5DB5', '#00D2B3'], ['#0D9DDB', '#76CDF3', '#AAE5FF'], ['#8A5DB5', '#C19BE6', '#DDBAFF'], ['#00D2B3', '#62F0DB', '#93FFEF']],
	  4: [['#0D9DDB', '#3B3B3B', '#01B69B', '#00D2B3'], ['#005174', '#0D9DDB', '#3B3B3B', '#00D2B3'], ['#0D9DDB', '#8A5DB5', '#00D2B3', '#ED4436'], ['#0D9DDB', '#41B5E7', '#76CDF3', '#AAE5FF'], ['#8A5DB5', '#A67CCE', '#C19BE6', '#DDBAFF'], ['#00D2B3', '#31E1C7', '#62F0DB', '#93FFEF']],
	  5: [['#0D9DDB', '#046A96', '#3B3B3B', '#01B69B', '#00D2B3'], ['#0D9DDB', '#005174', '#8A5DB5', '#3C294E', '#00D2B3'], ['#0D9DDB', '#8A5DB5', '#00D2B3', '#ED4436', '#FFCC1D'], ['#0984B9', '#0D9DDB', '#41B5E7', '#76CDF3', '#AAE5FF'], ['#6D4B8D', '#8A5DB5', '#A67CCE', '#C19BE6', '#DDBAFF'], ['#01B69B', '#00D2B3', '#31E1C7', '#62F0DB', '#93FFEF']],
	  6: [['#0D9DDB', '#046A96', '#3B3B3B', '#029983', '#01B69B', '#00D2B3'], ['#0D9DDB', '#005174', '#8A5DB5', '#3C294E', '#00D2B3', '#037D6B'], ['#0D9DDB', '#8A5DB5', '#00D2B3', '#ED4436', '#FFCC1D', '#EA60A7'], ['#046A96', '#0984B9', '#0D9DDB', '#41B5E7', '#76CDF3', '#AAE5FF'], ['#563A70', '#6D4B8D', '#8A5DB5', '#A67CCE', '#C19BE6', '#DDBAFF'], ['#029983', '#01B69B', '#00D2B3', '#31E1C7', '#62F0DB', '#93FFEF']],
	  all: [['#0D9DDB', '#0984B9', '#046A96', '#3B3B3B', '#029983', '#01B69B', '#00D2B3'], ['#0D9DDB', '#005174', '#AAE5FF', '#8A5DB5', '#3C294E', '#00D2B3', '#037D6B'], ['#0D9DDB', '#8A5DB5', '#00D2B3', '#ED4436', '#FFCC1D', '#EA60A7', '#4DAA50'], ['#005174', '#046A96', '#0984B9', '#0D9DDB', '#41B5E7', '#76CDF3', '#AAE5FF'], ['#3C294E', '#563A70', '#6D4B8D', '#8A5DB5', '#A67CCE', '#C19BE6', '#DDBAFF'], ['#037D6B', '#029983', '#01B69B', '#00D2B3', '#31E1C7', '#62F0DB', '#93FFEF']]
	};
	var bnefDarkColors = {
	  1: [['#0D9DDB'], ['#00D2B3'], ['#8A5DB5']],
	  2: [['#0D9DDB', '#00D2B3'], ['#0D9DDB', '#8A5DB5'], ['#0D9DDB', '#005174'], ['#8A5DB5', '#563A70'], ['#00D2B3', '#037D6B']],
	  3: [['#0D9DDB', '#E5E5E5', '#00D2B3'], ['#0D9DDB', '#8A5DB5', '#00D2B3'], ['#0D9DDB', '#0984B9', '#005174'], ['#8A5DB5', '#563A70', '#3C294E'], ['#00D2B3', '#01B69B', '#037D6B']],
	  4: [['#0D9DDB', '#76CDF3', '#62F0DB', '#00D2B3'], ['#AAE5FF', '#0D9DDB', '#8A5DB5', '#00D2B3'], ['#0D9DDB', '#8A5DB5', '#00D2B3', '#ED4436'], ['#0D9DDB', '#0984B9', '#046A96', '#005174'], ['#8A5DB5', '#704C93', '#563A70', '#3C294E'], ['#00D2B3', '#01B69B', '#029983', '#037D6B']],
	  5: [['#0D9DDB', '#76CDF3', '#E5E5E5', '#62F0DB', '#00D2B3'], ['#0D9DDB', '#AAE5FF', '#8A5DB5', '#C19BE6', '#00D2B3'], ['#0D9DDB', '#8A5DB5', '#00D2B3', '#ED4436', '#FFCC1D'], ['#41B5E7', '#0D9DDB', '#0984B9', '#046A96', '#005174'], ['#A67CCE', '#8A5DB5', '#704C93', '#563A70', '#3C294E'], ['#31E1C7', '#00D2B3', '#01B69B', '#029983', '#037D6B']],
	  6: [['#0D9DDB', '#1DB8FB', '#AAE5FF', '#93FFEF', '#62F0DB', '#00D2B3'], ['#0D9DDB', '#AAE5FF', '#8A5DB5', '#C19BE6', '#00D2B3', '#93FFEF'], ['#0D9DDB', '#8A5DB5', '#00D2B3', '#ED4436', '#FFCC1D', '#EA60A7'], ['#76CDF3', '#41B5E7', '#0D9DDB', '#0984B9', '#046A96', '#005174'], ['#DDBAFF', '#A67CCE', '#8A5DB5', '#704C93', '#563A70', '#3C294E'], ['#62F0DB', '#31E1C7', '#00D2B3', '#01B69B', '#029983', '#037D6B']],
	  all: [['#0D9DDB', '#1DB8FB', '#62D0FF', '#E5E5E5', '#93FFEF', '#62F0DB', '#00D2B3'], ['#76CDF3', '#0D9DDB', '#AAE5FF', '#8A5DB5', '#C19BE6', '#00D2B3', '#93FFEF'], ['#0D9DDB', '#8A5DB5', '#00D2B3', '#ED4436', '#FFCC1D', '#EA60A7', '#4DAA50'], ['#AAE5FF', '#76CDF3', '#41B5E7', '#0D9DDB', '#0984B9', '#046A96', '#005174'], ['#DDBAFF', '#DDBAFF', '#A67CCE', '#8A5DB5', '#704C93', '#563A70', '#3C294E'], ['#93FFEF', '#62F0DB', '#31E1C7', '#00D2B3', '#01B69B', '#029983', '#037D6B']]
	}; // no fully defined sets for these

	var opinionColors = ['#0072FF', '#000000', '#999', '#ff6564', '#2800d8', '#c1c1c1', '#a196d0', '#91c7bb', '#b5cec8', '#c5c2d2'];
	var opinionDarkColors = ['#0072FF', '#FFFFFF', '#999', '#ff6564', '#2800d8', '#c1c1c1', '#a196d0', '#91c7bb', '#b5cec8', '#c5c2d2'];
	var daybreakColors = ['#f8f704', '#02bceb', '#f32367', '#8462fa', '#19f4de', '#ff9000', '#91c7bb', '#b5cec8', '#c5c2d2'];
	var biColors = ['#4ab0ff', '#ffffff', '#fda315', '#ff00fc', '#ffe273', '#008616', '#ff1e3e', '#ffff00', '#1b84ed', '#bbbbbb', '#999999', '#666666', '#333333'];
	var THEME_DEFAULT_SETS = {
	  business: businessBarSeries.all[0],
	  'business-dark': businessDarkBarSeries.all[0],
	  terminal: terminalColors.all[0],
	  coth: terminalColors.all[0],
	  opinion: opinionColors,
	  'opinion-dark': opinionDarkColors,
	  view: opinionColors,
	  bizweek: bizweekColors.all[0],
	  'bizweek-dark': bizweekDarkColors.all[0],
	  green: greenColors.all[0],
	  'green-dark': greenDarkColors.all[0],
	  citylab: citylabColumnColors.all[0],
	  'citylab-dark': citylabDarkColumnColors.all[0],
	  bnef: bnefColors.all[0],
	  'bnef-dark': bnefDarkColors.all[0],
	  bi: biColors,
	  daybreak: daybreakColors
	}; // COLOR VARIATIONS

	var VARIATION_POLITICS_US = {
	  colors: ['#199cfc', '#ed203d', '#666', '#333'],
	  highlightColor: '#ed203d'
	};
	var VARIATION_POLITICS_US_DARK = {
	  colors: ['#199cfc', '#ed203d', '#999999', '#666'],
	  highlightColor: '#ed203d'
	};
	var VARIATION_POLITICS_UK = {
	  colors: ['#dc241f', '#0087dc', '#fdbb30', '#ff0', '#008142', '#09b7d0', '#666', '#333'],
	  highlightColor: '#0087dc'
	};
	var VARIATION_POLITICS_UK_DARK = {
	  colors: ['#dc241f', '#0087dc', '#fdbb30', '#ff0', '#008142', '#09b7d0', '#666', '#333'],
	  highlightColor: '#0087dc'
	};
	var VARIATION_POLITICS_GERMANY = {
	  colors: ['#ff0038', '#262626', '#00ff2a', '#fff200', '#00aeff', '#ff008c', '#860000', '#888'],
	  highlightColor: '#fa0033'
	};
	var VARIATION_POLITICS_GERMANY_DARK = {
	  colors: ['#ff0038', '#666666', '#00ff2a', '#fff200', '#00aeff', '#ff008c', '#860000', '#888'],
	  highlightColor: '#fa0033'
	};
	var VARIATION_MARKETS = {
	  colors: ['#00c88a', '#ff415f', '#000000', '#aaaaaa', '#888', '#444'],
	  highlightColor: '#ff415f'
	};
	var VARIATION_MARKETS_DARK = {
	  colors: ['#00c88a', '#ff415f', '#ffffff', '#aaaaaa', '#888', '#444'],
	  highlightColor: '#ff415f'
	};
	var VARIATION_POLITICS_BGOV = {
	  colors: ['#0d9ddb', '#ed4436', '#666', '#333'],
	  highlightColor: '#ed4436'
	};
	var VARIATION_POLITICS_BGOV_DARK = {
	  colors: ['#0d9ddb', '#ed4436', '#666', '#333'],
	  highlightColor: '#ed4436'
	};
	var VARIATION_BGOV = {
	  colors: ['#8A5DB5', '#0D9DDB', '#00D2B3', '#4DAA50', '#FFCC1D', '#ED4436', '#EA60A7', '#BBBBBB', '#999999', '#666666'],
	  highlightColor: '#FFCC1D'
	};
	var VARIATION_COMMUNICATIONS = {
	  colors: ['#8A5DB5', '#0D9DDB', '#00D2B3', '#4DAA50', '#FFCC1D', '#ED4436', '#EA60A7', '#BBBBBB', '#999999', '#666666'],
	  highlightColor: '#ED4436'
	};
	var VARIATIONS = {
	  light: {
	    'politics-us': VARIATION_POLITICS_US,
	    'politics-uk': VARIATION_POLITICS_UK,
	    'politics-germany': VARIATION_POLITICS_GERMANY,
	    'politics-bgov': VARIATION_POLITICS_BGOV,
	    bgov: VARIATION_BGOV,
	    market: VARIATION_MARKETS,
	    communications: VARIATION_COMMUNICATIONS
	  },
	  dark: {
	    'politics-us': VARIATION_POLITICS_US_DARK,
	    'politics-uk': VARIATION_POLITICS_UK_DARK,
	    'politics-germany': VARIATION_POLITICS_GERMANY_DARK,
	    'politics-bgov': VARIATION_POLITICS_BGOV_DARK,
	    bgov: VARIATION_BGOV,
	    market: VARIATION_MARKETS_DARK,
	    communications: VARIATION_COMMUNICATIONS
	  }
	};

	function gPattern(i) {
	  return "url(#pattern-green-light".concat(i, ") #fff");
	}

	function gPatternDark(i) {
	  return "url(#pattern-green-dark".concat(i, ") #fff");
	}

	var seriesThemes = {
	  business: businessBarSeries,
	  'business-dark': businessDarkBarSeries,
	  bizweek: bizweekColors,
	  'bizweek-dark': bizweekDarkColors,
	  green: greenColors,
	  'green-dark': greenDarkColors,
	  citylab: citylabColumnColors,
	  'citylab-dark': citylabDarkColumnColors,
	  bnef: bnefColors,
	  'bnef-dark': bnefDarkColors,
	  terminalX: terminalColors
	}; // if the line colors are different than bar colors override here
	// otherwise the same colors will be used for both

	var lineSeriesColors = {
	  business: businessLineSeries,
	  'business-dark': businessDarkLineSeries,
	  citylab: citylabLineColors,
	  'citylab-dark': citylabDarkLineColors
	};
	function seriesColors(theme) {
	  var _seriesThemes$theme;

	  // treat line and area types differently in color options etc.
	  var columnTypes = ['bar', 'hbar', 'stackedVbar', 'stackedHbar', 'area', 'dumbbell', 'horizontalDumbbell', 'comparison'];
	  var lineTypes = ['line', 'barline'];
	  var fillTypes = ['pie'];
	  var colorfulTypes = ['scatterPlot'];
	  var values = {};
	  lineTypes.forEach(function (type) {
	    values[type] = lineSeriesColors[theme] || filterLineColorSeries(theme, seriesThemes[theme]);
	  });
	  columnTypes.forEach(function (type) {
	    values[type] = seriesThemes[theme];
	  });
	  fillTypes.forEach(function (type) {
	    values[type] = filterPieColorSeries(theme, seriesThemes[theme]);
	  });
	  colorfulTypes.forEach(function (type) {
	    values[type] = filterNoMutedColorSeries(theme, seriesThemes[theme]);
	  });
	  values.default = (_seriesThemes$theme = seriesThemes[theme]) === null || _seriesThemes$theme === void 0 ? void 0 : _seriesThemes$theme.all;
	  return values;
	} // strip out color series options that don't apply to lines

	function filterLineColorSeries(theme, values) {
	  if (!values) return null;

	  var newValues = cloneDeep(values);

	  var noStroke = function noStroke(row) {
	    return row.map(function (v) {
	      if (v.stroke) return v.color;
	      return v;
	    });
	  };

	  var lineExclude = function lineExclude(row) {
	    if (!row) return false;
	    return !row.excludeFromLine;
	  };

	  newValues[1] = newValues[1].filter(lineExclude).map(noStroke);
	  newValues[2] = newValues[2].filter(lineExclude).map(noStroke);
	  newValues[5] = newValues[5].filter(lineExclude).map(noStroke);
	  newValues[6] = newValues[6].filter(lineExclude).map(noStroke);
	  newValues.all = newValues.all.filter(lineExclude).map(noStroke);
	  return newValues;
	} // allow patterns for pie fill types


	function filterPieColorSeries(theme, values) {
	  if (!values) return null;
	  var newValues = {};
	  Object.keys(values).forEach(function (key) {
	    newValues[key] = values[key].slice();
	  }); // deep copy

	  if (theme === 'green') {
	    Object.keys(greenPatterns).forEach(function (key) {
	      newValues[key] = newValues[key].slice(1).concat(greenPatterns[key]);
	    });
	  } else if (theme === 'green-dark') {
	    Object.keys(greenDarkPatterns).forEach(function (key) {
	      newValues[key] = newValues[key].slice(1).concat(greenDarkPatterns[key]);
	    });
	  }

	  return newValues;
	} // basically for ScatterPlot and other types we don't want the column
	// colors exactly -- we want to filter out the black default (and white
	// default for dark themes)


	function filterNoMutedColorSeries(theme, values) {
	  if (!values) return null;

	  if (theme === 'business') {
	    return businessColorfulSeries;
	  }

	  if (theme === 'business-dark') {
	    return businessDarkColorfulSeries;
	  }

	  return values;
	}

	function defaultThemeColors(theme, options) {
	  return THEME_DEFAULT_SETS[theme] || THEME_DEFAULT_SETS.business;
	}

	/**
	 * This function is like `assignValue` except that it doesn't assign
	 * `undefined` values.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {string} key The key of the property to assign.
	 * @param {*} value The value to assign.
	 */
	function assignMergeValue(object, key, value) {
	  if ((value !== undefined && !eq$1(object[key], value)) ||
	      (value === undefined && !(key in object))) {
	    baseAssignValue(object, key, value);
	  }
	}

	/**
	 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
	 *
	 * @private
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {Function} Returns the new base function.
	 */
	function createBaseFor(fromRight) {
	  return function(object, iteratee, keysFunc) {
	    var index = -1,
	        iterable = Object(object),
	        props = keysFunc(object),
	        length = props.length;

	    while (length--) {
	      var key = props[fromRight ? length : ++index];
	      if (iteratee(iterable[key], key, iterable) === false) {
	        break;
	      }
	    }
	    return object;
	  };
	}

	/**
	 * The base implementation of `baseForOwn` which iterates over `object`
	 * properties returned by `keysFunc` and invokes `iteratee` for each property.
	 * Iteratee functions may exit iteration early by explicitly returning `false`.
	 *
	 * @private
	 * @param {Object} object The object to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @param {Function} keysFunc The function to get the keys of `object`.
	 * @returns {Object} Returns `object`.
	 */
	var baseFor = createBaseFor();

	var baseFor$1 = baseFor;

	/**
	 * This method is like `_.isArrayLike` except that it also checks if `value`
	 * is an object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array-like object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArrayLikeObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLikeObject(document.body.children);
	 * // => true
	 *
	 * _.isArrayLikeObject('abc');
	 * // => false
	 *
	 * _.isArrayLikeObject(_.noop);
	 * // => false
	 */
	function isArrayLikeObject(value) {
	  return isObjectLike$2(value) && isArrayLike(value);
	}

	/** `Object#toString` result references. */
	var objectTag$1 = '[object Object]';

	/** Used for built-in method references. */
	var funcProto$2 = Function.prototype,
	    objectProto$8 = Object.prototype;

	/** Used to resolve the decompiled source of functions. */
	var funcToString$2 = funcProto$2.toString;

	/** Used to check objects for own properties. */
	var hasOwnProperty$6 = objectProto$8.hasOwnProperty;

	/** Used to infer the `Object` constructor. */
	var objectCtorString = funcToString$2.call(Object);

	/**
	 * Checks if `value` is a plain object, that is, an object created by the
	 * `Object` constructor or one with a `[[Prototype]]` of `null`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.8.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 * }
	 *
	 * _.isPlainObject(new Foo);
	 * // => false
	 *
	 * _.isPlainObject([1, 2, 3]);
	 * // => false
	 *
	 * _.isPlainObject({ 'x': 0, 'y': 0 });
	 * // => true
	 *
	 * _.isPlainObject(Object.create(null));
	 * // => true
	 */
	function isPlainObject(value) {
	  if (!isObjectLike$2(value) || baseGetTag$1(value) != objectTag$1) {
	    return false;
	  }
	  var proto = getPrototype$1(value);
	  if (proto === null) {
	    return true;
	  }
	  var Ctor = hasOwnProperty$6.call(proto, 'constructor') && proto.constructor;
	  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
	    funcToString$2.call(Ctor) == objectCtorString;
	}

	/**
	 * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the property to get.
	 * @returns {*} Returns the property value.
	 */
	function safeGet(object, key) {
	  if (key === 'constructor' && typeof object[key] === 'function') {
	    return;
	  }

	  if (key == '__proto__') {
	    return;
	  }

	  return object[key];
	}

	/**
	 * Converts `value` to a plain object flattening inherited enumerable string
	 * keyed properties of `value` to own properties of the plain object.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Lang
	 * @param {*} value The value to convert.
	 * @returns {Object} Returns the converted plain object.
	 * @example
	 *
	 * function Foo() {
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.assign({ 'a': 1 }, new Foo);
	 * // => { 'a': 1, 'b': 2 }
	 *
	 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
	 * // => { 'a': 1, 'b': 2, 'c': 3 }
	 */
	function toPlainObject(value) {
	  return copyObject(value, keysIn$1(value));
	}

	/**
	 * A specialized version of `baseMerge` for arrays and objects which performs
	 * deep merges and tracks traversed objects enabling objects with circular
	 * references to be merged.
	 *
	 * @private
	 * @param {Object} object The destination object.
	 * @param {Object} source The source object.
	 * @param {string} key The key of the value to merge.
	 * @param {number} srcIndex The index of `source`.
	 * @param {Function} mergeFunc The function to merge values.
	 * @param {Function} [customizer] The function to customize assigned values.
	 * @param {Object} [stack] Tracks traversed source values and their merged
	 *  counterparts.
	 */
	function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
	  var objValue = safeGet(object, key),
	      srcValue = safeGet(source, key),
	      stacked = stack.get(srcValue);

	  if (stacked) {
	    assignMergeValue(object, key, stacked);
	    return;
	  }
	  var newValue = customizer
	    ? customizer(objValue, srcValue, (key + ''), object, source, stack)
	    : undefined;

	  var isCommon = newValue === undefined;

	  if (isCommon) {
	    var isArr = isArray$2(srcValue),
	        isBuff = !isArr && isBuffer$2(srcValue),
	        isTyped = !isArr && !isBuff && isTypedArray$1(srcValue);

	    newValue = srcValue;
	    if (isArr || isBuff || isTyped) {
	      if (isArray$2(objValue)) {
	        newValue = objValue;
	      }
	      else if (isArrayLikeObject(objValue)) {
	        newValue = copyArray(objValue);
	      }
	      else if (isBuff) {
	        isCommon = false;
	        newValue = cloneBuffer(srcValue, true);
	      }
	      else if (isTyped) {
	        isCommon = false;
	        newValue = cloneTypedArray(srcValue, true);
	      }
	      else {
	        newValue = [];
	      }
	    }
	    else if (isPlainObject(srcValue) || isArguments$1(srcValue)) {
	      newValue = objValue;
	      if (isArguments$1(objValue)) {
	        newValue = toPlainObject(objValue);
	      }
	      else if (!isObject$2(objValue) || isFunction$1(objValue)) {
	        newValue = initCloneObject(srcValue);
	      }
	    }
	    else {
	      isCommon = false;
	    }
	  }
	  if (isCommon) {
	    // Recursively merge objects and arrays (susceptible to call stack limits).
	    stack.set(srcValue, newValue);
	    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
	    stack['delete'](srcValue);
	  }
	  assignMergeValue(object, key, newValue);
	}

	/**
	 * The base implementation of `_.merge` without support for multiple sources.
	 *
	 * @private
	 * @param {Object} object The destination object.
	 * @param {Object} source The source object.
	 * @param {number} srcIndex The index of `source`.
	 * @param {Function} [customizer] The function to customize merged values.
	 * @param {Object} [stack] Tracks traversed source values and their merged
	 *  counterparts.
	 */
	function baseMerge(object, source, srcIndex, customizer, stack) {
	  if (object === source) {
	    return;
	  }
	  baseFor$1(source, function(srcValue, key) {
	    stack || (stack = new Stack);
	    if (isObject$2(srcValue)) {
	      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
	    }
	    else {
	      var newValue = customizer
	        ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)
	        : undefined;

	      if (newValue === undefined) {
	        newValue = srcValue;
	      }
	      assignMergeValue(object, key, newValue);
	    }
	  }, keysIn$1);
	}

	/**
	 * This method returns the first argument it receives.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Util
	 * @param {*} value Any value.
	 * @returns {*} Returns `value`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 *
	 * console.log(_.identity(object) === object);
	 * // => true
	 */
	function identity$6(value) {
	  return value;
	}

	/**
	 * A faster alternative to `Function#apply`, this function invokes `func`
	 * with the `this` binding of `thisArg` and the arguments of `args`.
	 *
	 * @private
	 * @param {Function} func The function to invoke.
	 * @param {*} thisArg The `this` binding of `func`.
	 * @param {Array} args The arguments to invoke `func` with.
	 * @returns {*} Returns the result of `func`.
	 */
	function apply(func, thisArg, args) {
	  switch (args.length) {
	    case 0: return func.call(thisArg);
	    case 1: return func.call(thisArg, args[0]);
	    case 2: return func.call(thisArg, args[0], args[1]);
	    case 3: return func.call(thisArg, args[0], args[1], args[2]);
	  }
	  return func.apply(thisArg, args);
	}

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMax$4 = Math.max;

	/**
	 * A specialized version of `baseRest` which transforms the rest array.
	 *
	 * @private
	 * @param {Function} func The function to apply a rest parameter to.
	 * @param {number} [start=func.length-1] The start position of the rest parameter.
	 * @param {Function} transform The rest array transform.
	 * @returns {Function} Returns the new function.
	 */
	function overRest(func, start, transform) {
	  start = nativeMax$4(start === undefined ? (func.length - 1) : start, 0);
	  return function() {
	    var args = arguments,
	        index = -1,
	        length = nativeMax$4(args.length - start, 0),
	        array = Array(length);

	    while (++index < length) {
	      array[index] = args[start + index];
	    }
	    index = -1;
	    var otherArgs = Array(start + 1);
	    while (++index < start) {
	      otherArgs[index] = args[index];
	    }
	    otherArgs[start] = transform(array);
	    return apply(func, this, otherArgs);
	  };
	}

	/**
	 * Creates a function that returns `value`.
	 *
	 * @static
	 * @memberOf _
	 * @since 2.4.0
	 * @category Util
	 * @param {*} value The value to return from the new function.
	 * @returns {Function} Returns the new constant function.
	 * @example
	 *
	 * var objects = _.times(2, _.constant({ 'a': 1 }));
	 *
	 * console.log(objects);
	 * // => [{ 'a': 1 }, { 'a': 1 }]
	 *
	 * console.log(objects[0] === objects[1]);
	 * // => true
	 */
	function constant$4(value) {
	  return function() {
	    return value;
	  };
	}

	/**
	 * The base implementation of `setToString` without support for hot loop shorting.
	 *
	 * @private
	 * @param {Function} func The function to modify.
	 * @param {Function} string The `toString` result.
	 * @returns {Function} Returns `func`.
	 */
	var baseSetToString = !defineProperty$4 ? identity$6 : function(func, string) {
	  return defineProperty$4(func, 'toString', {
	    'configurable': true,
	    'enumerable': false,
	    'value': constant$4(string),
	    'writable': true
	  });
	};

	var baseSetToString$1 = baseSetToString;

	/** Used to detect hot functions by number of calls within a span of milliseconds. */
	var HOT_COUNT = 800,
	    HOT_SPAN = 16;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeNow = Date.now;

	/**
	 * Creates a function that'll short out and invoke `identity` instead
	 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
	 * milliseconds.
	 *
	 * @private
	 * @param {Function} func The function to restrict.
	 * @returns {Function} Returns the new shortable function.
	 */
	function shortOut(func) {
	  var count = 0,
	      lastCalled = 0;

	  return function() {
	    var stamp = nativeNow(),
	        remaining = HOT_SPAN - (stamp - lastCalled);

	    lastCalled = stamp;
	    if (remaining > 0) {
	      if (++count >= HOT_COUNT) {
	        return arguments[0];
	      }
	    } else {
	      count = 0;
	    }
	    return func.apply(undefined, arguments);
	  };
	}

	/**
	 * Sets the `toString` method of `func` to return `string`.
	 *
	 * @private
	 * @param {Function} func The function to modify.
	 * @param {Function} string The `toString` result.
	 * @returns {Function} Returns `func`.
	 */
	var setToString = shortOut(baseSetToString$1);

	var setToString$1 = setToString;

	/**
	 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
	 *
	 * @private
	 * @param {Function} func The function to apply a rest parameter to.
	 * @param {number} [start=func.length-1] The start position of the rest parameter.
	 * @returns {Function} Returns the new function.
	 */
	function baseRest(func, start) {
	  return setToString$1(overRest(func, start, identity$6), func + '');
	}

	/**
	 * Checks if the given arguments are from an iteratee call.
	 *
	 * @private
	 * @param {*} value The potential iteratee value argument.
	 * @param {*} index The potential iteratee index or key argument.
	 * @param {*} object The potential iteratee object argument.
	 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
	 *  else `false`.
	 */
	function isIterateeCall(value, index, object) {
	  if (!isObject$2(object)) {
	    return false;
	  }
	  var type = typeof index;
	  if (type == 'number'
	        ? (isArrayLike(object) && isIndex(index, object.length))
	        : (type == 'string' && index in object)
	      ) {
	    return eq$1(object[index], value);
	  }
	  return false;
	}

	/**
	 * Creates a function like `_.assign`.
	 *
	 * @private
	 * @param {Function} assigner The function to assign values.
	 * @returns {Function} Returns the new assigner function.
	 */
	function createAssigner(assigner) {
	  return baseRest(function(object, sources) {
	    var index = -1,
	        length = sources.length,
	        customizer = length > 1 ? sources[length - 1] : undefined,
	        guard = length > 2 ? sources[2] : undefined;

	    customizer = (assigner.length > 3 && typeof customizer == 'function')
	      ? (length--, customizer)
	      : undefined;

	    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
	      customizer = length < 3 ? undefined : customizer;
	      length = 1;
	    }
	    object = Object(object);
	    while (++index < length) {
	      var source = sources[index];
	      if (source) {
	        assigner(object, source, index, customizer);
	      }
	    }
	    return object;
	  });
	}

	/**
	 * This method is like `_.assign` except that it recursively merges own and
	 * inherited enumerable string keyed properties of source objects into the
	 * destination object. Source properties that resolve to `undefined` are
	 * skipped if a destination value exists. Array and plain object properties
	 * are merged recursively. Other objects and value types are overridden by
	 * assignment. Source objects are applied from left to right. Subsequent
	 * sources overwrite property assignments of previous sources.
	 *
	 * **Note:** This method mutates `object`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.5.0
	 * @category Object
	 * @param {Object} object The destination object.
	 * @param {...Object} [sources] The source objects.
	 * @returns {Object} Returns `object`.
	 * @example
	 *
	 * var object = {
	 *   'a': [{ 'b': 2 }, { 'd': 4 }]
	 * };
	 *
	 * var other = {
	 *   'a': [{ 'c': 3 }, { 'e': 5 }]
	 * };
	 *
	 * _.merge(object, other);
	 * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
	 */
	var merge = createAssigner(function(object, source, srcIndex) {
	  baseMerge(object, source, srcIndex);
	});

	var _merge = merge;

	// a theme, to allow for terminal-specific behavior

	var DARK_THEMES = ['terminal', 'coth', 'opinion-dark', 'green-dark', 'bizweek-dark', 'citylab-dark', 'business-dark', 'bnef-dark', 'daybreak', 'bi'];
	var themeDefaults = {
	  gadfly: {
	    renderAreaChart: true
	  },
	  bizweek: {
	    linearAxis: {
	      tickLabelAlternate: false
	    }
	  },
	  coth: {
	    columnWidthBreakpointMin: 20,
	    columnWidthLongTextBreakpoint: 50,
	    screenshotMinHeight: 340,
	    ratioHeightOffset: true
	  },
	  bi: {
	    screenshotMinHeight: 385,
	    layoutManager: {
	      aspectDrivenHeight: true // fixedHeightSizing: true,
	      // fixedHeight: 385 // 781 x 385 images are expected

	    }
	  },
	  green: {
	    mobileBreakpoint: 480,
	    linearAxis: {
	      tickStepVertical: 180
	    },
	    layoutManager: {
	      aspectRatio: '4:3',
	      maxAspectHeight: 465 // 4:3 at 620

	    }
	  },
	  'green-dark': {
	    mobileBreakpoint: 480,
	    linearAxis: {
	      tickStepVertical: 180
	    },
	    layoutManager: {
	      aspectRatio: '4:3',
	      maxAspectRatioForTerminal: 2.25 // 9:4

	    }
	  },
	  citylab: {
	    mobileBreakpoint: 480,
	    linearAxis: {
	      tickStepVertical: 180
	    },
	    layoutManager: {
	      aspectRatio: '4:3',
	      maxAspectHeight: 465 // 4:3 at 620

	    }
	  },
	  'citylab-dark': {
	    mobileBreakpoint: 480,
	    linearAxis: {
	      tickStepVertical: 180
	    },
	    layoutManager: {
	      aspectRatio: '4:3',
	      maxAspectRatioForTerminal: 2.25 // 9:4

	    }
	  } // 'terminal': {
	  //   bandAxis: {
	  //     axisTextLineHeightHorizontal: 15
	  //   }
	  // },
	  // 'coth': {
	  //   bandAxis: {
	  //     axisTextLineHeightHorizontal: 15
	  //   }
	  // }

	};
	var LIGHT_TO_DARK = {
	  business: 'terminal',
	  opinion: 'opinion-dark',
	  view: 'terminal',
	  bizweek: 'bizweek-dark',
	  green: 'green-dark',
	  citylab: 'citylab-dark',
	  bnef: 'bnef-dark'
	};
	// there are three ways this happens
	// 1) a theme or webTheme option overrides data.theme
	// 2) toaster-data transforms data.theme but sets data.originalTheme
	// 3) toaster rails sets data.config.original_theme

	function isOriginalTheme(data, options) {
	  if (options.theme && options.theme !== data.theme) return false;
	  if (data.originalTheme && data.theme !== data.originalTheme) return false;

	  if (data.config.original_theme && data.theme !== data.config.original_theme) {
	    return false;
	  }

	  return true;
	}
	function getDarkTheme(theme) {
	  return LIGHT_TO_DARK[theme] || theme;
	}
	function themeOptions(data, theme, options) {
	  options = options || {};
	  var defaults = themeDefaults[theme] || {}; // to avoid having COTH's ratioHeightOffset mess up
	  // other themes via webTheme= we need to read the original theme
	  // and apply it based off that

	  if (data.originalTheme === 'coth' || data.config && data.config.original_theme === 'coth') {
	    defaults.ratioHeightOffset = true;
	  }

	  options.isDarkTheme = DARK_THEMES.includes(theme);
	  return _merge(options, defaults);
	}
	function isDarkTheme() {
	  var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	  var theme = options.theme || data.theme;
	  return DARK_THEMES.includes(theme);
	}

	var defaultModifier = function defaultModifier(selection) {
	  return null;
	};

	var themeModifiers = {
	  gadfly: function gadfly(el, chartData) {
	    // using +3 to match rails implementation color
	    var colorSetId = (parseInt('0x' + chartData.id) + 3) % 5;
	    classed(el, 'color-set-0', false);
	    classed(el, 'color-set-1', false);
	    classed(el, 'color-set-2', false);
	    classed(el, 'color-set-3', false);
	    classed(el, 'color-set-4', false);
	    classed(el, "color-set-".concat(colorSetId), true);
	  }
	};
	function themeModifier(theme, options) {
	  if (themeModifiers[theme]) {
	    return themeModifiers[theme];
	  }

	  return defaultModifier;
	}

	var INVERTED_SERIES_TYPES = ['pie', 'comparison']; // series colors are the color options that can be chosen on a per-chart
	// basis - we fetch the colors and merge them into the options as custom
	// colors so they are applied the same way as a custom color option

	function createColorScheme(el, data, options) {
	  var colors = seriesColors(data.theme);
	  var isHighlighted = data.config.highlight_values;
	  var isHighlightedPie = isHighlighted && data.chartType === 'pie';
	  var seriesIndex = options.colorSeriesKey || seriesKey(data, isHighlighted);
	  var styleSet = false;
	  var activeColors = null;
	  var colorSets = null;
	  var styleIndex = 0;
	  if (data.config.series_color_style) styleIndex = Number(data.config.series_color_style);
	  if (options.colorSeries != null) styleIndex = Number(options.colorSeries);

	  if (!options.colorVariableSet && colors && data.data[0] && !isHighlightedPie) {
	    if (colors[data.chartType]) {
	      styleSet = true;
	      colorSets = colors[data.chartType];
	      activeColors = colorSets[seriesIndex] || colorSets.all;

	      if (activeColors) {
	        applySeriesColors(options, activeColors[styleIndex], 0, isHighlighted);
	      }
	    }
	  }

	  var colorVariant = getOption('variant_color', data, options);

	  if (colorVariant) {
	    applyColorVariant(options, data, colorVariant);
	  } // the editor will check for these and propogate up to define
	  // the selection options


	  options.seriesColorStyleSet = styleSet;
	  options.seriesColorStyles = activeColors;

	  if (options.editorHooks && options.editorHooks.colorSeries) {
	    options.editorHooks.colorSeries(activeColors, styleIndex);
	  }

	  if (activeColors) return activeColors[styleIndex];
	  return null;
	} // series length is determined by type and if it is a pie chart
	// pie charts or similar have series as rows rather than columns

	function seriesKey(chartData, isHighlighted) {
	  if (!(chartData && chartData.data && chartData.data[0])) return 0;
	  var length = isHighlighted ? chartData.data[0].length : chartData.data[0].length - 1;

	  if (INVERTED_SERIES_TYPES.includes(chartData.chartType)) {
	    length = chartData.data.length;
	  }

	  return length > 6 ? 'all' : length;
	} // mutable function to apply series colors as custom colors to options object

	function applySeriesColors(options, colors) {
	  var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
	  var isHighlighted = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
	  if (!colors) return;
	  var seriesColors = {};

	  var setC = function setC(key, value) {
	    if (!seriesColors[key]) {
	      seriesColors[key] = value;
	    }
	  };

	  colors.forEach(function (c, i) {
	    if (typeof c === 'string') {
	      setC("color".concat(i + offset), c);
	    } else {
	      setC("color".concat(i + offset), c.color);
	      setC("stroke".concat(i + offset), c.stroke);
	    }

	    if (isHighlighted && i + offset === 1) {
	      setC('colorh', seriesColors.color1);

	      if (c.stroke) {
	        setC('strokeh', c.stroke);
	      }
	    }
	  }); // store seriesColors on options

	  options.seriesColors = seriesColors;
	} // mutable function to apply series colors as custom colors to options object


	function applyColorVariant(options, chartData, colorVariant) {
	  var lightDark = isDarkTheme(chartData, options) ? 'dark' : 'light';
	  var colorConfig = VARIATIONS[lightDark][colorVariant];
	  if (!colorConfig) return;
	  var seriesColors = {
	    fromColorVariantSelection: true
	  };

	  var setC = function setC(key, value) {
	    if (!seriesColors[key]) {
	      seriesColors[key] = value;
	    }
	  };

	  colorConfig.colors.forEach(function (c, i) {
	    setC("color".concat(i), c);
	  });
	  setC('colorh', colorConfig.highlightColor); // store seriesColors on options

	  options.seriesColors = seriesColors;
	}

	// A place to put any features that change based on the date created
	// to provide backwards-compatable support. For example custom colors
	// will apply to all themes from date X
	var DATE_CUSTOM_COLOR_ALL_THEMES = '2023-05-18';
	function applyCustomColorsToAllThemes(chartData) {
	  if (!chartData.createdAt) return true;
	  return new Date(chartData.createdAt) >= new Date(DATE_CUSTOM_COLOR_ALL_THEMES);
	}

	var COLOR_KEYS$1 = ['color0', 'color1', 'color2', 'color3', 'color4', 'color5', 'color6', 'color7', 'color8', 'color9', 'colorDark0', 'colorDark1', 'colorDark2', 'colorDark3', 'colorDark4', 'colorDark5', 'colorDark6', 'colorDark7', 'colorDark8', 'colorDark9', 'colorLight0', 'colorLight1', 'colorLight2', 'colorLight3', 'colorLight4', 'colorLight5', 'colorLight6', 'colorLight7', 'colorLight8', 'colorLight9', 'colorbg', 'colorfg', 'colorh', 'stroke0', 'stroke1', 'stroke2', 'stroke3', 'stroke4', 'stroke5', 'stroke6', 'stroke7', 'stroke8', 'stroke9', 'strokeh'];
	/**
	 * A check to define if custom colors have been defined separately
	 * from the seriesColor option
	 * @param {*} options
	 */

	function customColorsOrSeriesColorsDefined(options) {
	  if (options.seriesColors) return true;
	  return customColorsDefined(options);
	}
	/**
	 * A check to define if custom colors have been defined separately
	 * from the seriesColor option
	 * @param {*} options
	 */

	function customColorsDefined(options) {
	  var colorOpts = COLOR_KEYS$1.filter(function (key) {
	    return options[key] != null;
	  });
	  return colorOpts.length > 0;
	} // generic method for allowing custom colors to override
	// colors from a gradient or series
	// assumed input matches the number of colors to apply
	// color and/or stroke
	// note that the values can be strings like '#000', or objects
	// with { color: '#000', stroke: '#fff' }

	function applyCustomColorsToArray(chartData, inputColors) {
	  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

	  // OLD LOGIC only applies to light theme -- uses a dateCreatedSwitch to
	  // determine wheter to use old or new logic
	  // ONLY apply if we are the original theme, not terminal
	  // THIS case should only apply to actual custom colors otherwise it will override
	  // the series colors
	  if (!applyCustomColorsToAllThemes(chartData) && !isOriginalTheme(chartData, options) && customColorsDefined(options) && options.applyColorsOnAllThemes !== true) {
	    return inputColors;
	  }

	  var darkOrLight = isDarkTheme(chartData, options) ? 'Dark' : 'Light';
	  return inputColors.map(function (val, i) {
	    var themedColorKey = "color".concat(darkOrLight).concat(i);
	    var colorVal = options[themedColorKey] == null ? options["color".concat(i)] : options[themedColorKey];
	    var strokeVal = options["stroke".concat(i)];

	    if (typeof val === 'string') {
	      if (strokeVal != null) {
	        // convert back to obj
	        return {
	          color: colorVal != null ? colorVal : val,
	          stroke: strokeVal
	        };
	      }

	      return colorVal != null ? colorVal : val;
	    } else if (_typeof(val) === 'object') {
	      return {
	        color: colorVal != null ? colorVal : val.color,
	        stroke: strokeVal != null ? strokeVal : val.stroke
	      };
	    }

	    return val;
	  });
	} // take a list like ['#000', { color: 'red', stroke: 'black'}]
	// and return only the color values as strings

	function onlyFillColors(colorValues) {
	  return colorValues.map(function (v) {
	    if (_typeof(v) === 'object') return v.color;
	    return v;
	  });
	} // take a list like ['#000', { color: 'red', stroke: 'black'}]
	// and return only the stroke value or undefined

	function onlyStrokeColors(colorValues) {
	  return colorValues.map(function (v) {
	    if (_typeof(v) === 'object') return v.stroke;
	    return undefined;
	  });
	}
	/**
	  Allow query parameters to customize the color of a chart via:
	  ?color0=#fff&color1=#f0n23&colorbg=#888&colorfg=#aaa
	*/

	function applyCustomColors(el, data, options) {
	  var colorOptions = _objectSpread2(_objectSpread2({}, options.seriesColors), options); // OLD LOGIC only applies to light theme -- uses a dateCreatedSwitch to
	  // determine wheter to use old or new logic
	  // allow a method to disable colors for terminal/other themes
	  // ie you set a custom color as black on business theme and only
	  // want it to appear on that theme


	  if (!applyCustomColorsToAllThemes(data) && !isOriginalTheme(data, options) && customColorsDefined(options) && colorOptions.fromColorVariantSelection !== true && options.applyColorsOnAllThemes !== true) {
	    return false;
	  }

	  var darkOrLight = isDarkTheme(data, options) ? 'Dark' : 'Light';
	  COLOR_KEYS$1.forEach(function (key) {
	    if (colorOptions[key]) {
	      var color = colorOptions[key];
	      var nonFillColor = domBackground(key) || color; // for gradient/patterns

	      var theme = colorOptions.theme || data.theme;

	      if (color.substring(0, 5) === 'url(#') {
	        ensureDefsInSVG(el, color);
	      }

	      if (key === 'colorbg') {
	        style(select$1('body.toaster-iframe, body.framed-viewer'), 'background', color);
	        style(el, 'background', color);
	        style(el.querySelectorAll(".toaster-theme-".concat(theme)), 'background', color);
	        style(el.querySelectorAll('.pie-container.highlighted path'), 'stroke', color);
	        style(el.querySelectorAll('.tooltip-label-box, .toaster-iframe, .logo'), 'background-color', color);
	        style(el.querySelectorAll('.tooltip-valueline'), 'color', color);
	        style(el.querySelectorAll('.tooltip-anchor, .axis-label-box > rect'), 'fill', color);
	        style(el.querySelectorAll('.annotations text'), 'text-shadow', "-1px -1px 0px ".concat(color, ", \n          -1px 1px 0px ").concat(color, ", \n          1px -1px 0px ").concat(color, ",\n          1px 1px 0px ").concat(color, ",\n          -2px -2px 0px ").concat(color, ",\n          -2px 2px 0px ").concat(color, ",\n          2px -2px 0px ").concat(color, ",\n          2px 2px 0px ").concat(color));
	      } else if (key === 'colorfg') {
	        style(el.querySelectorAll('h1, h2, a, th, .source, .logo, label, .tooltip-value, .title, .footnote, .label-bottom, .annotations-footer'), 'color', color);
	        style(el.querySelectorAll('.tooltip-gridline, .tooltip-anchor, .grid line, rect.column'), 'stroke', color);
	        style(el.querySelectorAll('text, text.column-label'), 'fill', color);
	        style(el.querySelectorAll('.axis path.domain, .axis .tick > line, .zero-line, .label line, .annotations line'), 'stroke', color);
	        var labelBoxEls = el.querySelectorAll('.tooltip-label-box');
	        style(labelBoxEls, 'border-color', color);
	        style(labelBoxEls, 'color', color);
	        style(el.querySelectorAll('.swatch'), 'border-color', color);
	      } else if (key === 'colorh') {
	        style(el.querySelectorAll('.highlight, .f.highlight'), 'fill', color);
	        style(el.querySelectorAll('.highlight-legend'), 'background-color', color);
	      } else if (key === 'strokeh') {
	        style(el.querySelectorAll('.highlight, .f.highlight'), 'stroke', color);
	        style(el.querySelectorAll('.highlight-legend'), 'border-color', color);
	      } else if (key.indexOf('stroke') !== -1) {
	        var i = Number(key.replace('stroke', ''));
	        var bgEls = el.querySelectorAll(".bg.series-".concat(i));
	        style(bgEls, 'border-style', 'solid');
	        style(bgEls, 'border-width', '1px');
	        style(bgEls, 'border-color', color);
	        style(el.querySelectorAll(".f.series-".concat(i, ", .bg.series-").concat(i, ", .s.series-").concat(i, ", .series-").concat(i, "-stroke")), 'stroke', color);
	      } else {
	        var _i = Number(key.slice(-1)); // skip the color application if a more specific key exists.. ie if we are
	        // on a dark theme an color0 and colorDark0 exists, use colorDark0


	        if (key === "color".concat(_i) && colorOptions["color".concat(darkOrLight).concat(_i)]) return;
	        if (key === "colorLight".concat(_i) && darkOrLight === 'Dark') return;
	        if (key === "colorDark".concat(_i) && darkOrLight === 'Light') return;
	        style(el.querySelectorAll(".bg.series-".concat(_i)), 'background', nonFillColor);
	        style(el.querySelectorAll(".c.series-".concat(_i)), 'color', color);
	        style(el.querySelectorAll(".s.series-".concat(_i, ", .series-").concat(_i, "-stroke")), 'stroke', color);
	        style(el.querySelectorAll(".f.series-".concat(_i, ", .line-area.series-").concat(_i)), 'fill', color);
	      }
	    }
	  });
	}

	function ensureDefsInSVG(el, key) {
	  if (defs(key)) {
	    var id = key.replace('url(', '').replace(')', '');
	    if (el.querySelector(id)) return;

	    var _defs = selectAppend$1(el.querySelector('svg'), 'defs', 'style-defs');

	    _defs.innerHTML = _defs(key);
	  }
	}

	// and then applying it to the dom via css

	function setupColors(el, data) {
	  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
	  createColorScheme(el, data, options);
	  applyColors(el, data, options);
	} // instead of exporting applyCustomColors directly
	// we provide this wrapper method to only apply
	// when colorVariant is not set and custom color options
	// are not provided by the user

	function applyColors(el, data) {
	  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

	  if (customColorsOrSeriesColorsDefined(options)) {
	    applyCustomColors(el, data, options);
	  }
	}

	var ARRAY_ITERATOR = 'Array Iterator';
	var setInternalState$2 = internalState.set;
	var getInternalState$1 = internalState.getterFor(ARRAY_ITERATOR);

	// `Array.prototype.entries` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.entries
	// `Array.prototype.keys` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.keys
	// `Array.prototype.values` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.values
	// `Array.prototype[@@iterator]` method
	// https://tc39.github.io/ecma262/#sec-array.prototype-@@iterator
	// `CreateArrayIterator` internal method
	// https://tc39.github.io/ecma262/#sec-createarrayiterator
	var es_array_iterator = defineIterator(Array, 'Array', function (iterated, kind) {
	  setInternalState$2(this, {
	    type: ARRAY_ITERATOR,
	    target: toIndexedObject(iterated), // target
	    index: 0,                          // next index
	    kind: kind                         // kind
	  });
	// `%ArrayIteratorPrototype%.next` method
	// https://tc39.github.io/ecma262/#sec-%arrayiteratorprototype%.next
	}, function () {
	  var state = getInternalState$1(this);
	  var target = state.target;
	  var kind = state.kind;
	  var index = state.index++;
	  if (!target || index >= target.length) {
	    state.target = undefined;
	    return { value: undefined, done: true };
	  }
	  if (kind == 'keys') return { value: index, done: false };
	  if (kind == 'values') return { value: target[index], done: false };
	  return { value: [index, target[index]], done: false };
	}, 'values');

	// argumentsList[@@iterator] is %ArrayProto_values%
	// https://tc39.github.io/ecma262/#sec-createunmappedargumentsobject
	// https://tc39.github.io/ecma262/#sec-createmappedargumentsobject
	iterators.Arguments = iterators.Array;

	// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
	addToUnscopables('keys');
	addToUnscopables('values');
	addToUnscopables('entries');

	var propertyIsEnumerable = objectPropertyIsEnumerable.f;

	// `Object.{ entries, values }` methods implementation
	var createMethod = function (TO_ENTRIES) {
	  return function (it) {
	    var O = toIndexedObject(it);
	    var keys = objectKeys(O);
	    var length = keys.length;
	    var i = 0;
	    var result = [];
	    var key;
	    while (length > i) {
	      key = keys[i++];
	      if (!descriptors || propertyIsEnumerable.call(O, key)) {
	        result.push(TO_ENTRIES ? [key, O[key]] : O[key]);
	      }
	    }
	    return result;
	  };
	};

	var objectToArray = {
	  // `Object.entries` method
	  // https://tc39.github.io/ecma262/#sec-object.entries
	  entries: createMethod(true),
	  // `Object.values` method
	  // https://tc39.github.io/ecma262/#sec-object.values
	  values: createMethod(false)
	};

	var $entries = objectToArray.entries;

	// `Object.entries` method
	// https://tc39.github.io/ecma262/#sec-object.entries
	_export({ target: 'Object', stat: true }, {
	  entries: function entries(O) {
	    return $entries(O);
	  }
	});

	// `Object.fromEntries` method
	// https://github.com/tc39/proposal-object-from-entries
	_export({ target: 'Object', stat: true }, {
	  fromEntries: function fromEntries(iterable) {
	    var obj = {};
	    iterate(iterable, function (k, v) {
	      createProperty(obj, k, v);
	    }, { AS_ENTRIES: true });
	    return obj;
	  }
	});

	// that will take in a flat property name like aspectRatio
	// and apply it to the proper location on chartData whether
	// it's the config object, chartOptions, or primaryAxis
	// specify flat property keys to nested path locations
	// everything else should be considered as part of the open
	// 'chartData.config' object

	var propertyPaths = {
	  precision: ['chartOptions.decimalPlaces', 'secondaryAxis.decimal_places'],
	  tooltipPrecision: ['chartOptions.tooltipDecimals', 'secondaryAxis.tooltip_decimals'],
	  prefix: ['fields.:valField.unit_before', '!secondaryAxis.unit_before'],
	  postfix: ['fields.:valField.unit_after', '!secondaryAxis.unit_after'],
	  prefixSecondary: ['secondaryAxis.unit_before'],
	  postfixSecondary: ['secondaryAxis.unit_after'],
	  // removing labelPrimary because it creates an x axis label that
	  // cannot be deleted
	  // labelPrimary: ['primaryAxis.label', 'primaryAxis.caption'],
	  // labelSecondary: ['secondaryAxis.label'],
	  prefixPrimary: ['primaryAxis.unit_before'],
	  postfixPrimary: ['primaryAxis.unit_after'],
	  isPercent: ['fields.:valField.display_as', 'secondaryAxis.display_as'],
	  title: ['title'],
	  subtitle: ['subtitle'],
	  source: ['source'],
	  footnote: ['footnote'],
	  annotations: ['annotations'],
	  chartType: ['chartType', 'type'],
	  bubblePrecision: ['config.bubbleLegend.precision'],
	  bubblePrefix: ['config.bubbleLegend.prefix'],
	  bubblePostfix: ['config.bubbleLegend.postfix'],
	  bubbleLegendText: ['config.bubbleLegend.text'],
	  numberFormat: ['secondaryAxis.display_as'],
	  dateFormat: ['chartOptions.dateOutputFormat'],
	  scaleStart: ['chartOptions.scaleStart'],
	  scaleEnd: ['chartOptions.scaleEnd'],
	  scaleStep: ['chartOptions.scaleStep'],
	  automaticLabelDensity: ['primaryAxis.auto_density'],
	  labelDensity: ['primaryAxis.label_density'],
	  aspectRatio: ['chartOptions.aspectRatio'],
	  userAnnotations: ['config.annotations']
	}; // DH: there is a big problem with some of these transforms
	// in that these only get applied via the form changes but
	// the rails server doesn't save the transformed property
	// so a fix is to start storing the values on config
	// and apply these transforms in the factory at load time
	// I have pulled this into utils/data/accessors
	// but also these below are the properties that need
	// to also be saved to config

	var ALSO_SAVE_TO_CONFIG = ['dateFormat', 'prefixPrimary', 'postfixPrimary', 'prefixSecondary', 'postfixSecondary', 'labelDensity', 'automaticLabelDensity', 'userAnnotations']; // if any property doesn't save in it's transformed destination
	// we use this to perform the config -> transform on every chart load

	var configTransformPaths = Object.fromEntries(ALSO_SAVE_TO_CONFIG.map(function (key) {
	  return [key, propertyPaths[key]];
	})); // Duplicate of the Forms schema customTransforms

	var customTransforms = {
	  seriesLabels: function seriesLabels(labels, chartData) {
	    if (labels) {
	      labels.forEach(function (label, index) {
	        if (chartData.fields[index + 1]) {
	          chartData.fields[index + 1].name = label;
	        }
	      });
	    }
	  },
	  // apply tableFields to pluck out header and apply
	  // to each field
	  tableFields: function tableFields(fields, chartData) {
	    if (fields && chartData.chartType === 'table') {
	      fields.forEach(function (_ref, index) {
	        var header = _ref.header;

	        if (chartData.fields[index]) {
	          chartData.fields[index].name = header;
	        }
	      });
	    }
	  }
	}; // split a tranform into a series of tokens and then walk
	// the chartData path to return the parent object containing the property
	// from there we can read or set the property directly on the object
	// forceCreate will ensure the root object exists

	function getPropertyRoot(chartData, transform, forceCreate) {
	  var configKey;
	  var obj = chartData;
	  var nodes = transform.split('.');
	  var chartConfig = chartData.config || {};

	  for (var key = nodes.shift(); nodes.length && obj; key = nodes.shift()) {
	    if (key.startsWith(':')) {
	      configKey = key.substring(1);

	      if (chartConfig[configKey]) {
	        obj = obj[chartConfig[configKey]];
	      } else {
	        if (forceCreate) {
	          obj[chartConfig[configKey]] = {};
	          return obj[chartConfig[configKey]];
	        } else {
	          return null;
	        }
	      }
	    } else if (key.startsWith('!')) {
	      configKey = key.substring(1);

	      if (!obj[configKey]) {
	        obj[configKey] = {};
	      }

	      obj = obj[configKey];
	    } else if (obj[key]) {
	      obj = obj[key];
	    } else {
	      if (forceCreate) {
	        obj[key] = {};
	        return obj[key];
	      } else {
	        return null;
	      }
	    }
	  }

	  return obj;
	} // given a transform string, get the last property in the split('.') chain and
	// return only the key value.. ie given 'primaryAxis.auto_density' return
	// 'auto_density'


	function getPropertyKey(chartData, transform) {
	  var tokens = transform.split('.');
	  return tokens[tokens.length - 1];
	} // first check if value exists in config, otherwise use
	function setPropertyMutable() {
	  var chartData = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	  var property = arguments.length > 1 ? arguments[1] : undefined;
	  var value = arguments.length > 2 ? arguments[2] : undefined;
	  var transforms = propertyPaths[property]; // if a transform exists then set to that location, otherwise set
	  // on the chartData.config directly

	  if (transforms && transforms.length) {
	    transforms.forEach(function (transform) {
	      var propertyRoot = getPropertyRoot(chartData, transform, true);
	      var propertyKey = getPropertyKey(chartData, transform);

	      if (propertyRoot) {
	        propertyRoot[propertyKey] = value;
	      }
	    });
	  } else {
	    if (!chartData.config) {
	      chartData.config = {};
	    }

	    chartData.config[property] = value;
	  }

	  return chartData;
	}
	// allow field properties to be overridden in the config

	function fieldTransforms(chartData) {
	  var _chartData$config = chartData.config,
	      config = _chartData$config === void 0 ? {} : _chartData$config;

	  if (config.fieldPropertyOverrides) {
	    chartData.fields = _toConsumableArray(chartData.fields);

	    for (var _i = 0, _Object$entries = Object.entries(config.fieldPropertyOverrides); _i < _Object$entries.length; _i++) {
	      var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
	          index = _Object$entries$_i[0],
	          props = _Object$entries$_i[1];

	      if (chartData.fields[index]) {
	        chartData.fields[index] = _objectSpread2(_objectSpread2({}, chartData.fields[index]), props);
	      }
	    }
	  }

	  return chartData;
	} // in the factory perform all of the configTransforms if there
	// is a defined value in the chartData.config
	// this is a MUTABLE function

	function configTransforms(chartData) {
	  var transformedData = chartData;
	  var _transformedData = transformedData,
	      _transformedData$conf = _transformedData.config,
	      config = _transformedData$conf === void 0 ? {} : _transformedData$conf;
	  Object.keys(configTransformPaths).forEach(function (key) {
	    if (config[key] != null) {
	      setPropertyMutable(transformedData, key, config[key]);
	    }

	    if (customTransforms[key]) {
	      customTransforms[key](config[key], chartData);
	    }
	  }); // loop through config keys to apply customTransforms

	  Object.keys(config).forEach(function (key) {
	    if (customTransforms[key]) {
	      customTransforms[key](config[key], chartData);
	    }
	  });
	  transformedData = fieldTransforms(transformedData);
	  return transformedData;
	} // same as above but running through all properties instead of just
	// those defined in configTransforms

	function configTransformsAll(chartData) {
	  var _chartData$config2 = chartData.config,
	      config = _chartData$config2 === void 0 ? {} : _chartData$config2;
	  Object.keys(propertyPaths).forEach(function (key) {
	    if (config[key] != null) {
	      setPropertyMutable(chartData, key, config[key]);
	    }
	  }); // loop through config keys to apply customTransforms

	  Object.keys(config).forEach(function (key) {
	    if (customTransforms[key]) {
	      customTransforms[key](config[key], chartData);
	    }
	  });
	  return chartData;
	} // simple utility to have a default when not defined

	function getConfigValue(chartData, prop1, prop2, prop3) {
	  if (!chartData.config) return;
	  var value = chartData.config[prop1];

	  if (value == null) {
	    value = chartData.config[prop2];
	  }

	  if (value == null) {
	    value = chartData.config[prop3];
	  }

	  return value;
	}

	var _FIELD_LABELS, _DISPLAY_AS_MULTIPLIE;

	// a place for constants that have no dependencies defined
	// we need to make sure we can have imports that don't bring
	// in all of d3, so this is part of that effort
	var CHANGE_REGEX = /^\s*\+\d*\.?\d+\s*$/;
	var NUMBER_REGEX = /^\s*[+-]?\d*\.?\d+([eE][-+]?\d+)?\s*$/;
	// used to determine if numeric values falling within this
	// range can be treated as year values

	var NUMERIC_YEAR_MIN = 1800;
	var NUMERIC_YEAR_MAX = 2200;
	var FIELD_TYPE_STRING = 'string';
	var FIELD_TYPE_NUMERIC = 'numeric';
	var FIELD_TYPE_PERCENT = 'percent';
	var FIELD_TYPE_YEAR = 'year';
	var FIELD_TYPE_QUARTER = 'quarter';
	var FIELD_TYPE_MONTH = 'month';
	var FIELD_TYPE_CHANGE = 'change';
	var FIELD_TYPE_DATE = 'date';
	var FIELD_TYPE_CATEGORICAL = 'categorical';
	var FIELD_TYPE_JUMBLE = 'jumble';
	(_FIELD_LABELS = {}, _defineProperty(_FIELD_LABELS, FIELD_TYPE_STRING, 'String'), _defineProperty(_FIELD_LABELS, FIELD_TYPE_NUMERIC, 'Number'), _defineProperty(_FIELD_LABELS, FIELD_TYPE_PERCENT, 'Percent'), _defineProperty(_FIELD_LABELS, FIELD_TYPE_YEAR, 'Year'), _defineProperty(_FIELD_LABELS, FIELD_TYPE_MONTH, 'Month'), _defineProperty(_FIELD_LABELS, FIELD_TYPE_QUARTER, 'Quarter'), _defineProperty(_FIELD_LABELS, FIELD_TYPE_DATE, 'Date'), _defineProperty(_FIELD_LABELS, FIELD_TYPE_CATEGORICAL, 'Categorical'), _defineProperty(_FIELD_LABELS, FIELD_TYPE_JUMBLE, 'Unknown'), _FIELD_LABELS); // selectable field types

	var FIELD_TYPES_DEFINED = [FIELD_TYPE_YEAR, FIELD_TYPE_DATE, FIELD_TYPE_CHANGE, FIELD_TYPE_NUMERIC, FIELD_TYPE_PERCENT];

	var DISPLAY_FORMAT_TO_TYPE = {
	  '%': FIELD_TYPE_PERCENT,
	  Y: FIELD_TYPE_STRING,
	  M: FIELD_TYPE_STRING,
	  D: FIELD_TYPE_STRING,
	  K: FIELD_TYPE_NUMERIC,
	  ML: FIELD_TYPE_NUMERIC,
	  B: FIELD_TYPE_NUMERIC,
	  T: FIELD_TYPE_NUMERIC
	};

	var AMBIGUOUS_YEAR_DATE_FORMATS = ['MMM D', // Jun 1
	'MMM DD', // Jun 1
	'MMM YY', // Jun 1
	'MMM. D', // Jun. 1
	'MMM. DD', // Jun. 01
	'MMM. YY', // Jun. 01
	'MMM-D', // Jun-1
	'MMM-DD', // Jun-01
	'MMM-YY', // Jun-01
	'MMMM-D', // June-1
	'MMMM-DD', // June-01
	'MMMM-YY', // June-01
	'MMMM D', // June 1
	'D MMM', // 1 Jun
	'DD MMM', // 1 Jun
	'YY MMM', // 23 Jun
	'D MMM.', // 1 Jun.
	'DD MMM.', // 01 Jun.
	'YY MMM.', // 01 Jun.
	'D-MMM', // 1-Jun
	'DD-MMM', // 16-Jun
	'YY-MMM', // 16-Jun
	'D-MMMM', // 1-June
	'DD-MMMM', // 01-June
	'YY-MMMM', // 01-June
	'D MMMM', // 1 June
	'DD-MMM-YY', // 16-Jun-01
	'DD-MMMM-YY' // 16-June-01
	];
	var AMBIGUOUS_DATE_FORMATS = [].concat(AMBIGUOUS_YEAR_DATE_FORMATS, [// the below values are only ambiguous in that they fail
	// browser date parsing
	'MMM YYYY', // Jun 2019 (fails safari)
	'YYYY MMM', // 2019 Jun (fails safari)
	'MMMM YYYY', // June 2019 (fails safari)
	'YYYY MMMM' // 2019 June (fails safari)
	]); // odd formats that we can parse and use to cast

	var DATE_INPUT_PARSERS = ['YYYY-MM-DD', // 2017-01-91
	'MM-DD-YYYY', // 01-01-2017
	'YYYY/MM/DD', // '2017/01/01',
	'YYYY/M/D', // '2017/1/1',
	'MM/DD/YYYY', // 01/01/2017
	'MM.DD.YYYY', // 01.01.2017
	'M/D/YYYY', // 1/1/2017
	'MM/DD/YY', // 01/01/17
	'M/D/YY', // 1/1/17
	'MMM \'YY', // Jan '13
	'MMM-YY', // Jan-13
	'MMMM \'YY', // January '13
	'MMM âYY', // Jan â13
	'MMMM âYY', // January â13
	'MMM D, \'YY', // Jan 1, '13
	'MMM DD, \'YY', // Jan 01, '13
	'MMM D, YYYY', // Jan 1, 2013
	'MMM DD, YYYY', // Jan 01, 2013
	'MMMM D, \'YY', // January 1, '13
	'MMMM DD, \'YY', // January 01, '13
	'MMMM D, YYYY', // January 1, 2013
	'MMMM DD, YYYY', // January 01, 2013
	'MMM YYYY', // Jun 2017
	'MMM. YYYY', // Jun. 2017
	'MMMM YYYY', // June 2017
	'YYYY MMM', // 2017 Jun
	'YYYY MMM.', // 2017 Jun.
	'YYYY MMMM', // 2017 June
	'DD-MMM-YY', // 16-Jun-01
	'DD-MMMM-YY'].concat(_toConsumableArray(AMBIGUOUS_DATE_FORMATS));
	// differently on the output to avoid rendering '1900'

	var DATE_INPUT_MONTH = ['MMM.', // Jan.
	'MMM', // Jan
	'MMMM' // January
	];
	// data/format.js

	var DURATION_MINUTES = 'minutes'; // minutes

	var DURATION_HOURS = 'hours'; // hours

	var DURATION_DAYS = 'days'; // 1 - 7 days

	var DURATION_WEEKS = 'weeks'; // 2 - 12 weeks

	var DURATION_MONTHS = 'months'; // 1 - 18 months

	var DURATION_QUARTERS = 'quarters'; // specifically quarterly data

	var DURATION_MULTIYEAR = 'years'; // 1 - 3 years

	var DURATION_DECADE = 'decade'; // within the last decade

	var DURATION_MULTIDECADE = 'multidecade'; // ~ 25 years

	var DURATION_CENTURY = 'century'; // 100 yrs +
	// map duration to a d3 time format string

	var DURATION_FORMATTERS = {};
	DURATION_FORMATTERS[DURATION_MINUTES] = 'H:mm:ss';
	DURATION_FORMATTERS[DURATION_HOURS] = 'M/D H:mm';
	DURATION_FORMATTERS[DURATION_DAYS] = 'M/D';
	DURATION_FORMATTERS[DURATION_WEEKS] = 'YYYY/M/D';
	DURATION_FORMATTERS[DURATION_MONTHS] = 'YYYY/M/D';
	DURATION_FORMATTERS[DURATION_MULTIYEAR] = 'YYYY/M/D';
	DURATION_FORMATTERS[DURATION_DECADE] = 'YYYY/M/D';
	DURATION_FORMATTERS[DURATION_MULTIDECADE] = 'YYYY/M/D';
	DURATION_FORMATTERS[DURATION_CENTURY] = 'YYYY/M/D';
	var DURATION_FORMATTER_YEAR = 'YYYY';
	var DURATION_FORMATTER_MD = 'M/D'; // used as a quick reference if the duration includes year

	var DURATION_FORMATTERS_WITH_YEAR = [DURATION_WEEKS, DURATION_MONTHS, DURATION_MULTIYEAR, DURATION_DECADE, DURATION_MULTIDECADE, DURATION_CENTURY]; // these are the "Show Date As values"

	var OUTPUT_FORMAT_YEARS = 'Yearly';
	var OUTPUT_FORMAT_QUARTERS = 'Quarterly';
	var OUTPUT_FORMAT_MONTHS = 'Monthly';
	var OUTPUT_FORMAT_DAYS = 'Daily';
	var OUTPUT_FORMAT_DAYS_OF_WEEK = 'DaysOfWeek';
	var OUTPUT_FORMAT_HOURS = 'Intraday';
	var OUTPUT_FORMAT_CATEGORICAL = 'Categorical';
	var DISPLAY_AS_PERCENT = '%';
	var DISPLAY_AS_THOUSANDS = 'K';
	var DISPLAY_AS_MILLIONS = 'M';
	var DISPLAY_AS_BILLIONS = 'B';
	var DISPLAY_AS_TRILLIONS = 'T';
	var DISPLAY_AS_MULTIPLIERS = (_DISPLAY_AS_MULTIPLIE = {}, _defineProperty(_DISPLAY_AS_MULTIPLIE, DISPLAY_AS_PERCENT, 1e2), _defineProperty(_DISPLAY_AS_MULTIPLIE, DISPLAY_AS_THOUSANDS, 1e3), _defineProperty(_DISPLAY_AS_MULTIPLIE, DISPLAY_AS_MILLIONS, 1e6), _defineProperty(_DISPLAY_AS_MULTIPLIE, DISPLAY_AS_BILLIONS, 1e9), _defineProperty(_DISPLAY_AS_MULTIPLIE, DISPLAY_AS_TRILLIONS, 1e12), _DISPLAY_AS_MULTIPLIE);
	var UNIT_LONG = {
	  1e1: 'Tens',
	  1e2: 'Hundreds',
	  1e3: 'Thousands',
	  1e6: 'Millions',
	  1e9: 'Billions',
	  1e12: 'Trillions'
	};
	var UNIT_SHORT = {
	  1e1: '',
	  1e2: '',
	  1e3: 'K',
	  1e6: 'M',
	  1e9: 'B',
	  1e12: 'T'
	}; // parse.js

	var MS_IN_DAY = 1000 * 60 * 60 * 24;
	var MS_IN_MINUTE = 1000 * 60;
	var REGEX_QUARTERS = {
	  quarter_year: /Q[1234]\s\d{4}/,
	  quarter_year_alt: /[1234]Q\s\d{4}/,
	  year_quarter: /\d{4}\sQ[1234]/,
	  year_quarter_alt: /\d{4}\s[1234]Q/,
	  year_quarter_nospace: /\d{4}Q[1234]/,
	  quarter_year_nospace: /Q[1234]\d{4}/,
	  quarter_year_nospace2: /[1234]Q\d{4}/,
	  quarter_dash_year: /Q[1234]-\d{4}/,
	  year_dash_nospace: /\d{4}-Q[1234]/
	}; // FY 2017 matches new Date() so we use this to
	// exclude these dates

	var REGEX_EXCLUDE = {
	  fy_year: /FY\s\d/
	};

	function guessType(d) {
	  // disabling date-like as our taxonomy is based on strings
	  // if (dateLike.exec(d)) return 'date'
	  if (CHANGE_REGEX.exec(d)) return FIELD_TYPE_CHANGE;
	  if (NUMBER_REGEX.exec(d)) return FIELD_TYPE_NUMERIC;
	  return FIELD_TYPE_STRING;
	}

	function isNull(v) {
	  if (v == null || v === 'na' || v === '' || v === '-') {
	    return true;
	  }

	  return false;
	} // in the makeData operation remove the empty rows


	function nullFilter(v) {
	  return !isNull(v);
	}

	function guessFieldType(field, options) {
	  if (field.forceType) {
	    field.type = field.forceType;
	    return field;
	  } // we'll trust the client assuming it's a valid type


	  if (field.type && FIELD_TYPES_DEFINED.indexOf(field.type) >= 0) {
	    return field;
	  } // Can we figure out the type of the displayFormat


	  if (field.displayFormat && DISPLAY_FORMAT_TO_TYPE[field.displayFormat]) {
	    field.type = DISPLAY_FORMAT_TO_TYPE[field.displayFormat];
	    return field;
	  }

	  var types = {};
	  field.data.filter(nullFilter).forEach(function (d) {
	    var dType = guessType(d);
	    types[dType] = types[dType] || 0;
	    types[dType] += 1;
	  });
	  types = Object.keys(types).sort(function (a, b) {
	    return types[b] - types[a];
	  });

	  if (types.length === 2) {
	    if (types.indexOf(FIELD_TYPE_NUMERIC) !== -1) {
	      if (types.indexOf(FIELD_TYPE_YEAR) !== -1) {
	        field.type = FIELD_TYPE_NUMERIC;
	        return field;
	      } else if (types.indexOf(FIELD_TYPE_CHANGE) !== -1) {
	        field.type = FIELD_TYPE_NUMERIC;
	        field.displayChange = true;
	        return field;
	      }
	    }
	  } // sometimes the type gets marked as jumble even if there is only
	  // a single string/null value


	  field.type = types[0];

	  if (types.length > 1) {
	    field.type = FIELD_TYPE_JUMBLE;
	    field.isJumbled = true;
	    field.mostCommonType = types[0];

	    if (options.useCommonTypeOnJumbleField) {
	      field.type = field.mostCommonType;
	    }
	  }

	  return field;
	}

	function makeData(chartData) {
	  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	  var fieldDataKey = options.fieldDataKey,
	      _options$forceRebuild = options.forceRebuild,
	      forceRebuild = _options$forceRebuild === void 0 ? false : _options$forceRebuild;

	  if (chartData._makeDataExecuted && !forceRebuild) {
	    return true; // prevent multiple execution
	  }

	  if (!chartData.data || !chartData.data.length) {
	    console.warn(chartData.id, 'has no data');
	    return false;
	  }

	  if (!chartData.fields || !chartData.fields.length) {
	    console.warn(chartData.id, 'has no fields');
	    return false;
	  }

	  if (chartData.fields.length < chartData.data[0].length) {
	    console.warn(chartData.id, 'Fields Not properly defined, fill with stubs');

	    for (var n = 0; n <= chartData.data[0].length - chartData.fields.length; n++) {
	      chartData.fields.push({
	        name: ''
	      }); // empty field
	    }
	  } // normalize the fields properties by changing the underscores to camelCase


	  var _iterator = _createForOfIteratorHelper(chartData.fields),
	      _step;

	  try {
	    for (_iterator.s(); !(_step = _iterator.n()).done;) {
	      var field = _step.value;

	      for (var _i = 0, _Object$keys = Object.keys(field); _i < _Object$keys.length; _i++) {
	        var prop = _Object$keys[_i];

	        if (prop.indexOf('_') >= 0) {
	          field[camelCase(prop)] = field[prop]; // delete field[prop];
	        }
	      }
	    }
	  } catch (err) {
	    _iterator.e(err);
	  } finally {
	    _iterator.f();
	  }

	  chartData.fields.forEach(function (field, i) {
	    field.index = i; // keep index

	    if (fieldDataKey) {
	      field.data = chartData.data.map(function (d) {
	        return d[i];
	      });
	    } else {
	      field.data = chartData.data.map(function (d) {
	        return d[fieldDataKey];
	      });
	    }

	    field.data = chartData.data.map(function (d) {
	      return field.dataKey ? d[field.dataKey] : d[i];
	    });
	    guessFieldType(field, options);

	    if (field.type !== FIELD_TYPE_STRING) {
	      // strip out any NaN values
	      var domainData = field.data.filter(function (v) {
	        return !isNaN(Number(v)) && v !== null;
	      });
	      field.min = Math.min.apply(null, domainData);
	      field.max = Math.max.apply(null, domainData);
	    }
	  });
	  chartData._makeDataExecuted = true;
	  return true;
	}

	/**
	  We need to support an interface that just takes in
	  the element and the data (which defines theme/type)

	  In order to do this the we return a factory given a
	  mapping of "type" -> chart constructor, and a theme
	  remapper for translating themes like "v2business" to "business"

	*/

	function factory$1(el, type, inData, inOptions) {
	  var data = _merge({}, inData); // deep clone input data


	  var options = makeOptions(inOptions, data);
	  makeData(data, _objectSpread2(_objectSpread2({}, options), {}, {
	    forceRebuild: true
	  })); // configTransforms copies attributes in the config object
	  // to their respective paths (chartOptions, primaryAxis etc.)

	  configTransforms(data); // create a forceResize handler to pass into client so that it
	  // can call an async resize

	  var onResize = function onResize() {
	    return null;
	  };

	  options.forceResize = function () {
	    return onResize(el, options);
	  };

	  if (!type) {
	    throw new Error('Chart Type not recognized');
	  } // allow type options to define scaffold


	  if (type.makeOptions) {
	    options = type.makeOptions(options);
	  }

	  var themeName = data.theme;
	  var typeName = data.chartType || options.typeClass;

	  if (options.themeMap && hasOwnProperty$h(options.themeMap, data.theme)) {
	    themeName = options.themeMap[data.theme];
	  }

	  options = themeOptions(data, themeName, options);
	  var themeClass = 'toaster-theme-' + themeName;
	  var typeClass = 'toaster-type-' + typeName; // remove the existing themes

	  el.classList.forEach(function (className) {
	    if (className.startsWith('toaster-theme')) el.classList.remove(className);
	  });
	  el.classList.add('toaster-chart');
	  el.classList.add(themeClass);
	  el.classList.add(typeClass);
	  el.__data__ = data; // d3 compatable datum
	  // clients can disable default scaffold or provide a custom
	  // scaffold function for building legend/titles

	  var scaffold$1 = options.customScaffold || scaffold;
	  scaffold$1(el, data, options);

	  var render = function render() {
	    var layerInterface = type(el, data, options);
	    themeModifier(themeName)(el, data, options);
	    setupColors(el, data, options);
	    setBreakpointClasses(el, options); // ensure postRender is only called on final render after fonts
	    // have loaded

	    if (layerInterface && layerInterface.postRender && !globalState(data.id, 'awaitingSecondaryRender')) {
	      layerInterface.postRender();
	    }

	    return layerInterface;
	  };

	  var instance = render(); // call right away

	  onResize = createResizeCallback();
	  bindMessageHandlers(el, onResize, options);
	  bindResizeHandlers(el, render, onResize, data, options);

	  var destroy = function destroy() {
	    destroyResizeHandlers(el, render, onResize, data);
	  };

	  var methods = {
	    render: render,
	    onResize: onResize,
	    destroy: destroy
	  };
	  return instance ? _extends(instance, methods) : methods;
	}

	// this is set to use the rollup provided ''
	// data for the terminal via avmmid

	var TERMINAL_DATA_HOSTS = {
	  dev: 'http://localhost:8080',
	  // for now staging is set to www
	  staging: 'https://www.bloomberg.com',
	  production: 'https://www.bloomberg.com'
	};
	var TERMINAL_HOST = TERMINAL_DATA_HOSTS[''] || TERMINAL_DATA_HOSTS.dev;

	var crypt = createCommonjsModule(function (module) {
	(function() {
	  var base64map
	      = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',

	  crypt = {
	    // Bit-wise rotation left
	    rotl: function(n, b) {
	      return (n << b) | (n >>> (32 - b));
	    },

	    // Bit-wise rotation right
	    rotr: function(n, b) {
	      return (n << (32 - b)) | (n >>> b);
	    },

	    // Swap big-endian to little-endian and vice versa
	    endian: function(n) {
	      // If number given, swap endian
	      if (n.constructor == Number) {
	        return crypt.rotl(n, 8) & 0x00FF00FF | crypt.rotl(n, 24) & 0xFF00FF00;
	      }

	      // Else, assume array and swap all items
	      for (var i = 0; i < n.length; i++)
	        n[i] = crypt.endian(n[i]);
	      return n;
	    },

	    // Generate an array of any length of random bytes
	    randomBytes: function(n) {
	      for (var bytes = []; n > 0; n--)
	        bytes.push(Math.floor(Math.random() * 256));
	      return bytes;
	    },

	    // Convert a byte array to big-endian 32-bit words
	    bytesToWords: function(bytes) {
	      for (var words = [], i = 0, b = 0; i < bytes.length; i++, b += 8)
	        words[b >>> 5] |= bytes[i] << (24 - b % 32);
	      return words;
	    },

	    // Convert big-endian 32-bit words to a byte array
	    wordsToBytes: function(words) {
	      for (var bytes = [], b = 0; b < words.length * 32; b += 8)
	        bytes.push((words[b >>> 5] >>> (24 - b % 32)) & 0xFF);
	      return bytes;
	    },

	    // Convert a byte array to a hex string
	    bytesToHex: function(bytes) {
	      for (var hex = [], i = 0; i < bytes.length; i++) {
	        hex.push((bytes[i] >>> 4).toString(16));
	        hex.push((bytes[i] & 0xF).toString(16));
	      }
	      return hex.join('');
	    },

	    // Convert a hex string to a byte array
	    hexToBytes: function(hex) {
	      for (var bytes = [], c = 0; c < hex.length; c += 2)
	        bytes.push(parseInt(hex.substr(c, 2), 16));
	      return bytes;
	    },

	    // Convert a byte array to a base-64 string
	    bytesToBase64: function(bytes) {
	      for (var base64 = [], i = 0; i < bytes.length; i += 3) {
	        var triplet = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2];
	        for (var j = 0; j < 4; j++)
	          if (i * 8 + j * 6 <= bytes.length * 8)
	            base64.push(base64map.charAt((triplet >>> 6 * (3 - j)) & 0x3F));
	          else
	            base64.push('=');
	      }
	      return base64.join('');
	    },

	    // Convert a base-64 string to a byte array
	    base64ToBytes: function(base64) {
	      // Remove non-base-64 characters
	      base64 = base64.replace(/[^A-Z0-9+\/]/ig, '');

	      for (var bytes = [], i = 0, imod4 = 0; i < base64.length;
	          imod4 = ++i % 4) {
	        if (imod4 == 0) continue;
	        bytes.push(((base64map.indexOf(base64.charAt(i - 1))
	            & (Math.pow(2, -2 * imod4 + 8) - 1)) << (imod4 * 2))
	            | (base64map.indexOf(base64.charAt(i)) >>> (6 - imod4 * 2)));
	      }
	      return bytes;
	    }
	  };

	  module.exports = crypt;
	})();
	});

	var charenc = {
	  // UTF-8 encoding
	  utf8: {
	    // Convert a string to a byte array
	    stringToBytes: function(str) {
	      return charenc.bin.stringToBytes(unescape(encodeURIComponent(str)));
	    },

	    // Convert a byte array to a string
	    bytesToString: function(bytes) {
	      return decodeURIComponent(escape(charenc.bin.bytesToString(bytes)));
	    }
	  },

	  // Binary encoding
	  bin: {
	    // Convert a string to a byte array
	    stringToBytes: function(str) {
	      for (var bytes = [], i = 0; i < str.length; i++)
	        bytes.push(str.charCodeAt(i) & 0xFF);
	      return bytes;
	    },

	    // Convert a byte array to a string
	    bytesToString: function(bytes) {
	      for (var str = [], i = 0; i < bytes.length; i++)
	        str.push(String.fromCharCode(bytes[i]));
	      return str.join('');
	    }
	  }
	};

	var charenc_1 = charenc;

	/*!
	 * Determine if an object is a Buffer
	 *
	 * @author   Feross Aboukhadijeh <https://feross.org>
	 * @license  MIT
	 */

	// The _isBuffer check is for Safari 5-7 support, because it's missing
	// Object.prototype.constructor. Remove this eventually
	var isBuffer_1 = function (obj) {
	  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
	};

	function isBuffer (obj) {
	  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
	}

	// For Node v0.10 support. Remove this eventually.
	function isSlowBuffer (obj) {
	  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
	}

	var md5 = createCommonjsModule(function (module) {
	(function(){
	  var crypt$1 = crypt,
	      utf8 = charenc_1.utf8,
	      isBuffer = isBuffer_1,
	      bin = charenc_1.bin,

	  // The core
	  md5 = function (message, options) {
	    // Convert to byte array
	    if (message.constructor == String)
	      if (options && options.encoding === 'binary')
	        message = bin.stringToBytes(message);
	      else
	        message = utf8.stringToBytes(message);
	    else if (isBuffer(message))
	      message = Array.prototype.slice.call(message, 0);
	    else if (!Array.isArray(message) && message.constructor !== Uint8Array)
	      message = message.toString();
	    // else, assume byte array already

	    var m = crypt$1.bytesToWords(message),
	        l = message.length * 8,
	        a =  1732584193,
	        b = -271733879,
	        c = -1732584194,
	        d =  271733878;

	    // Swap endian
	    for (var i = 0; i < m.length; i++) {
	      m[i] = ((m[i] <<  8) | (m[i] >>> 24)) & 0x00FF00FF |
	             ((m[i] << 24) | (m[i] >>>  8)) & 0xFF00FF00;
	    }

	    // Padding
	    m[l >>> 5] |= 0x80 << (l % 32);
	    m[(((l + 64) >>> 9) << 4) + 14] = l;

	    // Method shortcuts
	    var FF = md5._ff,
	        GG = md5._gg,
	        HH = md5._hh,
	        II = md5._ii;

	    for (var i = 0; i < m.length; i += 16) {

	      var aa = a,
	          bb = b,
	          cc = c,
	          dd = d;

	      a = FF(a, b, c, d, m[i+ 0],  7, -680876936);
	      d = FF(d, a, b, c, m[i+ 1], 12, -389564586);
	      c = FF(c, d, a, b, m[i+ 2], 17,  606105819);
	      b = FF(b, c, d, a, m[i+ 3], 22, -1044525330);
	      a = FF(a, b, c, d, m[i+ 4],  7, -176418897);
	      d = FF(d, a, b, c, m[i+ 5], 12,  1200080426);
	      c = FF(c, d, a, b, m[i+ 6], 17, -1473231341);
	      b = FF(b, c, d, a, m[i+ 7], 22, -45705983);
	      a = FF(a, b, c, d, m[i+ 8],  7,  1770035416);
	      d = FF(d, a, b, c, m[i+ 9], 12, -1958414417);
	      c = FF(c, d, a, b, m[i+10], 17, -42063);
	      b = FF(b, c, d, a, m[i+11], 22, -1990404162);
	      a = FF(a, b, c, d, m[i+12],  7,  1804603682);
	      d = FF(d, a, b, c, m[i+13], 12, -40341101);
	      c = FF(c, d, a, b, m[i+14], 17, -1502002290);
	      b = FF(b, c, d, a, m[i+15], 22,  1236535329);

	      a = GG(a, b, c, d, m[i+ 1],  5, -165796510);
	      d = GG(d, a, b, c, m[i+ 6],  9, -1069501632);
	      c = GG(c, d, a, b, m[i+11], 14,  643717713);
	      b = GG(b, c, d, a, m[i+ 0], 20, -373897302);
	      a = GG(a, b, c, d, m[i+ 5],  5, -701558691);
	      d = GG(d, a, b, c, m[i+10],  9,  38016083);
	      c = GG(c, d, a, b, m[i+15], 14, -660478335);
	      b = GG(b, c, d, a, m[i+ 4], 20, -405537848);
	      a = GG(a, b, c, d, m[i+ 9],  5,  568446438);
	      d = GG(d, a, b, c, m[i+14],  9, -1019803690);
	      c = GG(c, d, a, b, m[i+ 3], 14, -187363961);
	      b = GG(b, c, d, a, m[i+ 8], 20,  1163531501);
	      a = GG(a, b, c, d, m[i+13],  5, -1444681467);
	      d = GG(d, a, b, c, m[i+ 2],  9, -51403784);
	      c = GG(c, d, a, b, m[i+ 7], 14,  1735328473);
	      b = GG(b, c, d, a, m[i+12], 20, -1926607734);

	      a = HH(a, b, c, d, m[i+ 5],  4, -378558);
	      d = HH(d, a, b, c, m[i+ 8], 11, -2022574463);
	      c = HH(c, d, a, b, m[i+11], 16,  1839030562);
	      b = HH(b, c, d, a, m[i+14], 23, -35309556);
	      a = HH(a, b, c, d, m[i+ 1],  4, -1530992060);
	      d = HH(d, a, b, c, m[i+ 4], 11,  1272893353);
	      c = HH(c, d, a, b, m[i+ 7], 16, -155497632);
	      b = HH(b, c, d, a, m[i+10], 23, -1094730640);
	      a = HH(a, b, c, d, m[i+13],  4,  681279174);
	      d = HH(d, a, b, c, m[i+ 0], 11, -358537222);
	      c = HH(c, d, a, b, m[i+ 3], 16, -722521979);
	      b = HH(b, c, d, a, m[i+ 6], 23,  76029189);
	      a = HH(a, b, c, d, m[i+ 9],  4, -640364487);
	      d = HH(d, a, b, c, m[i+12], 11, -421815835);
	      c = HH(c, d, a, b, m[i+15], 16,  530742520);
	      b = HH(b, c, d, a, m[i+ 2], 23, -995338651);

	      a = II(a, b, c, d, m[i+ 0],  6, -198630844);
	      d = II(d, a, b, c, m[i+ 7], 10,  1126891415);
	      c = II(c, d, a, b, m[i+14], 15, -1416354905);
	      b = II(b, c, d, a, m[i+ 5], 21, -57434055);
	      a = II(a, b, c, d, m[i+12],  6,  1700485571);
	      d = II(d, a, b, c, m[i+ 3], 10, -1894986606);
	      c = II(c, d, a, b, m[i+10], 15, -1051523);
	      b = II(b, c, d, a, m[i+ 1], 21, -2054922799);
	      a = II(a, b, c, d, m[i+ 8],  6,  1873313359);
	      d = II(d, a, b, c, m[i+15], 10, -30611744);
	      c = II(c, d, a, b, m[i+ 6], 15, -1560198380);
	      b = II(b, c, d, a, m[i+13], 21,  1309151649);
	      a = II(a, b, c, d, m[i+ 4],  6, -145523070);
	      d = II(d, a, b, c, m[i+11], 10, -1120210379);
	      c = II(c, d, a, b, m[i+ 2], 15,  718787259);
	      b = II(b, c, d, a, m[i+ 9], 21, -343485551);

	      a = (a + aa) >>> 0;
	      b = (b + bb) >>> 0;
	      c = (c + cc) >>> 0;
	      d = (d + dd) >>> 0;
	    }

	    return crypt$1.endian([a, b, c, d]);
	  };

	  // Auxiliary functions
	  md5._ff  = function (a, b, c, d, x, s, t) {
	    var n = a + (b & c | ~b & d) + (x >>> 0) + t;
	    return ((n << s) | (n >>> (32 - s))) + b;
	  };
	  md5._gg  = function (a, b, c, d, x, s, t) {
	    var n = a + (b & d | c & ~d) + (x >>> 0) + t;
	    return ((n << s) | (n >>> (32 - s))) + b;
	  };
	  md5._hh  = function (a, b, c, d, x, s, t) {
	    var n = a + (b ^ c ^ d) + (x >>> 0) + t;
	    return ((n << s) | (n >>> (32 - s))) + b;
	  };
	  md5._ii  = function (a, b, c, d, x, s, t) {
	    var n = a + (c ^ (b | ~d)) + (x >>> 0) + t;
	    return ((n << s) | (n >>> (32 - s))) + b;
	  };

	  // Package private blocksize
	  md5._blocksize = 16;
	  md5._digestsize = 16;

	  module.exports = function (message, options) {
	    if (message === undefined || message === null)
	      throw new Error('Illegal argument ' + message);

	    var digestbytes = crypt$1.wordsToBytes(md5(message, options));
	    return options && options.asBytes ? digestbytes :
	        options && options.asString ? bin.bytesToString(digestbytes) :
	        crypt$1.bytesToHex(digestbytes);
	  };

	})();
	});

	var _window = window,
	    fetch = _window.fetch;
	/**
	  The terminal client is a specific factory implementation
	  designed for the terminal docreader. The data won't be passed
	  in so we need to fetch via the avmmid.

	  (shadowRoot, config)
	  ('${shadowId}', '${avmmID}', '${imageURL}')
	*/

	function terminalClient$1(el, config, factory) {
	  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
	  var configObj = typeof config === 'string' ? JSON.parse(config) : config;
	  var avmmId = configObj.avmmId,
	      imageUrl = configObj.imageUrl,
	      scaleRatio = configObj.scaleRatio; // Basic salt with avmmId duplicated to provide some obfuscation
	  // for the public facing avmm endpoint

	  var imageKey = md5("".concat(avmmId).concat(avmmId));

	  var opts = _objectSpread2({
	    isTerminalClient: true,
	    theme: 'terminal',
	    noPadding: true,
	    scaleRatio: scaleRatio || 1.23194
	  }, options);

	  var isInternalUuid = avmmId.length >= 32;
	  var url = isInternalUuid ? "".concat(TERMINAL_HOST, "/api/v2/charts/uuid/").concat(avmmId, ".json") : "".concat(TERMINAL_HOST, "/toaster/v2/terminal-client/").concat(avmmId, "/").concat(imageKey);
	  var hasErrored = false; // we use getBoundingRectWidth to get the actual pixel width of the container

	  var containerWidth = el.getBoundingClientRect().width;
	  el.style.width = "".concat(containerWidth, "px");
	  el.style.margin = '20px 0';
	  el.style.overflow = 'hidden'; // we're going to create two sub containers and apply scaling

	  var scaleDiv = document.createElement('div');
	  scaleDiv.style.width = "".concat(containerWidth, "px");
	  scaleDiv.style.transform = "scale(".concat(1 / opts.scaleRatio, ")");
	  scaleDiv.style.transformOrigin = 'top left';
	  el.appendChild(scaleDiv);

	  opts.onRenderComplete = function (targetEl, env, options) {
	    if (hasErrored) return;
	    var node = targetEl.node ? targetEl.node() : targetEl;
	    el.style.height = "".concat(node.clientHeight / opts.scaleRatio, "px");
	    el.style.width = "".concat(node.clientWidth / opts.scaleRatio, "px"); // if the containerWidth changes via a resize update our scales

	    var updatedContainerWidth = el.parentNode.getBoundingClientRect().width;

	    if (updatedContainerWidth !== containerWidth) {
	      containerWidth = updatedContainerWidth;
	      el.style.width = "".concat(containerWidth, "px");
	      scaleDiv.style.width = "".concat(containerWidth, "px");
	    }
	  };

	  var showImageOnError = function showImageOnError(err) {
	    console.error('Toaster terminal client error', avmmId, err);
	    hasErrored = true;
	    var img = document.createElement('img');
	    img.setAttribute('src', imageUrl);
	    img.style.width = '100%';
	    el.innerHTML = ''; // clear out the contents of the div

	    el.style.width = 'auto';
	    el.style.height = 'auto';
	    el.style.overflow = 'initial';
	    el.appendChild(img);
	  };

	  try {
	    fetch(url, {
	      headers: {
	        Accept: 'application/json'
	      }
	    }).then(function (res) {
	      return res.json();
	    }).then(function (data) {
	      data.theme = getDarkTheme(data.theme || 'terminal');
	      factory(scaleDiv, data, opts);
	    }).catch(function (err) {
	      showImageOnError(err);
	      throw err;
	    });
	  } catch (err) {
	    showImageOnError(err);
	    throw err;
	  }
	}

	// because each chart type uses the same namespace "toaster.factory" we need
	// to ensure that multiple JS bundle inclusions don't override the global namespace
	// and block other factories.
	//
	// So the approach here is to always have window.toaster.factory and window.toaster.types
	// as an object that maps a chart type to a factory. We now check if window.toaster
	// already exists and then append our types into the existing types, and modify the factory
	// to use the available types.
	// returns { factory, types }
	function globalFactory(inputFactory, inputTypes) {
	  var types = !(window.toaster && window.toaster.types) ? inputTypes : _objectSpread2(_objectSpread2({}, window.toaster.types), inputTypes); // factory will merge with existing toaster.types if available

	  var factory = !(window.toaster && window.toaster.types) ? inputFactory : function (el) {
	    var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
	    var chartType = data.chartType;

	    if (types[chartType]) {
	      return types[chartType](el, data, options);
	    }

	    return inputFactory(el, data, options);
	  };
	  return {
	    factory: factory,
	    types: types
	  };
	}

	/**
	* Providing a global debug method that reads
	* query param options like:  ?debug=1, or localhost in order to
	* add helpers to accessor scope
	*
	* TODO :: add other tools / options here
	*/
	function debugEnv (env) {
	  var isLocalHost = window.location.hostname === 'localhost';

	  if (env.options.debug || env.options.isEditor || isLocalHost) {
	    window.env = env;
	  }
	}

	// @@match logic
	fixRegexpWellKnownSymbolLogic('match', 1, function (MATCH, nativeMatch, maybeCallNative) {
	  return [
	    // `String.prototype.match` method
	    // https://tc39.github.io/ecma262/#sec-string.prototype.match
	    function match(regexp) {
	      var O = requireObjectCoercible(this);
	      var matcher = regexp == undefined ? undefined : regexp[MATCH];
	      return matcher !== undefined ? matcher.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
	    },
	    // `RegExp.prototype[@@match]` method
	    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@match
	    function (regexp) {
	      var res = maybeCallNative(nativeMatch, regexp, this);
	      if (res.done) return res.value;

	      var rx = anObject(regexp);
	      var S = String(this);

	      if (!rx.global) return regexpExecAbstract(rx, S);

	      var fullUnicode = rx.unicode;
	      rx.lastIndex = 0;
	      var A = [];
	      var n = 0;
	      var result;
	      while ((result = regexpExecAbstract(rx, S)) !== null) {
	        var matchStr = String(result[0]);
	        A[n] = matchStr;
	        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
	        n++;
	      }
	      return n === 0 ? null : A;
	    }
	  ];
	});

	var moment_min = createCommonjsModule(function (module, exports) {
	!function(e,t){module.exports=t();}(commonjsGlobal,function(){var e,i;function c(){return e.apply(null,arguments)}function o(e){return e instanceof Array||"[object Array]"===Object.prototype.toString.call(e)}function u(e){return null!=e&&"[object Object]"===Object.prototype.toString.call(e)}function l(e){return void 0===e}function h(e){return "number"==typeof e||"[object Number]"===Object.prototype.toString.call(e)}function d(e){return e instanceof Date||"[object Date]"===Object.prototype.toString.call(e)}function f(e,t){var n,s=[];for(n=0;n<e.length;++n)s.push(t(e[n],n));return s}function m(e,t){return Object.prototype.hasOwnProperty.call(e,t)}function _(e,t){for(var n in t)m(t,n)&&(e[n]=t[n]);return m(t,"toString")&&(e.toString=t.toString),m(t,"valueOf")&&(e.valueOf=t.valueOf),e}function y(e,t,n,s){return Tt(e,t,n,s,!0).utc()}function g(e){return null==e._pf&&(e._pf={empty:!1,unusedTokens:[],unusedInput:[],overflow:-2,charsLeftOver:0,nullInput:!1,invalidMonth:null,invalidFormat:!1,userInvalidated:!1,iso:!1,parsedDateParts:[],meridiem:null,rfc2822:!1,weekdayMismatch:!1}),e._pf}function v(e){if(null==e._isValid){var t=g(e),n=i.call(t.parsedDateParts,function(e){return null!=e}),s=!isNaN(e._d.getTime())&&t.overflow<0&&!t.empty&&!t.invalidMonth&&!t.invalidWeekday&&!t.weekdayMismatch&&!t.nullInput&&!t.invalidFormat&&!t.userInvalidated&&(!t.meridiem||t.meridiem&&n);if(e._strict&&(s=s&&0===t.charsLeftOver&&0===t.unusedTokens.length&&void 0===t.bigHour),null!=Object.isFrozen&&Object.isFrozen(e))return s;e._isValid=s;}return e._isValid}function p(e){var t=y(NaN);return null!=e?_(g(t),e):g(t).userInvalidated=!0,t}i=Array.prototype.some?Array.prototype.some:function(e){for(var t=Object(this),n=t.length>>>0,s=0;s<n;s++)if(s in t&&e.call(this,t[s],s,t))return !0;return !1};var r=c.momentProperties=[];function w(e,t){var n,s,i;if(l(t._isAMomentObject)||(e._isAMomentObject=t._isAMomentObject),l(t._i)||(e._i=t._i),l(t._f)||(e._f=t._f),l(t._l)||(e._l=t._l),l(t._strict)||(e._strict=t._strict),l(t._tzm)||(e._tzm=t._tzm),l(t._isUTC)||(e._isUTC=t._isUTC),l(t._offset)||(e._offset=t._offset),l(t._pf)||(e._pf=g(t)),l(t._locale)||(e._locale=t._locale),0<r.length)for(n=0;n<r.length;n++)l(i=t[s=r[n]])||(e[s]=i);return e}var t=!1;function M(e){w(this,e),this._d=new Date(null!=e._d?e._d.getTime():NaN),this.isValid()||(this._d=new Date(NaN)),!1===t&&(t=!0,c.updateOffset(this),t=!1);}function k(e){return e instanceof M||null!=e&&null!=e._isAMomentObject}function S(e){return e<0?Math.ceil(e)||0:Math.floor(e)}function D(e){var t=+e,n=0;return 0!==t&&isFinite(t)&&(n=S(t)),n}function a(e,t,n){var s,i=Math.min(e.length,t.length),r=Math.abs(e.length-t.length),a=0;for(s=0;s<i;s++)(n&&e[s]!==t[s]||!n&&D(e[s])!==D(t[s]))&&a++;return a+r}function Y(e){!1===c.suppressDeprecationWarnings&&"undefined"!=typeof console&&console.warn&&console.warn("Deprecation warning: "+e);}function n(i,r){var a=!0;return _(function(){if(null!=c.deprecationHandler&&c.deprecationHandler(null,i),a){for(var e,t=[],n=0;n<arguments.length;n++){if(e="","object"==typeof arguments[n]){for(var s in e+="\n["+n+"] ",arguments[0])e+=s+": "+arguments[0][s]+", ";e=e.slice(0,-2);}else e=arguments[n];t.push(e);}Y(i+"\nArguments: "+Array.prototype.slice.call(t).join("")+"\n"+(new Error).stack),a=!1;}return r.apply(this,arguments)},r)}var s,O={};function T(e,t){null!=c.deprecationHandler&&c.deprecationHandler(e,t),O[e]||(Y(t),O[e]=!0);}function b(e){return e instanceof Function||"[object Function]"===Object.prototype.toString.call(e)}function x(e,t){var n,s=_({},e);for(n in t)m(t,n)&&(u(e[n])&&u(t[n])?(s[n]={},_(s[n],e[n]),_(s[n],t[n])):null!=t[n]?s[n]=t[n]:delete s[n]);for(n in e)m(e,n)&&!m(t,n)&&u(e[n])&&(s[n]=_({},s[n]));return s}function P(e){null!=e&&this.set(e);}c.suppressDeprecationWarnings=!1,c.deprecationHandler=null,s=Object.keys?Object.keys:function(e){var t,n=[];for(t in e)m(e,t)&&n.push(t);return n};var W={};function C(e,t){var n=e.toLowerCase();W[n]=W[n+"s"]=W[t]=e;}function H(e){return "string"==typeof e?W[e]||W[e.toLowerCase()]:void 0}function R(e){var t,n,s={};for(n in e)m(e,n)&&(t=H(n))&&(s[t]=e[n]);return s}var U={};function F(e,t){U[e]=t;}function L(e,t,n){var s=""+Math.abs(e),i=t-s.length;return (0<=e?n?"+":"":"-")+Math.pow(10,Math.max(0,i)).toString().substr(1)+s}var N=/(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g,G=/(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g,V={},E={};function I(e,t,n,s){var i=s;"string"==typeof s&&(i=function(){return this[s]()}),e&&(E[e]=i),t&&(E[t[0]]=function(){return L(i.apply(this,arguments),t[1],t[2])}),n&&(E[n]=function(){return this.localeData().ordinal(i.apply(this,arguments),e)});}function A(e,t){return e.isValid()?(t=j(t,e.localeData()),V[t]=V[t]||function(s){var e,i,t,r=s.match(N);for(e=0,i=r.length;e<i;e++)E[r[e]]?r[e]=E[r[e]]:r[e]=(t=r[e]).match(/\[[\s\S]/)?t.replace(/^\[|\]$/g,""):t.replace(/\\/g,"");return function(e){var t,n="";for(t=0;t<i;t++)n+=b(r[t])?r[t].call(e,s):r[t];return n}}(t),V[t](e)):e.localeData().invalidDate()}function j(e,t){var n=5;function s(e){return t.longDateFormat(e)||e}for(G.lastIndex=0;0<=n&&G.test(e);)e=e.replace(G,s),G.lastIndex=0,n-=1;return e}var Z=/\d/,z=/\d\d/,$=/\d{3}/,q=/\d{4}/,J=/[+-]?\d{6}/,B=/\d\d?/,Q=/\d\d\d\d?/,X=/\d\d\d\d\d\d?/,K=/\d{1,3}/,ee=/\d{1,4}/,te=/[+-]?\d{1,6}/,ne=/\d+/,se=/[+-]?\d+/,ie=/Z|[+-]\d\d:?\d\d/gi,re=/Z|[+-]\d\d(?::?\d\d)?/gi,ae=/[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i,oe={};function ue(e,n,s){oe[e]=b(n)?n:function(e,t){return e&&s?s:n};}function le(e,t){return m(oe,e)?oe[e](t._strict,t._locale):new RegExp(he(e.replace("\\","").replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,function(e,t,n,s,i){return t||n||s||i})))}function he(e){return e.replace(/[-\/\\^$*+?.()|[\]{}]/g,"\\$&")}var de={};function ce(e,n){var t,s=n;for("string"==typeof e&&(e=[e]),h(n)&&(s=function(e,t){t[n]=D(e);}),t=0;t<e.length;t++)de[e[t]]=s;}function fe(e,i){ce(e,function(e,t,n,s){n._w=n._w||{},i(e,n._w,n,s);});}var me=0,_e=1,ye=2,ge=3,ve=4,pe=5,we=6,Me=7,ke=8;function Se(e){return De(e)?366:365}function De(e){return e%4==0&&e%100!=0||e%400==0}I("Y",0,0,function(){var e=this.year();return e<=9999?""+e:"+"+e}),I(0,["YY",2],0,function(){return this.year()%100}),I(0,["YYYY",4],0,"year"),I(0,["YYYYY",5],0,"year"),I(0,["YYYYYY",6,!0],0,"year"),C("year","y"),F("year",1),ue("Y",se),ue("YY",B,z),ue("YYYY",ee,q),ue("YYYYY",te,J),ue("YYYYYY",te,J),ce(["YYYYY","YYYYYY"],me),ce("YYYY",function(e,t){t[me]=2===e.length?c.parseTwoDigitYear(e):D(e);}),ce("YY",function(e,t){t[me]=c.parseTwoDigitYear(e);}),ce("Y",function(e,t){t[me]=parseInt(e,10);}),c.parseTwoDigitYear=function(e){return D(e)+(68<D(e)?1900:2e3)};var Ye,Oe=Te("FullYear",!0);function Te(t,n){return function(e){return null!=e?(xe(this,t,e),c.updateOffset(this,n),this):be(this,t)}}function be(e,t){return e.isValid()?e._d["get"+(e._isUTC?"UTC":"")+t]():NaN}function xe(e,t,n){e.isValid()&&!isNaN(n)&&("FullYear"===t&&De(e.year())&&1===e.month()&&29===e.date()?e._d["set"+(e._isUTC?"UTC":"")+t](n,e.month(),Pe(n,e.month())):e._d["set"+(e._isUTC?"UTC":"")+t](n));}function Pe(e,t){if(isNaN(e)||isNaN(t))return NaN;var n,s=(t%(n=12)+n)%n;return e+=(t-s)/12,1===s?De(e)?29:28:31-s%7%2}Ye=Array.prototype.indexOf?Array.prototype.indexOf:function(e){var t;for(t=0;t<this.length;++t)if(this[t]===e)return t;return -1},I("M",["MM",2],"Mo",function(){return this.month()+1}),I("MMM",0,0,function(e){return this.localeData().monthsShort(this,e)}),I("MMMM",0,0,function(e){return this.localeData().months(this,e)}),C("month","M"),F("month",8),ue("M",B),ue("MM",B,z),ue("MMM",function(e,t){return t.monthsShortRegex(e)}),ue("MMMM",function(e,t){return t.monthsRegex(e)}),ce(["M","MM"],function(e,t){t[_e]=D(e)-1;}),ce(["MMM","MMMM"],function(e,t,n,s){var i=n._locale.monthsParse(e,s,n._strict);null!=i?t[_e]=i:g(n).invalidMonth=e;});var We=/D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/,Ce="January_February_March_April_May_June_July_August_September_October_November_December".split("_");var He="Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_");function Re(e,t){var n;if(!e.isValid())return e;if("string"==typeof t)if(/^\d+$/.test(t))t=D(t);else if(!h(t=e.localeData().monthsParse(t)))return e;return n=Math.min(e.date(),Pe(e.year(),t)),e._d["set"+(e._isUTC?"UTC":"")+"Month"](t,n),e}function Ue(e){return null!=e?(Re(this,e),c.updateOffset(this,!0),this):be(this,"Month")}var Fe=ae;var Le=ae;function Ne(){function e(e,t){return t.length-e.length}var t,n,s=[],i=[],r=[];for(t=0;t<12;t++)n=y([2e3,t]),s.push(this.monthsShort(n,"")),i.push(this.months(n,"")),r.push(this.months(n,"")),r.push(this.monthsShort(n,""));for(s.sort(e),i.sort(e),r.sort(e),t=0;t<12;t++)s[t]=he(s[t]),i[t]=he(i[t]);for(t=0;t<24;t++)r[t]=he(r[t]);this._monthsRegex=new RegExp("^("+r.join("|")+")","i"),this._monthsShortRegex=this._monthsRegex,this._monthsStrictRegex=new RegExp("^("+i.join("|")+")","i"),this._monthsShortStrictRegex=new RegExp("^("+s.join("|")+")","i");}function Ge(e){var t;if(e<100&&0<=e){var n=Array.prototype.slice.call(arguments);n[0]=e+400,t=new Date(Date.UTC.apply(null,n)),isFinite(t.getUTCFullYear())&&t.setUTCFullYear(e);}else t=new Date(Date.UTC.apply(null,arguments));return t}function Ve(e,t,n){var s=7+t-n;return -((7+Ge(e,0,s).getUTCDay()-t)%7)+s-1}function Ee(e,t,n,s,i){var r,a,o=1+7*(t-1)+(7+n-s)%7+Ve(e,s,i);return a=o<=0?Se(r=e-1)+o:o>Se(e)?(r=e+1,o-Se(e)):(r=e,o),{year:r,dayOfYear:a}}function Ie(e,t,n){var s,i,r=Ve(e.year(),t,n),a=Math.floor((e.dayOfYear()-r-1)/7)+1;return a<1?s=a+Ae(i=e.year()-1,t,n):a>Ae(e.year(),t,n)?(s=a-Ae(e.year(),t,n),i=e.year()+1):(i=e.year(),s=a),{week:s,year:i}}function Ae(e,t,n){var s=Ve(e,t,n),i=Ve(e+1,t,n);return (Se(e)-s+i)/7}I("w",["ww",2],"wo","week"),I("W",["WW",2],"Wo","isoWeek"),C("week","w"),C("isoWeek","W"),F("week",5),F("isoWeek",5),ue("w",B),ue("ww",B,z),ue("W",B),ue("WW",B,z),fe(["w","ww","W","WW"],function(e,t,n,s){t[s.substr(0,1)]=D(e);});function je(e,t){return e.slice(t,7).concat(e.slice(0,t))}I("d",0,"do","day"),I("dd",0,0,function(e){return this.localeData().weekdaysMin(this,e)}),I("ddd",0,0,function(e){return this.localeData().weekdaysShort(this,e)}),I("dddd",0,0,function(e){return this.localeData().weekdays(this,e)}),I("e",0,0,"weekday"),I("E",0,0,"isoWeekday"),C("day","d"),C("weekday","e"),C("isoWeekday","E"),F("day",11),F("weekday",11),F("isoWeekday",11),ue("d",B),ue("e",B),ue("E",B),ue("dd",function(e,t){return t.weekdaysMinRegex(e)}),ue("ddd",function(e,t){return t.weekdaysShortRegex(e)}),ue("dddd",function(e,t){return t.weekdaysRegex(e)}),fe(["dd","ddd","dddd"],function(e,t,n,s){var i=n._locale.weekdaysParse(e,s,n._strict);null!=i?t.d=i:g(n).invalidWeekday=e;}),fe(["d","e","E"],function(e,t,n,s){t[s]=D(e);});var Ze="Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_");var ze="Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_");var $e="Su_Mo_Tu_We_Th_Fr_Sa".split("_");var qe=ae;var Je=ae;var Be=ae;function Qe(){function e(e,t){return t.length-e.length}var t,n,s,i,r,a=[],o=[],u=[],l=[];for(t=0;t<7;t++)n=y([2e3,1]).day(t),s=this.weekdaysMin(n,""),i=this.weekdaysShort(n,""),r=this.weekdays(n,""),a.push(s),o.push(i),u.push(r),l.push(s),l.push(i),l.push(r);for(a.sort(e),o.sort(e),u.sort(e),l.sort(e),t=0;t<7;t++)o[t]=he(o[t]),u[t]=he(u[t]),l[t]=he(l[t]);this._weekdaysRegex=new RegExp("^("+l.join("|")+")","i"),this._weekdaysShortRegex=this._weekdaysRegex,this._weekdaysMinRegex=this._weekdaysRegex,this._weekdaysStrictRegex=new RegExp("^("+u.join("|")+")","i"),this._weekdaysShortStrictRegex=new RegExp("^("+o.join("|")+")","i"),this._weekdaysMinStrictRegex=new RegExp("^("+a.join("|")+")","i");}function Xe(){return this.hours()%12||12}function Ke(e,t){I(e,0,0,function(){return this.localeData().meridiem(this.hours(),this.minutes(),t)});}function et(e,t){return t._meridiemParse}I("H",["HH",2],0,"hour"),I("h",["hh",2],0,Xe),I("k",["kk",2],0,function(){return this.hours()||24}),I("hmm",0,0,function(){return ""+Xe.apply(this)+L(this.minutes(),2)}),I("hmmss",0,0,function(){return ""+Xe.apply(this)+L(this.minutes(),2)+L(this.seconds(),2)}),I("Hmm",0,0,function(){return ""+this.hours()+L(this.minutes(),2)}),I("Hmmss",0,0,function(){return ""+this.hours()+L(this.minutes(),2)+L(this.seconds(),2)}),Ke("a",!0),Ke("A",!1),C("hour","h"),F("hour",13),ue("a",et),ue("A",et),ue("H",B),ue("h",B),ue("k",B),ue("HH",B,z),ue("hh",B,z),ue("kk",B,z),ue("hmm",Q),ue("hmmss",X),ue("Hmm",Q),ue("Hmmss",X),ce(["H","HH"],ge),ce(["k","kk"],function(e,t,n){var s=D(e);t[ge]=24===s?0:s;}),ce(["a","A"],function(e,t,n){n._isPm=n._locale.isPM(e),n._meridiem=e;}),ce(["h","hh"],function(e,t,n){t[ge]=D(e),g(n).bigHour=!0;}),ce("hmm",function(e,t,n){var s=e.length-2;t[ge]=D(e.substr(0,s)),t[ve]=D(e.substr(s)),g(n).bigHour=!0;}),ce("hmmss",function(e,t,n){var s=e.length-4,i=e.length-2;t[ge]=D(e.substr(0,s)),t[ve]=D(e.substr(s,2)),t[pe]=D(e.substr(i)),g(n).bigHour=!0;}),ce("Hmm",function(e,t,n){var s=e.length-2;t[ge]=D(e.substr(0,s)),t[ve]=D(e.substr(s));}),ce("Hmmss",function(e,t,n){var s=e.length-4,i=e.length-2;t[ge]=D(e.substr(0,s)),t[ve]=D(e.substr(s,2)),t[pe]=D(e.substr(i));});var tt,nt=Te("Hours",!0),st={calendar:{sameDay:"[Today at] LT",nextDay:"[Tomorrow at] LT",nextWeek:"dddd [at] LT",lastDay:"[Yesterday at] LT",lastWeek:"[Last] dddd [at] LT",sameElse:"L"},longDateFormat:{LTS:"h:mm:ss A",LT:"h:mm A",L:"MM/DD/YYYY",LL:"MMMM D, YYYY",LLL:"MMMM D, YYYY h:mm A",LLLL:"dddd, MMMM D, YYYY h:mm A"},invalidDate:"Invalid date",ordinal:"%d",dayOfMonthOrdinalParse:/\d{1,2}/,relativeTime:{future:"in %s",past:"%s ago",s:"a few seconds",ss:"%d seconds",m:"a minute",mm:"%d minutes",h:"an hour",hh:"%d hours",d:"a day",dd:"%d days",M:"a month",MM:"%d months",y:"a year",yy:"%d years"},months:Ce,monthsShort:He,week:{dow:0,doy:6},weekdays:Ze,weekdaysMin:$e,weekdaysShort:ze,meridiemParse:/[ap]\.?m?\.?/i},it={},rt={};function at(e){return e?e.toLowerCase().replace("_","-"):e}function ot(e){var t=null;if(!it[e]&&"undefined"!='object'&&module&&module.exports)try{t=tt._abbr,commonjsRequire("./locale/"+e),ut(t);}catch(e){}return it[e]}function ut(e,t){var n;return e&&((n=l(t)?ht(e):lt(e,t))?tt=n:"undefined"!=typeof console&&console.warn&&console.warn("Locale "+e+" not found. Did you forget to load it?")),tt._abbr}function lt(e,t){if(null===t)return delete it[e],null;var n,s=st;if(t.abbr=e,null!=it[e])T("defineLocaleOverride","use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."),s=it[e]._config;else if(null!=t.parentLocale)if(null!=it[t.parentLocale])s=it[t.parentLocale]._config;else {if(null==(n=ot(t.parentLocale)))return rt[t.parentLocale]||(rt[t.parentLocale]=[]),rt[t.parentLocale].push({name:e,config:t}),null;s=n._config;}return it[e]=new P(x(s,t)),rt[e]&&rt[e].forEach(function(e){lt(e.name,e.config);}),ut(e),it[e]}function ht(e){var t;if(e&&e._locale&&e._locale._abbr&&(e=e._locale._abbr),!e)return tt;if(!o(e)){if(t=ot(e))return t;e=[e];}return function(e){for(var t,n,s,i,r=0;r<e.length;){for(t=(i=at(e[r]).split("-")).length,n=(n=at(e[r+1]))?n.split("-"):null;0<t;){if(s=ot(i.slice(0,t).join("-")))return s;if(n&&n.length>=t&&a(i,n,!0)>=t-1)break;t--;}r++;}return tt}(e)}function dt(e){var t,n=e._a;return n&&-2===g(e).overflow&&(t=n[_e]<0||11<n[_e]?_e:n[ye]<1||n[ye]>Pe(n[me],n[_e])?ye:n[ge]<0||24<n[ge]||24===n[ge]&&(0!==n[ve]||0!==n[pe]||0!==n[we])?ge:n[ve]<0||59<n[ve]?ve:n[pe]<0||59<n[pe]?pe:n[we]<0||999<n[we]?we:-1,g(e)._overflowDayOfYear&&(t<me||ye<t)&&(t=ye),g(e)._overflowWeeks&&-1===t&&(t=Me),g(e)._overflowWeekday&&-1===t&&(t=ke),g(e).overflow=t),e}function ct(e,t,n){return null!=e?e:null!=t?t:n}function ft(e){var t,n,s,i,r,a=[];if(!e._d){var o,u;for(o=e,u=new Date(c.now()),s=o._useUTC?[u.getUTCFullYear(),u.getUTCMonth(),u.getUTCDate()]:[u.getFullYear(),u.getMonth(),u.getDate()],e._w&&null==e._a[ye]&&null==e._a[_e]&&function(e){var t,n,s,i,r,a,o,u;if(null!=(t=e._w).GG||null!=t.W||null!=t.E)r=1,a=4,n=ct(t.GG,e._a[me],Ie(bt(),1,4).year),s=ct(t.W,1),((i=ct(t.E,1))<1||7<i)&&(u=!0);else {r=e._locale._week.dow,a=e._locale._week.doy;var l=Ie(bt(),r,a);n=ct(t.gg,e._a[me],l.year),s=ct(t.w,l.week),null!=t.d?((i=t.d)<0||6<i)&&(u=!0):null!=t.e?(i=t.e+r,(t.e<0||6<t.e)&&(u=!0)):i=r;}s<1||s>Ae(n,r,a)?g(e)._overflowWeeks=!0:null!=u?g(e)._overflowWeekday=!0:(o=Ee(n,s,i,r,a),e._a[me]=o.year,e._dayOfYear=o.dayOfYear);}(e),null!=e._dayOfYear&&(r=ct(e._a[me],s[me]),(e._dayOfYear>Se(r)||0===e._dayOfYear)&&(g(e)._overflowDayOfYear=!0),n=Ge(r,0,e._dayOfYear),e._a[_e]=n.getUTCMonth(),e._a[ye]=n.getUTCDate()),t=0;t<3&&null==e._a[t];++t)e._a[t]=a[t]=s[t];for(;t<7;t++)e._a[t]=a[t]=null==e._a[t]?2===t?1:0:e._a[t];24===e._a[ge]&&0===e._a[ve]&&0===e._a[pe]&&0===e._a[we]&&(e._nextDay=!0,e._a[ge]=0),e._d=(e._useUTC?Ge:function(e,t,n,s,i,r,a){var o;return e<100&&0<=e?(o=new Date(e+400,t,n,s,i,r,a),isFinite(o.getFullYear())&&o.setFullYear(e)):o=new Date(e,t,n,s,i,r,a),o}).apply(null,a),i=e._useUTC?e._d.getUTCDay():e._d.getDay(),null!=e._tzm&&e._d.setUTCMinutes(e._d.getUTCMinutes()-e._tzm),e._nextDay&&(e._a[ge]=24),e._w&&void 0!==e._w.d&&e._w.d!==i&&(g(e).weekdayMismatch=!0);}}var mt=/^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,_t=/^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,yt=/Z|[+-]\d\d(?::?\d\d)?/,gt=[["YYYYYY-MM-DD",/[+-]\d{6}-\d\d-\d\d/],["YYYY-MM-DD",/\d{4}-\d\d-\d\d/],["GGGG-[W]WW-E",/\d{4}-W\d\d-\d/],["GGGG-[W]WW",/\d{4}-W\d\d/,!1],["YYYY-DDD",/\d{4}-\d{3}/],["YYYY-MM",/\d{4}-\d\d/,!1],["YYYYYYMMDD",/[+-]\d{10}/],["YYYYMMDD",/\d{8}/],["GGGG[W]WWE",/\d{4}W\d{3}/],["GGGG[W]WW",/\d{4}W\d{2}/,!1],["YYYYDDD",/\d{7}/]],vt=[["HH:mm:ss.SSSS",/\d\d:\d\d:\d\d\.\d+/],["HH:mm:ss,SSSS",/\d\d:\d\d:\d\d,\d+/],["HH:mm:ss",/\d\d:\d\d:\d\d/],["HH:mm",/\d\d:\d\d/],["HHmmss.SSSS",/\d\d\d\d\d\d\.\d+/],["HHmmss,SSSS",/\d\d\d\d\d\d,\d+/],["HHmmss",/\d\d\d\d\d\d/],["HHmm",/\d\d\d\d/],["HH",/\d\d/]],pt=/^\/?Date\((\-?\d+)/i;function wt(e){var t,n,s,i,r,a,o=e._i,u=mt.exec(o)||_t.exec(o);if(u){for(g(e).iso=!0,t=0,n=gt.length;t<n;t++)if(gt[t][1].exec(u[1])){i=gt[t][0],s=!1!==gt[t][2];break}if(null==i)return void(e._isValid=!1);if(u[3]){for(t=0,n=vt.length;t<n;t++)if(vt[t][1].exec(u[3])){r=(u[2]||" ")+vt[t][0];break}if(null==r)return void(e._isValid=!1)}if(!s&&null!=r)return void(e._isValid=!1);if(u[4]){if(!yt.exec(u[4]))return void(e._isValid=!1);a="Z";}e._f=i+(r||"")+(a||""),Yt(e);}else e._isValid=!1;}var Mt=/^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/;function kt(e,t,n,s,i,r){var a=[function(e){var t=parseInt(e,10);{if(t<=49)return 2e3+t;if(t<=999)return 1900+t}return t}(e),He.indexOf(t),parseInt(n,10),parseInt(s,10),parseInt(i,10)];return r&&a.push(parseInt(r,10)),a}var St={UT:0,GMT:0,EDT:-240,EST:-300,CDT:-300,CST:-360,MDT:-360,MST:-420,PDT:-420,PST:-480};function Dt(e){var t,n,s,i=Mt.exec(e._i.replace(/\([^)]*\)|[\n\t]/g," ").replace(/(\s\s+)/g," ").replace(/^\s\s*/,"").replace(/\s\s*$/,""));if(i){var r=kt(i[4],i[3],i[2],i[5],i[6],i[7]);if(t=i[1],n=r,s=e,t&&ze.indexOf(t)!==new Date(n[0],n[1],n[2]).getDay()&&(g(s).weekdayMismatch=!0,!(s._isValid=!1)))return;e._a=r,e._tzm=function(e,t,n){if(e)return St[e];if(t)return 0;var s=parseInt(n,10),i=s%100;return (s-i)/100*60+i}(i[8],i[9],i[10]),e._d=Ge.apply(null,e._a),e._d.setUTCMinutes(e._d.getUTCMinutes()-e._tzm),g(e).rfc2822=!0;}else e._isValid=!1;}function Yt(e){if(e._f!==c.ISO_8601)if(e._f!==c.RFC_2822){e._a=[],g(e).empty=!0;var t,n,s,i,r,a,o,u,l=""+e._i,h=l.length,d=0;for(s=j(e._f,e._locale).match(N)||[],t=0;t<s.length;t++)i=s[t],(n=(l.match(le(i,e))||[])[0])&&(0<(r=l.substr(0,l.indexOf(n))).length&&g(e).unusedInput.push(r),l=l.slice(l.indexOf(n)+n.length),d+=n.length),E[i]?(n?g(e).empty=!1:g(e).unusedTokens.push(i),a=i,u=e,null!=(o=n)&&m(de,a)&&de[a](o,u._a,u,a)):e._strict&&!n&&g(e).unusedTokens.push(i);g(e).charsLeftOver=h-d,0<l.length&&g(e).unusedInput.push(l),e._a[ge]<=12&&!0===g(e).bigHour&&0<e._a[ge]&&(g(e).bigHour=void 0),g(e).parsedDateParts=e._a.slice(0),g(e).meridiem=e._meridiem,e._a[ge]=function(e,t,n){var s;if(null==n)return t;return null!=e.meridiemHour?e.meridiemHour(t,n):(null!=e.isPM&&((s=e.isPM(n))&&t<12&&(t+=12),s||12!==t||(t=0)),t)}(e._locale,e._a[ge],e._meridiem),ft(e),dt(e);}else Dt(e);else wt(e);}function Ot(e){var t,n,s,i,r=e._i,a=e._f;return e._locale=e._locale||ht(e._l),null===r||void 0===a&&""===r?p({nullInput:!0}):("string"==typeof r&&(e._i=r=e._locale.preparse(r)),k(r)?new M(dt(r)):(d(r)?e._d=r:o(a)?function(e){var t,n,s,i,r;if(0===e._f.length)return g(e).invalidFormat=!0,e._d=new Date(NaN);for(i=0;i<e._f.length;i++)r=0,t=w({},e),null!=e._useUTC&&(t._useUTC=e._useUTC),t._f=e._f[i],Yt(t),v(t)&&(r+=g(t).charsLeftOver,r+=10*g(t).unusedTokens.length,g(t).score=r,(null==s||r<s)&&(s=r,n=t));_(e,n||t);}(e):a?Yt(e):l(n=(t=e)._i)?t._d=new Date(c.now()):d(n)?t._d=new Date(n.valueOf()):"string"==typeof n?(s=t,null===(i=pt.exec(s._i))?(wt(s),!1===s._isValid&&(delete s._isValid,Dt(s),!1===s._isValid&&(delete s._isValid,c.createFromInputFallback(s)))):s._d=new Date(+i[1])):o(n)?(t._a=f(n.slice(0),function(e){return parseInt(e,10)}),ft(t)):u(n)?function(e){if(!e._d){var t=R(e._i);e._a=f([t.year,t.month,t.day||t.date,t.hour,t.minute,t.second,t.millisecond],function(e){return e&&parseInt(e,10)}),ft(e);}}(t):h(n)?t._d=new Date(n):c.createFromInputFallback(t),v(e)||(e._d=null),e))}function Tt(e,t,n,s,i){var r,a={};return !0!==n&&!1!==n||(s=n,n=void 0),(u(e)&&function(e){if(Object.getOwnPropertyNames)return 0===Object.getOwnPropertyNames(e).length;var t;for(t in e)if(e.hasOwnProperty(t))return !1;return !0}(e)||o(e)&&0===e.length)&&(e=void 0),a._isAMomentObject=!0,a._useUTC=a._isUTC=i,a._l=n,a._i=e,a._f=t,a._strict=s,(r=new M(dt(Ot(a))))._nextDay&&(r.add(1,"d"),r._nextDay=void 0),r}function bt(e,t,n,s){return Tt(e,t,n,s,!1)}c.createFromInputFallback=n("value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged and will be removed in an upcoming major release. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.",function(e){e._d=new Date(e._i+(e._useUTC?" UTC":""));}),c.ISO_8601=function(){},c.RFC_2822=function(){};var xt=n("moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/",function(){var e=bt.apply(null,arguments);return this.isValid()&&e.isValid()?e<this?this:e:p()}),Pt=n("moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/",function(){var e=bt.apply(null,arguments);return this.isValid()&&e.isValid()?this<e?this:e:p()});function Wt(e,t){var n,s;if(1===t.length&&o(t[0])&&(t=t[0]),!t.length)return bt();for(n=t[0],s=1;s<t.length;++s)t[s].isValid()&&!t[s][e](n)||(n=t[s]);return n}var Ct=["year","quarter","month","week","day","hour","minute","second","millisecond"];function Ht(e){var t=R(e),n=t.year||0,s=t.quarter||0,i=t.month||0,r=t.week||t.isoWeek||0,a=t.day||0,o=t.hour||0,u=t.minute||0,l=t.second||0,h=t.millisecond||0;this._isValid=function(e){for(var t in e)if(-1===Ye.call(Ct,t)||null!=e[t]&&isNaN(e[t]))return !1;for(var n=!1,s=0;s<Ct.length;++s)if(e[Ct[s]]){if(n)return !1;parseFloat(e[Ct[s]])!==D(e[Ct[s]])&&(n=!0);}return !0}(t),this._milliseconds=+h+1e3*l+6e4*u+1e3*o*60*60,this._days=+a+7*r,this._months=+i+3*s+12*n,this._data={},this._locale=ht(),this._bubble();}function Rt(e){return e instanceof Ht}function Ut(e){return e<0?-1*Math.round(-1*e):Math.round(e)}function Ft(e,n){I(e,0,0,function(){var e=this.utcOffset(),t="+";return e<0&&(e=-e,t="-"),t+L(~~(e/60),2)+n+L(~~e%60,2)});}Ft("Z",":"),Ft("ZZ",""),ue("Z",re),ue("ZZ",re),ce(["Z","ZZ"],function(e,t,n){n._useUTC=!0,n._tzm=Nt(re,e);});var Lt=/([\+\-]|\d\d)/gi;function Nt(e,t){var n=(t||"").match(e);if(null===n)return null;var s=((n[n.length-1]||[])+"").match(Lt)||["-",0,0],i=60*s[1]+D(s[2]);return 0===i?0:"+"===s[0]?i:-i}function Gt(e,t){var n,s;return t._isUTC?(n=t.clone(),s=(k(e)||d(e)?e.valueOf():bt(e).valueOf())-n.valueOf(),n._d.setTime(n._d.valueOf()+s),c.updateOffset(n,!1),n):bt(e).local()}function Vt(e){return 15*-Math.round(e._d.getTimezoneOffset()/15)}function Et(){return !!this.isValid()&&(this._isUTC&&0===this._offset)}c.updateOffset=function(){};var It=/^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/,At=/^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;function jt(e,t){var n,s,i,r=e,a=null;return Rt(e)?r={ms:e._milliseconds,d:e._days,M:e._months}:h(e)?(r={},t?r[t]=e:r.milliseconds=e):(a=It.exec(e))?(n="-"===a[1]?-1:1,r={y:0,d:D(a[ye])*n,h:D(a[ge])*n,m:D(a[ve])*n,s:D(a[pe])*n,ms:D(Ut(1e3*a[we]))*n}):(a=At.exec(e))?(n="-"===a[1]?-1:1,r={y:Zt(a[2],n),M:Zt(a[3],n),w:Zt(a[4],n),d:Zt(a[5],n),h:Zt(a[6],n),m:Zt(a[7],n),s:Zt(a[8],n)}):null==r?r={}:"object"==typeof r&&("from"in r||"to"in r)&&(i=function(e,t){var n;if(!e.isValid()||!t.isValid())return {milliseconds:0,months:0};t=Gt(t,e),e.isBefore(t)?n=zt(e,t):((n=zt(t,e)).milliseconds=-n.milliseconds,n.months=-n.months);return n}(bt(r.from),bt(r.to)),(r={}).ms=i.milliseconds,r.M=i.months),s=new Ht(r),Rt(e)&&m(e,"_locale")&&(s._locale=e._locale),s}function Zt(e,t){var n=e&&parseFloat(e.replace(",","."));return (isNaN(n)?0:n)*t}function zt(e,t){var n={};return n.months=t.month()-e.month()+12*(t.year()-e.year()),e.clone().add(n.months,"M").isAfter(t)&&--n.months,n.milliseconds=+t-+e.clone().add(n.months,"M"),n}function $t(s,i){return function(e,t){var n;return null===t||isNaN(+t)||(T(i,"moment()."+i+"(period, number) is deprecated. Please use moment()."+i+"(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."),n=e,e=t,t=n),qt(this,jt(e="string"==typeof e?+e:e,t),s),this}}function qt(e,t,n,s){var i=t._milliseconds,r=Ut(t._days),a=Ut(t._months);e.isValid()&&(s=null==s||s,a&&Re(e,be(e,"Month")+a*n),r&&xe(e,"Date",be(e,"Date")+r*n),i&&e._d.setTime(e._d.valueOf()+i*n),s&&c.updateOffset(e,r||a));}jt.fn=Ht.prototype,jt.invalid=function(){return jt(NaN)};var Jt=$t(1,"add"),Bt=$t(-1,"subtract");function Qt(e,t){var n=12*(t.year()-e.year())+(t.month()-e.month()),s=e.clone().add(n,"months");return -(n+(t-s<0?(t-s)/(s-e.clone().add(n-1,"months")):(t-s)/(e.clone().add(n+1,"months")-s)))||0}function Xt(e){var t;return void 0===e?this._locale._abbr:(null!=(t=ht(e))&&(this._locale=t),this)}c.defaultFormat="YYYY-MM-DDTHH:mm:ssZ",c.defaultFormatUtc="YYYY-MM-DDTHH:mm:ss[Z]";var Kt=n("moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",function(e){return void 0===e?this.localeData():this.locale(e)});function en(){return this._locale}var tn=126227808e5;function nn(e,t){return (e%t+t)%t}function sn(e,t,n){return e<100&&0<=e?new Date(e+400,t,n)-tn:new Date(e,t,n).valueOf()}function rn(e,t,n){return e<100&&0<=e?Date.UTC(e+400,t,n)-tn:Date.UTC(e,t,n)}function an(e,t){I(0,[e,e.length],0,t);}function on(e,t,n,s,i){var r;return null==e?Ie(this,s,i).year:((r=Ae(e,s,i))<t&&(t=r),function(e,t,n,s,i){var r=Ee(e,t,n,s,i),a=Ge(r.year,0,r.dayOfYear);return this.year(a.getUTCFullYear()),this.month(a.getUTCMonth()),this.date(a.getUTCDate()),this}.call(this,e,t,n,s,i))}I(0,["gg",2],0,function(){return this.weekYear()%100}),I(0,["GG",2],0,function(){return this.isoWeekYear()%100}),an("gggg","weekYear"),an("ggggg","weekYear"),an("GGGG","isoWeekYear"),an("GGGGG","isoWeekYear"),C("weekYear","gg"),C("isoWeekYear","GG"),F("weekYear",1),F("isoWeekYear",1),ue("G",se),ue("g",se),ue("GG",B,z),ue("gg",B,z),ue("GGGG",ee,q),ue("gggg",ee,q),ue("GGGGG",te,J),ue("ggggg",te,J),fe(["gggg","ggggg","GGGG","GGGGG"],function(e,t,n,s){t[s.substr(0,2)]=D(e);}),fe(["gg","GG"],function(e,t,n,s){t[s]=c.parseTwoDigitYear(e);}),I("Q",0,"Qo","quarter"),C("quarter","Q"),F("quarter",7),ue("Q",Z),ce("Q",function(e,t){t[_e]=3*(D(e)-1);}),I("D",["DD",2],"Do","date"),C("date","D"),F("date",9),ue("D",B),ue("DD",B,z),ue("Do",function(e,t){return e?t._dayOfMonthOrdinalParse||t._ordinalParse:t._dayOfMonthOrdinalParseLenient}),ce(["D","DD"],ye),ce("Do",function(e,t){t[ye]=D(e.match(B)[0]);});var un=Te("Date",!0);I("DDD",["DDDD",3],"DDDo","dayOfYear"),C("dayOfYear","DDD"),F("dayOfYear",4),ue("DDD",K),ue("DDDD",$),ce(["DDD","DDDD"],function(e,t,n){n._dayOfYear=D(e);}),I("m",["mm",2],0,"minute"),C("minute","m"),F("minute",14),ue("m",B),ue("mm",B,z),ce(["m","mm"],ve);var ln=Te("Minutes",!1);I("s",["ss",2],0,"second"),C("second","s"),F("second",15),ue("s",B),ue("ss",B,z),ce(["s","ss"],pe);var hn,dn=Te("Seconds",!1);for(I("S",0,0,function(){return ~~(this.millisecond()/100)}),I(0,["SS",2],0,function(){return ~~(this.millisecond()/10)}),I(0,["SSS",3],0,"millisecond"),I(0,["SSSS",4],0,function(){return 10*this.millisecond()}),I(0,["SSSSS",5],0,function(){return 100*this.millisecond()}),I(0,["SSSSSS",6],0,function(){return 1e3*this.millisecond()}),I(0,["SSSSSSS",7],0,function(){return 1e4*this.millisecond()}),I(0,["SSSSSSSS",8],0,function(){return 1e5*this.millisecond()}),I(0,["SSSSSSSSS",9],0,function(){return 1e6*this.millisecond()}),C("millisecond","ms"),F("millisecond",16),ue("S",K,Z),ue("SS",K,z),ue("SSS",K,$),hn="SSSS";hn.length<=9;hn+="S")ue(hn,ne);function cn(e,t){t[we]=D(1e3*("0."+e));}for(hn="S";hn.length<=9;hn+="S")ce(hn,cn);var fn=Te("Milliseconds",!1);I("z",0,0,"zoneAbbr"),I("zz",0,0,"zoneName");var mn=M.prototype;function _n(e){return e}mn.add=Jt,mn.calendar=function(e,t){var n=e||bt(),s=Gt(n,this).startOf("day"),i=c.calendarFormat(this,s)||"sameElse",r=t&&(b(t[i])?t[i].call(this,n):t[i]);return this.format(r||this.localeData().calendar(i,this,bt(n)))},mn.clone=function(){return new M(this)},mn.diff=function(e,t,n){var s,i,r;if(!this.isValid())return NaN;if(!(s=Gt(e,this)).isValid())return NaN;switch(i=6e4*(s.utcOffset()-this.utcOffset()),t=H(t)){case"year":r=Qt(this,s)/12;break;case"month":r=Qt(this,s);break;case"quarter":r=Qt(this,s)/3;break;case"second":r=(this-s)/1e3;break;case"minute":r=(this-s)/6e4;break;case"hour":r=(this-s)/36e5;break;case"day":r=(this-s-i)/864e5;break;case"week":r=(this-s-i)/6048e5;break;default:r=this-s;}return n?r:S(r)},mn.endOf=function(e){var t;if(void 0===(e=H(e))||"millisecond"===e||!this.isValid())return this;var n=this._isUTC?rn:sn;switch(e){case"year":t=n(this.year()+1,0,1)-1;break;case"quarter":t=n(this.year(),this.month()-this.month()%3+3,1)-1;break;case"month":t=n(this.year(),this.month()+1,1)-1;break;case"week":t=n(this.year(),this.month(),this.date()-this.weekday()+7)-1;break;case"isoWeek":t=n(this.year(),this.month(),this.date()-(this.isoWeekday()-1)+7)-1;break;case"day":case"date":t=n(this.year(),this.month(),this.date()+1)-1;break;case"hour":t=this._d.valueOf(),t+=36e5-nn(t+(this._isUTC?0:6e4*this.utcOffset()),36e5)-1;break;case"minute":t=this._d.valueOf(),t+=6e4-nn(t,6e4)-1;break;case"second":t=this._d.valueOf(),t+=1e3-nn(t,1e3)-1;break}return this._d.setTime(t),c.updateOffset(this,!0),this},mn.format=function(e){e||(e=this.isUtc()?c.defaultFormatUtc:c.defaultFormat);var t=A(this,e);return this.localeData().postformat(t)},mn.from=function(e,t){return this.isValid()&&(k(e)&&e.isValid()||bt(e).isValid())?jt({to:this,from:e}).locale(this.locale()).humanize(!t):this.localeData().invalidDate()},mn.fromNow=function(e){return this.from(bt(),e)},mn.to=function(e,t){return this.isValid()&&(k(e)&&e.isValid()||bt(e).isValid())?jt({from:this,to:e}).locale(this.locale()).humanize(!t):this.localeData().invalidDate()},mn.toNow=function(e){return this.to(bt(),e)},mn.get=function(e){return b(this[e=H(e)])?this[e]():this},mn.invalidAt=function(){return g(this).overflow},mn.isAfter=function(e,t){var n=k(e)?e:bt(e);return !(!this.isValid()||!n.isValid())&&("millisecond"===(t=H(t)||"millisecond")?this.valueOf()>n.valueOf():n.valueOf()<this.clone().startOf(t).valueOf())},mn.isBefore=function(e,t){var n=k(e)?e:bt(e);return !(!this.isValid()||!n.isValid())&&("millisecond"===(t=H(t)||"millisecond")?this.valueOf()<n.valueOf():this.clone().endOf(t).valueOf()<n.valueOf())},mn.isBetween=function(e,t,n,s){var i=k(e)?e:bt(e),r=k(t)?t:bt(t);return !!(this.isValid()&&i.isValid()&&r.isValid())&&("("===(s=s||"()")[0]?this.isAfter(i,n):!this.isBefore(i,n))&&(")"===s[1]?this.isBefore(r,n):!this.isAfter(r,n))},mn.isSame=function(e,t){var n,s=k(e)?e:bt(e);return !(!this.isValid()||!s.isValid())&&("millisecond"===(t=H(t)||"millisecond")?this.valueOf()===s.valueOf():(n=s.valueOf(),this.clone().startOf(t).valueOf()<=n&&n<=this.clone().endOf(t).valueOf()))},mn.isSameOrAfter=function(e,t){return this.isSame(e,t)||this.isAfter(e,t)},mn.isSameOrBefore=function(e,t){return this.isSame(e,t)||this.isBefore(e,t)},mn.isValid=function(){return v(this)},mn.lang=Kt,mn.locale=Xt,mn.localeData=en,mn.max=Pt,mn.min=xt,mn.parsingFlags=function(){return _({},g(this))},mn.set=function(e,t){if("object"==typeof e)for(var n=function(e){var t=[];for(var n in e)t.push({unit:n,priority:U[n]});return t.sort(function(e,t){return e.priority-t.priority}),t}(e=R(e)),s=0;s<n.length;s++)this[n[s].unit](e[n[s].unit]);else if(b(this[e=H(e)]))return this[e](t);return this},mn.startOf=function(e){var t;if(void 0===(e=H(e))||"millisecond"===e||!this.isValid())return this;var n=this._isUTC?rn:sn;switch(e){case"year":t=n(this.year(),0,1);break;case"quarter":t=n(this.year(),this.month()-this.month()%3,1);break;case"month":t=n(this.year(),this.month(),1);break;case"week":t=n(this.year(),this.month(),this.date()-this.weekday());break;case"isoWeek":t=n(this.year(),this.month(),this.date()-(this.isoWeekday()-1));break;case"day":case"date":t=n(this.year(),this.month(),this.date());break;case"hour":t=this._d.valueOf(),t-=nn(t+(this._isUTC?0:6e4*this.utcOffset()),36e5);break;case"minute":t=this._d.valueOf(),t-=nn(t,6e4);break;case"second":t=this._d.valueOf(),t-=nn(t,1e3);break}return this._d.setTime(t),c.updateOffset(this,!0),this},mn.subtract=Bt,mn.toArray=function(){var e=this;return [e.year(),e.month(),e.date(),e.hour(),e.minute(),e.second(),e.millisecond()]},mn.toObject=function(){var e=this;return {years:e.year(),months:e.month(),date:e.date(),hours:e.hours(),minutes:e.minutes(),seconds:e.seconds(),milliseconds:e.milliseconds()}},mn.toDate=function(){return new Date(this.valueOf())},mn.toISOString=function(e){if(!this.isValid())return null;var t=!0!==e,n=t?this.clone().utc():this;return n.year()<0||9999<n.year()?A(n,t?"YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]":"YYYYYY-MM-DD[T]HH:mm:ss.SSSZ"):b(Date.prototype.toISOString)?t?this.toDate().toISOString():new Date(this.valueOf()+60*this.utcOffset()*1e3).toISOString().replace("Z",A(n,"Z")):A(n,t?"YYYY-MM-DD[T]HH:mm:ss.SSS[Z]":"YYYY-MM-DD[T]HH:mm:ss.SSSZ")},mn.inspect=function(){if(!this.isValid())return "moment.invalid(/* "+this._i+" */)";var e="moment",t="";this.isLocal()||(e=0===this.utcOffset()?"moment.utc":"moment.parseZone",t="Z");var n="["+e+'("]',s=0<=this.year()&&this.year()<=9999?"YYYY":"YYYYYY",i=t+'[")]';return this.format(n+s+"-MM-DD[T]HH:mm:ss.SSS"+i)},mn.toJSON=function(){return this.isValid()?this.toISOString():null},mn.toString=function(){return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ")},mn.unix=function(){return Math.floor(this.valueOf()/1e3)},mn.valueOf=function(){return this._d.valueOf()-6e4*(this._offset||0)},mn.creationData=function(){return {input:this._i,format:this._f,locale:this._locale,isUTC:this._isUTC,strict:this._strict}},mn.year=Oe,mn.isLeapYear=function(){return De(this.year())},mn.weekYear=function(e){return on.call(this,e,this.week(),this.weekday(),this.localeData()._week.dow,this.localeData()._week.doy)},mn.isoWeekYear=function(e){return on.call(this,e,this.isoWeek(),this.isoWeekday(),1,4)},mn.quarter=mn.quarters=function(e){return null==e?Math.ceil((this.month()+1)/3):this.month(3*(e-1)+this.month()%3)},mn.month=Ue,mn.daysInMonth=function(){return Pe(this.year(),this.month())},mn.week=mn.weeks=function(e){var t=this.localeData().week(this);return null==e?t:this.add(7*(e-t),"d")},mn.isoWeek=mn.isoWeeks=function(e){var t=Ie(this,1,4).week;return null==e?t:this.add(7*(e-t),"d")},mn.weeksInYear=function(){var e=this.localeData()._week;return Ae(this.year(),e.dow,e.doy)},mn.isoWeeksInYear=function(){return Ae(this.year(),1,4)},mn.date=un,mn.day=mn.days=function(e){if(!this.isValid())return null!=e?this:NaN;var t,n,s=this._isUTC?this._d.getUTCDay():this._d.getDay();return null!=e?(t=e,n=this.localeData(),e="string"!=typeof t?t:isNaN(t)?"number"==typeof(t=n.weekdaysParse(t))?t:null:parseInt(t,10),this.add(e-s,"d")):s},mn.weekday=function(e){if(!this.isValid())return null!=e?this:NaN;var t=(this.day()+7-this.localeData()._week.dow)%7;return null==e?t:this.add(e-t,"d")},mn.isoWeekday=function(e){if(!this.isValid())return null!=e?this:NaN;if(null==e)return this.day()||7;var t,n,s=(t=e,n=this.localeData(),"string"==typeof t?n.weekdaysParse(t)%7||7:isNaN(t)?null:t);return this.day(this.day()%7?s:s-7)},mn.dayOfYear=function(e){var t=Math.round((this.clone().startOf("day")-this.clone().startOf("year"))/864e5)+1;return null==e?t:this.add(e-t,"d")},mn.hour=mn.hours=nt,mn.minute=mn.minutes=ln,mn.second=mn.seconds=dn,mn.millisecond=mn.milliseconds=fn,mn.utcOffset=function(e,t,n){var s,i=this._offset||0;if(!this.isValid())return null!=e?this:NaN;if(null==e)return this._isUTC?i:Vt(this);if("string"==typeof e){if(null===(e=Nt(re,e)))return this}else Math.abs(e)<16&&!n&&(e*=60);return !this._isUTC&&t&&(s=Vt(this)),this._offset=e,this._isUTC=!0,null!=s&&this.add(s,"m"),i!==e&&(!t||this._changeInProgress?qt(this,jt(e-i,"m"),1,!1):this._changeInProgress||(this._changeInProgress=!0,c.updateOffset(this,!0),this._changeInProgress=null)),this},mn.utc=function(e){return this.utcOffset(0,e)},mn.local=function(e){return this._isUTC&&(this.utcOffset(0,e),this._isUTC=!1,e&&this.subtract(Vt(this),"m")),this},mn.parseZone=function(){if(null!=this._tzm)this.utcOffset(this._tzm,!1,!0);else if("string"==typeof this._i){var e=Nt(ie,this._i);null!=e?this.utcOffset(e):this.utcOffset(0,!0);}return this},mn.hasAlignedHourOffset=function(e){return !!this.isValid()&&(e=e?bt(e).utcOffset():0,(this.utcOffset()-e)%60==0)},mn.isDST=function(){return this.utcOffset()>this.clone().month(0).utcOffset()||this.utcOffset()>this.clone().month(5).utcOffset()},mn.isLocal=function(){return !!this.isValid()&&!this._isUTC},mn.isUtcOffset=function(){return !!this.isValid()&&this._isUTC},mn.isUtc=Et,mn.isUTC=Et,mn.zoneAbbr=function(){return this._isUTC?"UTC":""},mn.zoneName=function(){return this._isUTC?"Coordinated Universal Time":""},mn.dates=n("dates accessor is deprecated. Use date instead.",un),mn.months=n("months accessor is deprecated. Use month instead",Ue),mn.years=n("years accessor is deprecated. Use year instead",Oe),mn.zone=n("moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/",function(e,t){return null!=e?("string"!=typeof e&&(e=-e),this.utcOffset(e,t),this):-this.utcOffset()}),mn.isDSTShifted=n("isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information",function(){if(!l(this._isDSTShifted))return this._isDSTShifted;var e={};if(w(e,this),(e=Ot(e))._a){var t=e._isUTC?y(e._a):bt(e._a);this._isDSTShifted=this.isValid()&&0<a(e._a,t.toArray());}else this._isDSTShifted=!1;return this._isDSTShifted});var yn=P.prototype;function gn(e,t,n,s){var i=ht(),r=y().set(s,t);return i[n](r,e)}function vn(e,t,n){if(h(e)&&(t=e,e=void 0),e=e||"",null!=t)return gn(e,t,n,"month");var s,i=[];for(s=0;s<12;s++)i[s]=gn(e,s,n,"month");return i}function pn(e,t,n,s){t=("boolean"==typeof e?h(t)&&(n=t,t=void 0):(t=e,e=!1,h(n=t)&&(n=t,t=void 0)),t||"");var i,r=ht(),a=e?r._week.dow:0;if(null!=n)return gn(t,(n+a)%7,s,"day");var o=[];for(i=0;i<7;i++)o[i]=gn(t,(i+a)%7,s,"day");return o}yn.calendar=function(e,t,n){var s=this._calendar[e]||this._calendar.sameElse;return b(s)?s.call(t,n):s},yn.longDateFormat=function(e){var t=this._longDateFormat[e],n=this._longDateFormat[e.toUpperCase()];return t||!n?t:(this._longDateFormat[e]=n.replace(/MMMM|MM|DD|dddd/g,function(e){return e.slice(1)}),this._longDateFormat[e])},yn.invalidDate=function(){return this._invalidDate},yn.ordinal=function(e){return this._ordinal.replace("%d",e)},yn.preparse=_n,yn.postformat=_n,yn.relativeTime=function(e,t,n,s){var i=this._relativeTime[n];return b(i)?i(e,t,n,s):i.replace(/%d/i,e)},yn.pastFuture=function(e,t){var n=this._relativeTime[0<e?"future":"past"];return b(n)?n(t):n.replace(/%s/i,t)},yn.set=function(e){var t,n;for(n in e)b(t=e[n])?this[n]=t:this["_"+n]=t;this._config=e,this._dayOfMonthOrdinalParseLenient=new RegExp((this._dayOfMonthOrdinalParse.source||this._ordinalParse.source)+"|"+/\d{1,2}/.source);},yn.months=function(e,t){return e?o(this._months)?this._months[e.month()]:this._months[(this._months.isFormat||We).test(t)?"format":"standalone"][e.month()]:o(this._months)?this._months:this._months.standalone},yn.monthsShort=function(e,t){return e?o(this._monthsShort)?this._monthsShort[e.month()]:this._monthsShort[We.test(t)?"format":"standalone"][e.month()]:o(this._monthsShort)?this._monthsShort:this._monthsShort.standalone},yn.monthsParse=function(e,t,n){var s,i,r;if(this._monthsParseExact)return function(e,t,n){var s,i,r,a=e.toLocaleLowerCase();if(!this._monthsParse)for(this._monthsParse=[],this._longMonthsParse=[],this._shortMonthsParse=[],s=0;s<12;++s)r=y([2e3,s]),this._shortMonthsParse[s]=this.monthsShort(r,"").toLocaleLowerCase(),this._longMonthsParse[s]=this.months(r,"").toLocaleLowerCase();return n?"MMM"===t?-1!==(i=Ye.call(this._shortMonthsParse,a))?i:null:-1!==(i=Ye.call(this._longMonthsParse,a))?i:null:"MMM"===t?-1!==(i=Ye.call(this._shortMonthsParse,a))?i:-1!==(i=Ye.call(this._longMonthsParse,a))?i:null:-1!==(i=Ye.call(this._longMonthsParse,a))?i:-1!==(i=Ye.call(this._shortMonthsParse,a))?i:null}.call(this,e,t,n);for(this._monthsParse||(this._monthsParse=[],this._longMonthsParse=[],this._shortMonthsParse=[]),s=0;s<12;s++){if(i=y([2e3,s]),n&&!this._longMonthsParse[s]&&(this._longMonthsParse[s]=new RegExp("^"+this.months(i,"").replace(".","")+"$","i"),this._shortMonthsParse[s]=new RegExp("^"+this.monthsShort(i,"").replace(".","")+"$","i")),n||this._monthsParse[s]||(r="^"+this.months(i,"")+"|^"+this.monthsShort(i,""),this._monthsParse[s]=new RegExp(r.replace(".",""),"i")),n&&"MMMM"===t&&this._longMonthsParse[s].test(e))return s;if(n&&"MMM"===t&&this._shortMonthsParse[s].test(e))return s;if(!n&&this._monthsParse[s].test(e))return s}},yn.monthsRegex=function(e){return this._monthsParseExact?(m(this,"_monthsRegex")||Ne.call(this),e?this._monthsStrictRegex:this._monthsRegex):(m(this,"_monthsRegex")||(this._monthsRegex=Le),this._monthsStrictRegex&&e?this._monthsStrictRegex:this._monthsRegex)},yn.monthsShortRegex=function(e){return this._monthsParseExact?(m(this,"_monthsRegex")||Ne.call(this),e?this._monthsShortStrictRegex:this._monthsShortRegex):(m(this,"_monthsShortRegex")||(this._monthsShortRegex=Fe),this._monthsShortStrictRegex&&e?this._monthsShortStrictRegex:this._monthsShortRegex)},yn.week=function(e){return Ie(e,this._week.dow,this._week.doy).week},yn.firstDayOfYear=function(){return this._week.doy},yn.firstDayOfWeek=function(){return this._week.dow},yn.weekdays=function(e,t){var n=o(this._weekdays)?this._weekdays:this._weekdays[e&&!0!==e&&this._weekdays.isFormat.test(t)?"format":"standalone"];return !0===e?je(n,this._week.dow):e?n[e.day()]:n},yn.weekdaysMin=function(e){return !0===e?je(this._weekdaysMin,this._week.dow):e?this._weekdaysMin[e.day()]:this._weekdaysMin},yn.weekdaysShort=function(e){return !0===e?je(this._weekdaysShort,this._week.dow):e?this._weekdaysShort[e.day()]:this._weekdaysShort},yn.weekdaysParse=function(e,t,n){var s,i,r;if(this._weekdaysParseExact)return function(e,t,n){var s,i,r,a=e.toLocaleLowerCase();if(!this._weekdaysParse)for(this._weekdaysParse=[],this._shortWeekdaysParse=[],this._minWeekdaysParse=[],s=0;s<7;++s)r=y([2e3,1]).day(s),this._minWeekdaysParse[s]=this.weekdaysMin(r,"").toLocaleLowerCase(),this._shortWeekdaysParse[s]=this.weekdaysShort(r,"").toLocaleLowerCase(),this._weekdaysParse[s]=this.weekdays(r,"").toLocaleLowerCase();return n?"dddd"===t?-1!==(i=Ye.call(this._weekdaysParse,a))?i:null:"ddd"===t?-1!==(i=Ye.call(this._shortWeekdaysParse,a))?i:null:-1!==(i=Ye.call(this._minWeekdaysParse,a))?i:null:"dddd"===t?-1!==(i=Ye.call(this._weekdaysParse,a))?i:-1!==(i=Ye.call(this._shortWeekdaysParse,a))?i:-1!==(i=Ye.call(this._minWeekdaysParse,a))?i:null:"ddd"===t?-1!==(i=Ye.call(this._shortWeekdaysParse,a))?i:-1!==(i=Ye.call(this._weekdaysParse,a))?i:-1!==(i=Ye.call(this._minWeekdaysParse,a))?i:null:-1!==(i=Ye.call(this._minWeekdaysParse,a))?i:-1!==(i=Ye.call(this._weekdaysParse,a))?i:-1!==(i=Ye.call(this._shortWeekdaysParse,a))?i:null}.call(this,e,t,n);for(this._weekdaysParse||(this._weekdaysParse=[],this._minWeekdaysParse=[],this._shortWeekdaysParse=[],this._fullWeekdaysParse=[]),s=0;s<7;s++){if(i=y([2e3,1]).day(s),n&&!this._fullWeekdaysParse[s]&&(this._fullWeekdaysParse[s]=new RegExp("^"+this.weekdays(i,"").replace(".","\\.?")+"$","i"),this._shortWeekdaysParse[s]=new RegExp("^"+this.weekdaysShort(i,"").replace(".","\\.?")+"$","i"),this._minWeekdaysParse[s]=new RegExp("^"+this.weekdaysMin(i,"").replace(".","\\.?")+"$","i")),this._weekdaysParse[s]||(r="^"+this.weekdays(i,"")+"|^"+this.weekdaysShort(i,"")+"|^"+this.weekdaysMin(i,""),this._weekdaysParse[s]=new RegExp(r.replace(".",""),"i")),n&&"dddd"===t&&this._fullWeekdaysParse[s].test(e))return s;if(n&&"ddd"===t&&this._shortWeekdaysParse[s].test(e))return s;if(n&&"dd"===t&&this._minWeekdaysParse[s].test(e))return s;if(!n&&this._weekdaysParse[s].test(e))return s}},yn.weekdaysRegex=function(e){return this._weekdaysParseExact?(m(this,"_weekdaysRegex")||Qe.call(this),e?this._weekdaysStrictRegex:this._weekdaysRegex):(m(this,"_weekdaysRegex")||(this._weekdaysRegex=qe),this._weekdaysStrictRegex&&e?this._weekdaysStrictRegex:this._weekdaysRegex)},yn.weekdaysShortRegex=function(e){return this._weekdaysParseExact?(m(this,"_weekdaysRegex")||Qe.call(this),e?this._weekdaysShortStrictRegex:this._weekdaysShortRegex):(m(this,"_weekdaysShortRegex")||(this._weekdaysShortRegex=Je),this._weekdaysShortStrictRegex&&e?this._weekdaysShortStrictRegex:this._weekdaysShortRegex)},yn.weekdaysMinRegex=function(e){return this._weekdaysParseExact?(m(this,"_weekdaysRegex")||Qe.call(this),e?this._weekdaysMinStrictRegex:this._weekdaysMinRegex):(m(this,"_weekdaysMinRegex")||(this._weekdaysMinRegex=Be),this._weekdaysMinStrictRegex&&e?this._weekdaysMinStrictRegex:this._weekdaysMinRegex)},yn.isPM=function(e){return "p"===(e+"").toLowerCase().charAt(0)},yn.meridiem=function(e,t,n){return 11<e?n?"pm":"PM":n?"am":"AM"},ut("en",{dayOfMonthOrdinalParse:/\d{1,2}(th|st|nd|rd)/,ordinal:function(e){var t=e%10;return e+(1===D(e%100/10)?"th":1===t?"st":2===t?"nd":3===t?"rd":"th")}}),c.lang=n("moment.lang is deprecated. Use moment.locale instead.",ut),c.langData=n("moment.langData is deprecated. Use moment.localeData instead.",ht);var wn=Math.abs;function Mn(e,t,n,s){var i=jt(t,n);return e._milliseconds+=s*i._milliseconds,e._days+=s*i._days,e._months+=s*i._months,e._bubble()}function kn(e){return e<0?Math.floor(e):Math.ceil(e)}function Sn(e){return 4800*e/146097}function Dn(e){return 146097*e/4800}function Yn(e){return function(){return this.as(e)}}var On=Yn("ms"),Tn=Yn("s"),bn=Yn("m"),xn=Yn("h"),Pn=Yn("d"),Wn=Yn("w"),Cn=Yn("M"),Hn=Yn("Q"),Rn=Yn("y");function Un(e){return function(){return this.isValid()?this._data[e]:NaN}}var Fn=Un("milliseconds"),Ln=Un("seconds"),Nn=Un("minutes"),Gn=Un("hours"),Vn=Un("days"),En=Un("months"),In=Un("years");var An=Math.round,jn={ss:44,s:45,m:45,h:22,d:26,M:11};var Zn=Math.abs;function zn(e){return (0<e)-(e<0)||+e}function $n(){if(!this.isValid())return this.localeData().invalidDate();var e,t,n=Zn(this._milliseconds)/1e3,s=Zn(this._days),i=Zn(this._months);t=S((e=S(n/60))/60),n%=60,e%=60;var r=S(i/12),a=i%=12,o=s,u=t,l=e,h=n?n.toFixed(3).replace(/\.?0+$/,""):"",d=this.asSeconds();if(!d)return "P0D";var c=d<0?"-":"",f=zn(this._months)!==zn(d)?"-":"",m=zn(this._days)!==zn(d)?"-":"",_=zn(this._milliseconds)!==zn(d)?"-":"";return c+"P"+(r?f+r+"Y":"")+(a?f+a+"M":"")+(o?m+o+"D":"")+(u||l||h?"T":"")+(u?_+u+"H":"")+(l?_+l+"M":"")+(h?_+h+"S":"")}var qn=Ht.prototype;return qn.isValid=function(){return this._isValid},qn.abs=function(){var e=this._data;return this._milliseconds=wn(this._milliseconds),this._days=wn(this._days),this._months=wn(this._months),e.milliseconds=wn(e.milliseconds),e.seconds=wn(e.seconds),e.minutes=wn(e.minutes),e.hours=wn(e.hours),e.months=wn(e.months),e.years=wn(e.years),this},qn.add=function(e,t){return Mn(this,e,t,1)},qn.subtract=function(e,t){return Mn(this,e,t,-1)},qn.as=function(e){if(!this.isValid())return NaN;var t,n,s=this._milliseconds;if("month"===(e=H(e))||"quarter"===e||"year"===e)switch(t=this._days+s/864e5,n=this._months+Sn(t),e){case"month":return n;case"quarter":return n/3;case"year":return n/12}else switch(t=this._days+Math.round(Dn(this._months)),e){case"week":return t/7+s/6048e5;case"day":return t+s/864e5;case"hour":return 24*t+s/36e5;case"minute":return 1440*t+s/6e4;case"second":return 86400*t+s/1e3;case"millisecond":return Math.floor(864e5*t)+s;default:throw new Error("Unknown unit "+e)}},qn.asMilliseconds=On,qn.asSeconds=Tn,qn.asMinutes=bn,qn.asHours=xn,qn.asDays=Pn,qn.asWeeks=Wn,qn.asMonths=Cn,qn.asQuarters=Hn,qn.asYears=Rn,qn.valueOf=function(){return this.isValid()?this._milliseconds+864e5*this._days+this._months%12*2592e6+31536e6*D(this._months/12):NaN},qn._bubble=function(){var e,t,n,s,i,r=this._milliseconds,a=this._days,o=this._months,u=this._data;return 0<=r&&0<=a&&0<=o||r<=0&&a<=0&&o<=0||(r+=864e5*kn(Dn(o)+a),o=a=0),u.milliseconds=r%1e3,e=S(r/1e3),u.seconds=e%60,t=S(e/60),u.minutes=t%60,n=S(t/60),u.hours=n%24,o+=i=S(Sn(a+=S(n/24))),a-=kn(Dn(i)),s=S(o/12),o%=12,u.days=a,u.months=o,u.years=s,this},qn.clone=function(){return jt(this)},qn.get=function(e){return e=H(e),this.isValid()?this[e+"s"]():NaN},qn.milliseconds=Fn,qn.seconds=Ln,qn.minutes=Nn,qn.hours=Gn,qn.days=Vn,qn.weeks=function(){return S(this.days()/7)},qn.months=En,qn.years=In,qn.humanize=function(e){if(!this.isValid())return this.localeData().invalidDate();var t,n,s,i,r,a,o,u,l,h,d,c=this.localeData(),f=(n=!e,s=c,i=jt(t=this).abs(),r=An(i.as("s")),a=An(i.as("m")),o=An(i.as("h")),u=An(i.as("d")),l=An(i.as("M")),h=An(i.as("y")),(d=r<=jn.ss&&["s",r]||r<jn.s&&["ss",r]||a<=1&&["m"]||a<jn.m&&["mm",a]||o<=1&&["h"]||o<jn.h&&["hh",o]||u<=1&&["d"]||u<jn.d&&["dd",u]||l<=1&&["M"]||l<jn.M&&["MM",l]||h<=1&&["y"]||["yy",h])[2]=n,d[3]=0<+t,d[4]=s,function(e,t,n,s,i){return i.relativeTime(t||1,!!n,e,s)}.apply(null,d));return e&&(f=c.pastFuture(+this,f)),c.postformat(f)},qn.toISOString=$n,qn.toString=$n,qn.toJSON=$n,qn.locale=Xt,qn.localeData=en,qn.toIsoString=n("toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",$n),qn.lang=Kt,I("X",0,0,"unix"),I("x",0,0,"valueOf"),ue("x",se),ue("X",/[+-]?\d+(\.\d{1,3})?/),ce("X",function(e,t,n){n._d=new Date(1e3*parseFloat(e,10));}),ce("x",function(e,t,n){n._d=new Date(D(e));}),c.version="2.24.0",e=bt,c.fn=mn,c.min=function(){return Wt("isBefore",[].slice.call(arguments,0))},c.max=function(){return Wt("isAfter",[].slice.call(arguments,0))},c.now=function(){return Date.now?Date.now():+new Date},c.utc=y,c.unix=function(e){return bt(1e3*e)},c.months=function(e,t){return vn(e,t,"months")},c.isDate=d,c.locale=ut,c.invalid=p,c.duration=jt,c.isMoment=k,c.weekdays=function(e,t,n){return pn(e,t,n,"weekdays")},c.parseZone=function(){return bt.apply(null,arguments).parseZone()},c.localeData=ht,c.isDuration=Rt,c.monthsShort=function(e,t){return vn(e,t,"monthsShort")},c.weekdaysMin=function(e,t,n){return pn(e,t,n,"weekdaysMin")},c.defineLocale=lt,c.updateLocale=function(e,t){if(null!=t){var n,s,i=st;null!=(s=ot(e))&&(i=s._config),(n=new P(t=x(i,t))).parentLocale=it[e],it[e]=n,ut(e);}else null!=it[e]&&(null!=it[e].parentLocale?it[e]=it[e].parentLocale:null!=it[e]&&delete it[e]);return it[e]},c.locales=function(){return s(it)},c.weekdaysShort=function(e,t,n){return pn(e,t,n,"weekdaysShort")},c.normalizeUnits=H,c.relativeTimeRounding=function(e){return void 0===e?An:"function"==typeof e&&(An=e,!0)},c.relativeTimeThreshold=function(e,t){return void 0!==jn[e]&&(void 0===t?jn[e]:(jn[e]=t,"s"===e&&(jn.ss=t-1),!0))},c.calendarFormat=function(e,t){var n=e.diff(t,"days",!0);return n<-6?"sameElse":n<-1?"lastWeek":n<0?"lastDay":n<1?"sameDay":n<2?"nextDay":n<7?"nextWeek":"sameElse"},c.prototype=mn,c.HTML5_FMT={DATETIME_LOCAL:"YYYY-MM-DDTHH:mm",DATETIME_LOCAL_SECONDS:"YYYY-MM-DDTHH:mm:ss",DATETIME_LOCAL_MS:"YYYY-MM-DDTHH:mm:ss.SSS",DATE:"YYYY-MM-DD",TIME:"HH:mm",TIME_SECONDS:"HH:mm:ss",TIME_MS:"HH:mm:ss.SSS",WEEK:"GGGG-[W]WW",MONTH:"YYYY-MM"},c});
	});

	moment_min.suppressDeprecationWarnings = true;
	function getQuarterRegex(val) {
	  var reg = null;
	  Object.keys(REGEX_QUARTERS).forEach(function (key) {
	    if (reg) return;
	    if (REGEX_QUARTERS[key].test(val)) reg = REGEX_QUARTERS[key];
	  });
	  return reg;
	} // given a value parser return a function that returns date objects
	// instead of [year, quarter] tuples

	function quarterlyDateParser(field) {
	  var valueParser = quarterSplitValueParser(field);
	  return function (val) {
	    var _valueParser = valueParser(val),
	        _valueParser2 = _slicedToArray(_valueParser, 2),
	        year = _valueParser2[0],
	        quarter = _valueParser2[1];

	    return parseDate(Date.UTC(year, 1 + 3 * (quarter - 1), 1));
	  };
	} // return a function that parses [year, quarter]

	function quarterSplitValueParser(field) {
	  var initialValue = getFirstValue(field.data);
	  var reg = getQuarterRegex(initialValue);
	  return function (val) {
	    if (val === null) return val;
	    if (!val.split) return val; // make sure it's a string

	    var year, quarter;

	    if (reg === REGEX_QUARTERS.quarter_year || reg === REGEX_QUARTERS.quarter_year_alt) {
	      var _val$split = val.split(' ');

	      var _val$split2 = _slicedToArray(_val$split, 2);

	      quarter = _val$split2[0];
	      year = _val$split2[1];
	    } else if (reg === REGEX_QUARTERS.quarter_dash_year) {
	      var _val$split3 = val.split('-');

	      var _val$split4 = _slicedToArray(_val$split3, 2);

	      quarter = _val$split4[0];
	      year = _val$split4[1];
	    } else if (reg === REGEX_QUARTERS.quarter_year_nospace) {
	      quarter = val.slice(1, 2);
	      year = val.slice(2);
	    } else if (reg === REGEX_QUARTERS.quarter_year_nospace2) {
	      var _val$replace$split = val.replace(/\s|-|'/g, '').split('Q');

	      var _val$replace$split2 = _slicedToArray(_val$replace$split, 2);

	      quarter = _val$replace$split2[0];
	      year = _val$replace$split2[1];
	    } else if (reg === REGEX_QUARTERS.year_quarter || reg === REGEX_QUARTERS.year_quarter_nospace || reg === REGEX_QUARTERS.year_dash_quarter) {
	      var _val$replace$split3 = val.replace(/\s|-|'/g, '').split('Q');

	      var _val$replace$split4 = _slicedToArray(_val$replace$split3, 2);

	      year = _val$replace$split4[0];
	      quarter = _val$replace$split4[1];
	    } // filter out Q and '


	    year = year || '';
	    quarter = quarter || '';
	    year = year.replace('\'', '');
	    quarter = quarter.replace('Q', ''); // NOTE:: be sure to fix this naive method if still running in 2050

	    if (year.length === 2) {
	      year = Number(year) < 50 ? '20' + year : '19' + year;
	    }

	    return [Number(year), Number(quarter)];
	  };
	} // get field from chartData
	// currently only grabs x or y axis

	function getFieldValueParser(chartData) {
	  var isPrimaryAxis = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
	  var forceCategorical = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

	  if (isPrimaryAxis) {
	    return fieldValueParser(chartData.fields[0], forceCategorical);
	  }

	  return fieldValueParser(chartData.fields[1], forceCategorical);
	} // convenience function for mapping an index to a parsed value

	function getFieldIndexValueParser(chartData) {
	  var isPrimaryAxis = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
	  var forceCategorical = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
	  var field = isPrimaryAxis ? chartData.fields[0] : chartData.fields[1];
	  var parser = fieldValueParser(field, forceCategorical);
	  return function (index) {
	    return parser(field.data[index]);
	  };
	} // return a function that parses a value based on the field taxonomy
	// for now its only date values we need to parse

	function fieldValueParser(field, forceCategorical) {
	  if (field && field.taxonomy && field.taxonomy.isQuarters) {
	    return function (v) {
	      return v;
	    };
	  } else if (field && field.taxonomy && field.taxonomy.isDate && !forceCategorical) {
	    return fieldDateParser(field);
	  } else {
	    return function (v) {
	      return v;
	    };
	  }
	} // bind field to parseDate method

	function fieldDateParser(field) {
	  if (field && field.taxonomy && field.taxonomy.isQuarters) {
	    return quarterlyDateParser(field);
	  } else {
	    return function (val) {
	      return parseDate(val, field);
	    };
	  }
	}
	function parseDate(val, field, testDate) {
	  var timeZoneOffset = 0;

	  if (field && field.taxonomy) {
	    timeZoneOffset = field.taxonomy.timeZoneOffset || 0;
	  } // if customFormatter is supplied on the field we use that


	  if (field && field.taxonomy && field.taxonomy.customFormatter) {
	    var customDate = moment_min.utc(val, field.taxonomy.customFormatter).utcOffset(timeZoneOffset);
	    if (customDate.isValid()) return customDate;
	  } // first pass is through moment directly - this will keep UTC strings as
	  // is rather than passing them through Date constructor that offsets by
	  // local timezone


	  var momentDate = moment_min.utc(val).utcOffset(timeZoneOffset);
	  if (momentDate.isValid()) return momentDate; // special case for years because utc("2050") fails
	  // using Jan 2nd because future years have offset more than 1 day

	  if (val && val.length && val.length === 4) {
	    momentDate = moment_min.utc('1/2/' + val).utcOffset(timeZoneOffset);
	    if (momentDate.isValid()) return momentDate;
	  } // second pass casts through Date() we have to manually offset timezone
	  // here, only for positiveOffsets (negative timezone shift like NYC)


	  var dateVal = new Date(val);

	  if (dateVal.getTimezoneOffset() > 0) {
	    dateVal = new Date(dateVal.getTime() + dateVal.getTimezoneOffset() * MS_IN_MINUTE);
	  }

	  if (!isNaN(dateVal.valueOf())) return moment_min.utc(dateVal).utcOffset(timeZoneOffset); // charts shouldn't break if a single date breaks

	  if (testDate) return null;
	  return moment_min.utc(new Date('1/1/1900'));
	} // convert vals like 400.0M to 400000000
	// consumed by moment and _NOT_ new Date()

	function dateToUTCString(d, field) {
	  var val = fieldDateParser(field)(d);
	  if (val.isValid()) return val.format();
	  return '';
	}

	var nativeJoin = [].join;

	var ES3_STRINGS = indexedObject != Object;
	var STRICT_METHOD$2 = arrayMethodIsStrict('join', ',');

	// `Array.prototype.join` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.join
	_export({ target: 'Array', proto: true, forced: ES3_STRINGS || !STRICT_METHOD$2 }, {
	  join: function join(separator) {
	    return nativeJoin.call(toIndexedObject(this), separator === undefined ? ',' : separator);
	  }
	});

	// `thisNumberValue` abstract operation
	// https://tc39.github.io/ecma262/#sec-thisnumbervalue
	var thisNumberValue = function (value) {
	  if (typeof value != 'number' && classofRaw(value) != 'Number') {
	    throw TypeError('Incorrect invocation');
	  }
	  return +value;
	};

	// `String.prototype.repeat` method implementation
	// https://tc39.github.io/ecma262/#sec-string.prototype.repeat
	var stringRepeat = ''.repeat || function repeat(count) {
	  var str = String(requireObjectCoercible(this));
	  var result = '';
	  var n = toInteger$1(count);
	  if (n < 0 || n == Infinity) throw RangeError('Wrong number of repetitions');
	  for (;n > 0; (n >>>= 1) && (str += str)) if (n & 1) result += str;
	  return result;
	};

	var nativeToFixed = 1.0.toFixed;
	var floor = Math.floor;

	var pow$2 = function (x, n, acc) {
	  return n === 0 ? acc : n % 2 === 1 ? pow$2(x, n - 1, acc * x) : pow$2(x * x, n / 2, acc);
	};

	var log$2 = function (x) {
	  var n = 0;
	  var x2 = x;
	  while (x2 >= 4096) {
	    n += 12;
	    x2 /= 4096;
	  }
	  while (x2 >= 2) {
	    n += 1;
	    x2 /= 2;
	  } return n;
	};

	var FORCED = nativeToFixed && (
	  0.00008.toFixed(3) !== '0.000' ||
	  0.9.toFixed(0) !== '1' ||
	  1.255.toFixed(2) !== '1.25' ||
	  1000000000000000128.0.toFixed(0) !== '1000000000000000128'
	) || !fails(function () {
	  // V8 ~ Android 4.3-
	  nativeToFixed.call({});
	});

	// `Number.prototype.toFixed` method
	// https://tc39.github.io/ecma262/#sec-number.prototype.tofixed
	_export({ target: 'Number', proto: true, forced: FORCED }, {
	  // eslint-disable-next-line max-statements
	  toFixed: function toFixed(fractionDigits) {
	    var number = thisNumberValue(this);
	    var fractDigits = toInteger$1(fractionDigits);
	    var data = [0, 0, 0, 0, 0, 0];
	    var sign = '';
	    var result = '0';
	    var e, z, j, k;

	    var multiply = function (n, c) {
	      var index = -1;
	      var c2 = c;
	      while (++index < 6) {
	        c2 += n * data[index];
	        data[index] = c2 % 1e7;
	        c2 = floor(c2 / 1e7);
	      }
	    };

	    var divide = function (n) {
	      var index = 6;
	      var c = 0;
	      while (--index >= 0) {
	        c += data[index];
	        data[index] = floor(c / n);
	        c = (c % n) * 1e7;
	      }
	    };

	    var dataToString = function () {
	      var index = 6;
	      var s = '';
	      while (--index >= 0) {
	        if (s !== '' || index === 0 || data[index] !== 0) {
	          var t = String(data[index]);
	          s = s === '' ? t : s + stringRepeat.call('0', 7 - t.length) + t;
	        }
	      } return s;
	    };

	    if (fractDigits < 0 || fractDigits > 20) throw RangeError('Incorrect fraction digits');
	    // eslint-disable-next-line no-self-compare
	    if (number != number) return 'NaN';
	    if (number <= -1e21 || number >= 1e21) return String(number);
	    if (number < 0) {
	      sign = '-';
	      number = -number;
	    }
	    if (number > 1e-21) {
	      e = log$2(number * pow$2(2, 69, 1)) - 69;
	      z = e < 0 ? number * pow$2(2, -e, 1) : number / pow$2(2, e, 1);
	      z *= 0x10000000000000;
	      e = 52 - e;
	      if (e > 0) {
	        multiply(0, z);
	        j = fractDigits;
	        while (j >= 7) {
	          multiply(1e7, 0);
	          j -= 7;
	        }
	        multiply(pow$2(10, j, 1), 0);
	        j = e - 1;
	        while (j >= 23) {
	          divide(1 << 23);
	          j -= 23;
	        }
	        divide(1 << j);
	        multiply(1, 1);
	        divide(2);
	        result = dataToString();
	      } else {
	        multiply(0, z);
	        multiply(1 << -e, 0);
	        result = dataToString() + stringRepeat.call('0', fractDigits);
	      }
	    }
	    if (fractDigits > 0) {
	      k = result.length;
	      result = sign + (k <= fractDigits
	        ? '0.' + stringRepeat.call('0', fractDigits - k) + result
	        : result.slice(0, k - fractDigits) + '.' + result.slice(k - fractDigits));
	    } else {
	      result = sign + result;
	    } return result;
	  }
	});

	var getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;






	var nativeEndsWith = ''.endsWith;
	var min$3 = Math.min;

	var CORRECT_IS_REGEXP_LOGIC = correctIsRegexpLogic('endsWith');
	// https://github.com/zloirock/core-js/pull/702
	var MDN_POLYFILL_BUG = !CORRECT_IS_REGEXP_LOGIC && !!function () {
	  var descriptor = getOwnPropertyDescriptor(String.prototype, 'endsWith');
	  return descriptor && !descriptor.writable;
	}();

	// `String.prototype.endsWith` method
	// https://tc39.github.io/ecma262/#sec-string.prototype.endswith
	_export({ target: 'String', proto: true, forced: !MDN_POLYFILL_BUG && !CORRECT_IS_REGEXP_LOGIC }, {
	  endsWith: function endsWith(searchString /* , endPosition = @length */) {
	    var that = String(requireObjectCoercible(this));
	    notARegexp(searchString);
	    var endPosition = arguments.length > 1 ? arguments[1] : undefined;
	    var len = toLength(that.length);
	    var end = endPosition === undefined ? len : min$3(toLength(endPosition), len);
	    var search = String(searchString);
	    return nativeEndsWith
	      ? nativeEndsWith.call(that, search, end)
	      : that.slice(end - search.length, end) === search;
	  }
	});

	function formatDecimal(x) {
	  return Math.abs(x = Math.round(x)) >= 1e21
	      ? x.toLocaleString("en").replace(/,/g, "")
	      : x.toString(10);
	}

	// Computes the decimal coefficient and exponent of the specified number x with
	// significant digits p, where x is positive and p is in [1, 21] or undefined.
	// For example, formatDecimalParts(1.23) returns ["123", 0].
	function formatDecimalParts(x, p) {
	  if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, Â±Infinity
	  var i, coefficient = x.slice(0, i);

	  // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
	  // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
	  return [
	    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
	    +x.slice(i + 1)
	  ];
	}

	function exponent(x) {
	  return x = formatDecimalParts(Math.abs(x)), x ? x[1] : NaN;
	}

	function formatGroup(grouping, thousands) {
	  return function(value, width) {
	    var i = value.length,
	        t = [],
	        j = 0,
	        g = grouping[0],
	        length = 0;

	    while (i > 0 && g > 0) {
	      if (length + g + 1 > width) g = Math.max(1, width - length);
	      t.push(value.substring(i -= g, i + g));
	      if ((length += g + 1) > width) break;
	      g = grouping[j = (j + 1) % grouping.length];
	    }

	    return t.reverse().join(thousands);
	  };
	}

	function formatNumerals(numerals) {
	  return function(value) {
	    return value.replace(/[0-9]/g, function(i) {
	      return numerals[+i];
	    });
	  };
	}

	// [[fill]align][sign][symbol][0][width][,][.precision][~][type]
	var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;

	function formatSpecifier(specifier) {
	  if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
	  var match;
	  return new FormatSpecifier({
	    fill: match[1],
	    align: match[2],
	    sign: match[3],
	    symbol: match[4],
	    zero: match[5],
	    width: match[6],
	    comma: match[7],
	    precision: match[8] && match[8].slice(1),
	    trim: match[9],
	    type: match[10]
	  });
	}

	formatSpecifier.prototype = FormatSpecifier.prototype; // instanceof

	function FormatSpecifier(specifier) {
	  this.fill = specifier.fill === undefined ? " " : specifier.fill + "";
	  this.align = specifier.align === undefined ? ">" : specifier.align + "";
	  this.sign = specifier.sign === undefined ? "-" : specifier.sign + "";
	  this.symbol = specifier.symbol === undefined ? "" : specifier.symbol + "";
	  this.zero = !!specifier.zero;
	  this.width = specifier.width === undefined ? undefined : +specifier.width;
	  this.comma = !!specifier.comma;
	  this.precision = specifier.precision === undefined ? undefined : +specifier.precision;
	  this.trim = !!specifier.trim;
	  this.type = specifier.type === undefined ? "" : specifier.type + "";
	}

	FormatSpecifier.prototype.toString = function() {
	  return this.fill
	      + this.align
	      + this.sign
	      + this.symbol
	      + (this.zero ? "0" : "")
	      + (this.width === undefined ? "" : Math.max(1, this.width | 0))
	      + (this.comma ? "," : "")
	      + (this.precision === undefined ? "" : "." + Math.max(0, this.precision | 0))
	      + (this.trim ? "~" : "")
	      + this.type;
	};

	// Trims insignificant zeros, e.g., replaces 1.2000k with 1.2k.
	function formatTrim(s) {
	  out: for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
	    switch (s[i]) {
	      case ".": i0 = i1 = i; break;
	      case "0": if (i0 === 0) i0 = i; i1 = i; break;
	      default: if (!+s[i]) break out; if (i0 > 0) i0 = 0; break;
	    }
	  }
	  return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
	}

	var prefixExponent;

	function formatPrefixAuto(x, p) {
	  var d = formatDecimalParts(x, p);
	  if (!d) return x + "";
	  var coefficient = d[0],
	      exponent = d[1],
	      i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
	      n = coefficient.length;
	  return i === n ? coefficient
	      : i > n ? coefficient + new Array(i - n + 1).join("0")
	      : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i)
	      : "0." + new Array(1 - i).join("0") + formatDecimalParts(x, Math.max(0, p + i - 1))[0]; // less than 1y!
	}

	function formatRounded(x, p) {
	  var d = formatDecimalParts(x, p);
	  if (!d) return x + "";
	  var coefficient = d[0],
	      exponent = d[1];
	  return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient
	      : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1)
	      : coefficient + new Array(exponent - coefficient.length + 2).join("0");
	}

	var formatTypes = {
	  "%": function(x, p) { return (x * 100).toFixed(p); },
	  "b": function(x) { return Math.round(x).toString(2); },
	  "c": function(x) { return x + ""; },
	  "d": formatDecimal,
	  "e": function(x, p) { return x.toExponential(p); },
	  "f": function(x, p) { return x.toFixed(p); },
	  "g": function(x, p) { return x.toPrecision(p); },
	  "o": function(x) { return Math.round(x).toString(8); },
	  "p": function(x, p) { return formatRounded(x * 100, p); },
	  "r": formatRounded,
	  "s": formatPrefixAuto,
	  "X": function(x) { return Math.round(x).toString(16).toUpperCase(); },
	  "x": function(x) { return Math.round(x).toString(16); }
	};

	function identity$5(x) {
	  return x;
	}

	var map$2 = Array.prototype.map,
	    prefixes = ["y","z","a","f","p","n","Âµ","m","","k","M","G","T","P","E","Z","Y"];

	function formatLocale$1(locale) {
	  var group = locale.grouping === undefined || locale.thousands === undefined ? identity$5 : formatGroup(map$2.call(locale.grouping, Number), locale.thousands + ""),
	      currencyPrefix = locale.currency === undefined ? "" : locale.currency[0] + "",
	      currencySuffix = locale.currency === undefined ? "" : locale.currency[1] + "",
	      decimal = locale.decimal === undefined ? "." : locale.decimal + "",
	      numerals = locale.numerals === undefined ? identity$5 : formatNumerals(map$2.call(locale.numerals, String)),
	      percent = locale.percent === undefined ? "%" : locale.percent + "",
	      minus = locale.minus === undefined ? "-" : locale.minus + "",
	      nan = locale.nan === undefined ? "NaN" : locale.nan + "";

	  function newFormat(specifier) {
	    specifier = formatSpecifier(specifier);

	    var fill = specifier.fill,
	        align = specifier.align,
	        sign = specifier.sign,
	        symbol = specifier.symbol,
	        zero = specifier.zero,
	        width = specifier.width,
	        comma = specifier.comma,
	        precision = specifier.precision,
	        trim = specifier.trim,
	        type = specifier.type;

	    // The "n" type is an alias for ",g".
	    if (type === "n") comma = true, type = "g";

	    // The "" type, and any invalid type, is an alias for ".12~g".
	    else if (!formatTypes[type]) precision === undefined && (precision = 12), trim = true, type = "g";

	    // If zero fill is specified, padding goes after sign and before digits.
	    if (zero || (fill === "0" && align === "=")) zero = true, fill = "0", align = "=";

	    // Compute the prefix and suffix.
	    // For SI-prefix, the suffix is lazily computed.
	    var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
	        suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "";

	    // What format function should we use?
	    // Is this an integer type?
	    // Can this type generate exponential notation?
	    var formatType = formatTypes[type],
	        maybeSuffix = /[defgprs%]/.test(type);

	    // Set the default precision if not specified,
	    // or clamp the specified precision to the supported range.
	    // For significant precision, it must be in [1, 21].
	    // For fixed precision, it must be in [0, 20].
	    precision = precision === undefined ? 6
	        : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))
	        : Math.max(0, Math.min(20, precision));

	    function format(value) {
	      var valuePrefix = prefix,
	          valueSuffix = suffix,
	          i, n, c;

	      if (type === "c") {
	        valueSuffix = formatType(value) + valueSuffix;
	        value = "";
	      } else {
	        value = +value;

	        // Determine the sign. -0 is not less than 0, but 1 / -0 is!
	        var valueNegative = value < 0 || 1 / value < 0;

	        // Perform the initial formatting.
	        value = isNaN(value) ? nan : formatType(Math.abs(value), precision);

	        // Trim insignificant zeros.
	        if (trim) value = formatTrim(value);

	        // If a negative value rounds to zero after formatting, and no explicit positive sign is requested, hide the sign.
	        if (valueNegative && +value === 0 && sign !== "+") valueNegative = false;

	        // Compute the prefix and suffix.
	        valuePrefix = (valueNegative ? (sign === "(" ? sign : minus) : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
	        valueSuffix = (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");

	        // Break the formatted value into the integer âvalueâ part that can be
	        // grouped, and fractional or exponential âsuffixâ part that is not.
	        if (maybeSuffix) {
	          i = -1, n = value.length;
	          while (++i < n) {
	            if (c = value.charCodeAt(i), 48 > c || c > 57) {
	              valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
	              value = value.slice(0, i);
	              break;
	            }
	          }
	        }
	      }

	      // If the fill character is not "0", grouping is applied before padding.
	      if (comma && !zero) value = group(value, Infinity);

	      // Compute the padding.
	      var length = valuePrefix.length + value.length + valueSuffix.length,
	          padding = length < width ? new Array(width - length + 1).join(fill) : "";

	      // If the fill character is "0", grouping is applied after padding.
	      if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";

	      // Reconstruct the final output based on the desired alignment.
	      switch (align) {
	        case "<": value = valuePrefix + value + valueSuffix + padding; break;
	        case "=": value = valuePrefix + padding + value + valueSuffix; break;
	        case "^": value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length); break;
	        default: value = padding + valuePrefix + value + valueSuffix; break;
	      }

	      return numerals(value);
	    }

	    format.toString = function() {
	      return specifier + "";
	    };

	    return format;
	  }

	  function formatPrefix(specifier, value) {
	    var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)),
	        e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3,
	        k = Math.pow(10, -e),
	        prefix = prefixes[8 + e / 3];
	    return function(value) {
	      return f(k * value) + prefix;
	    };
	  }

	  return {
	    format: newFormat,
	    formatPrefix: formatPrefix
	  };
	}

	var locale$1;
	var format;
	var formatPrefix;

	defaultLocale$1({
	  decimal: ".",
	  thousands: ",",
	  grouping: [3],
	  currency: ["$", ""],
	  minus: "-"
	});

	function defaultLocale$1(definition) {
	  locale$1 = formatLocale$1(definition);
	  format = locale$1.format;
	  formatPrefix = locale$1.formatPrefix;
	  return locale$1;
	}

	function precisionFixed(step) {
	  return Math.max(0, -exponent(Math.abs(step)));
	}

	function precisionPrefix(step, value) {
	  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3 - exponent(Math.abs(step)));
	}

	function precisionRound(step, max) {
	  step = Math.abs(step), max = Math.abs(max) - step;
	  return Math.max(0, exponent(max) - exponent(step)) + 1;
	}

	/**
	 * Checks if `value` is classified as an `Array` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
	 * @example
	 *
	 * _.isArray([1, 2, 3]);
	 * // => true
	 *
	 * _.isArray(document.body.children);
	 * // => false
	 *
	 * _.isArray('abc');
	 * // => false
	 *
	 * _.isArray(_.noop);
	 * // => false
	 */
	var isArray = Array.isArray;

	var isArray_1 = isArray;

	/** Detect free variable `global` from Node.js. */
	var freeGlobal$1 = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

	var _freeGlobal = freeGlobal$1;

	/** Detect free variable `self`. */
	var freeSelf$1 = typeof self == 'object' && self && self.Object === Object && self;

	/** Used as a reference to the global object. */
	var root$2 = _freeGlobal || freeSelf$1 || Function('return this')();

	var _root = root$2;

	/** Built-in value references. */
	var Symbol$1 = _root.Symbol;

	var _Symbol = Symbol$1;

	/** Used for built-in method references. */
	var objectProto$7 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$5 = objectProto$7.hasOwnProperty;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString$1 = objectProto$7.toString;

	/** Built-in value references. */
	var symToStringTag$1 = _Symbol ? _Symbol.toStringTag : undefined;

	/**
	 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the raw `toStringTag`.
	 */
	function getRawTag(value) {
	  var isOwn = hasOwnProperty$5.call(value, symToStringTag$1),
	      tag = value[symToStringTag$1];

	  try {
	    value[symToStringTag$1] = undefined;
	    var unmasked = true;
	  } catch (e) {}

	  var result = nativeObjectToString$1.call(value);
	  if (unmasked) {
	    if (isOwn) {
	      value[symToStringTag$1] = tag;
	    } else {
	      delete value[symToStringTag$1];
	    }
	  }
	  return result;
	}

	var _getRawTag = getRawTag;

	/** Used for built-in method references. */
	var objectProto$6 = Object.prototype;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString = objectProto$6.toString;

	/**
	 * Converts `value` to a string using `Object.prototype.toString`.
	 *
	 * @private
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 */
	function objectToString$1(value) {
	  return nativeObjectToString.call(value);
	}

	var _objectToString = objectToString$1;

	/** `Object#toString` result references. */
	var nullTag = '[object Null]',
	    undefinedTag = '[object Undefined]';

	/** Built-in value references. */
	var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;

	/**
	 * The base implementation of `getTag` without fallbacks for buggy environments.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	function baseGetTag(value) {
	  if (value == null) {
	    return value === undefined ? undefinedTag : nullTag;
	  }
	  return (symToStringTag && symToStringTag in Object(value))
	    ? _getRawTag(value)
	    : _objectToString(value);
	}

	var _baseGetTag = baseGetTag;

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike$1(value) {
	  return value != null && typeof value == 'object';
	}

	var isObjectLike_1 = isObjectLike$1;

	/** `Object#toString` result references. */
	var symbolTag$3 = '[object Symbol]';

	/**
	 * Checks if `value` is classified as a `Symbol` primitive or object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
	 * @example
	 *
	 * _.isSymbol(Symbol.iterator);
	 * // => true
	 *
	 * _.isSymbol('abc');
	 * // => false
	 */
	function isSymbol$3(value) {
	  return typeof value == 'symbol' ||
	    (isObjectLike_1(value) && _baseGetTag(value) == symbolTag$3);
	}

	var isSymbol_1 = isSymbol$3;

	/** Used to match property names within property paths. */
	var reIsDeepProp$1 = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
	    reIsPlainProp$1 = /^\w*$/;

	/**
	 * Checks if `value` is a property name and not a property path.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {Object} [object] The object to query keys on.
	 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
	 */
	function isKey$1(value, object) {
	  if (isArray_1(value)) {
	    return false;
	  }
	  var type = typeof value;
	  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
	      value == null || isSymbol_1(value)) {
	    return true;
	  }
	  return reIsPlainProp$1.test(value) || !reIsDeepProp$1.test(value) ||
	    (object != null && value in Object(object));
	}

	var _isKey = isKey$1;

	/**
	 * Checks if `value` is the
	 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(_.noop);
	 * // => true
	 *
	 * _.isObject(null);
	 * // => false
	 */
	function isObject$1(value) {
	  var type = typeof value;
	  return value != null && (type == 'object' || type == 'function');
	}

	var isObject_1 = isObject$1;

	/** `Object#toString` result references. */
	var asyncTag = '[object AsyncFunction]',
	    funcTag = '[object Function]',
	    genTag = '[object GeneratorFunction]',
	    proxyTag = '[object Proxy]';

	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction(value) {
	  if (!isObject_1(value)) {
	    return false;
	  }
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in Safari 9 which returns 'object' for typed arrays and other constructors.
	  var tag = _baseGetTag(value);
	  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
	}

	var isFunction_1 = isFunction;

	/** Used to detect overreaching core-js shims. */
	var coreJsData = _root['__core-js_shared__'];

	var _coreJsData = coreJsData;

	/** Used to detect methods masquerading as native. */
	var maskSrcKey = (function() {
	  var uid = /[^.]+$/.exec(_coreJsData && _coreJsData.keys && _coreJsData.keys.IE_PROTO || '');
	  return uid ? ('Symbol(src)_1.' + uid) : '';
	}());

	/**
	 * Checks if `func` has its source masked.
	 *
	 * @private
	 * @param {Function} func The function to check.
	 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
	 */
	function isMasked(func) {
	  return !!maskSrcKey && (maskSrcKey in func);
	}

	var _isMasked = isMasked;

	/** Used for built-in method references. */
	var funcProto$1 = Function.prototype;

	/** Used to resolve the decompiled source of functions. */
	var funcToString$1 = funcProto$1.toString;

	/**
	 * Converts `func` to its source code.
	 *
	 * @private
	 * @param {Function} func The function to convert.
	 * @returns {string} Returns the source code.
	 */
	function toSource(func) {
	  if (func != null) {
	    try {
	      return funcToString$1.call(func);
	    } catch (e) {}
	    try {
	      return (func + '');
	    } catch (e) {}
	  }
	  return '';
	}

	var _toSource = toSource;

	/**
	 * Used to match `RegExp`
	 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
	 */
	var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

	/** Used to detect host constructors (Safari). */
	var reIsHostCtor = /^\[object .+?Constructor\]$/;

	/** Used for built-in method references. */
	var funcProto = Function.prototype,
	    objectProto$5 = Object.prototype;

	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;

	/** Used to check objects for own properties. */
	var hasOwnProperty$4 = objectProto$5.hasOwnProperty;

	/** Used to detect if a method is native. */
	var reIsNative = RegExp('^' +
	  funcToString.call(hasOwnProperty$4).replace(reRegExpChar, '\\$&')
	  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	);

	/**
	 * The base implementation of `_.isNative` without bad shim checks.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a native function,
	 *  else `false`.
	 */
	function baseIsNative(value) {
	  if (!isObject_1(value) || _isMasked(value)) {
	    return false;
	  }
	  var pattern = isFunction_1(value) ? reIsNative : reIsHostCtor;
	  return pattern.test(_toSource(value));
	}

	var _baseIsNative = baseIsNative;

	/**
	 * Gets the value at `key` of `object`.
	 *
	 * @private
	 * @param {Object} [object] The object to query.
	 * @param {string} key The key of the property to get.
	 * @returns {*} Returns the property value.
	 */
	function getValue(object, key) {
	  return object == null ? undefined : object[key];
	}

	var _getValue = getValue;

	/**
	 * Gets the native function at `key` of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the method to get.
	 * @returns {*} Returns the function if it's native, else `undefined`.
	 */
	function getNative(object, key) {
	  var value = _getValue(object, key);
	  return _baseIsNative(value) ? value : undefined;
	}

	var _getNative = getNative;

	/* Built-in method references that are verified to be native. */
	var nativeCreate = _getNative(Object, 'create');

	var _nativeCreate = nativeCreate;

	/**
	 * Removes all key-value entries from the hash.
	 *
	 * @private
	 * @name clear
	 * @memberOf Hash
	 */
	function hashClear() {
	  this.__data__ = _nativeCreate ? _nativeCreate(null) : {};
	  this.size = 0;
	}

	var _hashClear = hashClear;

	/**
	 * Removes `key` and its value from the hash.
	 *
	 * @private
	 * @name delete
	 * @memberOf Hash
	 * @param {Object} hash The hash to modify.
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function hashDelete(key) {
	  var result = this.has(key) && delete this.__data__[key];
	  this.size -= result ? 1 : 0;
	  return result;
	}

	var _hashDelete = hashDelete;

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED$2 = '__lodash_hash_undefined__';

	/** Used for built-in method references. */
	var objectProto$4 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$3 = objectProto$4.hasOwnProperty;

	/**
	 * Gets the hash value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Hash
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function hashGet(key) {
	  var data = this.__data__;
	  if (_nativeCreate) {
	    var result = data[key];
	    return result === HASH_UNDEFINED$2 ? undefined : result;
	  }
	  return hasOwnProperty$3.call(data, key) ? data[key] : undefined;
	}

	var _hashGet = hashGet;

	/** Used for built-in method references. */
	var objectProto$3 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$2 = objectProto$3.hasOwnProperty;

	/**
	 * Checks if a hash value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Hash
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function hashHas(key) {
	  var data = this.__data__;
	  return _nativeCreate ? (data[key] !== undefined) : hasOwnProperty$2.call(data, key);
	}

	var _hashHas = hashHas;

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';

	/**
	 * Sets the hash `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Hash
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the hash instance.
	 */
	function hashSet(key, value) {
	  var data = this.__data__;
	  this.size += this.has(key) ? 0 : 1;
	  data[key] = (_nativeCreate && value === undefined) ? HASH_UNDEFINED$1 : value;
	  return this;
	}

	var _hashSet = hashSet;

	/**
	 * Creates a hash object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Hash(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `Hash`.
	Hash.prototype.clear = _hashClear;
	Hash.prototype['delete'] = _hashDelete;
	Hash.prototype.get = _hashGet;
	Hash.prototype.has = _hashHas;
	Hash.prototype.set = _hashSet;

	var _Hash = Hash;

	/**
	 * Removes all key-value entries from the list cache.
	 *
	 * @private
	 * @name clear
	 * @memberOf ListCache
	 */
	function listCacheClear() {
	  this.__data__ = [];
	  this.size = 0;
	}

	var _listCacheClear = listCacheClear;

	/**
	 * Performs a
	 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * comparison between two values to determine if they are equivalent.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 * var other = { 'a': 1 };
	 *
	 * _.eq(object, object);
	 * // => true
	 *
	 * _.eq(object, other);
	 * // => false
	 *
	 * _.eq('a', 'a');
	 * // => true
	 *
	 * _.eq('a', Object('a'));
	 * // => false
	 *
	 * _.eq(NaN, NaN);
	 * // => true
	 */
	function eq(value, other) {
	  return value === other || (value !== value && other !== other);
	}

	var eq_1 = eq;

	/**
	 * Gets the index at which the `key` is found in `array` of key-value pairs.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} key The key to search for.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function assocIndexOf(array, key) {
	  var length = array.length;
	  while (length--) {
	    if (eq_1(array[length][0], key)) {
	      return length;
	    }
	  }
	  return -1;
	}

	var _assocIndexOf = assocIndexOf;

	/** Used for built-in method references. */
	var arrayProto = Array.prototype;

	/** Built-in value references. */
	var splice = arrayProto.splice;

	/**
	 * Removes `key` and its value from the list cache.
	 *
	 * @private
	 * @name delete
	 * @memberOf ListCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function listCacheDelete(key) {
	  var data = this.__data__,
	      index = _assocIndexOf(data, key);

	  if (index < 0) {
	    return false;
	  }
	  var lastIndex = data.length - 1;
	  if (index == lastIndex) {
	    data.pop();
	  } else {
	    splice.call(data, index, 1);
	  }
	  --this.size;
	  return true;
	}

	var _listCacheDelete = listCacheDelete;

	/**
	 * Gets the list cache value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf ListCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function listCacheGet(key) {
	  var data = this.__data__,
	      index = _assocIndexOf(data, key);

	  return index < 0 ? undefined : data[index][1];
	}

	var _listCacheGet = listCacheGet;

	/**
	 * Checks if a list cache value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf ListCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function listCacheHas(key) {
	  return _assocIndexOf(this.__data__, key) > -1;
	}

	var _listCacheHas = listCacheHas;

	/**
	 * Sets the list cache `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf ListCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the list cache instance.
	 */
	function listCacheSet(key, value) {
	  var data = this.__data__,
	      index = _assocIndexOf(data, key);

	  if (index < 0) {
	    ++this.size;
	    data.push([key, value]);
	  } else {
	    data[index][1] = value;
	  }
	  return this;
	}

	var _listCacheSet = listCacheSet;

	/**
	 * Creates an list cache object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function ListCache(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `ListCache`.
	ListCache.prototype.clear = _listCacheClear;
	ListCache.prototype['delete'] = _listCacheDelete;
	ListCache.prototype.get = _listCacheGet;
	ListCache.prototype.has = _listCacheHas;
	ListCache.prototype.set = _listCacheSet;

	var _ListCache = ListCache;

	/* Built-in method references that are verified to be native. */
	var Map$2 = _getNative(_root, 'Map');

	var _Map = Map$2;

	/**
	 * Removes all key-value entries from the map.
	 *
	 * @private
	 * @name clear
	 * @memberOf MapCache
	 */
	function mapCacheClear() {
	  this.size = 0;
	  this.__data__ = {
	    'hash': new _Hash,
	    'map': new (_Map || _ListCache),
	    'string': new _Hash
	  };
	}

	var _mapCacheClear = mapCacheClear;

	/**
	 * Checks if `value` is suitable for use as unique object key.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
	 */
	function isKeyable(value) {
	  var type = typeof value;
	  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
	    ? (value !== '__proto__')
	    : (value === null);
	}

	var _isKeyable = isKeyable;

	/**
	 * Gets the data for `map`.
	 *
	 * @private
	 * @param {Object} map The map to query.
	 * @param {string} key The reference key.
	 * @returns {*} Returns the map data.
	 */
	function getMapData(map, key) {
	  var data = map.__data__;
	  return _isKeyable(key)
	    ? data[typeof key == 'string' ? 'string' : 'hash']
	    : data.map;
	}

	var _getMapData = getMapData;

	/**
	 * Removes `key` and its value from the map.
	 *
	 * @private
	 * @name delete
	 * @memberOf MapCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function mapCacheDelete(key) {
	  var result = _getMapData(this, key)['delete'](key);
	  this.size -= result ? 1 : 0;
	  return result;
	}

	var _mapCacheDelete = mapCacheDelete;

	/**
	 * Gets the map value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf MapCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function mapCacheGet(key) {
	  return _getMapData(this, key).get(key);
	}

	var _mapCacheGet = mapCacheGet;

	/**
	 * Checks if a map value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf MapCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function mapCacheHas(key) {
	  return _getMapData(this, key).has(key);
	}

	var _mapCacheHas = mapCacheHas;

	/**
	 * Sets the map `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf MapCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the map cache instance.
	 */
	function mapCacheSet(key, value) {
	  var data = _getMapData(this, key),
	      size = data.size;

	  data.set(key, value);
	  this.size += data.size == size ? 0 : 1;
	  return this;
	}

	var _mapCacheSet = mapCacheSet;

	/**
	 * Creates a map cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function MapCache(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `MapCache`.
	MapCache.prototype.clear = _mapCacheClear;
	MapCache.prototype['delete'] = _mapCacheDelete;
	MapCache.prototype.get = _mapCacheGet;
	MapCache.prototype.has = _mapCacheHas;
	MapCache.prototype.set = _mapCacheSet;

	var _MapCache = MapCache;

	/** Error message constants. */
	var FUNC_ERROR_TEXT$4 = 'Expected a function';

	/**
	 * Creates a function that memoizes the result of `func`. If `resolver` is
	 * provided, it determines the cache key for storing the result based on the
	 * arguments provided to the memoized function. By default, the first argument
	 * provided to the memoized function is used as the map cache key. The `func`
	 * is invoked with the `this` binding of the memoized function.
	 *
	 * **Note:** The cache is exposed as the `cache` property on the memoized
	 * function. Its creation may be customized by replacing the `_.memoize.Cache`
	 * constructor with one whose instances implement the
	 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
	 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Function
	 * @param {Function} func The function to have its output memoized.
	 * @param {Function} [resolver] The function to resolve the cache key.
	 * @returns {Function} Returns the new memoized function.
	 * @example
	 *
	 * var object = { 'a': 1, 'b': 2 };
	 * var other = { 'c': 3, 'd': 4 };
	 *
	 * var values = _.memoize(_.values);
	 * values(object);
	 * // => [1, 2]
	 *
	 * values(other);
	 * // => [3, 4]
	 *
	 * object.a = 2;
	 * values(object);
	 * // => [1, 2]
	 *
	 * // Modify the result cache.
	 * values.cache.set(object, ['a', 'b']);
	 * values(object);
	 * // => ['a', 'b']
	 *
	 * // Replace `_.memoize.Cache`.
	 * _.memoize.Cache = WeakMap;
	 */
	function memoize$1(func, resolver) {
	  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
	    throw new TypeError(FUNC_ERROR_TEXT$4);
	  }
	  var memoized = function() {
	    var args = arguments,
	        key = resolver ? resolver.apply(this, args) : args[0],
	        cache = memoized.cache;

	    if (cache.has(key)) {
	      return cache.get(key);
	    }
	    var result = func.apply(this, args);
	    memoized.cache = cache.set(key, result) || cache;
	    return result;
	  };
	  memoized.cache = new (memoize$1.Cache || _MapCache);
	  return memoized;
	}

	// Expose `MapCache`.
	memoize$1.Cache = _MapCache;

	var memoize_1 = memoize$1;

	/** Used as the maximum memoize cache size. */
	var MAX_MEMOIZE_SIZE$1 = 500;

	/**
	 * A specialized version of `_.memoize` which clears the memoized function's
	 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
	 *
	 * @private
	 * @param {Function} func The function to have its output memoized.
	 * @returns {Function} Returns the new memoized function.
	 */
	function memoizeCapped$1(func) {
	  var result = memoize_1(func, function(key) {
	    if (cache.size === MAX_MEMOIZE_SIZE$1) {
	      cache.clear();
	    }
	    return key;
	  });

	  var cache = result.cache;
	  return result;
	}

	var _memoizeCapped = memoizeCapped$1;

	/** Used to match property names within property paths. */
	var rePropName$1 = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

	/** Used to match backslashes in property paths. */
	var reEscapeChar$1 = /\\(\\)?/g;

	/**
	 * Converts `string` to a property path array.
	 *
	 * @private
	 * @param {string} string The string to convert.
	 * @returns {Array} Returns the property path array.
	 */
	var stringToPath$2 = _memoizeCapped(function(string) {
	  var result = [];
	  if (string.charCodeAt(0) === 46 /* . */) {
	    result.push('');
	  }
	  string.replace(rePropName$1, function(match, number, quote, subString) {
	    result.push(quote ? subString.replace(reEscapeChar$1, '$1') : (number || match));
	  });
	  return result;
	});

	var _stringToPath = stringToPath$2;

	/**
	 * A specialized version of `_.map` for arrays without support for iteratee
	 * shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the new mapped array.
	 */
	function arrayMap$1(array, iteratee) {
	  var index = -1,
	      length = array == null ? 0 : array.length,
	      result = Array(length);

	  while (++index < length) {
	    result[index] = iteratee(array[index], index, array);
	  }
	  return result;
	}

	var _arrayMap = arrayMap$1;

	/** Used as references for various `Number` constants. */
	var INFINITY$4 = 1 / 0;

	/** Used to convert symbols to primitives and strings. */
	var symbolProto$2 = _Symbol ? _Symbol.prototype : undefined,
	    symbolToString$2 = symbolProto$2 ? symbolProto$2.toString : undefined;

	/**
	 * The base implementation of `_.toString` which doesn't convert nullish
	 * values to empty strings.
	 *
	 * @private
	 * @param {*} value The value to process.
	 * @returns {string} Returns the string.
	 */
	function baseToString$1(value) {
	  // Exit early for strings to avoid a performance hit in some environments.
	  if (typeof value == 'string') {
	    return value;
	  }
	  if (isArray_1(value)) {
	    // Recursively convert values (susceptible to call stack limits).
	    return _arrayMap(value, baseToString$1) + '';
	  }
	  if (isSymbol_1(value)) {
	    return symbolToString$2 ? symbolToString$2.call(value) : '';
	  }
	  var result = (value + '');
	  return (result == '0' && (1 / value) == -INFINITY$4) ? '-0' : result;
	}

	var _baseToString = baseToString$1;

	/**
	 * Converts `value` to a string. An empty string is returned for `null`
	 * and `undefined` values. The sign of `-0` is preserved.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 * @example
	 *
	 * _.toString(null);
	 * // => ''
	 *
	 * _.toString(-0);
	 * // => '-0'
	 *
	 * _.toString([1, 2, 3]);
	 * // => '1,2,3'
	 */
	function toString$2(value) {
	  return value == null ? '' : _baseToString(value);
	}

	var toString_1 = toString$2;

	/**
	 * Casts `value` to a path array if it's not one.
	 *
	 * @private
	 * @param {*} value The value to inspect.
	 * @param {Object} [object] The object to query keys on.
	 * @returns {Array} Returns the cast property path array.
	 */
	function castPath$1(value, object) {
	  if (isArray_1(value)) {
	    return value;
	  }
	  return _isKey(value, object) ? [value] : _stringToPath(toString_1(value));
	}

	var _castPath = castPath$1;

	/** Used as references for various `Number` constants. */
	var INFINITY$3 = 1 / 0;

	/**
	 * Converts `value` to a string key if it's not a string or symbol.
	 *
	 * @private
	 * @param {*} value The value to inspect.
	 * @returns {string|symbol} Returns the key.
	 */
	function toKey$1(value) {
	  if (typeof value == 'string' || isSymbol_1(value)) {
	    return value;
	  }
	  var result = (value + '');
	  return (result == '0' && (1 / value) == -INFINITY$3) ? '-0' : result;
	}

	var _toKey = toKey$1;

	/**
	 * The base implementation of `_.get` without support for default values.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path of the property to get.
	 * @returns {*} Returns the resolved value.
	 */
	function baseGet$1(object, path) {
	  path = _castPath(path, object);

	  var index = 0,
	      length = path.length;

	  while (object != null && index < length) {
	    object = object[_toKey(path[index++])];
	  }
	  return (index && index == length) ? object : undefined;
	}

	var _baseGet = baseGet$1;

	/**
	 * Gets the value at `path` of `object`. If the resolved value is
	 * `undefined`, the `defaultValue` is returned in its place.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.7.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path of the property to get.
	 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
	 * @returns {*} Returns the resolved value.
	 * @example
	 *
	 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	 *
	 * _.get(object, 'a[0].b.c');
	 * // => 3
	 *
	 * _.get(object, ['a', '0', 'b', 'c']);
	 * // => 3
	 *
	 * _.get(object, 'a.b.c', 'default');
	 * // => 'default'
	 */
	function get$3(object, path, defaultValue) {
	  var result = object == null ? undefined : _baseGet(object, path);
	  return result === undefined ? defaultValue : result;
	}

	var get_1 = get$3;

	var xhtml = "http://www.w3.org/1999/xhtml";

	var namespaces = {
	  svg: "http://www.w3.org/2000/svg",
	  xhtml: xhtml,
	  xlink: "http://www.w3.org/1999/xlink",
	  xml: "http://www.w3.org/XML/1998/namespace",
	  xmlns: "http://www.w3.org/2000/xmlns/"
	};

	function namespace(name) {
	  var prefix = name += "", i = prefix.indexOf(":");
	  if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
	  return namespaces.hasOwnProperty(prefix) ? {space: namespaces[prefix], local: name} : name;
	}

	function creatorInherit(name) {
	  return function() {
	    var document = this.ownerDocument,
	        uri = this.namespaceURI;
	    return uri === xhtml && document.documentElement.namespaceURI === xhtml
	        ? document.createElement(name)
	        : document.createElementNS(uri, name);
	  };
	}

	function creatorFixed(fullname) {
	  return function() {
	    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
	  };
	}

	function creator(name) {
	  var fullname = namespace(name);
	  return (fullname.local
	      ? creatorFixed
	      : creatorInherit)(fullname);
	}

	function none$2() {}

	function selector(selector) {
	  return selector == null ? none$2 : function() {
	    return this.querySelector(selector);
	  };
	}

	function selection_select(select) {
	  if (typeof select !== "function") select = selector(select);

	  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
	    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
	      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
	        if ("__data__" in node) subnode.__data__ = node.__data__;
	        subgroup[i] = subnode;
	      }
	    }
	  }

	  return new Selection$1(subgroups, this._parents);
	}

	function empty$1() {
	  return [];
	}

	function selectorAll(selector) {
	  return selector == null ? empty$1 : function() {
	    return this.querySelectorAll(selector);
	  };
	}

	function selection_selectAll(select) {
	  if (typeof select !== "function") select = selectorAll(select);

	  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
	    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
	      if (node = group[i]) {
	        subgroups.push(select.call(node, node.__data__, i, group));
	        parents.push(node);
	      }
	    }
	  }

	  return new Selection$1(subgroups, parents);
	}

	function matcher(selector) {
	  return function() {
	    return this.matches(selector);
	  };
	}

	function selection_filter(match) {
	  if (typeof match !== "function") match = matcher(match);

	  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
	    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
	      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
	        subgroup.push(node);
	      }
	    }
	  }

	  return new Selection$1(subgroups, this._parents);
	}

	function sparse(update) {
	  return new Array(update.length);
	}

	function selection_enter() {
	  return new Selection$1(this._enter || this._groups.map(sparse), this._parents);
	}

	function EnterNode(parent, datum) {
	  this.ownerDocument = parent.ownerDocument;
	  this.namespaceURI = parent.namespaceURI;
	  this._next = null;
	  this._parent = parent;
	  this.__data__ = datum;
	}

	EnterNode.prototype = {
	  constructor: EnterNode,
	  appendChild: function(child) { return this._parent.insertBefore(child, this._next); },
	  insertBefore: function(child, next) { return this._parent.insertBefore(child, next); },
	  querySelector: function(selector) { return this._parent.querySelector(selector); },
	  querySelectorAll: function(selector) { return this._parent.querySelectorAll(selector); }
	};

	function constant$3(x) {
	  return function() {
	    return x;
	  };
	}

	var keyPrefix = "$"; // Protect against keys like â__proto__â.

	function bindIndex(parent, group, enter, update, exit, data) {
	  var i = 0,
	      node,
	      groupLength = group.length,
	      dataLength = data.length;

	  // Put any non-null nodes that fit into update.
	  // Put any null nodes into enter.
	  // Put any remaining data into enter.
	  for (; i < dataLength; ++i) {
	    if (node = group[i]) {
	      node.__data__ = data[i];
	      update[i] = node;
	    } else {
	      enter[i] = new EnterNode(parent, data[i]);
	    }
	  }

	  // Put any non-null nodes that donât fit into exit.
	  for (; i < groupLength; ++i) {
	    if (node = group[i]) {
	      exit[i] = node;
	    }
	  }
	}

	function bindKey(parent, group, enter, update, exit, data, key) {
	  var i,
	      node,
	      nodeByKeyValue = {},
	      groupLength = group.length,
	      dataLength = data.length,
	      keyValues = new Array(groupLength),
	      keyValue;

	  // Compute the key for each node.
	  // If multiple nodes have the same key, the duplicates are added to exit.
	  for (i = 0; i < groupLength; ++i) {
	    if (node = group[i]) {
	      keyValues[i] = keyValue = keyPrefix + key.call(node, node.__data__, i, group);
	      if (keyValue in nodeByKeyValue) {
	        exit[i] = node;
	      } else {
	        nodeByKeyValue[keyValue] = node;
	      }
	    }
	  }

	  // Compute the key for each datum.
	  // If there a node associated with this key, join and add it to update.
	  // If there is not (or the key is a duplicate), add it to enter.
	  for (i = 0; i < dataLength; ++i) {
	    keyValue = keyPrefix + key.call(parent, data[i], i, data);
	    if (node = nodeByKeyValue[keyValue]) {
	      update[i] = node;
	      node.__data__ = data[i];
	      nodeByKeyValue[keyValue] = null;
	    } else {
	      enter[i] = new EnterNode(parent, data[i]);
	    }
	  }

	  // Add any remaining nodes that were not bound to data to exit.
	  for (i = 0; i < groupLength; ++i) {
	    if ((node = group[i]) && (nodeByKeyValue[keyValues[i]] === node)) {
	      exit[i] = node;
	    }
	  }
	}

	function selection_data(value, key) {
	  if (!value) {
	    data = new Array(this.size()), j = -1;
	    this.each(function(d) { data[++j] = d; });
	    return data;
	  }

	  var bind = key ? bindKey : bindIndex,
	      parents = this._parents,
	      groups = this._groups;

	  if (typeof value !== "function") value = constant$3(value);

	  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
	    var parent = parents[j],
	        group = groups[j],
	        groupLength = group.length,
	        data = value.call(parent, parent && parent.__data__, j, parents),
	        dataLength = data.length,
	        enterGroup = enter[j] = new Array(dataLength),
	        updateGroup = update[j] = new Array(dataLength),
	        exitGroup = exit[j] = new Array(groupLength);

	    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);

	    // Now connect the enter nodes to their following update node, such that
	    // appendChild can insert the materialized enter node before this node,
	    // rather than at the end of the parent node.
	    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
	      if (previous = enterGroup[i0]) {
	        if (i0 >= i1) i1 = i0 + 1;
	        while (!(next = updateGroup[i1]) && ++i1 < dataLength);
	        previous._next = next || null;
	      }
	    }
	  }

	  update = new Selection$1(update, parents);
	  update._enter = enter;
	  update._exit = exit;
	  return update;
	}

	function selection_exit() {
	  return new Selection$1(this._exit || this._groups.map(sparse), this._parents);
	}

	function selection_join(onenter, onupdate, onexit) {
	  var enter = this.enter(), update = this, exit = this.exit();
	  enter = typeof onenter === "function" ? onenter(enter) : enter.append(onenter + "");
	  if (onupdate != null) update = onupdate(update);
	  if (onexit == null) exit.remove(); else onexit(exit);
	  return enter && update ? enter.merge(update).order() : update;
	}

	function selection_merge(selection) {

	  for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
	    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
	      if (node = group0[i] || group1[i]) {
	        merge[i] = node;
	      }
	    }
	  }

	  for (; j < m0; ++j) {
	    merges[j] = groups0[j];
	  }

	  return new Selection$1(merges, this._parents);
	}

	function selection_order() {

	  for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
	    for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
	      if (node = group[i]) {
	        if (next && node.compareDocumentPosition(next) ^ 4) next.parentNode.insertBefore(node, next);
	        next = node;
	      }
	    }
	  }

	  return this;
	}

	function selection_sort(compare) {
	  if (!compare) compare = ascending$1;

	  function compareNode(a, b) {
	    return a && b ? compare(a.__data__, b.__data__) : !a - !b;
	  }

	  for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
	    for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
	      if (node = group[i]) {
	        sortgroup[i] = node;
	      }
	    }
	    sortgroup.sort(compareNode);
	  }

	  return new Selection$1(sortgroups, this._parents).order();
	}

	function ascending$1(a, b) {
	  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
	}

	function selection_call() {
	  var callback = arguments[0];
	  arguments[0] = this;
	  callback.apply(null, arguments);
	  return this;
	}

	function selection_nodes() {
	  var nodes = new Array(this.size()), i = -1;
	  this.each(function() { nodes[++i] = this; });
	  return nodes;
	}

	function selection_node() {

	  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
	    for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
	      var node = group[i];
	      if (node) return node;
	    }
	  }

	  return null;
	}

	function selection_size() {
	  var size = 0;
	  this.each(function() { ++size; });
	  return size;
	}

	function selection_empty() {
	  return !this.node();
	}

	function selection_each(callback) {

	  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
	    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
	      if (node = group[i]) callback.call(node, node.__data__, i, group);
	    }
	  }

	  return this;
	}

	function attrRemove$1(name) {
	  return function() {
	    this.removeAttribute(name);
	  };
	}

	function attrRemoveNS$1(fullname) {
	  return function() {
	    this.removeAttributeNS(fullname.space, fullname.local);
	  };
	}

	function attrConstant$1(name, value) {
	  return function() {
	    this.setAttribute(name, value);
	  };
	}

	function attrConstantNS$1(fullname, value) {
	  return function() {
	    this.setAttributeNS(fullname.space, fullname.local, value);
	  };
	}

	function attrFunction$1(name, value) {
	  return function() {
	    var v = value.apply(this, arguments);
	    if (v == null) this.removeAttribute(name);
	    else this.setAttribute(name, v);
	  };
	}

	function attrFunctionNS$1(fullname, value) {
	  return function() {
	    var v = value.apply(this, arguments);
	    if (v == null) this.removeAttributeNS(fullname.space, fullname.local);
	    else this.setAttributeNS(fullname.space, fullname.local, v);
	  };
	}

	function selection_attr(name, value) {
	  var fullname = namespace(name);

	  if (arguments.length < 2) {
	    var node = this.node();
	    return fullname.local
	        ? node.getAttributeNS(fullname.space, fullname.local)
	        : node.getAttribute(fullname);
	  }

	  return this.each((value == null
	      ? (fullname.local ? attrRemoveNS$1 : attrRemove$1) : (typeof value === "function"
	      ? (fullname.local ? attrFunctionNS$1 : attrFunction$1)
	      : (fullname.local ? attrConstantNS$1 : attrConstant$1)))(fullname, value));
	}

	function defaultView(node) {
	  return (node.ownerDocument && node.ownerDocument.defaultView) // node is a Node
	      || (node.document && node) // node is a Window
	      || node.defaultView; // node is a Document
	}

	function styleRemove$1(name) {
	  return function() {
	    this.style.removeProperty(name);
	  };
	}

	function styleConstant$1(name, value, priority) {
	  return function() {
	    this.style.setProperty(name, value, priority);
	  };
	}

	function styleFunction$1(name, value, priority) {
	  return function() {
	    var v = value.apply(this, arguments);
	    if (v == null) this.style.removeProperty(name);
	    else this.style.setProperty(name, v, priority);
	  };
	}

	function selection_style(name, value, priority) {
	  return arguments.length > 1
	      ? this.each((value == null
	            ? styleRemove$1 : typeof value === "function"
	            ? styleFunction$1
	            : styleConstant$1)(name, value, priority == null ? "" : priority))
	      : styleValue(this.node(), name);
	}

	function styleValue(node, name) {
	  return node.style.getPropertyValue(name)
	      || defaultView(node).getComputedStyle(node, null).getPropertyValue(name);
	}

	function propertyRemove(name) {
	  return function() {
	    delete this[name];
	  };
	}

	function propertyConstant(name, value) {
	  return function() {
	    this[name] = value;
	  };
	}

	function propertyFunction(name, value) {
	  return function() {
	    var v = value.apply(this, arguments);
	    if (v == null) delete this[name];
	    else this[name] = v;
	  };
	}

	function selection_property(name, value) {
	  return arguments.length > 1
	      ? this.each((value == null
	          ? propertyRemove : typeof value === "function"
	          ? propertyFunction
	          : propertyConstant)(name, value))
	      : this.node()[name];
	}

	function classArray(string) {
	  return string.trim().split(/^|\s+/);
	}

	function classList(node) {
	  return node.classList || new ClassList(node);
	}

	function ClassList(node) {
	  this._node = node;
	  this._names = classArray(node.getAttribute("class") || "");
	}

	ClassList.prototype = {
	  add: function(name) {
	    var i = this._names.indexOf(name);
	    if (i < 0) {
	      this._names.push(name);
	      this._node.setAttribute("class", this._names.join(" "));
	    }
	  },
	  remove: function(name) {
	    var i = this._names.indexOf(name);
	    if (i >= 0) {
	      this._names.splice(i, 1);
	      this._node.setAttribute("class", this._names.join(" "));
	    }
	  },
	  contains: function(name) {
	    return this._names.indexOf(name) >= 0;
	  }
	};

	function classedAdd(node, names) {
	  var list = classList(node), i = -1, n = names.length;
	  while (++i < n) list.add(names[i]);
	}

	function classedRemove(node, names) {
	  var list = classList(node), i = -1, n = names.length;
	  while (++i < n) list.remove(names[i]);
	}

	function classedTrue(names) {
	  return function() {
	    classedAdd(this, names);
	  };
	}

	function classedFalse(names) {
	  return function() {
	    classedRemove(this, names);
	  };
	}

	function classedFunction(names, value) {
	  return function() {
	    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
	  };
	}

	function selection_classed(name, value) {
	  var names = classArray(name + "");

	  if (arguments.length < 2) {
	    var list = classList(this.node()), i = -1, n = names.length;
	    while (++i < n) if (!list.contains(names[i])) return false;
	    return true;
	  }

	  return this.each((typeof value === "function"
	      ? classedFunction : value
	      ? classedTrue
	      : classedFalse)(names, value));
	}

	function textRemove() {
	  this.textContent = "";
	}

	function textConstant$1(value) {
	  return function() {
	    this.textContent = value;
	  };
	}

	function textFunction$1(value) {
	  return function() {
	    var v = value.apply(this, arguments);
	    this.textContent = v == null ? "" : v;
	  };
	}

	function selection_text(value) {
	  return arguments.length
	      ? this.each(value == null
	          ? textRemove : (typeof value === "function"
	          ? textFunction$1
	          : textConstant$1)(value))
	      : this.node().textContent;
	}

	function htmlRemove() {
	  this.innerHTML = "";
	}

	function htmlConstant(value) {
	  return function() {
	    this.innerHTML = value;
	  };
	}

	function htmlFunction(value) {
	  return function() {
	    var v = value.apply(this, arguments);
	    this.innerHTML = v == null ? "" : v;
	  };
	}

	function selection_html(value) {
	  return arguments.length
	      ? this.each(value == null
	          ? htmlRemove : (typeof value === "function"
	          ? htmlFunction
	          : htmlConstant)(value))
	      : this.node().innerHTML;
	}

	function raise() {
	  if (this.nextSibling) this.parentNode.appendChild(this);
	}

	function selection_raise() {
	  return this.each(raise);
	}

	function lower() {
	  if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
	}

	function selection_lower() {
	  return this.each(lower);
	}

	function selection_append(name) {
	  var create = typeof name === "function" ? name : creator(name);
	  return this.select(function() {
	    return this.appendChild(create.apply(this, arguments));
	  });
	}

	function constantNull() {
	  return null;
	}

	function selection_insert(name, before) {
	  var create = typeof name === "function" ? name : creator(name),
	      select = before == null ? constantNull : typeof before === "function" ? before : selector(before);
	  return this.select(function() {
	    return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
	  });
	}

	function remove() {
	  var parent = this.parentNode;
	  if (parent) parent.removeChild(this);
	}

	function selection_remove() {
	  return this.each(remove);
	}

	function selection_cloneShallow() {
	  var clone = this.cloneNode(false), parent = this.parentNode;
	  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
	}

	function selection_cloneDeep() {
	  var clone = this.cloneNode(true), parent = this.parentNode;
	  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
	}

	function selection_clone(deep) {
	  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
	}

	function selection_datum(value) {
	  return arguments.length
	      ? this.property("__data__", value)
	      : this.node().__data__;
	}

	var filterEvents = {};

	if (typeof document !== "undefined") {
	  var element$1 = document.documentElement;
	  if (!("onmouseenter" in element$1)) {
	    filterEvents = {mouseenter: "mouseover", mouseleave: "mouseout"};
	  }
	}

	function filterContextListener(listener, index, group) {
	  listener = contextListener(listener, index, group);
	  return function(event) {
	    var related = event.relatedTarget;
	    if (!related || (related !== this && !(related.compareDocumentPosition(this) & 8))) {
	      listener.call(this, event);
	    }
	  };
	}

	function contextListener(listener, index, group) {
	  return function(event1) {
	    try {
	      listener.call(this, this.__data__, index, group);
	    } finally {
	    }
	  };
	}

	function parseTypenames$1(typenames) {
	  return typenames.trim().split(/^|\s+/).map(function(t) {
	    var name = "", i = t.indexOf(".");
	    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
	    return {type: t, name: name};
	  });
	}

	function onRemove(typename) {
	  return function() {
	    var on = this.__on;
	    if (!on) return;
	    for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
	      if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
	        this.removeEventListener(o.type, o.listener, o.capture);
	      } else {
	        on[++i] = o;
	      }
	    }
	    if (++i) on.length = i;
	    else delete this.__on;
	  };
	}

	function onAdd(typename, value, capture) {
	  var wrap = filterEvents.hasOwnProperty(typename.type) ? filterContextListener : contextListener;
	  return function(d, i, group) {
	    var on = this.__on, o, listener = wrap(value, i, group);
	    if (on) for (var j = 0, m = on.length; j < m; ++j) {
	      if ((o = on[j]).type === typename.type && o.name === typename.name) {
	        this.removeEventListener(o.type, o.listener, o.capture);
	        this.addEventListener(o.type, o.listener = listener, o.capture = capture);
	        o.value = value;
	        return;
	      }
	    }
	    this.addEventListener(typename.type, listener, capture);
	    o = {type: typename.type, name: typename.name, value: value, listener: listener, capture: capture};
	    if (!on) this.__on = [o];
	    else on.push(o);
	  };
	}

	function selection_on(typename, value, capture) {
	  var typenames = parseTypenames$1(typename + ""), i, n = typenames.length, t;

	  if (arguments.length < 2) {
	    var on = this.node().__on;
	    if (on) for (var j = 0, m = on.length, o; j < m; ++j) {
	      for (i = 0, o = on[j]; i < n; ++i) {
	        if ((t = typenames[i]).type === o.type && t.name === o.name) {
	          return o.value;
	        }
	      }
	    }
	    return;
	  }

	  on = value ? onAdd : onRemove;
	  if (capture == null) capture = false;
	  for (i = 0; i < n; ++i) this.each(on(typenames[i], value, capture));
	  return this;
	}

	function dispatchEvent(node, type, params) {
	  var window = defaultView(node),
	      event = window.CustomEvent;

	  if (typeof event === "function") {
	    event = new event(type, params);
	  } else {
	    event = window.document.createEvent("Event");
	    if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
	    else event.initEvent(type, false, false);
	  }

	  node.dispatchEvent(event);
	}

	function dispatchConstant(type, params) {
	  return function() {
	    return dispatchEvent(this, type, params);
	  };
	}

	function dispatchFunction(type, params) {
	  return function() {
	    return dispatchEvent(this, type, params.apply(this, arguments));
	  };
	}

	function selection_dispatch(type, params) {
	  return this.each((typeof params === "function"
	      ? dispatchFunction
	      : dispatchConstant)(type, params));
	}

	var root$1 = [null];

	function Selection$1(groups, parents) {
	  this._groups = groups;
	  this._parents = parents;
	}

	function selection() {
	  return new Selection$1([[document.documentElement]], root$1);
	}

	Selection$1.prototype = selection.prototype = {
	  constructor: Selection$1,
	  select: selection_select,
	  selectAll: selection_selectAll,
	  filter: selection_filter,
	  data: selection_data,
	  enter: selection_enter,
	  exit: selection_exit,
	  join: selection_join,
	  merge: selection_merge,
	  order: selection_order,
	  sort: selection_sort,
	  call: selection_call,
	  nodes: selection_nodes,
	  node: selection_node,
	  size: selection_size,
	  empty: selection_empty,
	  each: selection_each,
	  attr: selection_attr,
	  style: selection_style,
	  property: selection_property,
	  classed: selection_classed,
	  text: selection_text,
	  html: selection_html,
	  raise: selection_raise,
	  lower: selection_lower,
	  append: selection_append,
	  insert: selection_insert,
	  remove: selection_remove,
	  clone: selection_clone,
	  datum: selection_datum,
	  on: selection_on,
	  dispatch: selection_dispatch
	};

	function select(selector) {
	  return typeof selector === "string"
	      ? new Selection$1([[document.querySelector(selector)]], [document.documentElement])
	      : new Selection$1([[selector]], root$1);
	}

	function selectAll(selector) {
	  return typeof selector === "string"
	      ? new Selection$1([document.querySelectorAll(selector)], [document.documentElement])
	      : new Selection$1([selector == null ? [] : selector], root$1);
	}

	function selectAppend(name) {
	  var select = selector(name);
	  var n = parseAttributes(name);
	  var creatorNmae = creator(n.tag);
	  var s = this.select(function () {
	    return select.apply(this, arguments) || this.appendChild(creatorNmae.apply(this, arguments));
	  }); // attrs not provided by default in v4

	  for (var key in n.attr) {
	    s.attr(key, n.attr[key]);
	  }

	  return s;
	}
	function append$1(name) {
	  var n = parseAttributes(name);
	  var creatorName = creator(n.tag);
	  var s = this.select(function () {
	    return this.appendChild(creatorName.apply(this, arguments));
	  }); // attrs not provided by default in v4

	  for (var key in n.attr) {
	    s.attr(key, n.attr[key]);
	  }

	  return s;
	}

	function parseAttributes(name) {
	  if (typeof name === 'string') {
	    var attr = {};
	    var parts = name.split(/([.#])/g);
	    name = parts.shift();
	    var p;

	    while (p = parts.shift()) {
	      if (p === '.') {
	        attr.class = attr.class ? attr.class + ' ' + parts.shift() : parts.shift();
	      } else if (p === '#') {
	        attr.id = parts.shift();
	      }
	    }

	    return {
	      attr: attr,
	      tag: name
	    };
	  }

	  return name;
	}

	var degrees = 180 / Math.PI;

	var identity$4 = {
	  translateX: 0,
	  translateY: 0,
	  rotate: 0,
	  skewX: 0,
	  scaleX: 1,
	  scaleY: 1
	};

	function decompose(a, b, c, d, e, f) {
	  var scaleX, scaleY, skewX;
	  if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
	  if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
	  if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
	  if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
	  return {
	    translateX: e,
	    translateY: f,
	    rotate: Math.atan2(b, a) * degrees,
	    skewX: Math.atan(skewX) * degrees,
	    scaleX: scaleX,
	    scaleY: scaleY
	  };
	}

	function ascending(a, b) {
	  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
	}

	function bisector(compare) {
	  if (compare.length === 1) compare = ascendingComparator(compare);
	  return {
	    left: function(a, x, lo, hi) {
	      if (lo == null) lo = 0;
	      if (hi == null) hi = a.length;
	      while (lo < hi) {
	        var mid = lo + hi >>> 1;
	        if (compare(a[mid], x) < 0) lo = mid + 1;
	        else hi = mid;
	      }
	      return lo;
	    },
	    right: function(a, x, lo, hi) {
	      if (lo == null) lo = 0;
	      if (hi == null) hi = a.length;
	      while (lo < hi) {
	        var mid = lo + hi >>> 1;
	        if (compare(a[mid], x) > 0) hi = mid;
	        else lo = mid + 1;
	      }
	      return lo;
	    }
	  };
	}

	function ascendingComparator(f) {
	  return function(d, x) {
	    return ascending(f(d), x);
	  };
	}

	var ascendingBisect = bisector(ascending);
	var bisectRight = ascendingBisect.right;

	function number$3(x) {
	  return x === null ? NaN : +x;
	}

	function range$2(start, stop, step) {
	  start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;

	  var i = -1,
	      n = Math.max(0, Math.ceil((stop - start) / step)) | 0,
	      range = new Array(n);

	  while (++i < n) {
	    range[i] = start + i * step;
	  }

	  return range;
	}

	var e10 = Math.sqrt(50),
	    e5 = Math.sqrt(10),
	    e2 = Math.sqrt(2);

	function d3ticks(start, stop, count) {
	  var reverse,
	      i = -1,
	      n,
	      ticks,
	      step;

	  stop = +stop, start = +start, count = +count;
	  if (start === stop && count > 0) return [start];
	  if (reverse = stop < start) n = start, start = stop, stop = n;
	  if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) return [];

	  if (step > 0) {
	    start = Math.ceil(start / step);
	    stop = Math.floor(stop / step);
	    ticks = new Array(n = Math.ceil(stop - start + 1));
	    while (++i < n) ticks[i] = (start + i) * step;
	  } else {
	    start = Math.floor(start * step);
	    stop = Math.ceil(stop * step);
	    ticks = new Array(n = Math.ceil(start - stop + 1));
	    while (++i < n) ticks[i] = (start - i) / step;
	  }

	  if (reverse) ticks.reverse();

	  return ticks;
	}

	function tickIncrement(start, stop, count) {
	  var step = (stop - start) / Math.max(0, count),
	      power = Math.floor(Math.log(step) / Math.LN10),
	      error = step / Math.pow(10, power);
	  return power >= 0
	      ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power)
	      : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
	}

	function tickStep(start, stop, count) {
	  var step0 = Math.abs(stop - start) / Math.max(0, count),
	      step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),
	      error = step0 / step1;
	  if (error >= e10) step1 *= 10;
	  else if (error >= e5) step1 *= 5;
	  else if (error >= e2) step1 *= 2;
	  return stop < start ? -step1 : step1;
	}

	function d3quantile(values, p, valueof) {
	  if (valueof == null) valueof = number$3;
	  if (!(n = values.length)) return;
	  if ((p = +p) <= 0 || n < 2) return +valueof(values[0], 0, values);
	  if (p >= 1) return +valueof(values[n - 1], n - 1, values);
	  var n,
	      i = (n - 1) * p,
	      i0 = Math.floor(i),
	      value0 = +valueof(values[i0], i0, values),
	      value1 = +valueof(values[i0 + 1], i0 + 1, values);
	  return value0 + (value1 - value0) * (i - i0);
	}

	function max$2(values, valueof) {
	  var n = values.length,
	      i = -1,
	      value,
	      max;

	  if (valueof == null) {
	    while (++i < n) { // Find the first comparable value.
	      if ((value = values[i]) != null && value >= value) {
	        max = value;
	        while (++i < n) { // Compare the remaining values.
	          if ((value = values[i]) != null && value > max) {
	            max = value;
	          }
	        }
	      }
	    }
	  }

	  else {
	    while (++i < n) { // Find the first comparable value.
	      if ((value = valueof(values[i], i, values)) != null && value >= value) {
	        max = value;
	        while (++i < n) { // Compare the remaining values.
	          if ((value = valueof(values[i], i, values)) != null && value > max) {
	            max = value;
	          }
	        }
	      }
	    }
	  }

	  return max;
	}

	function min$2(values, valueof) {
	  var n = values.length,
	      i = -1,
	      value,
	      min;

	  if (valueof == null) {
	    while (++i < n) { // Find the first comparable value.
	      if ((value = values[i]) != null && value >= value) {
	        min = value;
	        while (++i < n) { // Compare the remaining values.
	          if ((value = values[i]) != null && min > value) {
	            min = value;
	          }
	        }
	      }
	    }
	  }

	  else {
	    while (++i < n) { // Find the first comparable value.
	      if ((value = valueof(values[i], i, values)) != null && value >= value) {
	        min = value;
	        while (++i < n) { // Compare the remaining values.
	          if ((value = valueof(values[i], i, values)) != null && min > value) {
	            min = value;
	          }
	        }
	      }
	    }
	  }

	  return min;
	}

	var slice$2 = Array.prototype.slice;

	function identity$3(x) {
	  return x;
	}

	var top = 1,
	    right = 2,
	    bottom = 3,
	    left = 4,
	    epsilon$4 = 1e-6;

	function translateX(x) {
	  return "translate(" + (x + 0.5) + ",0)";
	}

	function translateY(y) {
	  return "translate(0," + (y + 0.5) + ")";
	}

	function number$2(scale) {
	  return function(d) {
	    return +scale(d);
	  };
	}

	function center(scale) {
	  var offset = Math.max(0, scale.bandwidth() - 1) / 2; // Adjust for 0.5px offset.
	  if (scale.round()) offset = Math.round(offset);
	  return function(d) {
	    return +scale(d) + offset;
	  };
	}

	function entering() {
	  return !this.__axis;
	}

	function axis(orient, scale) {
	  var tickArguments = [],
	      tickValues = null,
	      tickFormat = null,
	      tickSizeInner = 6,
	      tickSizeOuter = 6,
	      tickPadding = 3,
	      k = orient === top || orient === left ? -1 : 1,
	      x = orient === left || orient === right ? "x" : "y",
	      transform = orient === top || orient === bottom ? translateX : translateY;

	  function axis(context) {
	    var values = tickValues == null ? (scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain()) : tickValues,
	        format = tickFormat == null ? (scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : identity$3) : tickFormat,
	        spacing = Math.max(tickSizeInner, 0) + tickPadding,
	        range = scale.range(),
	        range0 = +range[0] + 0.5,
	        range1 = +range[range.length - 1] + 0.5,
	        position = (scale.bandwidth ? center : number$2)(scale.copy()),
	        selection = context.selection ? context.selection() : context,
	        path = selection.selectAll(".domain").data([null]),
	        tick = selection.selectAll(".tick").data(values, scale).order(),
	        tickExit = tick.exit(),
	        tickEnter = tick.enter().append("g").attr("class", "tick"),
	        line = tick.select("line"),
	        text = tick.select("text");

	    path = path.merge(path.enter().insert("path", ".tick")
	        .attr("class", "domain")
	        .attr("stroke", "currentColor"));

	    tick = tick.merge(tickEnter);

	    line = line.merge(tickEnter.append("line")
	        .attr("stroke", "currentColor")
	        .attr(x + "2", k * tickSizeInner));

	    text = text.merge(tickEnter.append("text")
	        .attr("fill", "currentColor")
	        .attr(x, k * spacing)
	        .attr("dy", orient === top ? "0em" : orient === bottom ? "0.71em" : "0.32em"));

	    if (context !== selection) {
	      path = path.transition(context);
	      tick = tick.transition(context);
	      line = line.transition(context);
	      text = text.transition(context);

	      tickExit = tickExit.transition(context)
	          .attr("opacity", epsilon$4)
	          .attr("transform", function(d) { return isFinite(d = position(d)) ? transform(d) : this.getAttribute("transform"); });

	      tickEnter
	          .attr("opacity", epsilon$4)
	          .attr("transform", function(d) { var p = this.parentNode.__axis; return transform(p && isFinite(p = p(d)) ? p : position(d)); });
	    }

	    tickExit.remove();

	    path
	        .attr("d", orient === left || orient == right
	            ? (tickSizeOuter ? "M" + k * tickSizeOuter + "," + range0 + "H0.5V" + range1 + "H" + k * tickSizeOuter : "M0.5," + range0 + "V" + range1)
	            : (tickSizeOuter ? "M" + range0 + "," + k * tickSizeOuter + "V0.5H" + range1 + "V" + k * tickSizeOuter : "M" + range0 + ",0.5H" + range1));

	    tick
	        .attr("opacity", 1)
	        .attr("transform", function(d) { return transform(position(d)); });

	    line
	        .attr(x + "2", k * tickSizeInner);

	    text
	        .attr(x, k * spacing)
	        .text(format);

	    selection.filter(entering)
	        .attr("fill", "none")
	        .attr("font-size", 10)
	        .attr("font-family", "sans-serif")
	        .attr("text-anchor", orient === right ? "start" : orient === left ? "end" : "middle");

	    selection
	        .each(function() { this.__axis = position; });
	  }

	  axis.scale = function(_) {
	    return arguments.length ? (scale = _, axis) : scale;
	  };

	  axis.ticks = function() {
	    return tickArguments = slice$2.call(arguments), axis;
	  };

	  axis.tickArguments = function(_) {
	    return arguments.length ? (tickArguments = _ == null ? [] : slice$2.call(_), axis) : tickArguments.slice();
	  };

	  axis.tickValues = function(_) {
	    return arguments.length ? (tickValues = _ == null ? null : slice$2.call(_), axis) : tickValues && tickValues.slice();
	  };

	  axis.tickFormat = function(_) {
	    return arguments.length ? (tickFormat = _, axis) : tickFormat;
	  };

	  axis.tickSize = function(_) {
	    return arguments.length ? (tickSizeInner = tickSizeOuter = +_, axis) : tickSizeInner;
	  };

	  axis.tickSizeInner = function(_) {
	    return arguments.length ? (tickSizeInner = +_, axis) : tickSizeInner;
	  };

	  axis.tickSizeOuter = function(_) {
	    return arguments.length ? (tickSizeOuter = +_, axis) : tickSizeOuter;
	  };

	  axis.tickPadding = function(_) {
	    return arguments.length ? (tickPadding = +_, axis) : tickPadding;
	  };

	  return axis;
	}

	function axisTop(scale) {
	  return axis(top, scale);
	}

	function axisRight(scale) {
	  return axis(right, scale);
	}

	function axisBottom(scale) {
	  return axis(bottom, scale);
	}

	function axisLeft(scale) {
	  return axis(left, scale);
	}

	var noop$1 = {value: function() {}};

	function dispatch() {
	  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
	    if (!(t = arguments[i] + "") || (t in _) || /[\s.]/.test(t)) throw new Error("illegal type: " + t);
	    _[t] = [];
	  }
	  return new Dispatch(_);
	}

	function Dispatch(_) {
	  this._ = _;
	}

	function parseTypenames(typenames, types) {
	  return typenames.trim().split(/^|\s+/).map(function(t) {
	    var name = "", i = t.indexOf(".");
	    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
	    if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
	    return {type: t, name: name};
	  });
	}

	Dispatch.prototype = dispatch.prototype = {
	  constructor: Dispatch,
	  on: function(typename, callback) {
	    var _ = this._,
	        T = parseTypenames(typename + "", _),
	        t,
	        i = -1,
	        n = T.length;

	    // If no callback was specified, return the callback of the given type and name.
	    if (arguments.length < 2) {
	      while (++i < n) if ((t = (typename = T[i]).type) && (t = get$2(_[t], typename.name))) return t;
	      return;
	    }

	    // If a type was specified, set the callback for the given type and name.
	    // Otherwise, if a null callback was specified, remove callbacks of the given name.
	    if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
	    while (++i < n) {
	      if (t = (typename = T[i]).type) _[t] = set$1(_[t], typename.name, callback);
	      else if (callback == null) for (t in _) _[t] = set$1(_[t], typename.name, null);
	    }

	    return this;
	  },
	  copy: function() {
	    var copy = {}, _ = this._;
	    for (var t in _) copy[t] = _[t].slice();
	    return new Dispatch(copy);
	  },
	  call: function(type, that) {
	    if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
	    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
	    for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
	  },
	  apply: function(type, that, args) {
	    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
	    for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
	  }
	};

	function get$2(type, name) {
	  for (var i = 0, n = type.length, c; i < n; ++i) {
	    if ((c = type[i]).name === name) {
	      return c.value;
	    }
	  }
	}

	function set$1(type, name, callback) {
	  for (var i = 0, n = type.length; i < n; ++i) {
	    if (type[i].name === name) {
	      type[i] = noop$1, type = type.slice(0, i).concat(type.slice(i + 1));
	      break;
	    }
	  }
	  if (callback != null) type.push({name: name, value: callback});
	  return type;
	}

	function define(constructor, factory, prototype) {
	  constructor.prototype = factory.prototype = prototype;
	  prototype.constructor = constructor;
	}

	function extend(parent, definition) {
	  var prototype = Object.create(parent.prototype);
	  for (var key in definition) prototype[key] = definition[key];
	  return prototype;
	}

	function Color() {}

	var darker = 0.7;
	var brighter = 1 / darker;

	var reI = "\\s*([+-]?\\d+)\\s*",
	    reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*",
	    reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
	    reHex = /^#([0-9a-f]{3,8})$/,
	    reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$"),
	    reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$"),
	    reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$"),
	    reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$"),
	    reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$"),
	    reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");

	var named = {
	  aliceblue: 0xf0f8ff,
	  antiquewhite: 0xfaebd7,
	  aqua: 0x00ffff,
	  aquamarine: 0x7fffd4,
	  azure: 0xf0ffff,
	  beige: 0xf5f5dc,
	  bisque: 0xffe4c4,
	  black: 0x000000,
	  blanchedalmond: 0xffebcd,
	  blue: 0x0000ff,
	  blueviolet: 0x8a2be2,
	  brown: 0xa52a2a,
	  burlywood: 0xdeb887,
	  cadetblue: 0x5f9ea0,
	  chartreuse: 0x7fff00,
	  chocolate: 0xd2691e,
	  coral: 0xff7f50,
	  cornflowerblue: 0x6495ed,
	  cornsilk: 0xfff8dc,
	  crimson: 0xdc143c,
	  cyan: 0x00ffff,
	  darkblue: 0x00008b,
	  darkcyan: 0x008b8b,
	  darkgoldenrod: 0xb8860b,
	  darkgray: 0xa9a9a9,
	  darkgreen: 0x006400,
	  darkgrey: 0xa9a9a9,
	  darkkhaki: 0xbdb76b,
	  darkmagenta: 0x8b008b,
	  darkolivegreen: 0x556b2f,
	  darkorange: 0xff8c00,
	  darkorchid: 0x9932cc,
	  darkred: 0x8b0000,
	  darksalmon: 0xe9967a,
	  darkseagreen: 0x8fbc8f,
	  darkslateblue: 0x483d8b,
	  darkslategray: 0x2f4f4f,
	  darkslategrey: 0x2f4f4f,
	  darkturquoise: 0x00ced1,
	  darkviolet: 0x9400d3,
	  deeppink: 0xff1493,
	  deepskyblue: 0x00bfff,
	  dimgray: 0x696969,
	  dimgrey: 0x696969,
	  dodgerblue: 0x1e90ff,
	  firebrick: 0xb22222,
	  floralwhite: 0xfffaf0,
	  forestgreen: 0x228b22,
	  fuchsia: 0xff00ff,
	  gainsboro: 0xdcdcdc,
	  ghostwhite: 0xf8f8ff,
	  gold: 0xffd700,
	  goldenrod: 0xdaa520,
	  gray: 0x808080,
	  green: 0x008000,
	  greenyellow: 0xadff2f,
	  grey: 0x808080,
	  honeydew: 0xf0fff0,
	  hotpink: 0xff69b4,
	  indianred: 0xcd5c5c,
	  indigo: 0x4b0082,
	  ivory: 0xfffff0,
	  khaki: 0xf0e68c,
	  lavender: 0xe6e6fa,
	  lavenderblush: 0xfff0f5,
	  lawngreen: 0x7cfc00,
	  lemonchiffon: 0xfffacd,
	  lightblue: 0xadd8e6,
	  lightcoral: 0xf08080,
	  lightcyan: 0xe0ffff,
	  lightgoldenrodyellow: 0xfafad2,
	  lightgray: 0xd3d3d3,
	  lightgreen: 0x90ee90,
	  lightgrey: 0xd3d3d3,
	  lightpink: 0xffb6c1,
	  lightsalmon: 0xffa07a,
	  lightseagreen: 0x20b2aa,
	  lightskyblue: 0x87cefa,
	  lightslategray: 0x778899,
	  lightslategrey: 0x778899,
	  lightsteelblue: 0xb0c4de,
	  lightyellow: 0xffffe0,
	  lime: 0x00ff00,
	  limegreen: 0x32cd32,
	  linen: 0xfaf0e6,
	  magenta: 0xff00ff,
	  maroon: 0x800000,
	  mediumaquamarine: 0x66cdaa,
	  mediumblue: 0x0000cd,
	  mediumorchid: 0xba55d3,
	  mediumpurple: 0x9370db,
	  mediumseagreen: 0x3cb371,
	  mediumslateblue: 0x7b68ee,
	  mediumspringgreen: 0x00fa9a,
	  mediumturquoise: 0x48d1cc,
	  mediumvioletred: 0xc71585,
	  midnightblue: 0x191970,
	  mintcream: 0xf5fffa,
	  mistyrose: 0xffe4e1,
	  moccasin: 0xffe4b5,
	  navajowhite: 0xffdead,
	  navy: 0x000080,
	  oldlace: 0xfdf5e6,
	  olive: 0x808000,
	  olivedrab: 0x6b8e23,
	  orange: 0xffa500,
	  orangered: 0xff4500,
	  orchid: 0xda70d6,
	  palegoldenrod: 0xeee8aa,
	  palegreen: 0x98fb98,
	  paleturquoise: 0xafeeee,
	  palevioletred: 0xdb7093,
	  papayawhip: 0xffefd5,
	  peachpuff: 0xffdab9,
	  peru: 0xcd853f,
	  pink: 0xffc0cb,
	  plum: 0xdda0dd,
	  powderblue: 0xb0e0e6,
	  purple: 0x800080,
	  rebeccapurple: 0x663399,
	  red: 0xff0000,
	  rosybrown: 0xbc8f8f,
	  royalblue: 0x4169e1,
	  saddlebrown: 0x8b4513,
	  salmon: 0xfa8072,
	  sandybrown: 0xf4a460,
	  seagreen: 0x2e8b57,
	  seashell: 0xfff5ee,
	  sienna: 0xa0522d,
	  silver: 0xc0c0c0,
	  skyblue: 0x87ceeb,
	  slateblue: 0x6a5acd,
	  slategray: 0x708090,
	  slategrey: 0x708090,
	  snow: 0xfffafa,
	  springgreen: 0x00ff7f,
	  steelblue: 0x4682b4,
	  tan: 0xd2b48c,
	  teal: 0x008080,
	  thistle: 0xd8bfd8,
	  tomato: 0xff6347,
	  turquoise: 0x40e0d0,
	  violet: 0xee82ee,
	  wheat: 0xf5deb3,
	  white: 0xffffff,
	  whitesmoke: 0xf5f5f5,
	  yellow: 0xffff00,
	  yellowgreen: 0x9acd32
	};

	define(Color, color, {
	  copy: function(channels) {
	    return Object.assign(new this.constructor, this, channels);
	  },
	  displayable: function() {
	    return this.rgb().displayable();
	  },
	  hex: color_formatHex, // Deprecated! Use color.formatHex.
	  formatHex: color_formatHex,
	  formatHsl: color_formatHsl,
	  formatRgb: color_formatRgb,
	  toString: color_formatRgb
	});

	function color_formatHex() {
	  return this.rgb().formatHex();
	}

	function color_formatHsl() {
	  return hslConvert(this).formatHsl();
	}

	function color_formatRgb() {
	  return this.rgb().formatRgb();
	}

	function color(format) {
	  var m, l;
	  format = (format + "").trim().toLowerCase();
	  return (m = reHex.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) // #ff0000
	      : l === 3 ? new Rgb((m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1) // #f00
	      : l === 8 ? rgba(m >> 24 & 0xff, m >> 16 & 0xff, m >> 8 & 0xff, (m & 0xff) / 0xff) // #ff000000
	      : l === 4 ? rgba((m >> 12 & 0xf) | (m >> 8 & 0xf0), (m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), (((m & 0xf) << 4) | (m & 0xf)) / 0xff) // #f000
	      : null) // invalid hex
	      : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
	      : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
	      : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
	      : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
	      : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
	      : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
	      : named.hasOwnProperty(format) ? rgbn(named[format]) // eslint-disable-line no-prototype-builtins
	      : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0)
	      : null;
	}

	function rgbn(n) {
	  return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
	}

	function rgba(r, g, b, a) {
	  if (a <= 0) r = g = b = NaN;
	  return new Rgb(r, g, b, a);
	}

	function rgbConvert(o) {
	  if (!(o instanceof Color)) o = color(o);
	  if (!o) return new Rgb;
	  o = o.rgb();
	  return new Rgb(o.r, o.g, o.b, o.opacity);
	}

	function rgb(r, g, b, opacity) {
	  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
	}

	function Rgb(r, g, b, opacity) {
	  this.r = +r;
	  this.g = +g;
	  this.b = +b;
	  this.opacity = +opacity;
	}

	define(Rgb, rgb, extend(Color, {
	  brighter: function(k) {
	    k = k == null ? brighter : Math.pow(brighter, k);
	    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
	  },
	  darker: function(k) {
	    k = k == null ? darker : Math.pow(darker, k);
	    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
	  },
	  rgb: function() {
	    return this;
	  },
	  displayable: function() {
	    return (-0.5 <= this.r && this.r < 255.5)
	        && (-0.5 <= this.g && this.g < 255.5)
	        && (-0.5 <= this.b && this.b < 255.5)
	        && (0 <= this.opacity && this.opacity <= 1);
	  },
	  hex: rgb_formatHex, // Deprecated! Use color.formatHex.
	  formatHex: rgb_formatHex,
	  formatRgb: rgb_formatRgb,
	  toString: rgb_formatRgb
	}));

	function rgb_formatHex() {
	  return "#" + hex(this.r) + hex(this.g) + hex(this.b);
	}

	function rgb_formatRgb() {
	  var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
	  return (a === 1 ? "rgb(" : "rgba(")
	      + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", "
	      + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", "
	      + Math.max(0, Math.min(255, Math.round(this.b) || 0))
	      + (a === 1 ? ")" : ", " + a + ")");
	}

	function hex(value) {
	  value = Math.max(0, Math.min(255, Math.round(value) || 0));
	  return (value < 16 ? "0" : "") + value.toString(16);
	}

	function hsla(h, s, l, a) {
	  if (a <= 0) h = s = l = NaN;
	  else if (l <= 0 || l >= 1) h = s = NaN;
	  else if (s <= 0) h = NaN;
	  return new Hsl(h, s, l, a);
	}

	function hslConvert(o) {
	  if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
	  if (!(o instanceof Color)) o = color(o);
	  if (!o) return new Hsl;
	  if (o instanceof Hsl) return o;
	  o = o.rgb();
	  var r = o.r / 255,
	      g = o.g / 255,
	      b = o.b / 255,
	      min = Math.min(r, g, b),
	      max = Math.max(r, g, b),
	      h = NaN,
	      s = max - min,
	      l = (max + min) / 2;
	  if (s) {
	    if (r === max) h = (g - b) / s + (g < b) * 6;
	    else if (g === max) h = (b - r) / s + 2;
	    else h = (r - g) / s + 4;
	    s /= l < 0.5 ? max + min : 2 - max - min;
	    h *= 60;
	  } else {
	    s = l > 0 && l < 1 ? 0 : h;
	  }
	  return new Hsl(h, s, l, o.opacity);
	}

	function hsl(h, s, l, opacity) {
	  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
	}

	function Hsl(h, s, l, opacity) {
	  this.h = +h;
	  this.s = +s;
	  this.l = +l;
	  this.opacity = +opacity;
	}

	define(Hsl, hsl, extend(Color, {
	  brighter: function(k) {
	    k = k == null ? brighter : Math.pow(brighter, k);
	    return new Hsl(this.h, this.s, this.l * k, this.opacity);
	  },
	  darker: function(k) {
	    k = k == null ? darker : Math.pow(darker, k);
	    return new Hsl(this.h, this.s, this.l * k, this.opacity);
	  },
	  rgb: function() {
	    var h = this.h % 360 + (this.h < 0) * 360,
	        s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
	        l = this.l,
	        m2 = l + (l < 0.5 ? l : 1 - l) * s,
	        m1 = 2 * l - m2;
	    return new Rgb(
	      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
	      hsl2rgb(h, m1, m2),
	      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
	      this.opacity
	    );
	  },
	  displayable: function() {
	    return (0 <= this.s && this.s <= 1 || isNaN(this.s))
	        && (0 <= this.l && this.l <= 1)
	        && (0 <= this.opacity && this.opacity <= 1);
	  },
	  formatHsl: function() {
	    var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
	    return (a === 1 ? "hsl(" : "hsla(")
	        + (this.h || 0) + ", "
	        + (this.s || 0) * 100 + "%, "
	        + (this.l || 0) * 100 + "%"
	        + (a === 1 ? ")" : ", " + a + ")");
	  }
	}));

	/* From FvD 13.37, CSS Color Module Level 3 */
	function hsl2rgb(h, m1, m2) {
	  return (h < 60 ? m1 + (m2 - m1) * h / 60
	      : h < 180 ? m2
	      : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60
	      : m1) * 255;
	}

	function constant$2(x) {
	  return function() {
	    return x;
	  };
	}

	function linear$2(a, d) {
	  return function(t) {
	    return a + t * d;
	  };
	}

	function exponential(a, b, y) {
	  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
	    return Math.pow(a + t * b, y);
	  };
	}

	function gamma(y) {
	  return (y = +y) === 1 ? nogamma : function(a, b) {
	    return b - a ? exponential(a, b, y) : constant$2(isNaN(a) ? b : a);
	  };
	}

	function nogamma(a, b) {
	  var d = b - a;
	  return d ? linear$2(a, d) : constant$2(isNaN(a) ? b : a);
	}

	var interpolateRgb = (function rgbGamma(y) {
	  var color = gamma(y);

	  function rgb$1(start, end) {
	    var r = color((start = rgb(start)).r, (end = rgb(end)).r),
	        g = color(start.g, end.g),
	        b = color(start.b, end.b),
	        opacity = nogamma(start.opacity, end.opacity);
	    return function(t) {
	      start.r = r(t);
	      start.g = g(t);
	      start.b = b(t);
	      start.opacity = opacity(t);
	      return start + "";
	    };
	  }

	  rgb$1.gamma = rgbGamma;

	  return rgb$1;
	})(1);

	function numberArray(a, b) {
	  if (!b) b = [];
	  var n = a ? Math.min(b.length, a.length) : 0,
	      c = b.slice(),
	      i;
	  return function(t) {
	    for (i = 0; i < n; ++i) c[i] = a[i] * (1 - t) + b[i] * t;
	    return c;
	  };
	}

	function isNumberArray(x) {
	  return ArrayBuffer.isView(x) && !(x instanceof DataView);
	}

	function genericArray(a, b) {
	  var nb = b ? b.length : 0,
	      na = a ? Math.min(nb, a.length) : 0,
	      x = new Array(na),
	      c = new Array(nb),
	      i;

	  for (i = 0; i < na; ++i) x[i] = interpolate$1(a[i], b[i]);
	  for (; i < nb; ++i) c[i] = b[i];

	  return function(t) {
	    for (i = 0; i < na; ++i) c[i] = x[i](t);
	    return c;
	  };
	}

	function date$1(a, b) {
	  var d = new Date;
	  return a = +a, b = +b, function(t) {
	    return d.setTime(a * (1 - t) + b * t), d;
	  };
	}

	function interpolateNumber(a, b) {
	  return a = +a, b = +b, function(t) {
	    return a * (1 - t) + b * t;
	  };
	}

	function object(a, b) {
	  var i = {},
	      c = {},
	      k;

	  if (a === null || typeof a !== "object") a = {};
	  if (b === null || typeof b !== "object") b = {};

	  for (k in b) {
	    if (k in a) {
	      i[k] = interpolate$1(a[k], b[k]);
	    } else {
	      c[k] = b[k];
	    }
	  }

	  return function(t) {
	    for (k in i) c[k] = i[k](t);
	    return c;
	  };
	}

	var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
	    reB = new RegExp(reA.source, "g");

	function zero(b) {
	  return function() {
	    return b;
	  };
	}

	function one(b) {
	  return function(t) {
	    return b(t) + "";
	  };
	}

	function interpolateString(a, b) {
	  var bi = reA.lastIndex = reB.lastIndex = 0, // scan index for next number in b
	      am, // current match in a
	      bm, // current match in b
	      bs, // string preceding current number in b, if any
	      i = -1, // index in s
	      s = [], // string constants and placeholders
	      q = []; // number interpolators

	  // Coerce inputs to strings.
	  a = a + "", b = b + "";

	  // Interpolate pairs of numbers in a & b.
	  while ((am = reA.exec(a))
	      && (bm = reB.exec(b))) {
	    if ((bs = bm.index) > bi) { // a string precedes the next number in b
	      bs = b.slice(bi, bs);
	      if (s[i]) s[i] += bs; // coalesce with previous string
	      else s[++i] = bs;
	    }
	    if ((am = am[0]) === (bm = bm[0])) { // numbers in a & b match
	      if (s[i]) s[i] += bm; // coalesce with previous string
	      else s[++i] = bm;
	    } else { // interpolate non-matching numbers
	      s[++i] = null;
	      q.push({i: i, x: interpolateNumber(am, bm)});
	    }
	    bi = reB.lastIndex;
	  }

	  // Add remains of b.
	  if (bi < b.length) {
	    bs = b.slice(bi);
	    if (s[i]) s[i] += bs; // coalesce with previous string
	    else s[++i] = bs;
	  }

	  // Special optimization for only a single match.
	  // Otherwise, interpolate each of the numbers and rejoin the string.
	  return s.length < 2 ? (q[0]
	      ? one(q[0].x)
	      : zero(b))
	      : (b = q.length, function(t) {
	          for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
	          return s.join("");
	        });
	}

	function interpolate$1(a, b) {
	  var t = typeof b, c;
	  return b == null || t === "boolean" ? constant$2(b)
	      : (t === "number" ? interpolateNumber
	      : t === "string" ? ((c = color(b)) ? (b = c, interpolateRgb) : interpolateString)
	      : b instanceof color ? interpolateRgb
	      : b instanceof Date ? date$1
	      : isNumberArray(b) ? numberArray
	      : Array.isArray(b) ? genericArray
	      : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object
	      : interpolateNumber)(a, b);
	}

	function interpolateRound(a, b) {
	  return a = +a, b = +b, function(t) {
	    return Math.round(a * (1 - t) + b * t);
	  };
	}

	var cssNode,
	    cssRoot,
	    cssView,
	    svgNode$1;

	function parseCss(value) {
	  if (value === "none") return identity$4;
	  if (!cssNode) cssNode = document.createElement("DIV"), cssRoot = document.documentElement, cssView = document.defaultView;
	  cssNode.style.transform = value;
	  value = cssView.getComputedStyle(cssRoot.appendChild(cssNode), null).getPropertyValue("transform");
	  cssRoot.removeChild(cssNode);
	  value = value.slice(7, -1).split(",");
	  return decompose(+value[0], +value[1], +value[2], +value[3], +value[4], +value[5]);
	}

	function parseSvg$1(value) {
	  if (value == null) return identity$4;
	  if (!svgNode$1) svgNode$1 = document.createElementNS("http://www.w3.org/2000/svg", "g");
	  svgNode$1.setAttribute("transform", value);
	  if (!(value = svgNode$1.transform.baseVal.consolidate())) return identity$4;
	  value = value.matrix;
	  return decompose(value.a, value.b, value.c, value.d, value.e, value.f);
	}

	function interpolateTransform(parse, pxComma, pxParen, degParen) {

	  function pop(s) {
	    return s.length ? s.pop() + " " : "";
	  }

	  function translate(xa, ya, xb, yb, s, q) {
	    if (xa !== xb || ya !== yb) {
	      var i = s.push("translate(", null, pxComma, null, pxParen);
	      q.push({i: i - 4, x: interpolateNumber(xa, xb)}, {i: i - 2, x: interpolateNumber(ya, yb)});
	    } else if (xb || yb) {
	      s.push("translate(" + xb + pxComma + yb + pxParen);
	    }
	  }

	  function rotate(a, b, s, q) {
	    if (a !== b) {
	      if (a - b > 180) b += 360; else if (b - a > 180) a += 360; // shortest path
	      q.push({i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: interpolateNumber(a, b)});
	    } else if (b) {
	      s.push(pop(s) + "rotate(" + b + degParen);
	    }
	  }

	  function skewX(a, b, s, q) {
	    if (a !== b) {
	      q.push({i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: interpolateNumber(a, b)});
	    } else if (b) {
	      s.push(pop(s) + "skewX(" + b + degParen);
	    }
	  }

	  function scale(xa, ya, xb, yb, s, q) {
	    if (xa !== xb || ya !== yb) {
	      var i = s.push(pop(s) + "scale(", null, ",", null, ")");
	      q.push({i: i - 4, x: interpolateNumber(xa, xb)}, {i: i - 2, x: interpolateNumber(ya, yb)});
	    } else if (xb !== 1 || yb !== 1) {
	      s.push(pop(s) + "scale(" + xb + "," + yb + ")");
	    }
	  }

	  return function(a, b) {
	    var s = [], // string constants and placeholders
	        q = []; // number interpolators
	    a = parse(a), b = parse(b);
	    translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
	    rotate(a.rotate, b.rotate, s, q);
	    skewX(a.skewX, b.skewX, s, q);
	    scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
	    a = b = null; // gc
	    return function(t) {
	      var i = -1, n = q.length, o;
	      while (++i < n) s[(o = q[i]).i] = o.x(t);
	      return s.join("");
	    };
	  };
	}

	var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
	var interpolateTransformSvg = interpolateTransform(parseSvg$1, ", ", ")", ")");

	var frame = 0, // is an animation frame pending?
	    timeout$1 = 0, // is a timeout pending?
	    interval = 0, // are any timers active?
	    pokeDelay = 1000, // how frequently we check for clock skew
	    taskHead,
	    taskTail,
	    clockLast = 0,
	    clockNow = 0,
	    clockSkew = 0,
	    clock = typeof performance === "object" && performance.now ? performance : Date,
	    setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) { setTimeout(f, 17); };

	function now$5() {
	  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
	}

	function clearNow() {
	  clockNow = 0;
	}

	function Timer() {
	  this._call =
	  this._time =
	  this._next = null;
	}

	Timer.prototype = timer.prototype = {
	  constructor: Timer,
	  restart: function(callback, delay, time) {
	    if (typeof callback !== "function") throw new TypeError("callback is not a function");
	    time = (time == null ? now$5() : +time) + (delay == null ? 0 : +delay);
	    if (!this._next && taskTail !== this) {
	      if (taskTail) taskTail._next = this;
	      else taskHead = this;
	      taskTail = this;
	    }
	    this._call = callback;
	    this._time = time;
	    sleep();
	  },
	  stop: function() {
	    if (this._call) {
	      this._call = null;
	      this._time = Infinity;
	      sleep();
	    }
	  }
	};

	function timer(callback, delay, time) {
	  var t = new Timer;
	  t.restart(callback, delay, time);
	  return t;
	}

	function timerFlush() {
	  now$5(); // Get the current time, if not already set.
	  ++frame; // Pretend weâve set an alarm, if we havenât already.
	  var t = taskHead, e;
	  while (t) {
	    if ((e = clockNow - t._time) >= 0) t._call.call(null, e);
	    t = t._next;
	  }
	  --frame;
	}

	function wake() {
	  clockNow = (clockLast = clock.now()) + clockSkew;
	  frame = timeout$1 = 0;
	  try {
	    timerFlush();
	  } finally {
	    frame = 0;
	    nap();
	    clockNow = 0;
	  }
	}

	function poke() {
	  var now = clock.now(), delay = now - clockLast;
	  if (delay > pokeDelay) clockSkew -= delay, clockLast = now;
	}

	function nap() {
	  var t0, t1 = taskHead, t2, time = Infinity;
	  while (t1) {
	    if (t1._call) {
	      if (time > t1._time) time = t1._time;
	      t0 = t1, t1 = t1._next;
	    } else {
	      t2 = t1._next, t1._next = null;
	      t1 = t0 ? t0._next = t2 : taskHead = t2;
	    }
	  }
	  taskTail = t0;
	  sleep(time);
	}

	function sleep(time) {
	  if (frame) return; // Soonest alarm already set, or will be.
	  if (timeout$1) timeout$1 = clearTimeout(timeout$1);
	  var delay = time - clockNow; // Strictly less than if we recomputed clockNow.
	  if (delay > 24) {
	    if (time < Infinity) timeout$1 = setTimeout(wake, time - clock.now() - clockSkew);
	    if (interval) interval = clearInterval(interval);
	  } else {
	    if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
	    frame = 1, setFrame(wake);
	  }
	}

	function timeout(callback, delay, time) {
	  var t = new Timer;
	  delay = delay == null ? 0 : +delay;
	  t.restart(function(elapsed) {
	    t.stop();
	    callback(elapsed + delay);
	  }, delay, time);
	  return t;
	}

	var emptyOn = dispatch("start", "end", "cancel", "interrupt");
	var emptyTween = [];

	var CREATED = 0;
	var SCHEDULED = 1;
	var STARTING = 2;
	var STARTED = 3;
	var RUNNING = 4;
	var ENDING = 5;
	var ENDED = 6;

	function schedule(node, name, id, index, group, timing) {
	  var schedules = node.__transition;
	  if (!schedules) node.__transition = {};
	  else if (id in schedules) return;
	  create(node, id, {
	    name: name,
	    index: index, // For context during callback.
	    group: group, // For context during callback.
	    on: emptyOn,
	    tween: emptyTween,
	    time: timing.time,
	    delay: timing.delay,
	    duration: timing.duration,
	    ease: timing.ease,
	    timer: null,
	    state: CREATED
	  });
	}

	function init$1(node, id) {
	  var schedule = get$1(node, id);
	  if (schedule.state > CREATED) throw new Error("too late; already scheduled");
	  return schedule;
	}

	function set(node, id) {
	  var schedule = get$1(node, id);
	  if (schedule.state > STARTED) throw new Error("too late; already running");
	  return schedule;
	}

	function get$1(node, id) {
	  var schedule = node.__transition;
	  if (!schedule || !(schedule = schedule[id])) throw new Error("transition not found");
	  return schedule;
	}

	function create(node, id, self) {
	  var schedules = node.__transition,
	      tween;

	  // Initialize the self timer when the transition is created.
	  // Note the actual delay is not known until the first callback!
	  schedules[id] = self;
	  self.timer = timer(schedule, 0, self.time);

	  function schedule(elapsed) {
	    self.state = SCHEDULED;
	    self.timer.restart(start, self.delay, self.time);

	    // If the elapsed delay is less than our first sleep, start immediately.
	    if (self.delay <= elapsed) start(elapsed - self.delay);
	  }

	  function start(elapsed) {
	    var i, j, n, o;

	    // If the state is not SCHEDULED, then we previously errored on start.
	    if (self.state !== SCHEDULED) return stop();

	    for (i in schedules) {
	      o = schedules[i];
	      if (o.name !== self.name) continue;

	      // While this element already has a starting transition during this frame,
	      // defer starting an interrupting transition until that transition has a
	      // chance to tick (and possibly end); see d3/d3-transition#54!
	      if (o.state === STARTED) return timeout(start);

	      // Interrupt the active transition, if any.
	      if (o.state === RUNNING) {
	        o.state = ENDED;
	        o.timer.stop();
	        o.on.call("interrupt", node, node.__data__, o.index, o.group);
	        delete schedules[i];
	      }

	      // Cancel any pre-empted transitions.
	      else if (+i < id) {
	        o.state = ENDED;
	        o.timer.stop();
	        o.on.call("cancel", node, node.__data__, o.index, o.group);
	        delete schedules[i];
	      }
	    }

	    // Defer the first tick to end of the current frame; see d3/d3#1576.
	    // Note the transition may be canceled after start and before the first tick!
	    // Note this must be scheduled before the start event; see d3/d3-transition#16!
	    // Assuming this is successful, subsequent callbacks go straight to tick.
	    timeout(function() {
	      if (self.state === STARTED) {
	        self.state = RUNNING;
	        self.timer.restart(tick, self.delay, self.time);
	        tick(elapsed);
	      }
	    });

	    // Dispatch the start event.
	    // Note this must be done before the tween are initialized.
	    self.state = STARTING;
	    self.on.call("start", node, node.__data__, self.index, self.group);
	    if (self.state !== STARTING) return; // interrupted
	    self.state = STARTED;

	    // Initialize the tween, deleting null tween.
	    tween = new Array(n = self.tween.length);
	    for (i = 0, j = -1; i < n; ++i) {
	      if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {
	        tween[++j] = o;
	      }
	    }
	    tween.length = j + 1;
	  }

	  function tick(elapsed) {
	    var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1),
	        i = -1,
	        n = tween.length;

	    while (++i < n) {
	      tween[i].call(node, t);
	    }

	    // Dispatch the end event.
	    if (self.state === ENDING) {
	      self.on.call("end", node, node.__data__, self.index, self.group);
	      stop();
	    }
	  }

	  function stop() {
	    self.state = ENDED;
	    self.timer.stop();
	    delete schedules[id];
	    for (var i in schedules) return; // eslint-disable-line no-unused-vars
	    delete node.__transition;
	  }
	}

	function interrupt(node, name) {
	  var schedules = node.__transition,
	      schedule,
	      active,
	      empty = true,
	      i;

	  if (!schedules) return;

	  name = name == null ? null : name + "";

	  for (i in schedules) {
	    if ((schedule = schedules[i]).name !== name) { empty = false; continue; }
	    active = schedule.state > STARTING && schedule.state < ENDING;
	    schedule.state = ENDED;
	    schedule.timer.stop();
	    schedule.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule.index, schedule.group);
	    delete schedules[i];
	  }

	  if (empty) delete node.__transition;
	}

	function selection_interrupt(name) {
	  return this.each(function() {
	    interrupt(this, name);
	  });
	}

	function tweenRemove(id, name) {
	  var tween0, tween1;
	  return function() {
	    var schedule = set(this, id),
	        tween = schedule.tween;

	    // If this node shared tween with the previous node,
	    // just assign the updated shared tween and weâre done!
	    // Otherwise, copy-on-write.
	    if (tween !== tween0) {
	      tween1 = tween0 = tween;
	      for (var i = 0, n = tween1.length; i < n; ++i) {
	        if (tween1[i].name === name) {
	          tween1 = tween1.slice();
	          tween1.splice(i, 1);
	          break;
	        }
	      }
	    }

	    schedule.tween = tween1;
	  };
	}

	function tweenFunction(id, name, value) {
	  var tween0, tween1;
	  if (typeof value !== "function") throw new Error;
	  return function() {
	    var schedule = set(this, id),
	        tween = schedule.tween;

	    // If this node shared tween with the previous node,
	    // just assign the updated shared tween and weâre done!
	    // Otherwise, copy-on-write.
	    if (tween !== tween0) {
	      tween1 = (tween0 = tween).slice();
	      for (var t = {name: name, value: value}, i = 0, n = tween1.length; i < n; ++i) {
	        if (tween1[i].name === name) {
	          tween1[i] = t;
	          break;
	        }
	      }
	      if (i === n) tween1.push(t);
	    }

	    schedule.tween = tween1;
	  };
	}

	function transition_tween(name, value) {
	  var id = this._id;

	  name += "";

	  if (arguments.length < 2) {
	    var tween = get$1(this.node(), id).tween;
	    for (var i = 0, n = tween.length, t; i < n; ++i) {
	      if ((t = tween[i]).name === name) {
	        return t.value;
	      }
	    }
	    return null;
	  }

	  return this.each((value == null ? tweenRemove : tweenFunction)(id, name, value));
	}

	function tweenValue(transition, name, value) {
	  var id = transition._id;

	  transition.each(function() {
	    var schedule = set(this, id);
	    (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);
	  });

	  return function(node) {
	    return get$1(node, id).value[name];
	  };
	}

	function interpolate(a, b) {
	  var c;
	  return (typeof b === "number" ? interpolateNumber
	      : b instanceof color ? interpolateRgb
	      : (c = color(b)) ? (b = c, interpolateRgb)
	      : interpolateString)(a, b);
	}

	function attrRemove(name) {
	  return function() {
	    this.removeAttribute(name);
	  };
	}

	function attrRemoveNS(fullname) {
	  return function() {
	    this.removeAttributeNS(fullname.space, fullname.local);
	  };
	}

	function attrConstant(name, interpolate, value1) {
	  var string00,
	      string1 = value1 + "",
	      interpolate0;
	  return function() {
	    var string0 = this.getAttribute(name);
	    return string0 === string1 ? null
	        : string0 === string00 ? interpolate0
	        : interpolate0 = interpolate(string00 = string0, value1);
	  };
	}

	function attrConstantNS(fullname, interpolate, value1) {
	  var string00,
	      string1 = value1 + "",
	      interpolate0;
	  return function() {
	    var string0 = this.getAttributeNS(fullname.space, fullname.local);
	    return string0 === string1 ? null
	        : string0 === string00 ? interpolate0
	        : interpolate0 = interpolate(string00 = string0, value1);
	  };
	}

	function attrFunction(name, interpolate, value) {
	  var string00,
	      string10,
	      interpolate0;
	  return function() {
	    var string0, value1 = value(this), string1;
	    if (value1 == null) return void this.removeAttribute(name);
	    string0 = this.getAttribute(name);
	    string1 = value1 + "";
	    return string0 === string1 ? null
	        : string0 === string00 && string1 === string10 ? interpolate0
	        : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
	  };
	}

	function attrFunctionNS(fullname, interpolate, value) {
	  var string00,
	      string10,
	      interpolate0;
	  return function() {
	    var string0, value1 = value(this), string1;
	    if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);
	    string0 = this.getAttributeNS(fullname.space, fullname.local);
	    string1 = value1 + "";
	    return string0 === string1 ? null
	        : string0 === string00 && string1 === string10 ? interpolate0
	        : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
	  };
	}

	function transition_attr(name, value) {
	  var fullname = namespace(name), i = fullname === "transform" ? interpolateTransformSvg : interpolate;
	  return this.attrTween(name, typeof value === "function"
	      ? (fullname.local ? attrFunctionNS : attrFunction)(fullname, i, tweenValue(this, "attr." + name, value))
	      : value == null ? (fullname.local ? attrRemoveNS : attrRemove)(fullname)
	      : (fullname.local ? attrConstantNS : attrConstant)(fullname, i, value));
	}

	function attrInterpolate(name, i) {
	  return function(t) {
	    this.setAttribute(name, i.call(this, t));
	  };
	}

	function attrInterpolateNS(fullname, i) {
	  return function(t) {
	    this.setAttributeNS(fullname.space, fullname.local, i.call(this, t));
	  };
	}

	function attrTweenNS(fullname, value) {
	  var t0, i0;
	  function tween() {
	    var i = value.apply(this, arguments);
	    if (i !== i0) t0 = (i0 = i) && attrInterpolateNS(fullname, i);
	    return t0;
	  }
	  tween._value = value;
	  return tween;
	}

	function attrTween(name, value) {
	  var t0, i0;
	  function tween() {
	    var i = value.apply(this, arguments);
	    if (i !== i0) t0 = (i0 = i) && attrInterpolate(name, i);
	    return t0;
	  }
	  tween._value = value;
	  return tween;
	}

	function transition_attrTween(name, value) {
	  var key = "attr." + name;
	  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
	  if (value == null) return this.tween(key, null);
	  if (typeof value !== "function") throw new Error;
	  var fullname = namespace(name);
	  return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
	}

	function delayFunction(id, value) {
	  return function() {
	    init$1(this, id).delay = +value.apply(this, arguments);
	  };
	}

	function delayConstant(id, value) {
	  return value = +value, function() {
	    init$1(this, id).delay = value;
	  };
	}

	function transition_delay(value) {
	  var id = this._id;

	  return arguments.length
	      ? this.each((typeof value === "function"
	          ? delayFunction
	          : delayConstant)(id, value))
	      : get$1(this.node(), id).delay;
	}

	function durationFunction(id, value) {
	  return function() {
	    set(this, id).duration = +value.apply(this, arguments);
	  };
	}

	function durationConstant(id, value) {
	  return value = +value, function() {
	    set(this, id).duration = value;
	  };
	}

	function transition_duration(value) {
	  var id = this._id;

	  return arguments.length
	      ? this.each((typeof value === "function"
	          ? durationFunction
	          : durationConstant)(id, value))
	      : get$1(this.node(), id).duration;
	}

	function easeConstant(id, value) {
	  if (typeof value !== "function") throw new Error;
	  return function() {
	    set(this, id).ease = value;
	  };
	}

	function transition_ease(value) {
	  var id = this._id;

	  return arguments.length
	      ? this.each(easeConstant(id, value))
	      : get$1(this.node(), id).ease;
	}

	function transition_filter(match) {
	  if (typeof match !== "function") match = matcher(match);

	  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
	    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
	      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
	        subgroup.push(node);
	      }
	    }
	  }

	  return new Transition(subgroups, this._parents, this._name, this._id);
	}

	function transition_merge(transition) {
	  if (transition._id !== this._id) throw new Error;

	  for (var groups0 = this._groups, groups1 = transition._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
	    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
	      if (node = group0[i] || group1[i]) {
	        merge[i] = node;
	      }
	    }
	  }

	  for (; j < m0; ++j) {
	    merges[j] = groups0[j];
	  }

	  return new Transition(merges, this._parents, this._name, this._id);
	}

	function start(name) {
	  return (name + "").trim().split(/^|\s+/).every(function(t) {
	    var i = t.indexOf(".");
	    if (i >= 0) t = t.slice(0, i);
	    return !t || t === "start";
	  });
	}

	function onFunction(id, name, listener) {
	  var on0, on1, sit = start(name) ? init$1 : set;
	  return function() {
	    var schedule = sit(this, id),
	        on = schedule.on;

	    // If this node shared a dispatch with the previous node,
	    // just assign the updated shared dispatch and weâre done!
	    // Otherwise, copy-on-write.
	    if (on !== on0) (on1 = (on0 = on).copy()).on(name, listener);

	    schedule.on = on1;
	  };
	}

	function transition_on(name, listener) {
	  var id = this._id;

	  return arguments.length < 2
	      ? get$1(this.node(), id).on.on(name)
	      : this.each(onFunction(id, name, listener));
	}

	function removeFunction(id) {
	  return function() {
	    var parent = this.parentNode;
	    for (var i in this.__transition) if (+i !== id) return;
	    if (parent) parent.removeChild(this);
	  };
	}

	function transition_remove() {
	  return this.on("end.remove", removeFunction(this._id));
	}

	function transition_select(select) {
	  var name = this._name,
	      id = this._id;

	  if (typeof select !== "function") select = selector(select);

	  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
	    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
	      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
	        if ("__data__" in node) subnode.__data__ = node.__data__;
	        subgroup[i] = subnode;
	        schedule(subgroup[i], name, id, i, subgroup, get$1(node, id));
	      }
	    }
	  }

	  return new Transition(subgroups, this._parents, name, id);
	}

	function transition_selectAll(select) {
	  var name = this._name,
	      id = this._id;

	  if (typeof select !== "function") select = selectorAll(select);

	  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
	    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
	      if (node = group[i]) {
	        for (var children = select.call(node, node.__data__, i, group), child, inherit = get$1(node, id), k = 0, l = children.length; k < l; ++k) {
	          if (child = children[k]) {
	            schedule(child, name, id, k, children, inherit);
	          }
	        }
	        subgroups.push(children);
	        parents.push(node);
	      }
	    }
	  }

	  return new Transition(subgroups, parents, name, id);
	}

	var Selection = selection.prototype.constructor;

	function transition_selection() {
	  return new Selection(this._groups, this._parents);
	}

	function styleNull(name, interpolate) {
	  var string00,
	      string10,
	      interpolate0;
	  return function() {
	    var string0 = styleValue(this, name),
	        string1 = (this.style.removeProperty(name), styleValue(this, name));
	    return string0 === string1 ? null
	        : string0 === string00 && string1 === string10 ? interpolate0
	        : interpolate0 = interpolate(string00 = string0, string10 = string1);
	  };
	}

	function styleRemove(name) {
	  return function() {
	    this.style.removeProperty(name);
	  };
	}

	function styleConstant(name, interpolate, value1) {
	  var string00,
	      string1 = value1 + "",
	      interpolate0;
	  return function() {
	    var string0 = styleValue(this, name);
	    return string0 === string1 ? null
	        : string0 === string00 ? interpolate0
	        : interpolate0 = interpolate(string00 = string0, value1);
	  };
	}

	function styleFunction(name, interpolate, value) {
	  var string00,
	      string10,
	      interpolate0;
	  return function() {
	    var string0 = styleValue(this, name),
	        value1 = value(this),
	        string1 = value1 + "";
	    if (value1 == null) string1 = value1 = (this.style.removeProperty(name), styleValue(this, name));
	    return string0 === string1 ? null
	        : string0 === string00 && string1 === string10 ? interpolate0
	        : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
	  };
	}

	function styleMaybeRemove(id, name) {
	  var on0, on1, listener0, key = "style." + name, event = "end." + key, remove;
	  return function() {
	    var schedule = set(this, id),
	        on = schedule.on,
	        listener = schedule.value[key] == null ? remove || (remove = styleRemove(name)) : undefined;

	    // If this node shared a dispatch with the previous node,
	    // just assign the updated shared dispatch and weâre done!
	    // Otherwise, copy-on-write.
	    if (on !== on0 || listener0 !== listener) (on1 = (on0 = on).copy()).on(event, listener0 = listener);

	    schedule.on = on1;
	  };
	}

	function transition_style(name, value, priority) {
	  var i = (name += "") === "transform" ? interpolateTransformCss : interpolate;
	  return value == null ? this
	      .styleTween(name, styleNull(name, i))
	      .on("end.style." + name, styleRemove(name))
	    : typeof value === "function" ? this
	      .styleTween(name, styleFunction(name, i, tweenValue(this, "style." + name, value)))
	      .each(styleMaybeRemove(this._id, name))
	    : this
	      .styleTween(name, styleConstant(name, i, value), priority)
	      .on("end.style." + name, null);
	}

	function styleInterpolate(name, i, priority) {
	  return function(t) {
	    this.style.setProperty(name, i.call(this, t), priority);
	  };
	}

	function styleTween(name, value, priority) {
	  var t, i0;
	  function tween() {
	    var i = value.apply(this, arguments);
	    if (i !== i0) t = (i0 = i) && styleInterpolate(name, i, priority);
	    return t;
	  }
	  tween._value = value;
	  return tween;
	}

	function transition_styleTween(name, value, priority) {
	  var key = "style." + (name += "");
	  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
	  if (value == null) return this.tween(key, null);
	  if (typeof value !== "function") throw new Error;
	  return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
	}

	function textConstant(value) {
	  return function() {
	    this.textContent = value;
	  };
	}

	function textFunction(value) {
	  return function() {
	    var value1 = value(this);
	    this.textContent = value1 == null ? "" : value1;
	  };
	}

	function transition_text(value) {
	  return this.tween("text", typeof value === "function"
	      ? textFunction(tweenValue(this, "text", value))
	      : textConstant(value == null ? "" : value + ""));
	}

	function textInterpolate(i) {
	  return function(t) {
	    this.textContent = i.call(this, t);
	  };
	}

	function textTween(value) {
	  var t0, i0;
	  function tween() {
	    var i = value.apply(this, arguments);
	    if (i !== i0) t0 = (i0 = i) && textInterpolate(i);
	    return t0;
	  }
	  tween._value = value;
	  return tween;
	}

	function transition_textTween(value) {
	  var key = "text";
	  if (arguments.length < 1) return (key = this.tween(key)) && key._value;
	  if (value == null) return this.tween(key, null);
	  if (typeof value !== "function") throw new Error;
	  return this.tween(key, textTween(value));
	}

	function transition_transition() {
	  var name = this._name,
	      id0 = this._id,
	      id1 = newId();

	  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
	    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
	      if (node = group[i]) {
	        var inherit = get$1(node, id0);
	        schedule(node, name, id1, i, group, {
	          time: inherit.time + inherit.delay + inherit.duration,
	          delay: 0,
	          duration: inherit.duration,
	          ease: inherit.ease
	        });
	      }
	    }
	  }

	  return new Transition(groups, this._parents, name, id1);
	}

	function transition_end() {
	  var on0, on1, that = this, id = that._id, size = that.size();
	  return new Promise(function(resolve, reject) {
	    var cancel = {value: reject},
	        end = {value: function() { if (--size === 0) resolve(); }};

	    that.each(function() {
	      var schedule = set(this, id),
	          on = schedule.on;

	      // If this node shared a dispatch with the previous node,
	      // just assign the updated shared dispatch and weâre done!
	      // Otherwise, copy-on-write.
	      if (on !== on0) {
	        on1 = (on0 = on).copy();
	        on1._.cancel.push(cancel);
	        on1._.interrupt.push(cancel);
	        on1._.end.push(end);
	      }

	      schedule.on = on1;
	    });
	  });
	}

	var id = 0;

	function Transition(groups, parents, name, id) {
	  this._groups = groups;
	  this._parents = parents;
	  this._name = name;
	  this._id = id;
	}

	function newId() {
	  return ++id;
	}

	var selection_prototype = selection.prototype;

	Transition.prototype = {
	  constructor: Transition,
	  select: transition_select,
	  selectAll: transition_selectAll,
	  filter: transition_filter,
	  merge: transition_merge,
	  selection: transition_selection,
	  transition: transition_transition,
	  call: selection_prototype.call,
	  nodes: selection_prototype.nodes,
	  node: selection_prototype.node,
	  size: selection_prototype.size,
	  empty: selection_prototype.empty,
	  each: selection_prototype.each,
	  on: transition_on,
	  attr: transition_attr,
	  attrTween: transition_attrTween,
	  style: transition_style,
	  styleTween: transition_styleTween,
	  text: transition_text,
	  textTween: transition_textTween,
	  remove: transition_remove,
	  tween: transition_tween,
	  delay: transition_delay,
	  duration: transition_duration,
	  ease: transition_ease,
	  end: transition_end
	};

	function linear$1(t) {
	  return +t;
	}

	function cubicInOut(t) {
	  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
	}

	var overshoot = 1.70158;

	((function custom(s) {
	  s = +s;

	  function backIn(t) {
	    return (t = +t) * t * (s * (t - 1) + t);
	  }

	  backIn.overshoot = custom;

	  return backIn;
	}))(overshoot);

	var backOut = (function custom(s) {
	  s = +s;

	  function backOut(t) {
	    return --t * t * ((t + 1) * s + t) + 1;
	  }

	  backOut.overshoot = custom;

	  return backOut;
	})(overshoot);

	((function custom(s) {
	  s = +s;

	  function backInOut(t) {
	    return ((t *= 2) < 1 ? t * t * ((s + 1) * t - s) : (t -= 2) * t * ((s + 1) * t + s) + 2) / 2;
	  }

	  backInOut.overshoot = custom;

	  return backInOut;
	}))(overshoot);

	var defaultTiming = {
	  time: null, // Set on use.
	  delay: 0,
	  duration: 250,
	  ease: cubicInOut
	};

	function inherit(node, id) {
	  var timing;
	  while (!(timing = node.__transition) || !(timing = timing[id])) {
	    if (!(node = node.parentNode)) {
	      return defaultTiming.time = now$5(), defaultTiming;
	    }
	  }
	  return timing;
	}

	function selection_transition(name) {
	  var id,
	      timing;

	  if (name instanceof Transition) {
	    id = name._id, name = name._name;
	  } else {
	    id = newId(), (timing = defaultTiming).time = now$5(), name = name == null ? null : name + "";
	  }

	  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
	    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
	      if (node = group[i]) {
	        schedule(node, name, id, i, group, timing || inherit(node, id));
	      }
	    }
	  }

	  return new Transition(groups, this._parents, name, id);
	}

	selection.prototype.interrupt = selection_interrupt;
	selection.prototype.transition = selection_transition;

	var pi$1 = Math.PI,
	    tau$2 = 2 * pi$1,
	    epsilon$3 = 1e-6,
	    tauEpsilon = tau$2 - epsilon$3;

	function Path$1() {
	  this._x0 = this._y0 = // start of current subpath
	  this._x1 = this._y1 = null; // end of current subpath
	  this._ = "";
	}

	function path() {
	  return new Path$1;
	}

	Path$1.prototype = path.prototype = {
	  constructor: Path$1,
	  moveTo: function(x, y) {
	    this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y);
	  },
	  closePath: function() {
	    if (this._x1 !== null) {
	      this._x1 = this._x0, this._y1 = this._y0;
	      this._ += "Z";
	    }
	  },
	  lineTo: function(x, y) {
	    this._ += "L" + (this._x1 = +x) + "," + (this._y1 = +y);
	  },
	  quadraticCurveTo: function(x1, y1, x, y) {
	    this._ += "Q" + (+x1) + "," + (+y1) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
	  },
	  bezierCurveTo: function(x1, y1, x2, y2, x, y) {
	    this._ += "C" + (+x1) + "," + (+y1) + "," + (+x2) + "," + (+y2) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
	  },
	  arcTo: function(x1, y1, x2, y2, r) {
	    x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;
	    var x0 = this._x1,
	        y0 = this._y1,
	        x21 = x2 - x1,
	        y21 = y2 - y1,
	        x01 = x0 - x1,
	        y01 = y0 - y1,
	        l01_2 = x01 * x01 + y01 * y01;

	    // Is the radius negative? Error.
	    if (r < 0) throw new Error("negative radius: " + r);

	    // Is this path empty? Move to (x1,y1).
	    if (this._x1 === null) {
	      this._ += "M" + (this._x1 = x1) + "," + (this._y1 = y1);
	    }

	    // Or, is (x1,y1) coincident with (x0,y0)? Do nothing.
	    else if (!(l01_2 > epsilon$3));

	    // Or, are (x0,y0), (x1,y1) and (x2,y2) collinear?
	    // Equivalently, is (x1,y1) coincident with (x2,y2)?
	    // Or, is the radius zero? Line to (x1,y1).
	    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon$3) || !r) {
	      this._ += "L" + (this._x1 = x1) + "," + (this._y1 = y1);
	    }

	    // Otherwise, draw an arc!
	    else {
	      var x20 = x2 - x0,
	          y20 = y2 - y0,
	          l21_2 = x21 * x21 + y21 * y21,
	          l20_2 = x20 * x20 + y20 * y20,
	          l21 = Math.sqrt(l21_2),
	          l01 = Math.sqrt(l01_2),
	          l = r * Math.tan((pi$1 - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2),
	          t01 = l / l01,
	          t21 = l / l21;

	      // If the start tangent is not coincident with (x0,y0), line to.
	      if (Math.abs(t01 - 1) > epsilon$3) {
	        this._ += "L" + (x1 + t01 * x01) + "," + (y1 + t01 * y01);
	      }

	      this._ += "A" + r + "," + r + ",0,0," + (+(y01 * x20 > x01 * y20)) + "," + (this._x1 = x1 + t21 * x21) + "," + (this._y1 = y1 + t21 * y21);
	    }
	  },
	  arc: function(x, y, r, a0, a1, ccw) {
	    x = +x, y = +y, r = +r, ccw = !!ccw;
	    var dx = r * Math.cos(a0),
	        dy = r * Math.sin(a0),
	        x0 = x + dx,
	        y0 = y + dy,
	        cw = 1 ^ ccw,
	        da = ccw ? a0 - a1 : a1 - a0;

	    // Is the radius negative? Error.
	    if (r < 0) throw new Error("negative radius: " + r);

	    // Is this path empty? Move to (x0,y0).
	    if (this._x1 === null) {
	      this._ += "M" + x0 + "," + y0;
	    }

	    // Or, is (x0,y0) not coincident with the previous point? Line to (x0,y0).
	    else if (Math.abs(this._x1 - x0) > epsilon$3 || Math.abs(this._y1 - y0) > epsilon$3) {
	      this._ += "L" + x0 + "," + y0;
	    }

	    // Is this arc empty? Weâre done.
	    if (!r) return;

	    // Does the angle go the wrong way? Flip the direction.
	    if (da < 0) da = da % tau$2 + tau$2;

	    // Is this a complete circle? Draw two arcs to complete the circle.
	    if (da > tauEpsilon) {
	      this._ += "A" + r + "," + r + ",0,1," + cw + "," + (x - dx) + "," + (y - dy) + "A" + r + "," + r + ",0,1," + cw + "," + (this._x1 = x0) + "," + (this._y1 = y0);
	    }

	    // Is this arc non-empty? Draw an arc!
	    else if (da > epsilon$3) {
	      this._ += "A" + r + "," + r + ",0," + (+(da >= pi$1)) + "," + cw + "," + (this._x1 = x + r * Math.cos(a1)) + "," + (this._y1 = y + r * Math.sin(a1));
	    }
	  },
	  rect: function(x, y, w, h) {
	    this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y) + "h" + (+w) + "v" + (+h) + "h" + (-w) + "Z";
	  },
	  toString: function() {
	    return this._;
	  }
	};

	var prefix = "$";

	function Map$1() {}

	Map$1.prototype = map$1.prototype = {
	  constructor: Map$1,
	  has: function(key) {
	    return (prefix + key) in this;
	  },
	  get: function(key) {
	    return this[prefix + key];
	  },
	  set: function(key, value) {
	    this[prefix + key] = value;
	    return this;
	  },
	  remove: function(key) {
	    var property = prefix + key;
	    return property in this && delete this[property];
	  },
	  clear: function() {
	    for (var property in this) if (property[0] === prefix) delete this[property];
	  },
	  keys: function() {
	    var keys = [];
	    for (var property in this) if (property[0] === prefix) keys.push(property.slice(1));
	    return keys;
	  },
	  values: function() {
	    var values = [];
	    for (var property in this) if (property[0] === prefix) values.push(this[property]);
	    return values;
	  },
	  entries: function() {
	    var entries = [];
	    for (var property in this) if (property[0] === prefix) entries.push({key: property.slice(1), value: this[property]});
	    return entries;
	  },
	  size: function() {
	    var size = 0;
	    for (var property in this) if (property[0] === prefix) ++size;
	    return size;
	  },
	  empty: function() {
	    for (var property in this) if (property[0] === prefix) return false;
	    return true;
	  },
	  each: function(f) {
	    for (var property in this) if (property[0] === prefix) f(this[property], property.slice(1), this);
	  }
	};

	function map$1(object, f) {
	  var map = new Map$1;

	  // Copy constructor.
	  if (object instanceof Map$1) object.each(function(value, key) { map.set(key, value); });

	  // Index array by numeric index or specified key function.
	  else if (Array.isArray(object)) {
	    var i = -1,
	        n = object.length,
	        o;

	    if (f == null) while (++i < n) map.set(i, object[i]);
	    else while (++i < n) map.set(f(o = object[i], i, object), o);
	  }

	  // Convert object to map.
	  else if (object) for (var key in object) map.set(key, object[key]);

	  return map;
	}

	function Set$1() {}

	var proto = map$1.prototype;

	Set$1.prototype = {
	  constructor: Set$1,
	  has: proto.has,
	  add: function(value) {
	    value += "";
	    this[prefix + value] = value;
	    return this;
	  },
	  remove: proto.remove,
	  clear: proto.clear,
	  values: proto.keys,
	  size: proto.size,
	  empty: proto.empty,
	  each: proto.each
	};

	function defaultSource() {
	  return Math.random();
	}

	((function sourceRandomUniform(source) {
	  function randomUniform(min, max) {
	    min = min == null ? 0 : +min;
	    max = max == null ? 1 : +max;
	    if (arguments.length === 1) max = min, min = 0;
	    else max -= min;
	    return function() {
	      return source() * max + min;
	    };
	  }

	  randomUniform.source = sourceRandomUniform;

	  return randomUniform;
	}))(defaultSource);

	var normal = (function sourceRandomNormal(source) {
	  function randomNormal(mu, sigma) {
	    var x, r;
	    mu = mu == null ? 0 : +mu;
	    sigma = sigma == null ? 1 : +sigma;
	    return function() {
	      var y;

	      // If available, use the second previously-generated uniform random.
	      if (x != null) y = x, x = null;

	      // Otherwise, generate a new x and y.
	      else do {
	        x = source() * 2 - 1;
	        y = source() * 2 - 1;
	        r = x * x + y * y;
	      } while (!r || r > 1);

	      return mu + sigma * y * Math.sqrt(-2 * Math.log(r) / r);
	    };
	  }

	  randomNormal.source = sourceRandomNormal;

	  return randomNormal;
	})(defaultSource);

	((function sourceRandomLogNormal(source) {
	  function randomLogNormal() {
	    var randomNormal = normal.source(source).apply(this, arguments);
	    return function() {
	      return Math.exp(randomNormal());
	    };
	  }

	  randomLogNormal.source = sourceRandomLogNormal;

	  return randomLogNormal;
	}))(defaultSource);

	var irwinHall = (function sourceRandomIrwinHall(source) {
	  function randomIrwinHall(n) {
	    return function() {
	      for (var sum = 0, i = 0; i < n; ++i) sum += source();
	      return sum;
	    };
	  }

	  randomIrwinHall.source = sourceRandomIrwinHall;

	  return randomIrwinHall;
	})(defaultSource);

	((function sourceRandomBates(source) {
	  function randomBates(n) {
	    var randomIrwinHall = irwinHall.source(source)(n);
	    return function() {
	      return randomIrwinHall() / n;
	    };
	  }

	  randomBates.source = sourceRandomBates;

	  return randomBates;
	}))(defaultSource);

	((function sourceRandomExponential(source) {
	  function randomExponential(lambda) {
	    return function() {
	      return -Math.log(1 - source()) / lambda;
	    };
	  }

	  randomExponential.source = sourceRandomExponential;

	  return randomExponential;
	}))(defaultSource);

	function initRange(domain, range) {
	  switch (arguments.length) {
	    case 0: break;
	    case 1: this.range(domain); break;
	    default: this.range(range).domain(domain); break;
	  }
	  return this;
	}

	var array = Array.prototype;

	var map = array.map;
	var slice$1 = array.slice;

	var implicit = {name: "implicit"};

	function ordinal() {
	  var index = map$1(),
	      domain = [],
	      range = [],
	      unknown = implicit;

	  function scale(d) {
	    var key = d + "", i = index.get(key);
	    if (!i) {
	      if (unknown !== implicit) return unknown;
	      index.set(key, i = domain.push(d));
	    }
	    return range[(i - 1) % range.length];
	  }

	  scale.domain = function(_) {
	    if (!arguments.length) return domain.slice();
	    domain = [], index = map$1();
	    var i = -1, n = _.length, d, key;
	    while (++i < n) if (!index.has(key = (d = _[i]) + "")) index.set(key, domain.push(d));
	    return scale;
	  };

	  scale.range = function(_) {
	    return arguments.length ? (range = slice$1.call(_), scale) : range.slice();
	  };

	  scale.unknown = function(_) {
	    return arguments.length ? (unknown = _, scale) : unknown;
	  };

	  scale.copy = function() {
	    return ordinal(domain, range).unknown(unknown);
	  };

	  initRange.apply(scale, arguments);

	  return scale;
	}

	function band() {
	  var scale = ordinal().unknown(undefined),
	      domain = scale.domain,
	      ordinalRange = scale.range,
	      range = [0, 1],
	      step,
	      bandwidth,
	      round = false,
	      paddingInner = 0,
	      paddingOuter = 0,
	      align = 0.5;

	  delete scale.unknown;

	  function rescale() {
	    var n = domain().length,
	        reverse = range[1] < range[0],
	        start = range[reverse - 0],
	        stop = range[1 - reverse];
	    step = (stop - start) / Math.max(1, n - paddingInner + paddingOuter * 2);
	    if (round) step = Math.floor(step);
	    start += (stop - start - step * (n - paddingInner)) * align;
	    bandwidth = step * (1 - paddingInner);
	    if (round) start = Math.round(start), bandwidth = Math.round(bandwidth);
	    var values = range$2(n).map(function(i) { return start + step * i; });
	    return ordinalRange(reverse ? values.reverse() : values);
	  }

	  scale.domain = function(_) {
	    return arguments.length ? (domain(_), rescale()) : domain();
	  };

	  scale.range = function(_) {
	    return arguments.length ? (range = [+_[0], +_[1]], rescale()) : range.slice();
	  };

	  scale.rangeRound = function(_) {
	    return range = [+_[0], +_[1]], round = true, rescale();
	  };

	  scale.bandwidth = function() {
	    return bandwidth;
	  };

	  scale.step = function() {
	    return step;
	  };

	  scale.round = function(_) {
	    return arguments.length ? (round = !!_, rescale()) : round;
	  };

	  scale.padding = function(_) {
	    return arguments.length ? (paddingInner = Math.min(1, paddingOuter = +_), rescale()) : paddingInner;
	  };

	  scale.paddingInner = function(_) {
	    return arguments.length ? (paddingInner = Math.min(1, _), rescale()) : paddingInner;
	  };

	  scale.paddingOuter = function(_) {
	    return arguments.length ? (paddingOuter = +_, rescale()) : paddingOuter;
	  };

	  scale.align = function(_) {
	    return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;
	  };

	  scale.copy = function() {
	    return band(domain(), range)
	        .round(round)
	        .paddingInner(paddingInner)
	        .paddingOuter(paddingOuter)
	        .align(align);
	  };

	  return initRange.apply(rescale(), arguments);
	}

	function pointish(scale) {
	  var copy = scale.copy;

	  scale.padding = scale.paddingOuter;
	  delete scale.paddingInner;
	  delete scale.paddingOuter;

	  scale.copy = function() {
	    return pointish(copy());
	  };

	  return scale;
	}

	function point$1() {
	  return pointish(band.apply(null, arguments).paddingInner(1));
	}

	function constant$1(x) {
	  return function() {
	    return x;
	  };
	}

	function number$1(x) {
	  return +x;
	}

	var unit = [0, 1];

	function identity$2(x) {
	  return x;
	}

	function normalize(a, b) {
	  return (b -= (a = +a))
	      ? function(x) { return (x - a) / b; }
	      : constant$1(isNaN(b) ? NaN : 0.5);
	}

	function clamper(domain) {
	  var a = domain[0], b = domain[domain.length - 1], t;
	  if (a > b) t = a, a = b, b = t;
	  return function(x) { return Math.max(a, Math.min(b, x)); };
	}

	// normalize(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].
	// interpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding range value x in [a,b].
	function bimap(domain, range, interpolate) {
	  var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];
	  if (d1 < d0) d0 = normalize(d1, d0), r0 = interpolate(r1, r0);
	  else d0 = normalize(d0, d1), r0 = interpolate(r0, r1);
	  return function(x) { return r0(d0(x)); };
	}

	function polymap(domain, range, interpolate) {
	  var j = Math.min(domain.length, range.length) - 1,
	      d = new Array(j),
	      r = new Array(j),
	      i = -1;

	  // Reverse descending domains.
	  if (domain[j] < domain[0]) {
	    domain = domain.slice().reverse();
	    range = range.slice().reverse();
	  }

	  while (++i < j) {
	    d[i] = normalize(domain[i], domain[i + 1]);
	    r[i] = interpolate(range[i], range[i + 1]);
	  }

	  return function(x) {
	    var i = bisectRight(domain, x, 1, j) - 1;
	    return r[i](d[i](x));
	  };
	}

	function copy(source, target) {
	  return target
	      .domain(source.domain())
	      .range(source.range())
	      .interpolate(source.interpolate())
	      .clamp(source.clamp())
	      .unknown(source.unknown());
	}

	function transformer() {
	  var domain = unit,
	      range = unit,
	      interpolate = interpolate$1,
	      transform,
	      untransform,
	      unknown,
	      clamp = identity$2,
	      piecewise,
	      output,
	      input;

	  function rescale() {
	    piecewise = Math.min(domain.length, range.length) > 2 ? polymap : bimap;
	    output = input = null;
	    return scale;
	  }

	  function scale(x) {
	    return isNaN(x = +x) ? unknown : (output || (output = piecewise(domain.map(transform), range, interpolate)))(transform(clamp(x)));
	  }

	  scale.invert = function(y) {
	    return clamp(untransform((input || (input = piecewise(range, domain.map(transform), interpolateNumber)))(y)));
	  };

	  scale.domain = function(_) {
	    return arguments.length ? (domain = map.call(_, number$1), clamp === identity$2 || (clamp = clamper(domain)), rescale()) : domain.slice();
	  };

	  scale.range = function(_) {
	    return arguments.length ? (range = slice$1.call(_), rescale()) : range.slice();
	  };

	  scale.rangeRound = function(_) {
	    return range = slice$1.call(_), interpolate = interpolateRound, rescale();
	  };

	  scale.clamp = function(_) {
	    return arguments.length ? (clamp = _ ? clamper(domain) : identity$2, scale) : clamp !== identity$2;
	  };

	  scale.interpolate = function(_) {
	    return arguments.length ? (interpolate = _, rescale()) : interpolate;
	  };

	  scale.unknown = function(_) {
	    return arguments.length ? (unknown = _, scale) : unknown;
	  };

	  return function(t, u) {
	    transform = t, untransform = u;
	    return rescale();
	  };
	}

	function continuous(transform, untransform) {
	  return transformer()(transform, untransform);
	}

	function tickFormat(start, stop, count, specifier) {
	  var step = tickStep(start, stop, count),
	      precision;
	  specifier = formatSpecifier(specifier == null ? ",f" : specifier);
	  switch (specifier.type) {
	    case "s": {
	      var value = Math.max(Math.abs(start), Math.abs(stop));
	      if (specifier.precision == null && !isNaN(precision = precisionPrefix(step, value))) specifier.precision = precision;
	      return formatPrefix(specifier, value);
	    }
	    case "":
	    case "e":
	    case "g":
	    case "p":
	    case "r": {
	      if (specifier.precision == null && !isNaN(precision = precisionRound(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
	      break;
	    }
	    case "f":
	    case "%": {
	      if (specifier.precision == null && !isNaN(precision = precisionFixed(step))) specifier.precision = precision - (specifier.type === "%") * 2;
	      break;
	    }
	  }
	  return format(specifier);
	}

	function linearish(scale) {
	  var domain = scale.domain;

	  scale.ticks = function(count) {
	    var d = domain();
	    return d3ticks(d[0], d[d.length - 1], count == null ? 10 : count);
	  };

	  scale.tickFormat = function(count, specifier) {
	    var d = domain();
	    return tickFormat(d[0], d[d.length - 1], count == null ? 10 : count, specifier);
	  };

	  scale.nice = function(count) {
	    if (count == null) count = 10;

	    var d = domain(),
	        i0 = 0,
	        i1 = d.length - 1,
	        start = d[i0],
	        stop = d[i1],
	        step;

	    if (stop < start) {
	      step = start, start = stop, stop = step;
	      step = i0, i0 = i1, i1 = step;
	    }

	    step = tickIncrement(start, stop, count);

	    if (step > 0) {
	      start = Math.floor(start / step) * step;
	      stop = Math.ceil(stop / step) * step;
	      step = tickIncrement(start, stop, count);
	    } else if (step < 0) {
	      start = Math.ceil(start * step) / step;
	      stop = Math.floor(stop * step) / step;
	      step = tickIncrement(start, stop, count);
	    }

	    if (step > 0) {
	      d[i0] = Math.floor(start / step) * step;
	      d[i1] = Math.ceil(stop / step) * step;
	      domain(d);
	    } else if (step < 0) {
	      d[i0] = Math.ceil(start * step) / step;
	      d[i1] = Math.floor(stop * step) / step;
	      domain(d);
	    }

	    return scale;
	  };

	  return scale;
	}

	function linear() {
	  var scale = continuous(identity$2, identity$2);

	  scale.copy = function() {
	    return copy(scale, linear());
	  };

	  initRange.apply(scale, arguments);

	  return linearish(scale);
	}

	function nice(domain, interval) {
	  domain = domain.slice();

	  var i0 = 0,
	      i1 = domain.length - 1,
	      x0 = domain[i0],
	      x1 = domain[i1],
	      t;

	  if (x1 < x0) {
	    t = i0, i0 = i1, i1 = t;
	    t = x0, x0 = x1, x1 = t;
	  }

	  domain[i0] = interval.floor(x0);
	  domain[i1] = interval.ceil(x1);
	  return domain;
	}

	function transformLog(x) {
	  return Math.log(x);
	}

	function transformExp(x) {
	  return Math.exp(x);
	}

	function transformLogn(x) {
	  return -Math.log(-x);
	}

	function transformExpn(x) {
	  return -Math.exp(-x);
	}

	function pow10(x) {
	  return isFinite(x) ? +("1e" + x) : x < 0 ? 0 : x;
	}

	function powp(base) {
	  return base === 10 ? pow10
	      : base === Math.E ? Math.exp
	      : function(x) { return Math.pow(base, x); };
	}

	function logp(base) {
	  return base === Math.E ? Math.log
	      : base === 10 && Math.log10
	      || base === 2 && Math.log2
	      || (base = Math.log(base), function(x) { return Math.log(x) / base; });
	}

	function reflect(f) {
	  return function(x) {
	    return -f(-x);
	  };
	}

	function loggish(transform) {
	  var scale = transform(transformLog, transformExp),
	      domain = scale.domain,
	      base = 10,
	      logs,
	      pows;

	  function rescale() {
	    logs = logp(base), pows = powp(base);
	    if (domain()[0] < 0) {
	      logs = reflect(logs), pows = reflect(pows);
	      transform(transformLogn, transformExpn);
	    } else {
	      transform(transformLog, transformExp);
	    }
	    return scale;
	  }

	  scale.base = function(_) {
	    return arguments.length ? (base = +_, rescale()) : base;
	  };

	  scale.domain = function(_) {
	    return arguments.length ? (domain(_), rescale()) : domain();
	  };

	  scale.ticks = function(count) {
	    var d = domain(),
	        u = d[0],
	        v = d[d.length - 1],
	        r;

	    if (r = v < u) i = u, u = v, v = i;

	    var i = logs(u),
	        j = logs(v),
	        p,
	        k,
	        t,
	        n = count == null ? 10 : +count,
	        z = [];

	    if (!(base % 1) && j - i < n) {
	      i = Math.round(i) - 1, j = Math.round(j) + 1;
	      if (u > 0) for (; i < j; ++i) {
	        for (k = 1, p = pows(i); k < base; ++k) {
	          t = p * k;
	          if (t < u) continue;
	          if (t > v) break;
	          z.push(t);
	        }
	      } else for (; i < j; ++i) {
	        for (k = base - 1, p = pows(i); k >= 1; --k) {
	          t = p * k;
	          if (t < u) continue;
	          if (t > v) break;
	          z.push(t);
	        }
	      }
	    } else {
	      z = d3ticks(i, j, Math.min(j - i, n)).map(pows);
	    }

	    return r ? z.reverse() : z;
	  };

	  scale.tickFormat = function(count, specifier) {
	    if (specifier == null) specifier = base === 10 ? ".0e" : ",";
	    if (typeof specifier !== "function") specifier = format(specifier);
	    if (count === Infinity) return specifier;
	    if (count == null) count = 10;
	    var k = Math.max(1, base * count / scale.ticks().length); // TODO fast estimate?
	    return function(d) {
	      var i = d / pows(Math.round(logs(d)));
	      if (i * base < base - 0.5) i *= base;
	      return i <= k ? specifier(d) : "";
	    };
	  };

	  scale.nice = function() {
	    return domain(nice(domain(), {
	      floor: function(x) { return pows(Math.floor(logs(x))); },
	      ceil: function(x) { return pows(Math.ceil(logs(x))); }
	    }));
	  };

	  return scale;
	}

	function log$1() {
	  var scale = loggish(transformer()).domain([1, 10]);

	  scale.copy = function() {
	    return copy(scale, log$1()).base(scale.base());
	  };

	  initRange.apply(scale, arguments);

	  return scale;
	}

	function transformPow(exponent) {
	  return function(x) {
	    return x < 0 ? -Math.pow(-x, exponent) : Math.pow(x, exponent);
	  };
	}

	function transformSqrt(x) {
	  return x < 0 ? -Math.sqrt(-x) : Math.sqrt(x);
	}

	function transformSquare(x) {
	  return x < 0 ? -x * x : x * x;
	}

	function powish(transform) {
	  var scale = transform(identity$2, identity$2),
	      exponent = 1;

	  function rescale() {
	    return exponent === 1 ? transform(identity$2, identity$2)
	        : exponent === 0.5 ? transform(transformSqrt, transformSquare)
	        : transform(transformPow(exponent), transformPow(1 / exponent));
	  }

	  scale.exponent = function(_) {
	    return arguments.length ? (exponent = +_, rescale()) : exponent;
	  };

	  return linearish(scale);
	}

	function pow$1() {
	  var scale = powish(transformer());

	  scale.copy = function() {
	    return copy(scale, pow$1()).exponent(scale.exponent());
	  };

	  initRange.apply(scale, arguments);

	  return scale;
	}

	function sqrt$1() {
	  return pow$1.apply(null, arguments).exponent(0.5);
	}

	var t0 = new Date,
	    t1 = new Date;

	function newInterval(floori, offseti, count, field) {

	  function interval(date) {
	    return floori(date = arguments.length === 0 ? new Date : new Date(+date)), date;
	  }

	  interval.floor = function(date) {
	    return floori(date = new Date(+date)), date;
	  };

	  interval.ceil = function(date) {
	    return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;
	  };

	  interval.round = function(date) {
	    var d0 = interval(date),
	        d1 = interval.ceil(date);
	    return date - d0 < d1 - date ? d0 : d1;
	  };

	  interval.offset = function(date, step) {
	    return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;
	  };

	  interval.range = function(start, stop, step) {
	    var range = [], previous;
	    start = interval.ceil(start);
	    step = step == null ? 1 : Math.floor(step);
	    if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date
	    do range.push(previous = new Date(+start)), offseti(start, step), floori(start);
	    while (previous < start && start < stop);
	    return range;
	  };

	  interval.filter = function(test) {
	    return newInterval(function(date) {
	      if (date >= date) while (floori(date), !test(date)) date.setTime(date - 1);
	    }, function(date, step) {
	      if (date >= date) {
	        if (step < 0) while (++step <= 0) {
	          while (offseti(date, -1), !test(date)) {} // eslint-disable-line no-empty
	        } else while (--step >= 0) {
	          while (offseti(date, +1), !test(date)) {} // eslint-disable-line no-empty
	        }
	      }
	    });
	  };

	  if (count) {
	    interval.count = function(start, end) {
	      t0.setTime(+start), t1.setTime(+end);
	      floori(t0), floori(t1);
	      return Math.floor(count(t0, t1));
	    };

	    interval.every = function(step) {
	      step = Math.floor(step);
	      return !isFinite(step) || !(step > 0) ? null
	          : !(step > 1) ? interval
	          : interval.filter(field
	              ? function(d) { return field(d) % step === 0; }
	              : function(d) { return interval.count(0, d) % step === 0; });
	    };
	  }

	  return interval;
	}

	var millisecond = newInterval(function() {
	  // noop
	}, function(date, step) {
	  date.setTime(+date + step);
	}, function(start, end) {
	  return end - start;
	});

	// An optimized implementation for this simple case.
	millisecond.every = function(k) {
	  k = Math.floor(k);
	  if (!isFinite(k) || !(k > 0)) return null;
	  if (!(k > 1)) return millisecond;
	  return newInterval(function(date) {
	    date.setTime(Math.floor(date / k) * k);
	  }, function(date, step) {
	    date.setTime(+date + step * k);
	  }, function(start, end) {
	    return (end - start) / k;
	  });
	};

	var utcMillisecond = millisecond;
	millisecond.range;

	var durationSecond$1 = 1e3;
	var durationMinute$1 = 6e4;
	var durationHour$1 = 36e5;
	var durationDay$1 = 864e5;
	var durationWeek$1 = 6048e5;

	var second = newInterval(function(date) {
	  date.setTime(date - date.getMilliseconds());
	}, function(date, step) {
	  date.setTime(+date + step * durationSecond$1);
	}, function(start, end) {
	  return (end - start) / durationSecond$1;
	}, function(date) {
	  return date.getUTCSeconds();
	});

	var utcSecond = second;
	second.range;

	var minute = newInterval(function(date) {
	  date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond$1);
	}, function(date, step) {
	  date.setTime(+date + step * durationMinute$1);
	}, function(start, end) {
	  return (end - start) / durationMinute$1;
	}, function(date) {
	  return date.getMinutes();
	});

	var timeMinute = minute;
	minute.range;

	var hour = newInterval(function(date) {
	  date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond$1 - date.getMinutes() * durationMinute$1);
	}, function(date, step) {
	  date.setTime(+date + step * durationHour$1);
	}, function(start, end) {
	  return (end - start) / durationHour$1;
	}, function(date) {
	  return date.getHours();
	});

	var timeHour = hour;
	hour.range;

	var day = newInterval(function(date) {
	  date.setHours(0, 0, 0, 0);
	}, function(date, step) {
	  date.setDate(date.getDate() + step);
	}, function(start, end) {
	  return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute$1) / durationDay$1;
	}, function(date) {
	  return date.getDate() - 1;
	});

	var d3timeDay = day;
	day.range;

	function weekday(i) {
	  return newInterval(function(date) {
	    date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
	    date.setHours(0, 0, 0, 0);
	  }, function(date, step) {
	    date.setDate(date.getDate() + step * 7);
	  }, function(start, end) {
	    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute$1) / durationWeek$1;
	  });
	}

	var sunday = weekday(0);
	var monday = weekday(1);
	var tuesday = weekday(2);
	var wednesday = weekday(3);
	var thursday = weekday(4);
	var friday = weekday(5);
	var saturday = weekday(6);

	sunday.range;
	monday.range;
	tuesday.range;
	wednesday.range;
	thursday.range;
	friday.range;
	saturday.range;

	var month = newInterval(function(date) {
	  date.setDate(1);
	  date.setHours(0, 0, 0, 0);
	}, function(date, step) {
	  date.setMonth(date.getMonth() + step);
	}, function(start, end) {
	  return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
	}, function(date) {
	  return date.getMonth();
	});

	var timeMonth = month;
	month.range;

	var year = newInterval(function(date) {
	  date.setMonth(0, 1);
	  date.setHours(0, 0, 0, 0);
	}, function(date, step) {
	  date.setFullYear(date.getFullYear() + step);
	}, function(start, end) {
	  return end.getFullYear() - start.getFullYear();
	}, function(date) {
	  return date.getFullYear();
	});

	// An optimized implementation for this simple case.
	year.every = function(k) {
	  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
	    date.setFullYear(Math.floor(date.getFullYear() / k) * k);
	    date.setMonth(0, 1);
	    date.setHours(0, 0, 0, 0);
	  }, function(date, step) {
	    date.setFullYear(date.getFullYear() + step * k);
	  });
	};

	var timeYear = year;
	year.range;

	var utcMinute = newInterval(function(date) {
	  date.setUTCSeconds(0, 0);
	}, function(date, step) {
	  date.setTime(+date + step * durationMinute$1);
	}, function(start, end) {
	  return (end - start) / durationMinute$1;
	}, function(date) {
	  return date.getUTCMinutes();
	});

	var utcMinute$1 = utcMinute;
	utcMinute.range;

	var utcHour = newInterval(function(date) {
	  date.setUTCMinutes(0, 0, 0);
	}, function(date, step) {
	  date.setTime(+date + step * durationHour$1);
	}, function(start, end) {
	  return (end - start) / durationHour$1;
	}, function(date) {
	  return date.getUTCHours();
	});

	var utcHour$1 = utcHour;
	utcHour.range;

	var utcDay = newInterval(function(date) {
	  date.setUTCHours(0, 0, 0, 0);
	}, function(date, step) {
	  date.setUTCDate(date.getUTCDate() + step);
	}, function(start, end) {
	  return (end - start) / durationDay$1;
	}, function(date) {
	  return date.getUTCDate() - 1;
	});

	var utcDay$1 = utcDay;
	utcDay.range;

	function utcWeekday(i) {
	  return newInterval(function(date) {
	    date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
	    date.setUTCHours(0, 0, 0, 0);
	  }, function(date, step) {
	    date.setUTCDate(date.getUTCDate() + step * 7);
	  }, function(start, end) {
	    return (end - start) / durationWeek$1;
	  });
	}

	var utcSunday = utcWeekday(0);
	var utcMonday = utcWeekday(1);
	var utcTuesday = utcWeekday(2);
	var utcWednesday = utcWeekday(3);
	var utcThursday = utcWeekday(4);
	var utcFriday = utcWeekday(5);
	var utcSaturday = utcWeekday(6);

	utcSunday.range;
	utcMonday.range;
	utcTuesday.range;
	utcWednesday.range;
	utcThursday.range;
	utcFriday.range;
	utcSaturday.range;

	var utcMonth = newInterval(function(date) {
	  date.setUTCDate(1);
	  date.setUTCHours(0, 0, 0, 0);
	}, function(date, step) {
	  date.setUTCMonth(date.getUTCMonth() + step);
	}, function(start, end) {
	  return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
	}, function(date) {
	  return date.getUTCMonth();
	});

	var utcMonth$1 = utcMonth;
	utcMonth.range;

	var utcYear = newInterval(function(date) {
	  date.setUTCMonth(0, 1);
	  date.setUTCHours(0, 0, 0, 0);
	}, function(date, step) {
	  date.setUTCFullYear(date.getUTCFullYear() + step);
	}, function(start, end) {
	  return end.getUTCFullYear() - start.getUTCFullYear();
	}, function(date) {
	  return date.getUTCFullYear();
	});

	// An optimized implementation for this simple case.
	utcYear.every = function(k) {
	  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
	    date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);
	    date.setUTCMonth(0, 1);
	    date.setUTCHours(0, 0, 0, 0);
	  }, function(date, step) {
	    date.setUTCFullYear(date.getUTCFullYear() + step * k);
	  });
	};

	var utcYear$1 = utcYear;
	utcYear.range;

	function localDate(d) {
	  if (0 <= d.y && d.y < 100) {
	    var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
	    date.setFullYear(d.y);
	    return date;
	  }
	  return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
	}

	function utcDate(d) {
	  if (0 <= d.y && d.y < 100) {
	    var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
	    date.setUTCFullYear(d.y);
	    return date;
	  }
	  return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
	}

	function newDate(y, m, d) {
	  return {y: y, m: m, d: d, H: 0, M: 0, S: 0, L: 0};
	}

	function formatLocale(locale) {
	  var locale_dateTime = locale.dateTime,
	      locale_date = locale.date,
	      locale_time = locale.time,
	      locale_periods = locale.periods,
	      locale_weekdays = locale.days,
	      locale_shortWeekdays = locale.shortDays,
	      locale_months = locale.months,
	      locale_shortMonths = locale.shortMonths;

	  var periodRe = formatRe(locale_periods),
	      periodLookup = formatLookup(locale_periods),
	      weekdayRe = formatRe(locale_weekdays),
	      weekdayLookup = formatLookup(locale_weekdays),
	      shortWeekdayRe = formatRe(locale_shortWeekdays),
	      shortWeekdayLookup = formatLookup(locale_shortWeekdays),
	      monthRe = formatRe(locale_months),
	      monthLookup = formatLookup(locale_months),
	      shortMonthRe = formatRe(locale_shortMonths),
	      shortMonthLookup = formatLookup(locale_shortMonths);

	  var formats = {
	    "a": formatShortWeekday,
	    "A": formatWeekday,
	    "b": formatShortMonth,
	    "B": formatMonth,
	    "c": null,
	    "d": formatDayOfMonth,
	    "e": formatDayOfMonth,
	    "f": formatMicroseconds,
	    "g": formatYearISO,
	    "G": formatFullYearISO,
	    "H": formatHour24,
	    "I": formatHour12,
	    "j": formatDayOfYear,
	    "L": formatMilliseconds,
	    "m": formatMonthNumber,
	    "M": formatMinutes,
	    "p": formatPeriod,
	    "q": formatQuarter,
	    "Q": formatUnixTimestamp,
	    "s": formatUnixTimestampSeconds,
	    "S": formatSeconds,
	    "u": formatWeekdayNumberMonday,
	    "U": formatWeekNumberSunday,
	    "V": formatWeekNumberISO,
	    "w": formatWeekdayNumberSunday,
	    "W": formatWeekNumberMonday,
	    "x": null,
	    "X": null,
	    "y": formatYear,
	    "Y": formatFullYear,
	    "Z": formatZone,
	    "%": formatLiteralPercent
	  };

	  var utcFormats = {
	    "a": formatUTCShortWeekday,
	    "A": formatUTCWeekday,
	    "b": formatUTCShortMonth,
	    "B": formatUTCMonth,
	    "c": null,
	    "d": formatUTCDayOfMonth,
	    "e": formatUTCDayOfMonth,
	    "f": formatUTCMicroseconds,
	    "g": formatUTCYearISO,
	    "G": formatUTCFullYearISO,
	    "H": formatUTCHour24,
	    "I": formatUTCHour12,
	    "j": formatUTCDayOfYear,
	    "L": formatUTCMilliseconds,
	    "m": formatUTCMonthNumber,
	    "M": formatUTCMinutes,
	    "p": formatUTCPeriod,
	    "q": formatUTCQuarter,
	    "Q": formatUnixTimestamp,
	    "s": formatUnixTimestampSeconds,
	    "S": formatUTCSeconds,
	    "u": formatUTCWeekdayNumberMonday,
	    "U": formatUTCWeekNumberSunday,
	    "V": formatUTCWeekNumberISO,
	    "w": formatUTCWeekdayNumberSunday,
	    "W": formatUTCWeekNumberMonday,
	    "x": null,
	    "X": null,
	    "y": formatUTCYear,
	    "Y": formatUTCFullYear,
	    "Z": formatUTCZone,
	    "%": formatLiteralPercent
	  };

	  var parses = {
	    "a": parseShortWeekday,
	    "A": parseWeekday,
	    "b": parseShortMonth,
	    "B": parseMonth,
	    "c": parseLocaleDateTime,
	    "d": parseDayOfMonth,
	    "e": parseDayOfMonth,
	    "f": parseMicroseconds,
	    "g": parseYear,
	    "G": parseFullYear,
	    "H": parseHour24,
	    "I": parseHour24,
	    "j": parseDayOfYear,
	    "L": parseMilliseconds,
	    "m": parseMonthNumber,
	    "M": parseMinutes,
	    "p": parsePeriod,
	    "q": parseQuarter,
	    "Q": parseUnixTimestamp,
	    "s": parseUnixTimestampSeconds,
	    "S": parseSeconds,
	    "u": parseWeekdayNumberMonday,
	    "U": parseWeekNumberSunday,
	    "V": parseWeekNumberISO,
	    "w": parseWeekdayNumberSunday,
	    "W": parseWeekNumberMonday,
	    "x": parseLocaleDate,
	    "X": parseLocaleTime,
	    "y": parseYear,
	    "Y": parseFullYear,
	    "Z": parseZone,
	    "%": parseLiteralPercent
	  };

	  // These recursive directive definitions must be deferred.
	  formats.x = newFormat(locale_date, formats);
	  formats.X = newFormat(locale_time, formats);
	  formats.c = newFormat(locale_dateTime, formats);
	  utcFormats.x = newFormat(locale_date, utcFormats);
	  utcFormats.X = newFormat(locale_time, utcFormats);
	  utcFormats.c = newFormat(locale_dateTime, utcFormats);

	  function newFormat(specifier, formats) {
	    return function(date) {
	      var string = [],
	          i = -1,
	          j = 0,
	          n = specifier.length,
	          c,
	          pad,
	          format;

	      if (!(date instanceof Date)) date = new Date(+date);

	      while (++i < n) {
	        if (specifier.charCodeAt(i) === 37) {
	          string.push(specifier.slice(j, i));
	          if ((pad = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);
	          else pad = c === "e" ? " " : "0";
	          if (format = formats[c]) c = format(date, pad);
	          string.push(c);
	          j = i + 1;
	        }
	      }

	      string.push(specifier.slice(j, i));
	      return string.join("");
	    };
	  }

	  function newParse(specifier, Z) {
	    return function(string) {
	      var d = newDate(1900, undefined, 1),
	          i = parseSpecifier(d, specifier, string += "", 0),
	          week, day;
	      if (i != string.length) return null;

	      // If a UNIX timestamp is specified, return it.
	      if ("Q" in d) return new Date(d.Q);
	      if ("s" in d) return new Date(d.s * 1000 + ("L" in d ? d.L : 0));

	      // If this is utcParse, never use the local timezone.
	      if (Z && !("Z" in d)) d.Z = 0;

	      // The am-pm flag is 0 for AM, and 1 for PM.
	      if ("p" in d) d.H = d.H % 12 + d.p * 12;

	      // If the month was not specified, inherit from the quarter.
	      if (d.m === undefined) d.m = "q" in d ? d.q : 0;

	      // Convert day-of-week and week-of-year to day-of-year.
	      if ("V" in d) {
	        if (d.V < 1 || d.V > 53) return null;
	        if (!("w" in d)) d.w = 1;
	        if ("Z" in d) {
	          week = utcDate(newDate(d.y, 0, 1)), day = week.getUTCDay();
	          week = day > 4 || day === 0 ? utcMonday.ceil(week) : utcMonday(week);
	          week = utcDay$1.offset(week, (d.V - 1) * 7);
	          d.y = week.getUTCFullYear();
	          d.m = week.getUTCMonth();
	          d.d = week.getUTCDate() + (d.w + 6) % 7;
	        } else {
	          week = localDate(newDate(d.y, 0, 1)), day = week.getDay();
	          week = day > 4 || day === 0 ? monday.ceil(week) : monday(week);
	          week = d3timeDay.offset(week, (d.V - 1) * 7);
	          d.y = week.getFullYear();
	          d.m = week.getMonth();
	          d.d = week.getDate() + (d.w + 6) % 7;
	        }
	      } else if ("W" in d || "U" in d) {
	        if (!("w" in d)) d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
	        day = "Z" in d ? utcDate(newDate(d.y, 0, 1)).getUTCDay() : localDate(newDate(d.y, 0, 1)).getDay();
	        d.m = 0;
	        d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day + 5) % 7 : d.w + d.U * 7 - (day + 6) % 7;
	      }

	      // If a time zone is specified, all fields are interpreted as UTC and then
	      // offset according to the specified time zone.
	      if ("Z" in d) {
	        d.H += d.Z / 100 | 0;
	        d.M += d.Z % 100;
	        return utcDate(d);
	      }

	      // Otherwise, all fields are in local time.
	      return localDate(d);
	    };
	  }

	  function parseSpecifier(d, specifier, string, j) {
	    var i = 0,
	        n = specifier.length,
	        m = string.length,
	        c,
	        parse;

	    while (i < n) {
	      if (j >= m) return -1;
	      c = specifier.charCodeAt(i++);
	      if (c === 37) {
	        c = specifier.charAt(i++);
	        parse = parses[c in pads ? specifier.charAt(i++) : c];
	        if (!parse || ((j = parse(d, string, j)) < 0)) return -1;
	      } else if (c != string.charCodeAt(j++)) {
	        return -1;
	      }
	    }

	    return j;
	  }

	  function parsePeriod(d, string, i) {
	    var n = periodRe.exec(string.slice(i));
	    return n ? (d.p = periodLookup[n[0].toLowerCase()], i + n[0].length) : -1;
	  }

	  function parseShortWeekday(d, string, i) {
	    var n = shortWeekdayRe.exec(string.slice(i));
	    return n ? (d.w = shortWeekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
	  }

	  function parseWeekday(d, string, i) {
	    var n = weekdayRe.exec(string.slice(i));
	    return n ? (d.w = weekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
	  }

	  function parseShortMonth(d, string, i) {
	    var n = shortMonthRe.exec(string.slice(i));
	    return n ? (d.m = shortMonthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
	  }

	  function parseMonth(d, string, i) {
	    var n = monthRe.exec(string.slice(i));
	    return n ? (d.m = monthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
	  }

	  function parseLocaleDateTime(d, string, i) {
	    return parseSpecifier(d, locale_dateTime, string, i);
	  }

	  function parseLocaleDate(d, string, i) {
	    return parseSpecifier(d, locale_date, string, i);
	  }

	  function parseLocaleTime(d, string, i) {
	    return parseSpecifier(d, locale_time, string, i);
	  }

	  function formatShortWeekday(d) {
	    return locale_shortWeekdays[d.getDay()];
	  }

	  function formatWeekday(d) {
	    return locale_weekdays[d.getDay()];
	  }

	  function formatShortMonth(d) {
	    return locale_shortMonths[d.getMonth()];
	  }

	  function formatMonth(d) {
	    return locale_months[d.getMonth()];
	  }

	  function formatPeriod(d) {
	    return locale_periods[+(d.getHours() >= 12)];
	  }

	  function formatQuarter(d) {
	    return 1 + ~~(d.getMonth() / 3);
	  }

	  function formatUTCShortWeekday(d) {
	    return locale_shortWeekdays[d.getUTCDay()];
	  }

	  function formatUTCWeekday(d) {
	    return locale_weekdays[d.getUTCDay()];
	  }

	  function formatUTCShortMonth(d) {
	    return locale_shortMonths[d.getUTCMonth()];
	  }

	  function formatUTCMonth(d) {
	    return locale_months[d.getUTCMonth()];
	  }

	  function formatUTCPeriod(d) {
	    return locale_periods[+(d.getUTCHours() >= 12)];
	  }

	  function formatUTCQuarter(d) {
	    return 1 + ~~(d.getUTCMonth() / 3);
	  }

	  return {
	    format: function(specifier) {
	      var f = newFormat(specifier += "", formats);
	      f.toString = function() { return specifier; };
	      return f;
	    },
	    parse: function(specifier) {
	      var p = newParse(specifier += "", false);
	      p.toString = function() { return specifier; };
	      return p;
	    },
	    utcFormat: function(specifier) {
	      var f = newFormat(specifier += "", utcFormats);
	      f.toString = function() { return specifier; };
	      return f;
	    },
	    utcParse: function(specifier) {
	      var p = newParse(specifier += "", true);
	      p.toString = function() { return specifier; };
	      return p;
	    }
	  };
	}

	var pads = {"-": "", "_": " ", "0": "0"},
	    numberRe = /^\s*\d+/, // note: ignores next directive
	    percentRe = /^%/,
	    requoteRe = /[\\^$*+?|[\]().{}]/g;

	function pad(value, fill, width) {
	  var sign = value < 0 ? "-" : "",
	      string = (sign ? -value : value) + "",
	      length = string.length;
	  return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
	}

	function requote(s) {
	  return s.replace(requoteRe, "\\$&");
	}

	function formatRe(names) {
	  return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
	}

	function formatLookup(names) {
	  var map = {}, i = -1, n = names.length;
	  while (++i < n) map[names[i].toLowerCase()] = i;
	  return map;
	}

	function parseWeekdayNumberSunday(d, string, i) {
	  var n = numberRe.exec(string.slice(i, i + 1));
	  return n ? (d.w = +n[0], i + n[0].length) : -1;
	}

	function parseWeekdayNumberMonday(d, string, i) {
	  var n = numberRe.exec(string.slice(i, i + 1));
	  return n ? (d.u = +n[0], i + n[0].length) : -1;
	}

	function parseWeekNumberSunday(d, string, i) {
	  var n = numberRe.exec(string.slice(i, i + 2));
	  return n ? (d.U = +n[0], i + n[0].length) : -1;
	}

	function parseWeekNumberISO(d, string, i) {
	  var n = numberRe.exec(string.slice(i, i + 2));
	  return n ? (d.V = +n[0], i + n[0].length) : -1;
	}

	function parseWeekNumberMonday(d, string, i) {
	  var n = numberRe.exec(string.slice(i, i + 2));
	  return n ? (d.W = +n[0], i + n[0].length) : -1;
	}

	function parseFullYear(d, string, i) {
	  var n = numberRe.exec(string.slice(i, i + 4));
	  return n ? (d.y = +n[0], i + n[0].length) : -1;
	}

	function parseYear(d, string, i) {
	  var n = numberRe.exec(string.slice(i, i + 2));
	  return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;
	}

	function parseZone(d, string, i) {
	  var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
	  return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
	}

	function parseQuarter(d, string, i) {
	  var n = numberRe.exec(string.slice(i, i + 1));
	  return n ? (d.q = n[0] * 3 - 3, i + n[0].length) : -1;
	}

	function parseMonthNumber(d, string, i) {
	  var n = numberRe.exec(string.slice(i, i + 2));
	  return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
	}

	function parseDayOfMonth(d, string, i) {
	  var n = numberRe.exec(string.slice(i, i + 2));
	  return n ? (d.d = +n[0], i + n[0].length) : -1;
	}

	function parseDayOfYear(d, string, i) {
	  var n = numberRe.exec(string.slice(i, i + 3));
	  return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
	}

	function parseHour24(d, string, i) {
	  var n = numberRe.exec(string.slice(i, i + 2));
	  return n ? (d.H = +n[0], i + n[0].length) : -1;
	}

	function parseMinutes(d, string, i) {
	  var n = numberRe.exec(string.slice(i, i + 2));
	  return n ? (d.M = +n[0], i + n[0].length) : -1;
	}

	function parseSeconds(d, string, i) {
	  var n = numberRe.exec(string.slice(i, i + 2));
	  return n ? (d.S = +n[0], i + n[0].length) : -1;
	}

	function parseMilliseconds(d, string, i) {
	  var n = numberRe.exec(string.slice(i, i + 3));
	  return n ? (d.L = +n[0], i + n[0].length) : -1;
	}

	function parseMicroseconds(d, string, i) {
	  var n = numberRe.exec(string.slice(i, i + 6));
	  return n ? (d.L = Math.floor(n[0] / 1000), i + n[0].length) : -1;
	}

	function parseLiteralPercent(d, string, i) {
	  var n = percentRe.exec(string.slice(i, i + 1));
	  return n ? i + n[0].length : -1;
	}

	function parseUnixTimestamp(d, string, i) {
	  var n = numberRe.exec(string.slice(i));
	  return n ? (d.Q = +n[0], i + n[0].length) : -1;
	}

	function parseUnixTimestampSeconds(d, string, i) {
	  var n = numberRe.exec(string.slice(i));
	  return n ? (d.s = +n[0], i + n[0].length) : -1;
	}

	function formatDayOfMonth(d, p) {
	  return pad(d.getDate(), p, 2);
	}

	function formatHour24(d, p) {
	  return pad(d.getHours(), p, 2);
	}

	function formatHour12(d, p) {
	  return pad(d.getHours() % 12 || 12, p, 2);
	}

	function formatDayOfYear(d, p) {
	  return pad(1 + d3timeDay.count(timeYear(d), d), p, 3);
	}

	function formatMilliseconds(d, p) {
	  return pad(d.getMilliseconds(), p, 3);
	}

	function formatMicroseconds(d, p) {
	  return formatMilliseconds(d, p) + "000";
	}

	function formatMonthNumber(d, p) {
	  return pad(d.getMonth() + 1, p, 2);
	}

	function formatMinutes(d, p) {
	  return pad(d.getMinutes(), p, 2);
	}

	function formatSeconds(d, p) {
	  return pad(d.getSeconds(), p, 2);
	}

	function formatWeekdayNumberMonday(d) {
	  var day = d.getDay();
	  return day === 0 ? 7 : day;
	}

	function formatWeekNumberSunday(d, p) {
	  return pad(sunday.count(timeYear(d) - 1, d), p, 2);
	}

	function dISO(d) {
	  var day = d.getDay();
	  return (day >= 4 || day === 0) ? thursday(d) : thursday.ceil(d);
	}

	function formatWeekNumberISO(d, p) {
	  d = dISO(d);
	  return pad(thursday.count(timeYear(d), d) + (timeYear(d).getDay() === 4), p, 2);
	}

	function formatWeekdayNumberSunday(d) {
	  return d.getDay();
	}

	function formatWeekNumberMonday(d, p) {
	  return pad(monday.count(timeYear(d) - 1, d), p, 2);
	}

	function formatYear(d, p) {
	  return pad(d.getFullYear() % 100, p, 2);
	}

	function formatYearISO(d, p) {
	  d = dISO(d);
	  return pad(d.getFullYear() % 100, p, 2);
	}

	function formatFullYear(d, p) {
	  return pad(d.getFullYear() % 10000, p, 4);
	}

	function formatFullYearISO(d, p) {
	  var day = d.getDay();
	  d = (day >= 4 || day === 0) ? thursday(d) : thursday.ceil(d);
	  return pad(d.getFullYear() % 10000, p, 4);
	}

	function formatZone(d) {
	  var z = d.getTimezoneOffset();
	  return (z > 0 ? "-" : (z *= -1, "+"))
	      + pad(z / 60 | 0, "0", 2)
	      + pad(z % 60, "0", 2);
	}

	function formatUTCDayOfMonth(d, p) {
	  return pad(d.getUTCDate(), p, 2);
	}

	function formatUTCHour24(d, p) {
	  return pad(d.getUTCHours(), p, 2);
	}

	function formatUTCHour12(d, p) {
	  return pad(d.getUTCHours() % 12 || 12, p, 2);
	}

	function formatUTCDayOfYear(d, p) {
	  return pad(1 + utcDay$1.count(utcYear$1(d), d), p, 3);
	}

	function formatUTCMilliseconds(d, p) {
	  return pad(d.getUTCMilliseconds(), p, 3);
	}

	function formatUTCMicroseconds(d, p) {
	  return formatUTCMilliseconds(d, p) + "000";
	}

	function formatUTCMonthNumber(d, p) {
	  return pad(d.getUTCMonth() + 1, p, 2);
	}

	function formatUTCMinutes(d, p) {
	  return pad(d.getUTCMinutes(), p, 2);
	}

	function formatUTCSeconds(d, p) {
	  return pad(d.getUTCSeconds(), p, 2);
	}

	function formatUTCWeekdayNumberMonday(d) {
	  var dow = d.getUTCDay();
	  return dow === 0 ? 7 : dow;
	}

	function formatUTCWeekNumberSunday(d, p) {
	  return pad(utcSunday.count(utcYear$1(d) - 1, d), p, 2);
	}

	function UTCdISO(d) {
	  var day = d.getUTCDay();
	  return (day >= 4 || day === 0) ? utcThursday(d) : utcThursday.ceil(d);
	}

	function formatUTCWeekNumberISO(d, p) {
	  d = UTCdISO(d);
	  return pad(utcThursday.count(utcYear$1(d), d) + (utcYear$1(d).getUTCDay() === 4), p, 2);
	}

	function formatUTCWeekdayNumberSunday(d) {
	  return d.getUTCDay();
	}

	function formatUTCWeekNumberMonday(d, p) {
	  return pad(utcMonday.count(utcYear$1(d) - 1, d), p, 2);
	}

	function formatUTCYear(d, p) {
	  return pad(d.getUTCFullYear() % 100, p, 2);
	}

	function formatUTCYearISO(d, p) {
	  d = UTCdISO(d);
	  return pad(d.getUTCFullYear() % 100, p, 2);
	}

	function formatUTCFullYear(d, p) {
	  return pad(d.getUTCFullYear() % 10000, p, 4);
	}

	function formatUTCFullYearISO(d, p) {
	  var day = d.getUTCDay();
	  d = (day >= 4 || day === 0) ? utcThursday(d) : utcThursday.ceil(d);
	  return pad(d.getUTCFullYear() % 10000, p, 4);
	}

	function formatUTCZone() {
	  return "+0000";
	}

	function formatLiteralPercent() {
	  return "%";
	}

	function formatUnixTimestamp(d) {
	  return +d;
	}

	function formatUnixTimestampSeconds(d) {
	  return Math.floor(+d / 1000);
	}

	var locale;
	var timeFormat;
	var utcFormat;

	defaultLocale({
	  dateTime: "%x, %X",
	  date: "%-m/%-d/%Y",
	  time: "%-I:%M:%S %p",
	  periods: ["AM", "PM"],
	  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
	  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
	  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
	  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
	});

	function defaultLocale(definition) {
	  locale = formatLocale(definition);
	  timeFormat = locale.format;
	  locale.parse;
	  utcFormat = locale.utcFormat;
	  locale.utcParse;
	  return locale;
	}

	var durationSecond = 1000,
	    durationMinute = durationSecond * 60,
	    durationHour = durationMinute * 60,
	    durationDay = durationHour * 24,
	    durationWeek = durationDay * 7,
	    durationMonth = durationDay * 30,
	    durationYear = durationDay * 365;

	function date(t) {
	  return new Date(t);
	}

	function number(t) {
	  return t instanceof Date ? +t : +new Date(+t);
	}

	function calendar(year, month, week, day, hour, minute, second, millisecond, format) {
	  var scale = continuous(identity$2, identity$2),
	      invert = scale.invert,
	      domain = scale.domain;

	  var formatMillisecond = format(".%L"),
	      formatSecond = format(":%S"),
	      formatMinute = format("%I:%M"),
	      formatHour = format("%I %p"),
	      formatDay = format("%a %d"),
	      formatWeek = format("%b %d"),
	      formatMonth = format("%B"),
	      formatYear = format("%Y");

	  var tickIntervals = [
	    [second,  1,      durationSecond],
	    [second,  5,  5 * durationSecond],
	    [second, 15, 15 * durationSecond],
	    [second, 30, 30 * durationSecond],
	    [minute,  1,      durationMinute],
	    [minute,  5,  5 * durationMinute],
	    [minute, 15, 15 * durationMinute],
	    [minute, 30, 30 * durationMinute],
	    [  hour,  1,      durationHour  ],
	    [  hour,  3,  3 * durationHour  ],
	    [  hour,  6,  6 * durationHour  ],
	    [  hour, 12, 12 * durationHour  ],
	    [   day,  1,      durationDay   ],
	    [   day,  2,  2 * durationDay   ],
	    [  week,  1,      durationWeek  ],
	    [ month,  1,      durationMonth ],
	    [ month,  3,  3 * durationMonth ],
	    [  year,  1,      durationYear  ]
	  ];

	  function tickFormat(date) {
	    return (second(date) < date ? formatMillisecond
	        : minute(date) < date ? formatSecond
	        : hour(date) < date ? formatMinute
	        : day(date) < date ? formatHour
	        : month(date) < date ? (week(date) < date ? formatDay : formatWeek)
	        : year(date) < date ? formatMonth
	        : formatYear)(date);
	  }

	  function tickInterval(interval, start, stop, step) {
	    if (interval == null) interval = 10;

	    // If a desired tick count is specified, pick a reasonable tick interval
	    // based on the extent of the domain and a rough estimate of tick size.
	    // Otherwise, assume interval is already a time interval and use it.
	    if (typeof interval === "number") {
	      var target = Math.abs(stop - start) / interval,
	          i = bisector(function(i) { return i[2]; }).right(tickIntervals, target);
	      if (i === tickIntervals.length) {
	        step = tickStep(start / durationYear, stop / durationYear, interval);
	        interval = year;
	      } else if (i) {
	        i = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];
	        step = i[1];
	        interval = i[0];
	      } else {
	        step = Math.max(tickStep(start, stop, interval), 1);
	        interval = millisecond;
	      }
	    }

	    return step == null ? interval : interval.every(step);
	  }

	  scale.invert = function(y) {
	    return new Date(invert(y));
	  };

	  scale.domain = function(_) {
	    return arguments.length ? domain(map.call(_, number)) : domain().map(date);
	  };

	  scale.ticks = function(interval, step) {
	    var d = domain(),
	        t0 = d[0],
	        t1 = d[d.length - 1],
	        r = t1 < t0,
	        t;
	    if (r) t = t0, t0 = t1, t1 = t;
	    t = tickInterval(interval, t0, t1, step);
	    t = t ? t.range(t0, t1 + 1) : []; // inclusive stop
	    return r ? t.reverse() : t;
	  };

	  scale.tickFormat = function(count, specifier) {
	    return specifier == null ? tickFormat : format(specifier);
	  };

	  scale.nice = function(interval, step) {
	    var d = domain();
	    return (interval = tickInterval(interval, d[0], d[d.length - 1], step))
	        ? domain(nice(d, interval))
	        : scale;
	  };

	  scale.copy = function() {
	    return copy(scale, calendar(year, month, week, day, hour, minute, second, millisecond, format));
	  };

	  return scale;
	}

	function scaleTime() {
	  return initRange.apply(calendar(timeYear, timeMonth, sunday, d3timeDay, timeHour, timeMinute, utcSecond, utcMillisecond, timeFormat).domain([new Date(2000, 0, 1), new Date(2000, 0, 2)]), arguments);
	}

	function scaleUtc() {
	  return initRange.apply(calendar(utcYear$1, utcMonth$1, utcSunday, utcDay$1, utcHour$1, utcMinute$1, utcSecond, utcMillisecond, utcFormat).domain([Date.UTC(2000, 0, 1), Date.UTC(2000, 0, 2)]), arguments);
	}

	function constant(x) {
	  return function constant() {
	    return x;
	  };
	}

	var abs = Math.abs;
	var atan2 = Math.atan2;
	var cos = Math.cos;
	var max$1 = Math.max;
	var min$1 = Math.min;
	var sin = Math.sin;
	var sqrt = Math.sqrt;

	var epsilon$2 = 1e-12;
	var pi = Math.PI;
	var halfPi = pi / 2;
	var tau$1 = 2 * pi;

	function acos(x) {
	  return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
	}

	function asin(x) {
	  return x >= 1 ? halfPi : x <= -1 ? -halfPi : Math.asin(x);
	}

	function arcInnerRadius(d) {
	  return d.innerRadius;
	}

	function arcOuterRadius(d) {
	  return d.outerRadius;
	}

	function arcStartAngle(d) {
	  return d.startAngle;
	}

	function arcEndAngle(d) {
	  return d.endAngle;
	}

	function arcPadAngle(d) {
	  return d && d.padAngle; // Note: optional!
	}

	function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
	  var x10 = x1 - x0, y10 = y1 - y0,
	      x32 = x3 - x2, y32 = y3 - y2,
	      t = y32 * x10 - x32 * y10;
	  if (t * t < epsilon$2) return;
	  t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / t;
	  return [x0 + t * x10, y0 + t * y10];
	}

	// Compute perpendicular offset line of length rc.
	// http://mathworld.wolfram.com/Circle-LineIntersection.html
	function cornerTangents(x0, y0, x1, y1, r1, rc, cw) {
	  var x01 = x0 - x1,
	      y01 = y0 - y1,
	      lo = (cw ? rc : -rc) / sqrt(x01 * x01 + y01 * y01),
	      ox = lo * y01,
	      oy = -lo * x01,
	      x11 = x0 + ox,
	      y11 = y0 + oy,
	      x10 = x1 + ox,
	      y10 = y1 + oy,
	      x00 = (x11 + x10) / 2,
	      y00 = (y11 + y10) / 2,
	      dx = x10 - x11,
	      dy = y10 - y11,
	      d2 = dx * dx + dy * dy,
	      r = r1 - rc,
	      D = x11 * y10 - x10 * y11,
	      d = (dy < 0 ? -1 : 1) * sqrt(max$1(0, r * r * d2 - D * D)),
	      cx0 = (D * dy - dx * d) / d2,
	      cy0 = (-D * dx - dy * d) / d2,
	      cx1 = (D * dy + dx * d) / d2,
	      cy1 = (-D * dx + dy * d) / d2,
	      dx0 = cx0 - x00,
	      dy0 = cy0 - y00,
	      dx1 = cx1 - x00,
	      dy1 = cy1 - y00;

	  // Pick the closer of the two intersection points.
	  // TODO Is there a faster way to determine which intersection to use?
	  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;

	  return {
	    cx: cx0,
	    cy: cy0,
	    x01: -ox,
	    y01: -oy,
	    x11: cx0 * (r1 / r - 1),
	    y11: cy0 * (r1 / r - 1)
	  };
	}

	function d3arc() {
	  var innerRadius = arcInnerRadius,
	      outerRadius = arcOuterRadius,
	      cornerRadius = constant(0),
	      padRadius = null,
	      startAngle = arcStartAngle,
	      endAngle = arcEndAngle,
	      padAngle = arcPadAngle,
	      context = null;

	  function arc() {
	    var buffer,
	        r,
	        r0 = +innerRadius.apply(this, arguments),
	        r1 = +outerRadius.apply(this, arguments),
	        a0 = startAngle.apply(this, arguments) - halfPi,
	        a1 = endAngle.apply(this, arguments) - halfPi,
	        da = abs(a1 - a0),
	        cw = a1 > a0;

	    if (!context) context = buffer = path();

	    // Ensure that the outer radius is always larger than the inner radius.
	    if (r1 < r0) r = r1, r1 = r0, r0 = r;

	    // Is it a point?
	    if (!(r1 > epsilon$2)) context.moveTo(0, 0);

	    // Or is it a circle or annulus?
	    else if (da > tau$1 - epsilon$2) {
	      context.moveTo(r1 * cos(a0), r1 * sin(a0));
	      context.arc(0, 0, r1, a0, a1, !cw);
	      if (r0 > epsilon$2) {
	        context.moveTo(r0 * cos(a1), r0 * sin(a1));
	        context.arc(0, 0, r0, a1, a0, cw);
	      }
	    }

	    // Or is it a circular or annular sector?
	    else {
	      var a01 = a0,
	          a11 = a1,
	          a00 = a0,
	          a10 = a1,
	          da0 = da,
	          da1 = da,
	          ap = padAngle.apply(this, arguments) / 2,
	          rp = (ap > epsilon$2) && (padRadius ? +padRadius.apply(this, arguments) : sqrt(r0 * r0 + r1 * r1)),
	          rc = min$1(abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments)),
	          rc0 = rc,
	          rc1 = rc,
	          t0,
	          t1;

	      // Apply padding? Note that since r1 â¥ r0, da1 â¥ da0.
	      if (rp > epsilon$2) {
	        var p0 = asin(rp / r0 * sin(ap)),
	            p1 = asin(rp / r1 * sin(ap));
	        if ((da0 -= p0 * 2) > epsilon$2) p0 *= (cw ? 1 : -1), a00 += p0, a10 -= p0;
	        else da0 = 0, a00 = a10 = (a0 + a1) / 2;
	        if ((da1 -= p1 * 2) > epsilon$2) p1 *= (cw ? 1 : -1), a01 += p1, a11 -= p1;
	        else da1 = 0, a01 = a11 = (a0 + a1) / 2;
	      }

	      var x01 = r1 * cos(a01),
	          y01 = r1 * sin(a01),
	          x10 = r0 * cos(a10),
	          y10 = r0 * sin(a10);

	      // Apply rounded corners?
	      if (rc > epsilon$2) {
	        var x11 = r1 * cos(a11),
	            y11 = r1 * sin(a11),
	            x00 = r0 * cos(a00),
	            y00 = r0 * sin(a00),
	            oc;

	        // Restrict the corner radius according to the sector angle.
	        if (da < pi && (oc = intersect(x01, y01, x00, y00, x11, y11, x10, y10))) {
	          var ax = x01 - oc[0],
	              ay = y01 - oc[1],
	              bx = x11 - oc[0],
	              by = y11 - oc[1],
	              kc = 1 / sin(acos((ax * bx + ay * by) / (sqrt(ax * ax + ay * ay) * sqrt(bx * bx + by * by))) / 2),
	              lc = sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
	          rc0 = min$1(rc, (r0 - lc) / (kc - 1));
	          rc1 = min$1(rc, (r1 - lc) / (kc + 1));
	        }
	      }

	      // Is the sector collapsed to a line?
	      if (!(da1 > epsilon$2)) context.moveTo(x01, y01);

	      // Does the sectorâs outer ring have rounded corners?
	      else if (rc1 > epsilon$2) {
	        t0 = cornerTangents(x00, y00, x01, y01, r1, rc1, cw);
	        t1 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);

	        context.moveTo(t0.cx + t0.x01, t0.cy + t0.y01);

	        // Have the corners merged?
	        if (rc1 < rc) context.arc(t0.cx, t0.cy, rc1, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !cw);

	        // Otherwise, draw the two corners and the ring.
	        else {
	          context.arc(t0.cx, t0.cy, rc1, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !cw);
	          context.arc(0, 0, r1, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), !cw);
	          context.arc(t1.cx, t1.cy, rc1, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !cw);
	        }
	      }

	      // Or is the outer ring just a circular arc?
	      else context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);

	      // Is there no inner ring, and itâs a circular sector?
	      // Or perhaps itâs an annular sector collapsed due to padding?
	      if (!(r0 > epsilon$2) || !(da0 > epsilon$2)) context.lineTo(x10, y10);

	      // Does the sectorâs inner ring (or point) have rounded corners?
	      else if (rc0 > epsilon$2) {
	        t0 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);
	        t1 = cornerTangents(x01, y01, x00, y00, r0, -rc0, cw);

	        context.lineTo(t0.cx + t0.x01, t0.cy + t0.y01);

	        // Have the corners merged?
	        if (rc0 < rc) context.arc(t0.cx, t0.cy, rc0, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !cw);

	        // Otherwise, draw the two corners and the ring.
	        else {
	          context.arc(t0.cx, t0.cy, rc0, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !cw);
	          context.arc(0, 0, r0, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), cw);
	          context.arc(t1.cx, t1.cy, rc0, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !cw);
	        }
	      }

	      // Or is the inner ring just a circular arc?
	      else context.arc(0, 0, r0, a10, a00, cw);
	    }

	    context.closePath();

	    if (buffer) return context = null, buffer + "" || null;
	  }

	  arc.centroid = function() {
	    var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2,
	        a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi / 2;
	    return [cos(a) * r, sin(a) * r];
	  };

	  arc.innerRadius = function(_) {
	    return arguments.length ? (innerRadius = typeof _ === "function" ? _ : constant(+_), arc) : innerRadius;
	  };

	  arc.outerRadius = function(_) {
	    return arguments.length ? (outerRadius = typeof _ === "function" ? _ : constant(+_), arc) : outerRadius;
	  };

	  arc.cornerRadius = function(_) {
	    return arguments.length ? (cornerRadius = typeof _ === "function" ? _ : constant(+_), arc) : cornerRadius;
	  };

	  arc.padRadius = function(_) {
	    return arguments.length ? (padRadius = _ == null ? null : typeof _ === "function" ? _ : constant(+_), arc) : padRadius;
	  };

	  arc.startAngle = function(_) {
	    return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant(+_), arc) : startAngle;
	  };

	  arc.endAngle = function(_) {
	    return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant(+_), arc) : endAngle;
	  };

	  arc.padAngle = function(_) {
	    return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant(+_), arc) : padAngle;
	  };

	  arc.context = function(_) {
	    return arguments.length ? ((context = _ == null ? null : _), arc) : context;
	  };

	  return arc;
	}

	function Linear(context) {
	  this._context = context;
	}

	Linear.prototype = {
	  areaStart: function() {
	    this._line = 0;
	  },
	  areaEnd: function() {
	    this._line = NaN;
	  },
	  lineStart: function() {
	    this._point = 0;
	  },
	  lineEnd: function() {
	    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
	    this._line = 1 - this._line;
	  },
	  point: function(x, y) {
	    x = +x, y = +y;
	    switch (this._point) {
	      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
	      case 1: this._point = 2; // proceed
	      default: this._context.lineTo(x, y); break;
	    }
	  }
	};

	function curveLinear(context) {
	  return new Linear(context);
	}

	function x(p) {
	  return p[0];
	}

	function y(p) {
	  return p[1];
	}

	function d3line() {
	  var x$1 = x,
	      y$1 = y,
	      defined = constant(true),
	      context = null,
	      curve = curveLinear,
	      output = null;

	  function line(data) {
	    var i,
	        n = data.length,
	        d,
	        defined0 = false,
	        buffer;

	    if (context == null) output = curve(buffer = path());

	    for (i = 0; i <= n; ++i) {
	      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
	        if (defined0 = !defined0) output.lineStart();
	        else output.lineEnd();
	      }
	      if (defined0) output.point(+x$1(d, i, data), +y$1(d, i, data));
	    }

	    if (buffer) return output = null, buffer + "" || null;
	  }

	  line.x = function(_) {
	    return arguments.length ? (x$1 = typeof _ === "function" ? _ : constant(+_), line) : x$1;
	  };

	  line.y = function(_) {
	    return arguments.length ? (y$1 = typeof _ === "function" ? _ : constant(+_), line) : y$1;
	  };

	  line.defined = function(_) {
	    return arguments.length ? (defined = typeof _ === "function" ? _ : constant(!!_), line) : defined;
	  };

	  line.curve = function(_) {
	    return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;
	  };

	  line.context = function(_) {
	    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;
	  };

	  return line;
	}

	function d3area() {
	  var x0 = x,
	      x1 = null,
	      y0 = constant(0),
	      y1 = y,
	      defined = constant(true),
	      context = null,
	      curve = curveLinear,
	      output = null;

	  function area(data) {
	    var i,
	        j,
	        k,
	        n = data.length,
	        d,
	        defined0 = false,
	        buffer,
	        x0z = new Array(n),
	        y0z = new Array(n);

	    if (context == null) output = curve(buffer = path());

	    for (i = 0; i <= n; ++i) {
	      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
	        if (defined0 = !defined0) {
	          j = i;
	          output.areaStart();
	          output.lineStart();
	        } else {
	          output.lineEnd();
	          output.lineStart();
	          for (k = i - 1; k >= j; --k) {
	            output.point(x0z[k], y0z[k]);
	          }
	          output.lineEnd();
	          output.areaEnd();
	        }
	      }
	      if (defined0) {
	        x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);
	        output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);
	      }
	    }

	    if (buffer) return output = null, buffer + "" || null;
	  }

	  function arealine() {
	    return d3line().defined(defined).curve(curve).context(context);
	  }

	  area.x = function(_) {
	    return arguments.length ? (x0 = typeof _ === "function" ? _ : constant(+_), x1 = null, area) : x0;
	  };

	  area.x0 = function(_) {
	    return arguments.length ? (x0 = typeof _ === "function" ? _ : constant(+_), area) : x0;
	  };

	  area.x1 = function(_) {
	    return arguments.length ? (x1 = _ == null ? null : typeof _ === "function" ? _ : constant(+_), area) : x1;
	  };

	  area.y = function(_) {
	    return arguments.length ? (y0 = typeof _ === "function" ? _ : constant(+_), y1 = null, area) : y0;
	  };

	  area.y0 = function(_) {
	    return arguments.length ? (y0 = typeof _ === "function" ? _ : constant(+_), area) : y0;
	  };

	  area.y1 = function(_) {
	    return arguments.length ? (y1 = _ == null ? null : typeof _ === "function" ? _ : constant(+_), area) : y1;
	  };

	  area.lineX0 =
	  area.lineY0 = function() {
	    return arealine().x(x0).y(y0);
	  };

	  area.lineY1 = function() {
	    return arealine().x(x0).y(y1);
	  };

	  area.lineX1 = function() {
	    return arealine().x(x1).y(y0);
	  };

	  area.defined = function(_) {
	    return arguments.length ? (defined = typeof _ === "function" ? _ : constant(!!_), area) : defined;
	  };

	  area.curve = function(_) {
	    return arguments.length ? (curve = _, context != null && (output = curve(context)), area) : curve;
	  };

	  area.context = function(_) {
	    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area) : context;
	  };

	  return area;
	}

	function descending(a, b) {
	  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
	}

	function identity$1(d) {
	  return d;
	}

	function d3pie() {
	  var value = identity$1,
	      sortValues = descending,
	      sort = null,
	      startAngle = constant(0),
	      endAngle = constant(tau$1),
	      padAngle = constant(0);

	  function pie(data) {
	    var i,
	        n = data.length,
	        j,
	        k,
	        sum = 0,
	        index = new Array(n),
	        arcs = new Array(n),
	        a0 = +startAngle.apply(this, arguments),
	        da = Math.min(tau$1, Math.max(-tau$1, endAngle.apply(this, arguments) - a0)),
	        a1,
	        p = Math.min(Math.abs(da) / n, padAngle.apply(this, arguments)),
	        pa = p * (da < 0 ? -1 : 1),
	        v;

	    for (i = 0; i < n; ++i) {
	      if ((v = arcs[index[i] = i] = +value(data[i], i, data)) > 0) {
	        sum += v;
	      }
	    }

	    // Optionally sort the arcs by previously-computed values or by data.
	    if (sortValues != null) index.sort(function(i, j) { return sortValues(arcs[i], arcs[j]); });
	    else if (sort != null) index.sort(function(i, j) { return sort(data[i], data[j]); });

	    // Compute the arcs! They are stored in the original data's order.
	    for (i = 0, k = sum ? (da - n * pa) / sum : 0; i < n; ++i, a0 = a1) {
	      j = index[i], v = arcs[j], a1 = a0 + (v > 0 ? v * k : 0) + pa, arcs[j] = {
	        data: data[j],
	        index: i,
	        value: v,
	        startAngle: a0,
	        endAngle: a1,
	        padAngle: p
	      };
	    }

	    return arcs;
	  }

	  pie.value = function(_) {
	    return arguments.length ? (value = typeof _ === "function" ? _ : constant(+_), pie) : value;
	  };

	  pie.sortValues = function(_) {
	    return arguments.length ? (sortValues = _, sort = null, pie) : sortValues;
	  };

	  pie.sort = function(_) {
	    return arguments.length ? (sort = _, sortValues = null, pie) : sort;
	  };

	  pie.startAngle = function(_) {
	    return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant(+_), pie) : startAngle;
	  };

	  pie.endAngle = function(_) {
	    return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant(+_), pie) : endAngle;
	  };

	  pie.padAngle = function(_) {
	    return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant(+_), pie) : padAngle;
	  };

	  return pie;
	}

	var slice = Array.prototype.slice;

	function point(that, x, y) {
	  that._context.bezierCurveTo(
	    (2 * that._x0 + that._x1) / 3,
	    (2 * that._y0 + that._y1) / 3,
	    (that._x0 + 2 * that._x1) / 3,
	    (that._y0 + 2 * that._y1) / 3,
	    (that._x0 + 4 * that._x1 + x) / 6,
	    (that._y0 + 4 * that._y1 + y) / 6
	  );
	}

	function Basis(context) {
	  this._context = context;
	}

	Basis.prototype = {
	  areaStart: function() {
	    this._line = 0;
	  },
	  areaEnd: function() {
	    this._line = NaN;
	  },
	  lineStart: function() {
	    this._x0 = this._x1 =
	    this._y0 = this._y1 = NaN;
	    this._point = 0;
	  },
	  lineEnd: function() {
	    switch (this._point) {
	      case 3: point(this, this._x1, this._y1); // proceed
	      case 2: this._context.lineTo(this._x1, this._y1); break;
	    }
	    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
	    this._line = 1 - this._line;
	  },
	  point: function(x, y) {
	    x = +x, y = +y;
	    switch (this._point) {
	      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
	      case 1: this._point = 2; break;
	      case 2: this._point = 3; this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6); // proceed
	      default: point(this, x, y); break;
	    }
	    this._x0 = this._x1, this._x1 = x;
	    this._y0 = this._y1, this._y1 = y;
	  }
	};

	function curveBasis(context) {
	  return new Basis(context);
	}

	function Step(context, t) {
	  this._context = context;
	  this._t = t;
	}

	Step.prototype = {
	  areaStart: function() {
	    this._line = 0;
	  },
	  areaEnd: function() {
	    this._line = NaN;
	  },
	  lineStart: function() {
	    this._x = this._y = NaN;
	    this._point = 0;
	  },
	  lineEnd: function() {
	    if (0 < this._t && this._t < 1 && this._point === 2) this._context.lineTo(this._x, this._y);
	    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
	    if (this._line >= 0) this._t = 1 - this._t, this._line = 1 - this._line;
	  },
	  point: function(x, y) {
	    x = +x, y = +y;
	    switch (this._point) {
	      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
	      case 1: this._point = 2; // proceed
	      default: {
	        if (this._t <= 0) {
	          this._context.lineTo(this._x, y);
	          this._context.lineTo(x, y);
	        } else {
	          var x1 = this._x * (1 - this._t) + x * this._t;
	          this._context.lineTo(x1, this._y);
	          this._context.lineTo(x1, y);
	        }
	        break;
	      }
	    }
	    this._x = x, this._y = y;
	  }
	};

	function curveStep(context) {
	  return new Step(context, 0.5);
	}

	function stepBefore(context) {
	  return new Step(context, 0);
	}

	function stepAfter(context) {
	  return new Step(context, 1);
	}

	function none$1(series, order) {
	  if (!((n = series.length) > 1)) return;
	  for (var i = 1, j, s0, s1 = series[order[0]], n, m = s1.length; i < n; ++i) {
	    s0 = s1, s1 = series[order[i]];
	    for (j = 0; j < m; ++j) {
	      s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1];
	    }
	  }
	}

	function none(series) {
	  var n = series.length, o = new Array(n);
	  while (--n >= 0) o[n] = n;
	  return o;
	}

	function stackValue(d, key) {
	  return d[key];
	}

	function d3stack() {
	  var keys = constant([]),
	      order = none,
	      offset = none$1,
	      value = stackValue;

	  function stack(data) {
	    var kz = keys.apply(this, arguments),
	        i,
	        m = data.length,
	        n = kz.length,
	        sz = new Array(n),
	        oz;

	    for (i = 0; i < n; ++i) {
	      for (var ki = kz[i], si = sz[i] = new Array(m), j = 0, sij; j < m; ++j) {
	        si[j] = sij = [0, +value(data[j], ki, j, data)];
	        sij.data = data[j];
	      }
	      si.key = ki;
	    }

	    for (i = 0, oz = order(sz); i < n; ++i) {
	      sz[oz[i]].index = i;
	    }

	    offset(sz, oz);
	    return sz;
	  }

	  stack.keys = function(_) {
	    return arguments.length ? (keys = typeof _ === "function" ? _ : constant(slice.call(_)), stack) : keys;
	  };

	  stack.value = function(_) {
	    return arguments.length ? (value = typeof _ === "function" ? _ : constant(+_), stack) : value;
	  };

	  stack.order = function(_) {
	    return arguments.length ? (order = _ == null ? none : typeof _ === "function" ? _ : constant(slice.call(_)), stack) : order;
	  };

	  stack.offset = function(_) {
	    return arguments.length ? (offset = _ == null ? none$1 : _, stack) : offset;
	  };

	  return stack;
	}

	function stackOffsetDiverging(series, order) {
	  if (!((n = series.length) > 0)) return;
	  for (var i, j = 0, d, dy, yp, yn, n, m = series[order[0]].length; j < m; ++j) {
	    for (yp = yn = 0, i = 0; i < n; ++i) {
	      if ((dy = (d = series[order[i]][j])[1] - d[0]) > 0) {
	        d[0] = yp, d[1] = yp += dy;
	      } else if (dy < 0) {
	        d[1] = yn, d[0] = yn += dy;
	      } else {
	        d[0] = 0, d[1] = dy;
	      }
	    }
	  }
	}

	function RedBlackTree() {
	  this._ = null; // root node
	}

	function RedBlackNode(node) {
	  node.U = // parent node
	  node.C = // color - true for red, false for black
	  node.L = // left node
	  node.R = // right node
	  node.P = // previous node
	  node.N = null; // next node
	}

	RedBlackTree.prototype = {
	  constructor: RedBlackTree,

	  insert: function(after, node) {
	    var parent, grandpa, uncle;

	    if (after) {
	      node.P = after;
	      node.N = after.N;
	      if (after.N) after.N.P = node;
	      after.N = node;
	      if (after.R) {
	        after = after.R;
	        while (after.L) after = after.L;
	        after.L = node;
	      } else {
	        after.R = node;
	      }
	      parent = after;
	    } else if (this._) {
	      after = RedBlackFirst(this._);
	      node.P = null;
	      node.N = after;
	      after.P = after.L = node;
	      parent = after;
	    } else {
	      node.P = node.N = null;
	      this._ = node;
	      parent = null;
	    }
	    node.L = node.R = null;
	    node.U = parent;
	    node.C = true;

	    after = node;
	    while (parent && parent.C) {
	      grandpa = parent.U;
	      if (parent === grandpa.L) {
	        uncle = grandpa.R;
	        if (uncle && uncle.C) {
	          parent.C = uncle.C = false;
	          grandpa.C = true;
	          after = grandpa;
	        } else {
	          if (after === parent.R) {
	            RedBlackRotateLeft(this, parent);
	            after = parent;
	            parent = after.U;
	          }
	          parent.C = false;
	          grandpa.C = true;
	          RedBlackRotateRight(this, grandpa);
	        }
	      } else {
	        uncle = grandpa.L;
	        if (uncle && uncle.C) {
	          parent.C = uncle.C = false;
	          grandpa.C = true;
	          after = grandpa;
	        } else {
	          if (after === parent.L) {
	            RedBlackRotateRight(this, parent);
	            after = parent;
	            parent = after.U;
	          }
	          parent.C = false;
	          grandpa.C = true;
	          RedBlackRotateLeft(this, grandpa);
	        }
	      }
	      parent = after.U;
	    }
	    this._.C = false;
	  },

	  remove: function(node) {
	    if (node.N) node.N.P = node.P;
	    if (node.P) node.P.N = node.N;
	    node.N = node.P = null;

	    var parent = node.U,
	        sibling,
	        left = node.L,
	        right = node.R,
	        next,
	        red;

	    if (!left) next = right;
	    else if (!right) next = left;
	    else next = RedBlackFirst(right);

	    if (parent) {
	      if (parent.L === node) parent.L = next;
	      else parent.R = next;
	    } else {
	      this._ = next;
	    }

	    if (left && right) {
	      red = next.C;
	      next.C = node.C;
	      next.L = left;
	      left.U = next;
	      if (next !== right) {
	        parent = next.U;
	        next.U = node.U;
	        node = next.R;
	        parent.L = node;
	        next.R = right;
	        right.U = next;
	      } else {
	        next.U = parent;
	        parent = next;
	        node = next.R;
	      }
	    } else {
	      red = node.C;
	      node = next;
	    }

	    if (node) node.U = parent;
	    if (red) return;
	    if (node && node.C) { node.C = false; return; }

	    do {
	      if (node === this._) break;
	      if (node === parent.L) {
	        sibling = parent.R;
	        if (sibling.C) {
	          sibling.C = false;
	          parent.C = true;
	          RedBlackRotateLeft(this, parent);
	          sibling = parent.R;
	        }
	        if ((sibling.L && sibling.L.C)
	            || (sibling.R && sibling.R.C)) {
	          if (!sibling.R || !sibling.R.C) {
	            sibling.L.C = false;
	            sibling.C = true;
	            RedBlackRotateRight(this, sibling);
	            sibling = parent.R;
	          }
	          sibling.C = parent.C;
	          parent.C = sibling.R.C = false;
	          RedBlackRotateLeft(this, parent);
	          node = this._;
	          break;
	        }
	      } else {
	        sibling = parent.L;
	        if (sibling.C) {
	          sibling.C = false;
	          parent.C = true;
	          RedBlackRotateRight(this, parent);
	          sibling = parent.L;
	        }
	        if ((sibling.L && sibling.L.C)
	          || (sibling.R && sibling.R.C)) {
	          if (!sibling.L || !sibling.L.C) {
	            sibling.R.C = false;
	            sibling.C = true;
	            RedBlackRotateLeft(this, sibling);
	            sibling = parent.L;
	          }
	          sibling.C = parent.C;
	          parent.C = sibling.L.C = false;
	          RedBlackRotateRight(this, parent);
	          node = this._;
	          break;
	        }
	      }
	      sibling.C = true;
	      node = parent;
	      parent = parent.U;
	    } while (!node.C);

	    if (node) node.C = false;
	  }
	};

	function RedBlackRotateLeft(tree, node) {
	  var p = node,
	      q = node.R,
	      parent = p.U;

	  if (parent) {
	    if (parent.L === p) parent.L = q;
	    else parent.R = q;
	  } else {
	    tree._ = q;
	  }

	  q.U = parent;
	  p.U = q;
	  p.R = q.L;
	  if (p.R) p.R.U = p;
	  q.L = p;
	}

	function RedBlackRotateRight(tree, node) {
	  var p = node,
	      q = node.L,
	      parent = p.U;

	  if (parent) {
	    if (parent.L === p) parent.L = q;
	    else parent.R = q;
	  } else {
	    tree._ = q;
	  }

	  q.U = parent;
	  p.U = q;
	  p.L = q.R;
	  if (p.L) p.L.U = p;
	  q.R = p;
	}

	function RedBlackFirst(node) {
	  while (node.L) node = node.L;
	  return node;
	}

	function createEdge(left, right, v0, v1) {
	  var edge = [null, null],
	      index = edges.push(edge) - 1;
	  edge.left = left;
	  edge.right = right;
	  if (v0) setEdgeEnd(edge, left, right, v0);
	  if (v1) setEdgeEnd(edge, right, left, v1);
	  cells[left.index].halfedges.push(index);
	  cells[right.index].halfedges.push(index);
	  return edge;
	}

	function createBorderEdge(left, v0, v1) {
	  var edge = [v0, v1];
	  edge.left = left;
	  return edge;
	}

	function setEdgeEnd(edge, left, right, vertex) {
	  if (!edge[0] && !edge[1]) {
	    edge[0] = vertex;
	    edge.left = left;
	    edge.right = right;
	  } else if (edge.left === right) {
	    edge[1] = vertex;
	  } else {
	    edge[0] = vertex;
	  }
	}

	// LiangâBarsky line clipping.
	function clipEdge(edge, x0, y0, x1, y1) {
	  var a = edge[0],
	      b = edge[1],
	      ax = a[0],
	      ay = a[1],
	      bx = b[0],
	      by = b[1],
	      t0 = 0,
	      t1 = 1,
	      dx = bx - ax,
	      dy = by - ay,
	      r;

	  r = x0 - ax;
	  if (!dx && r > 0) return;
	  r /= dx;
	  if (dx < 0) {
	    if (r < t0) return;
	    if (r < t1) t1 = r;
	  } else if (dx > 0) {
	    if (r > t1) return;
	    if (r > t0) t0 = r;
	  }

	  r = x1 - ax;
	  if (!dx && r < 0) return;
	  r /= dx;
	  if (dx < 0) {
	    if (r > t1) return;
	    if (r > t0) t0 = r;
	  } else if (dx > 0) {
	    if (r < t0) return;
	    if (r < t1) t1 = r;
	  }

	  r = y0 - ay;
	  if (!dy && r > 0) return;
	  r /= dy;
	  if (dy < 0) {
	    if (r < t0) return;
	    if (r < t1) t1 = r;
	  } else if (dy > 0) {
	    if (r > t1) return;
	    if (r > t0) t0 = r;
	  }

	  r = y1 - ay;
	  if (!dy && r < 0) return;
	  r /= dy;
	  if (dy < 0) {
	    if (r > t1) return;
	    if (r > t0) t0 = r;
	  } else if (dy > 0) {
	    if (r < t0) return;
	    if (r < t1) t1 = r;
	  }

	  if (!(t0 > 0) && !(t1 < 1)) return true; // TODO Better check?

	  if (t0 > 0) edge[0] = [ax + t0 * dx, ay + t0 * dy];
	  if (t1 < 1) edge[1] = [ax + t1 * dx, ay + t1 * dy];
	  return true;
	}

	function connectEdge(edge, x0, y0, x1, y1) {
	  var v1 = edge[1];
	  if (v1) return true;

	  var v0 = edge[0],
	      left = edge.left,
	      right = edge.right,
	      lx = left[0],
	      ly = left[1],
	      rx = right[0],
	      ry = right[1],
	      fx = (lx + rx) / 2,
	      fy = (ly + ry) / 2,
	      fm,
	      fb;

	  if (ry === ly) {
	    if (fx < x0 || fx >= x1) return;
	    if (lx > rx) {
	      if (!v0) v0 = [fx, y0];
	      else if (v0[1] >= y1) return;
	      v1 = [fx, y1];
	    } else {
	      if (!v0) v0 = [fx, y1];
	      else if (v0[1] < y0) return;
	      v1 = [fx, y0];
	    }
	  } else {
	    fm = (lx - rx) / (ry - ly);
	    fb = fy - fm * fx;
	    if (fm < -1 || fm > 1) {
	      if (lx > rx) {
	        if (!v0) v0 = [(y0 - fb) / fm, y0];
	        else if (v0[1] >= y1) return;
	        v1 = [(y1 - fb) / fm, y1];
	      } else {
	        if (!v0) v0 = [(y1 - fb) / fm, y1];
	        else if (v0[1] < y0) return;
	        v1 = [(y0 - fb) / fm, y0];
	      }
	    } else {
	      if (ly < ry) {
	        if (!v0) v0 = [x0, fm * x0 + fb];
	        else if (v0[0] >= x1) return;
	        v1 = [x1, fm * x1 + fb];
	      } else {
	        if (!v0) v0 = [x1, fm * x1 + fb];
	        else if (v0[0] < x0) return;
	        v1 = [x0, fm * x0 + fb];
	      }
	    }
	  }

	  edge[0] = v0;
	  edge[1] = v1;
	  return true;
	}

	function clipEdges(x0, y0, x1, y1) {
	  var i = edges.length,
	      edge;

	  while (i--) {
	    if (!connectEdge(edge = edges[i], x0, y0, x1, y1)
	        || !clipEdge(edge, x0, y0, x1, y1)
	        || !(Math.abs(edge[0][0] - edge[1][0]) > epsilon$1
	            || Math.abs(edge[0][1] - edge[1][1]) > epsilon$1)) {
	      delete edges[i];
	    }
	  }
	}

	function createCell(site) {
	  return cells[site.index] = {
	    site: site,
	    halfedges: []
	  };
	}

	function cellHalfedgeAngle(cell, edge) {
	  var site = cell.site,
	      va = edge.left,
	      vb = edge.right;
	  if (site === vb) vb = va, va = site;
	  if (vb) return Math.atan2(vb[1] - va[1], vb[0] - va[0]);
	  if (site === va) va = edge[1], vb = edge[0];
	  else va = edge[0], vb = edge[1];
	  return Math.atan2(va[0] - vb[0], vb[1] - va[1]);
	}

	function cellHalfedgeStart(cell, edge) {
	  return edge[+(edge.left !== cell.site)];
	}

	function cellHalfedgeEnd(cell, edge) {
	  return edge[+(edge.left === cell.site)];
	}

	function sortCellHalfedges() {
	  for (var i = 0, n = cells.length, cell, halfedges, j, m; i < n; ++i) {
	    if ((cell = cells[i]) && (m = (halfedges = cell.halfedges).length)) {
	      var index = new Array(m),
	          array = new Array(m);
	      for (j = 0; j < m; ++j) index[j] = j, array[j] = cellHalfedgeAngle(cell, edges[halfedges[j]]);
	      index.sort(function(i, j) { return array[j] - array[i]; });
	      for (j = 0; j < m; ++j) array[j] = halfedges[index[j]];
	      for (j = 0; j < m; ++j) halfedges[j] = array[j];
	    }
	  }
	}

	function clipCells(x0, y0, x1, y1) {
	  var nCells = cells.length,
	      iCell,
	      cell,
	      site,
	      iHalfedge,
	      halfedges,
	      nHalfedges,
	      start,
	      startX,
	      startY,
	      end,
	      endX,
	      endY,
	      cover = true;

	  for (iCell = 0; iCell < nCells; ++iCell) {
	    if (cell = cells[iCell]) {
	      site = cell.site;
	      halfedges = cell.halfedges;
	      iHalfedge = halfedges.length;

	      // Remove any dangling clipped edges.
	      while (iHalfedge--) {
	        if (!edges[halfedges[iHalfedge]]) {
	          halfedges.splice(iHalfedge, 1);
	        }
	      }

	      // Insert any border edges as necessary.
	      iHalfedge = 0, nHalfedges = halfedges.length;
	      while (iHalfedge < nHalfedges) {
	        end = cellHalfedgeEnd(cell, edges[halfedges[iHalfedge]]), endX = end[0], endY = end[1];
	        start = cellHalfedgeStart(cell, edges[halfedges[++iHalfedge % nHalfedges]]), startX = start[0], startY = start[1];
	        if (Math.abs(endX - startX) > epsilon$1 || Math.abs(endY - startY) > epsilon$1) {
	          halfedges.splice(iHalfedge, 0, edges.push(createBorderEdge(site, end,
	              Math.abs(endX - x0) < epsilon$1 && y1 - endY > epsilon$1 ? [x0, Math.abs(startX - x0) < epsilon$1 ? startY : y1]
	              : Math.abs(endY - y1) < epsilon$1 && x1 - endX > epsilon$1 ? [Math.abs(startY - y1) < epsilon$1 ? startX : x1, y1]
	              : Math.abs(endX - x1) < epsilon$1 && endY - y0 > epsilon$1 ? [x1, Math.abs(startX - x1) < epsilon$1 ? startY : y0]
	              : Math.abs(endY - y0) < epsilon$1 && endX - x0 > epsilon$1 ? [Math.abs(startY - y0) < epsilon$1 ? startX : x0, y0]
	              : null)) - 1);
	          ++nHalfedges;
	        }
	      }

	      if (nHalfedges) cover = false;
	    }
	  }

	  // If there werenât any edges, have the closest site cover the extent.
	  // It doesnât matter which corner of the extent we measure!
	  if (cover) {
	    var dx, dy, d2, dc = Infinity;

	    for (iCell = 0, cover = null; iCell < nCells; ++iCell) {
	      if (cell = cells[iCell]) {
	        site = cell.site;
	        dx = site[0] - x0;
	        dy = site[1] - y0;
	        d2 = dx * dx + dy * dy;
	        if (d2 < dc) dc = d2, cover = cell;
	      }
	    }

	    if (cover) {
	      var v00 = [x0, y0], v01 = [x0, y1], v11 = [x1, y1], v10 = [x1, y0];
	      cover.halfedges.push(
	        edges.push(createBorderEdge(site = cover.site, v00, v01)) - 1,
	        edges.push(createBorderEdge(site, v01, v11)) - 1,
	        edges.push(createBorderEdge(site, v11, v10)) - 1,
	        edges.push(createBorderEdge(site, v10, v00)) - 1
	      );
	    }
	  }

	  // Lastly delete any cells with no edges; these were entirely clipped.
	  for (iCell = 0; iCell < nCells; ++iCell) {
	    if (cell = cells[iCell]) {
	      if (!cell.halfedges.length) {
	        delete cells[iCell];
	      }
	    }
	  }
	}

	var circlePool = [];

	var firstCircle;

	function Circle$1() {
	  RedBlackNode(this);
	  this.x =
	  this.y =
	  this.arc =
	  this.site =
	  this.cy = null;
	}

	function attachCircle(arc) {
	  var lArc = arc.P,
	      rArc = arc.N;

	  if (!lArc || !rArc) return;

	  var lSite = lArc.site,
	      cSite = arc.site,
	      rSite = rArc.site;

	  if (lSite === rSite) return;

	  var bx = cSite[0],
	      by = cSite[1],
	      ax = lSite[0] - bx,
	      ay = lSite[1] - by,
	      cx = rSite[0] - bx,
	      cy = rSite[1] - by;

	  var d = 2 * (ax * cy - ay * cx);
	  if (d >= -epsilon2) return;

	  var ha = ax * ax + ay * ay,
	      hc = cx * cx + cy * cy,
	      x = (cy * ha - ay * hc) / d,
	      y = (ax * hc - cx * ha) / d;

	  var circle = circlePool.pop() || new Circle$1;
	  circle.arc = arc;
	  circle.site = cSite;
	  circle.x = x + bx;
	  circle.y = (circle.cy = y + by) + Math.sqrt(x * x + y * y); // y bottom

	  arc.circle = circle;

	  var before = null,
	      node = circles._;

	  while (node) {
	    if (circle.y < node.y || (circle.y === node.y && circle.x <= node.x)) {
	      if (node.L) node = node.L;
	      else { before = node.P; break; }
	    } else {
	      if (node.R) node = node.R;
	      else { before = node; break; }
	    }
	  }

	  circles.insert(before, circle);
	  if (!before) firstCircle = circle;
	}

	function detachCircle(arc) {
	  var circle = arc.circle;
	  if (circle) {
	    if (!circle.P) firstCircle = circle.N;
	    circles.remove(circle);
	    circlePool.push(circle);
	    RedBlackNode(circle);
	    arc.circle = null;
	  }
	}

	var beachPool = [];

	function Beach() {
	  RedBlackNode(this);
	  this.edge =
	  this.site =
	  this.circle = null;
	}

	function createBeach(site) {
	  var beach = beachPool.pop() || new Beach;
	  beach.site = site;
	  return beach;
	}

	function detachBeach(beach) {
	  detachCircle(beach);
	  beaches.remove(beach);
	  beachPool.push(beach);
	  RedBlackNode(beach);
	}

	function removeBeach(beach) {
	  var circle = beach.circle,
	      x = circle.x,
	      y = circle.cy,
	      vertex = [x, y],
	      previous = beach.P,
	      next = beach.N,
	      disappearing = [beach];

	  detachBeach(beach);

	  var lArc = previous;
	  while (lArc.circle
	      && Math.abs(x - lArc.circle.x) < epsilon$1
	      && Math.abs(y - lArc.circle.cy) < epsilon$1) {
	    previous = lArc.P;
	    disappearing.unshift(lArc);
	    detachBeach(lArc);
	    lArc = previous;
	  }

	  disappearing.unshift(lArc);
	  detachCircle(lArc);

	  var rArc = next;
	  while (rArc.circle
	      && Math.abs(x - rArc.circle.x) < epsilon$1
	      && Math.abs(y - rArc.circle.cy) < epsilon$1) {
	    next = rArc.N;
	    disappearing.push(rArc);
	    detachBeach(rArc);
	    rArc = next;
	  }

	  disappearing.push(rArc);
	  detachCircle(rArc);

	  var nArcs = disappearing.length,
	      iArc;
	  for (iArc = 1; iArc < nArcs; ++iArc) {
	    rArc = disappearing[iArc];
	    lArc = disappearing[iArc - 1];
	    setEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);
	  }

	  lArc = disappearing[0];
	  rArc = disappearing[nArcs - 1];
	  rArc.edge = createEdge(lArc.site, rArc.site, null, vertex);

	  attachCircle(lArc);
	  attachCircle(rArc);
	}

	function addBeach(site) {
	  var x = site[0],
	      directrix = site[1],
	      lArc,
	      rArc,
	      dxl,
	      dxr,
	      node = beaches._;

	  while (node) {
	    dxl = leftBreakPoint(node, directrix) - x;
	    if (dxl > epsilon$1) node = node.L; else {
	      dxr = x - rightBreakPoint(node, directrix);
	      if (dxr > epsilon$1) {
	        if (!node.R) {
	          lArc = node;
	          break;
	        }
	        node = node.R;
	      } else {
	        if (dxl > -epsilon$1) {
	          lArc = node.P;
	          rArc = node;
	        } else if (dxr > -epsilon$1) {
	          lArc = node;
	          rArc = node.N;
	        } else {
	          lArc = rArc = node;
	        }
	        break;
	      }
	    }
	  }

	  createCell(site);
	  var newArc = createBeach(site);
	  beaches.insert(lArc, newArc);

	  if (!lArc && !rArc) return;

	  if (lArc === rArc) {
	    detachCircle(lArc);
	    rArc = createBeach(lArc.site);
	    beaches.insert(newArc, rArc);
	    newArc.edge = rArc.edge = createEdge(lArc.site, newArc.site);
	    attachCircle(lArc);
	    attachCircle(rArc);
	    return;
	  }

	  if (!rArc) { // && lArc
	    newArc.edge = createEdge(lArc.site, newArc.site);
	    return;
	  }

	  // else lArc !== rArc
	  detachCircle(lArc);
	  detachCircle(rArc);

	  var lSite = lArc.site,
	      ax = lSite[0],
	      ay = lSite[1],
	      bx = site[0] - ax,
	      by = site[1] - ay,
	      rSite = rArc.site,
	      cx = rSite[0] - ax,
	      cy = rSite[1] - ay,
	      d = 2 * (bx * cy - by * cx),
	      hb = bx * bx + by * by,
	      hc = cx * cx + cy * cy,
	      vertex = [(cy * hb - by * hc) / d + ax, (bx * hc - cx * hb) / d + ay];

	  setEdgeEnd(rArc.edge, lSite, rSite, vertex);
	  newArc.edge = createEdge(lSite, site, null, vertex);
	  rArc.edge = createEdge(site, rSite, null, vertex);
	  attachCircle(lArc);
	  attachCircle(rArc);
	}

	function leftBreakPoint(arc, directrix) {
	  var site = arc.site,
	      rfocx = site[0],
	      rfocy = site[1],
	      pby2 = rfocy - directrix;

	  if (!pby2) return rfocx;

	  var lArc = arc.P;
	  if (!lArc) return -Infinity;

	  site = lArc.site;
	  var lfocx = site[0],
	      lfocy = site[1],
	      plby2 = lfocy - directrix;

	  if (!plby2) return lfocx;

	  var hl = lfocx - rfocx,
	      aby2 = 1 / pby2 - 1 / plby2,
	      b = hl / plby2;

	  if (aby2) return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;

	  return (rfocx + lfocx) / 2;
	}

	function rightBreakPoint(arc, directrix) {
	  var rArc = arc.N;
	  if (rArc) return leftBreakPoint(rArc, directrix);
	  var site = arc.site;
	  return site[1] === directrix ? site[0] : Infinity;
	}

	var epsilon$1 = 1e-6;
	var epsilon2 = 1e-12;
	var beaches;
	var cells;
	var circles;
	var edges;

	function triangleArea(a, b, c) {
	  return (a[0] - c[0]) * (b[1] - a[1]) - (a[0] - b[0]) * (c[1] - a[1]);
	}

	function lexicographic(a, b) {
	  return b[1] - a[1]
	      || b[0] - a[0];
	}

	function Diagram(sites, extent) {
	  var site = sites.sort(lexicographic).pop(),
	      x,
	      y,
	      circle;

	  edges = [];
	  cells = new Array(sites.length);
	  beaches = new RedBlackTree;
	  circles = new RedBlackTree;

	  while (true) {
	    circle = firstCircle;
	    if (site && (!circle || site[1] < circle.y || (site[1] === circle.y && site[0] < circle.x))) {
	      if (site[0] !== x || site[1] !== y) {
	        addBeach(site);
	        x = site[0], y = site[1];
	      }
	      site = sites.pop();
	    } else if (circle) {
	      removeBeach(circle.arc);
	    } else {
	      break;
	    }
	  }

	  sortCellHalfedges();

	  if (extent) {
	    var x0 = +extent[0][0],
	        y0 = +extent[0][1],
	        x1 = +extent[1][0],
	        y1 = +extent[1][1];
	    clipEdges(x0, y0, x1, y1);
	    clipCells(x0, y0, x1, y1);
	  }

	  this.edges = edges;
	  this.cells = cells;

	  beaches =
	  circles =
	  edges =
	  cells = null;
	}

	Diagram.prototype = {
	  constructor: Diagram,

	  polygons: function() {
	    var edges = this.edges;

	    return this.cells.map(function(cell) {
	      var polygon = cell.halfedges.map(function(i) { return cellHalfedgeStart(cell, edges[i]); });
	      polygon.data = cell.site.data;
	      return polygon;
	    });
	  },

	  triangles: function() {
	    var triangles = [],
	        edges = this.edges;

	    this.cells.forEach(function(cell, i) {
	      if (!(m = (halfedges = cell.halfedges).length)) return;
	      var site = cell.site,
	          halfedges,
	          j = -1,
	          m,
	          s0,
	          e1 = edges[halfedges[m - 1]],
	          s1 = e1.left === site ? e1.right : e1.left;

	      while (++j < m) {
	        s0 = s1;
	        e1 = edges[halfedges[j]];
	        s1 = e1.left === site ? e1.right : e1.left;
	        if (s0 && s1 && i < s0.index && i < s1.index && triangleArea(site, s0, s1) < 0) {
	          triangles.push([site.data, s0.data, s1.data]);
	        }
	      }
	    });

	    return triangles;
	  },

	  links: function() {
	    return this.edges.filter(function(edge) {
	      return edge.right;
	    }).map(function(edge) {
	      return {
	        source: edge.left.data,
	        target: edge.right.data
	      };
	    });
	  },

	  find: function(x, y, radius) {
	    var that = this, i0, i1 = that._found || 0, n = that.cells.length, cell;

	    // Use the previously-found cell, or start with an arbitrary one.
	    while (!(cell = that.cells[i1])) if (++i1 >= n) return null;
	    var dx = x - cell.site[0], dy = y - cell.site[1], d2 = dx * dx + dy * dy;

	    // Traverse the half-edges to find a closer cell, if any.
	    do {
	      cell = that.cells[i0 = i1], i1 = null;
	      cell.halfedges.forEach(function(e) {
	        var edge = that.edges[e], v = edge.left;
	        if ((v === cell.site || !v) && !(v = edge.right)) return;
	        var vx = x - v[0], vy = y - v[1], v2 = vx * vx + vy * vy;
	        if (v2 < d2) d2 = v2, i1 = v.index;
	      });
	    } while (i1 !== null);

	    that._found = i0;

	    return radius == null || d2 <= radius * radius ? cell.site : null;
	  }
	};

	function Transform(k, x, y) {
	  this.k = k;
	  this.x = x;
	  this.y = y;
	}

	Transform.prototype = {
	  constructor: Transform,
	  scale: function(k) {
	    return k === 1 ? this : new Transform(this.k * k, this.x, this.y);
	  },
	  translate: function(x, y) {
	    return x === 0 & y === 0 ? this : new Transform(this.k, this.x + this.k * x, this.y + this.k * y);
	  },
	  apply: function(point) {
	    return [point[0] * this.k + this.x, point[1] * this.k + this.y];
	  },
	  applyX: function(x) {
	    return x * this.k + this.x;
	  },
	  applyY: function(y) {
	    return y * this.k + this.y;
	  },
	  invert: function(location) {
	    return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
	  },
	  invertX: function(x) {
	    return (x - this.x) / this.k;
	  },
	  invertY: function(y) {
	    return (y - this.y) / this.k;
	  },
	  rescaleX: function(x) {
	    return x.copy().domain(x.range().map(this.invertX, this).map(x.invert, x));
	  },
	  rescaleY: function(y) {
	    return y.copy().domain(y.range().map(this.invertY, this).map(y.invert, y));
	  },
	  toString: function() {
	    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
	  }
	};

	new Transform(1, 0, 0);

	Transform.prototype;

	selection.prototype.selectAppend = selectAppend;
	selection.prototype.append = append$1; // selection.prototype.transition = transition
	// custom version that works in jest environment

	var svgNode;

	function parseSvg(value) {
	  if (value == null) return identity$4;
	  if (!svgNode) svgNode = document.createElementNS('http://www.w3.org/2000/svg', 'g');
	  svgNode.setAttribute('transform', value);

	  if (svgNode.transform && svgNode.transform.baseVal && svgNode.transform.baseVal.consolidate) {
	    if (!(value = svgNode.transform.baseVal.consolidate())) return identity$4;
	    value = value.matrix;
	    return decompose(value.a, value.b, value.c, value.d, value.e, value.f);
	  } else {
	    return identity$4;
	  }
	}

	function wrapText$1(width, options) {
	  var defaults = {
	    lineHeight: 16,
	    margin: 10
	  };
	  var newLineToken = '<N>';
	  options = _extends(defaults, options);
	  return function (d) {
	    var text = select(this); // make sure new line gets into the array

	    var textVal = text.text().replace(/\n|<br>/g, ' ' + newLineToken + ' ');
	    var words = textVal.split(/\s+/).reverse(); // /\s+/

	    var lineHeight = options.lineHeight; // ems

	    var y = text.attr('y');
	    var x = text.attr('x');
	    var dy = options.margin;
	    var lineNumber = 0;
	    var tspan = text.text(null).append('tspan').attr('x', x).attr('y', y).attr('dy', dy + 'px');
	    var line = [];
	    var word;
	    var pushCount = 0;

	    while (word = words.pop()) {
	      // eslint-disable-line
	      line.push(word);
	      pushCount++;
	      tspan.text(line.join(' ').trim());

	      if (pushCount > 1 && (tspan.node().getComputedTextLength() > width || word === newLineToken)) {
	        if (word === newLineToken) word = '';
	        line.pop();
	        tspan.text(line.join(' ').trim());
	        line = [word];
	        tspan = text.append('tspan').attr('x', x).attr('y', y).attr('dy', ++lineNumber * lineHeight + dy + 'px').text(word);
	      }
	    }
	  };
	}

	var LINE_SEPARATOR = '///'; // Place Vertically aligned text at a spot either left or right
	// aligned and vertically centered to the given coords
	// textObject = {
	//  position: [x,y], orientation: 'right', line1: 'asdf', line2: 'asdf'
	// }

	function placeMultiLineText(container, textObject, env) {
	  var tg = container.append('g').classed(textObject.orientation, true).classed('text-group', true);

	  if (textObject.orientation === 'right') {
	    textObject.position[0] += env.options.labelLineOffset;
	  } else {
	    textObject.position[0] -= env.options.labelLineOffset;
	  }

	  tg.append('text').classed('line1', true).attr('dy', 0).attr('y', 0).text(textObject.line1);

	  if (textObject.line2) {
	    var line2 = tg.append('text').classed('line2', true).attr('dy', 0).attr('y', env.options.labelLine2Height).text(textObject.line2);
	    line2.each(wrapText$1(env.options.labelTextWrapWidth, {
	      margin: 0
	    }));
	    line2.selectAll('tspan').attr('x', 0);
	  } // offset to vertically center


	  tg.attr('transform', "translate(".concat(textObject.position[0], ", ").concat(textObject.position[1], ")"));
	} // Given a text value of line1///line2///line3
	// separate into multiple tspan lines
	// support an option for horizontal labels with no wrapping

	function renderMultiLineText(options) {
	  var defaults = {
	    margin: 16,
	    lineHeight: 18,
	    isHorizontalText: false
	  };
	  options = _extends(defaults, options);
	  return function (d) {
	    var text = select(this);
	    var textVals = text.text().split(LINE_SEPARATOR);
	    var y = text.attr('y');
	    var dy = options.margin;

	    if (options.isHorizontalText) {
	      text.text(textVals.join(' '));
	    } else {
	      text.text(null);
	      textVals.forEach(function (val, i) {
	        text.append('tspan').attr('x', 0).attr('y', y).attr('dy', dy + 'px').classed('line' + (i + 1), true).text(val);
	        dy += options.lineHeight;
	      });
	    }
	  };
	}

	function toUnicode(str) {
	  return toUnicodeNumber(str, '\\');
	}
	function toUnicodeNumber(str, separator) {
	  separator = separator || '';
	  return str.split('').map(function (value) {
	    var temp = value.charCodeAt(0).toString(16).toUpperCase();

	    if (temp.length > 2) {
	      return "\\u" + temp;
	    }

	    return temp;
	  }).join(separator);
	}

	// 600B and convert to display as 0.6T

	function forceUnitDisplay(val, precision, options) {
	  if (options.forceUnitDisplay === 'Thousands') {
	    val = val / 1000;
	    return format('.' + precision + 'f')(val) + 'K';
	  } else if (options.forceUnitDisplay === 'Millions') {
	    val = val / 1000000;
	    return format('.' + precision + 'f')(val) + 'M';
	  } else if (options.forceUnitDisplay === 'Billions') {
	    val = val / 1000000000;
	    return format('.' + precision + 'f')(val) + 'B';
	  } else if (options.forceUnitDisplay === 'Trillions') {
	    val = val / 1000000000000;
	    return format('.' + precision + 'f')(val) + 'T';
	  }
	} // generic formatting for a number


	function smallNumber(precision, options) {
	  if (precision == null) precision = 2;
	  return function (val) {
	    if (options.absoluteValue) val = Math.abs(val);
	    return Number(numberOrNull(val)).toFixed(precision);
	  };
	}

	function prettyNumber(precision, options) {
	  if (precision == null || precision === '') precision = 0;
	  return function (val) {
	    if (val == null) return '';
	    val = Number(trimNumber(val));
	    if (isNaN(val)) return '';
	    if (val === 0) return 0;
	    if (options.absoluteValue) val = Math.abs(val); // precision

	    var currentPrecision = precision;

	    if (options.displayAsMultiplier && Math.abs(val) > 100 && Math.abs(val) < options.displayAsMultiplier) {
	      currentPrecision = Math.max(0, precision - 1);
	    }

	    if (options.forceCommaDisplay) {
	      return format(',.' + currentPrecision + 'f')(val);
	    }

	    if (Math.abs(val) < 10) {
	      return format('.' + currentPrecision + 'f')(val);
	    } // replace scientific "G" (Giga) with "B"


	    if (options.forceUnitDisplay) {
	      val = forceUnitDisplay(val, currentPrecision, options);
	    } else {
	      val = format('s')(val).replace('G', 'B');
	    }

	    if (options.lowerCaseUnits) {
	      val = String(val).toLowerCase();
	    } else {
	      // treat k as a special case of uppercase units
	      val = String(val).toUpperCase();
	    } // strip out non character part, and apply precisionf float


	    var numericVal = val.replace(/[^\d.-]/g, '');
	    var numericFormatted = format('.' + currentPrecision + 'f')(Number(numericVal));
	    return val.replace(numericVal, numericFormatted);
	  };
	} // this is meant for tick text elements so we return strings
	function dateFormatter(formatter, parser) {
	  parser = parser || parseDate;
	  return function (val) {
	    return parser(val).format(formatter);
	  };
	}

	function percentageShift(formatter) {
	  return function (val) {
	    return formatter(val * 100.0);
	  };
	}

	function valueMultiplier(formatter, multiplier) {
	  return function (val) {
	    return formatter(val * multiplier);
	  };
	}

	function displayAsMultiplier$1(field) {
	  if (field.display_as && DISPLAY_AS_MULTIPLIERS[field.display_as]) {
	    return DISPLAY_AS_MULTIPLIERS[field.display_as];
	  }

	  return 1.0;
	} // returns Q1, Q2 etc. for any date

	function formatDateAsQuarter(val) {
	  var d = parseDate(val);

	  if (d.valueOf()) {
	    return 'Q' + (Math.floor((d.format('M') - 1) / 3) + 1);
	  } else {
	    return '';
	  }
	}
	// TODO :: change to count only post label

	function isSingleCharLabel(field) {
	  var label = field.label || field.caption || '';
	  var pre = field.unit_before || field['label-left'] || '';
	  var post = field.unit_after || field['label-right'] || '';
	  var prepostLength = label.length + pre.length + post.length;
	  return prepostLength <= 3;
	}
	function mockAxis(_field) {
	  return {
	    field: function field() {
	      return _field;
	    },
	    scale: {
	      domain: function domain() {
	        return [_field.min, _field.max];
	      }
	    }
	  };
	} // build an axis from the field and return a value
	// formatter

	function fieldFormatter$1(field, env, options) {
	  return valueFormatter(mockAxis(field), env, options);
	} // Default value formatter

	function valueFormatter(axis, env) {
	  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
	  env = env || {};
	  env.options = env.options || {};
	  var field = axis.field();
	  var parser = fieldDateParser(field);
	  var tx = field.taxonomy;

	  var noFormat = function noFormat(val) {
	    return val;
	  };

	  var precision = null;
	  var formatter = noFormat;
	  var pre = field.unit_before || field.unitBefore || field['label-left'] || '';
	  var post = field.unit_after || field.unitAfter || field['label-right'] || '';
	  var prepostLength = pre.length + post.length;
	  var customFormatter;
	  if (options.unitBefore) pre = options.unitBefore;
	  if (options.unitAfter) post = options.unitAfter; // passed in with axis prepare options

	  if (hasOwnProperty$h(options, 'defaultDecimals')) {
	    precision = options.defaultDecimals;
	  }

	  if (!hasOwnProperty$h(options, 'forceCommaDisplay')) {
	    if (get_1(env, 'data.config')) {
	      options.forceCommaDisplay = get_1(env, 'data.config.force_comma_display');
	    }

	    if (get_1(env, 'options.forceCommaDisplay')) {
	      options.forceCommaDisplay = get_1(env, 'options.forceCommaDisplay');
	    }
	  }

	  if (!options.voidDecimals && hasOwnProperty$h(field, 'defaultDecimals') && (!precision || field.defaultDecimals >= precision)) {
	    // this is so field.defaultDecimals overrides options.defaultDecimals
	    precision = field.defaultDecimals;
	  }

	  if (get_1(env, 'data.chartOptions.decimalPlaces') != null && !options.ignoreChartOptions) {
	    precision = get_1(env, 'data.chartOptions.decimalPlaces');
	  } // defaultDecimals is lower precedence than options.decimalPlaces


	  if (options.decimalPlaces != null) {
	    precision = options.decimalPlaces;
	  }

	  if (options.isTooltip && get_1(env, 'data.chartOptions.tooltipDecimals') != null) {
	    precision = get_1(env, 'data.chartOptions.tooltipDecimals');
	  } else if (options.isTooltip) {
	    // special case for small decimal ranges
	    var d = axis.scale.domain();

	    if (Math.abs(d[1] - d[0]) < 0.05) {
	      precision = 3;
	    } else if (Math.abs(d[1] - d[0]) < 0.1) {
	      precision = 2;
	    }
	  } // on tooltip drop post if too long {


	  if (options.isTooltip) {
	    if (post.length > 4) post = '';
	    if (pre.length > 4) pre = '';
	  } // allow for a custom formatter


	  if (options.isTooltip && (options.customTooltipFormatter != null || env.options.customTooltipFormatter != null)) {
	    customFormatter = options.customTooltipFormatter || env.options.customTooltipFormatter;

	    if (typeof customFormatter === 'string') {
	      customFormatter = dateFormatter(customFormatter, parser);
	    }
	  }

	  if (options.lowerCaseUnits == null) {
	    options.lowerCaseUnits = get_1(env, 'data.config.lower_case_units');
	  }

	  if (tx && tx.isContinuous) {
	    if (tx.isDate) {
	      if (options.isTooltip && get_1(env, 'data.config.tooltipDateFormat')) {
	        var chosenFormatter = get_1(env, 'data.config.tooltipDateFormat');

	        formatter = dateFormatter(chosenFormatter, parser);
	      } else if (tx.duration && DURATION_FORMATTERS[tx.duration]) {
	        var durationFormatter = DURATION_FORMATTERS[tx.duration];

	        if (get_1(env, 'data.config.hide_year_display') && DURATION_FORMATTERS_WITH_YEAR.indexOf(tx.duration) !== -1) {
	          durationFormatter = DURATION_FORMATTER_MD;
	        }

	        formatter = dateFormatter(durationFormatter, parser);
	        pre = ''; // delete extra label -- was causing a bug

	        post = '';
	        prepostLength = 0;

	        if (tx.isYears) {
	          formatter = dateFormatter(DURATION_FORMATTER_YEAR, parser);
	        }
	      }

	      if (field.type === 'year') formatter = noFormat;
	    } else {
	      if (appliedDomainRange(field, axis) < 1) {
	        if (field.display_as) {
	          if (precision == null) precision = 1;
	          formatter = prettyNumber(precision, options);
	        } else {
	          formatter = smallNumber(precision, options);
	        }
	      } else if (appliedDomainRange(field, axis) < 10) {
	        if (options.forAxis || field.display_as) {
	          if (precision == null) precision = 0;
	          formatter = prettyNumber(precision, options);
	        } else {
	          formatter = smallNumber(precision, options);
	        }
	      } else {
	        if (appliedDomainRange(field, axis) < 1000 && !options.preventCommaDisplay) {
	          options.forceCommaDisplay = true;
	        }

	        formatter = prettyNumber(precision, options);
	      }
	    }
	  }

	  formatter = customFormatter || formatter || noFormat;

	  var preventNumericFormatting = get_1(env, 'data.config.preventNumericFormatting') || get_1(env, 'options.preventNumericFormatting');

	  if (preventNumericFormatting) {
	    formatter = noFormat;
	  } // wrap formatter in a function that multiplies value by 100


	  if (field.display_as === '%') {
	    formatter = percentageShift(formatter);
	  } else if (field.display_as) {
	    if (post.toUpperCase() === field.display_as) post = '';

	    if (!options.ignoreDisplayAsMultiplier) {
	      options.displayAsMultiplier = displayAsMultiplier$1(field);
	      formatter = valueMultiplier(formatter, options.displayAsMultiplier);
	    }
	  }

	  var formatPrePost = function formatPrePost(fVal, pre, post) {
	    if (options.spanWrapPrePost) {
	      return "<span class=\"pre\">".concat(pre, "</span>").concat(fVal, "<span class=\"post\">").concat(post, "</span>");
	    }

	    if (options.preventLongPrePost) {
	      return "".concat(pre.length > 3 ? '' : pre).concat(fVal).concat(post.length > 3 ? '' : post);
	    }

	    return "".concat(pre).concat(fVal).concat(post);
	  }; // the final return value


	  var finalFormatter = function finalFormatter(val) {
	    if (val == null) return ''; // allow bare value strings inside a numeric field

	    if (options.displayStringsInNumericFields) {
	      if (field.type === 'numeric' && isNaN(Number(val))) {
	        return val;
	      }
	    }

	    var fVal = formatter(val);

	    if (options.bareValueSingleChar && prepostLength === 1) {
	      return formatPrePost(fVal, pre, post);
	    }

	    if (options.bareValue && options.preventUnitDisplay) {
	      return String(fVal).replace(/[^\d.-]/g, '');
	    }

	    if (options.bareValue || fVal === '') {
	      return fVal;
	    }

	    return formatPrePost(fVal, pre, post);
	  }; // expose the precision used so we can make calculations


	  finalFormatter.precision = precision;
	  finalFormatter.decimals = precision;
	  return finalFormatter;
	} // one of the major problems that arises is tick values looking off
	// because of different unit displays: for example with one dataset
	// we get:  2T 2T 1T 1T 600B 200B  as axis values
	// we want to format all values to Trillion (so 0.6T instead of 600B)
	// as well as provide a default decimal place with repeating vals
	//
	// special case for thousands: keep 1,000 when values below 1000

	function prepareTickFormatOptions(ticks, options, axis, env) {
	  var opts = _objectSpread2({
	    defaultDecimals: 0,
	    forAxis: true
	  }, options); // var valMultiplier = displayAsMultiplier(axis.field())


	  ticks = ticks.filter(function (v) {
	    return v !== 0;
	  });
	  var reduced = reduceNumericValuesForDisplay(ticks, options);

	  if (reduced) {
	    var multipliers = ticks.map(function (v) {
	      return v / reduced.divisor;
	    });
	    var multipliersReduced = reduceNumericValues(multipliers); // if any multipliers are over 1000 that means there is a split

	    if (reduced.divisor === 1000 || multipliers.filter(function (v) {
	      return Math.abs(v) >= 1000;
	    }).length) {
	      // special case for 1000s force 1,000 etc.
	      // only when multiple 100s and less than 10k
	      if (reduced.divisor === 1000 && Math.abs(multipliers[1]) < 1) {
	        opts.forceCommaDisplay = true;
	      } else {
	        opts.preventCommaDisplay = true;
	      }
	    } // this prevents 1M and 500k in the same axis


	    var multiplier = 1;

	    if (multipliers.filter(function (v) {
	      return Math.abs(v) >= 1000;
	    }).length) {
	      multiplier = 1000;

	      if (multipliersReduced && multipliersReduced.divisor === 1e1) {
	        opts.defaultDecimals = 2;
	      } else if (multipliersReduced && multipliersReduced.divisor === 1e2) {
	        opts.defaultDecimals = 1;
	      }
	    } else if (multipliers.filter(function (v) {
	      return Math.abs(v) >= 100;
	    }).length) {
	      multiplier = 100;

	      if (multipliersReduced && multipliersReduced.divisor === 1e1) {
	        opts.defaultDecimals = 1;
	      }
	    } else if (multipliers.filter(function (v) {
	      return Math.abs(v) >= 10;
	    }).length) {
	      multiplier = 10;
	    } // ignore 100s and 10s for forceUnitDisplay


	    if (reduced.divisor * multiplier >= 1000) {
	      opts.forceUnitDisplay = UNIT_LONG[reduced.divisor * multiplier];
	    } // pass this info back down


	    opts.reduced = reduced;
	    opts.multipliers = multipliers;
	    opts.multipliersReduced = multipliersReduced; // now do one more check if there are
	  } else {
	    // special case for small decimal ranges
	    var d = axis.scale.domain();

	    if (Math.abs(d[1] - d[0]) < 0.05) {
	      opts.defaultDecimals = 3;
	    } else if (Math.abs(d[1] - d[0]) < 0.1) {
	      opts.defaultDecimals = 2;
	    }
	  } // now that we've defined the options pass them through the
	  // formatter and decide if we need to bump up decimals


	  var foundDecimals = false;
	  var count = 0;

	  var _loop = function _loop() {
	    var formatter = valueFormatter(axis, env, _objectSpread2(_objectSpread2({}, opts), {}, {
	      ignoreDisplayAsMultiplier: true // used for calc only

	    }));
	    var vals = ticks.map(function (v) {
	      return formatter(v);
	    });

	    if (!hasDuplicates(vals)) {
	      foundDecimals = true;
	    } else {
	      opts.defaultDecimals = opts.defaultDecimals || 0;
	      opts.defaultDecimals += 1;
	    }

	    count += 1;
	  };

	  while (!foundDecimals && count < 3) {
	    _loop();
	  }

	  return opts;
	} // provide a wrapper for a common use case where only the first
	// value in a series should have the full unit labeling

	function singleUseFormatter(formatter, altFormatter) {
	  var hasPrintedValue = false;
	  return function (val) {
	    if (hasPrintedValue) return altFormatter(val);
	    val = formatter(val);
	    if (val) hasPrintedValue = true;
	    return val;
	  };
	} // given [100000 200000] return {divisor: 1000, label: "k"}

	function reduceNumericValues(values) {
	  // first strip out any 0 values
	  values = values.filter(function (v) {
	    return v !== 0;
	  });

	  if (values.filter(function (v) {
	    return v % 1e12 === 0;
	  }).length === values.length) {
	    return {
	      divisor: 1e12,
	      short: UNIT_SHORT[1e12],
	      long: UNIT_LONG[1e12]
	    };
	  } else if (values.filter(function (v) {
	    return v % 1e9 === 0;
	  }).length === values.length) {
	    return {
	      divisor: 1e9,
	      short: UNIT_SHORT[1e9],
	      long: UNIT_LONG[1e9]
	    };
	  } else if (values.filter(function (v) {
	    return v % 1e6 === 0;
	  }).length === values.length) {
	    return {
	      divisor: 1e6,
	      short: UNIT_SHORT[1e6],
	      long: UNIT_LONG[1e6]
	    };
	  } else if (values.filter(function (v) {
	    return v % 1e3 === 0;
	  }).length === values.length) {
	    return {
	      divisor: 1e3,
	      short: UNIT_SHORT[1e3],
	      long: UNIT_LONG[1e3]
	    };
	  } else if (values.filter(function (v) {
	    return v % 1e2 === 0;
	  }).length === values.length) {
	    return {
	      divisor: 1e2,
	      short: UNIT_SHORT[1e2],
	      long: UNIT_LONG[1e2]
	    };
	  } else if (values.filter(function (v) {
	    return v % 1e1 === 0;
	  }).length === values.length) {
	    return {
	      divisor: 1e1,
	      short: UNIT_SHORT[1e1],
	      long: UNIT_LONG[1e1]
	    };
	  }

	  return null;
	} // reduceNumericValues() requires number to be exact multiples of units
	// this function is looser, e.g., given [123456 200000] return {divisor: 1000, label: "k"}

	function reduceNumericValuesLooseFit(values) {
	  // first strip out any 0 values
	  values = values.filter(function (v) {
	    return v !== 0;
	  });
	  var bestUnit; // start from the high end and try and choose the best fitting unit

	  Object.keys(UNIT_SHORT).map(function (d) {
	    return +d;
	  }).reverse().forEach(function (unit) {
	    var matches = values.filter(function (v) {
	      var vmod = v % unit;
	      return vmod > 0 && vmod < v;
	    });

	    if ((bestUnit == null || bestUnit < unit) && matches.length) {
	      bestUnit = unit;
	    }
	  }); // this is really only for large numbers

	  if (bestUnit && bestUnit >= 1e3) {
	    return {
	      divisor: bestUnit,
	      short: UNIT_SHORT[bestUnit],
	      long: UNIT_LONG[bestUnit]
	    };
	  }
	} // call reduceNumericValues, but exclude 10s and convert 100s
	// to display as 1000s. they are valid divisors but not good for display

	function reduceNumericValuesForDisplay(values) {
	  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	  var reduced = reduceNumericValues(values);

	  if (reduced == null && options.reductionLooseFit) {
	    reduced = reduceNumericValuesLooseFit(values);
	  }

	  if (reduced && reduced.divisor === 1e2 && !options.reductionLooseFit) {
	    return {
	      divisor: 1e3,
	      short: UNIT_SHORT[1e3],
	      long: UNIT_LONG[1e3]
	    };
	  } else if (reduced && reduced.divisor === 1e1) {
	    return null;
	  }

	  return reduced;
	} // simply return a string with line breaks as <br>

	var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('splice');
	var USES_TO_LENGTH$2 = arrayMethodUsesToLength('splice', { ACCESSORS: true, 0: 0, 1: 2 });

	var max = Math.max;
	var min = Math.min;
	var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF;
	var MAXIMUM_ALLOWED_LENGTH_EXCEEDED = 'Maximum allowed length exceeded';

	// `Array.prototype.splice` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.splice
	// with adding support of @@species
	_export({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT || !USES_TO_LENGTH$2 }, {
	  splice: function splice(start, deleteCount /* , ...items */) {
	    var O = toObject(this);
	    var len = toLength(O.length);
	    var actualStart = toAbsoluteIndex(start, len);
	    var argumentsLength = arguments.length;
	    var insertCount, actualDeleteCount, A, k, from, to;
	    if (argumentsLength === 0) {
	      insertCount = actualDeleteCount = 0;
	    } else if (argumentsLength === 1) {
	      insertCount = 0;
	      actualDeleteCount = len - actualStart;
	    } else {
	      insertCount = argumentsLength - 2;
	      actualDeleteCount = min(max(toInteger$1(deleteCount), 0), len - actualStart);
	    }
	    if (len + insertCount - actualDeleteCount > MAX_SAFE_INTEGER) {
	      throw TypeError(MAXIMUM_ALLOWED_LENGTH_EXCEEDED);
	    }
	    A = arraySpeciesCreate(O, actualDeleteCount);
	    for (k = 0; k < actualDeleteCount; k++) {
	      from = actualStart + k;
	      if (from in O) createProperty(A, k, O[from]);
	    }
	    A.length = actualDeleteCount;
	    if (insertCount < actualDeleteCount) {
	      for (k = actualStart; k < len - actualDeleteCount; k++) {
	        from = k + actualDeleteCount;
	        to = k + insertCount;
	        if (from in O) O[to] = O[from];
	        else delete O[to];
	      }
	      for (k = len; k > len - actualDeleteCount + insertCount; k--) delete O[k - 1];
	    } else if (insertCount > actualDeleteCount) {
	      for (k = len - actualDeleteCount; k > actualStart; k--) {
	        from = k + actualDeleteCount - 1;
	        to = k + insertCount - 1;
	        if (from in O) O[to] = O[from];
	        else delete O[to];
	      }
	    }
	    for (k = 0; k < insertCount; k++) {
	      O[k + actualStart] = arguments[k + 2];
	    }
	    O.length = len - actualDeleteCount + insertCount;
	    return A;
	  }
	});

	// the prior flatten function generates compile issues
	function flattenArrays(arrays) {
	  return [].concat.apply([], arrays);
	}

	function extent(values, valueof) {
	  var min;
	  var max;
	  if (!values) return [0, 1];

	  if (valueof === undefined) {
	    var _iterator = _createForOfIteratorHelper(values),
	        _step;

	    try {
	      for (_iterator.s(); !(_step = _iterator.n()).done;) {
	        var value = _step.value;

	        if (value != null) {
	          if (min === undefined) {
	            // eslint-disable-next-line
	            if (value >= value) min = max = value;
	          } else {
	            if (min > value) min = value;
	            if (max < value) max = value;
	          }
	        }
	      }
	    } catch (err) {
	      _iterator.e(err);
	    } finally {
	      _iterator.f();
	    }
	  } else {
	    var index = -1;

	    var _iterator2 = _createForOfIteratorHelper(values),
	        _step2;

	    try {
	      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
	        var _value = _step2.value;

	        if ((_value = valueof(_value, ++index, values)) != null) {
	          if (min === undefined) {
	            // eslint-disable-next-line
	            if (_value >= _value) min = max = _value;
	          } else {
	            if (min > _value) min = _value;
	            if (max < _value) max = _value;
	          }
	        }
	      }
	    } catch (err) {
	      _iterator2.e(err);
	    } finally {
	      _iterator2.f();
	    }
	  }

	  return [min, max];
	} // get series from chartData
	// TODO:: allow chartData to specify series breakdown other than default


	function getSeries(chartData) {
	  return chartData.fields.length > 1 ? chartData.fields.slice(1) : chartData.fields;
	} // get field from chartData
	// currently only grabs x or y axis

	function getField(chartData) {
	  var isPrimaryAxis = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

	  if (isPrimaryAxis) {
	    return chartData.fields[0];
	  } else {
	    return chartData.fields[1];
	  }
	}
	function isForceCategorical(field) {
	  if (field.taxonomy && field.taxonomy.forceCategorical) return true;
	  return false;
	} // no longer reading chartOptions.isCategorical

	function makeForceCategorical(field, chartData) {
	  var _chartData$chartOptio;

	  if ((chartData === null || chartData === void 0 ? void 0 : (_chartData$chartOptio = chartData.chartOptions) === null || _chartData$chartOptio === void 0 ? void 0 : _chartData$chartOptio.dateOutputFormat) === OUTPUT_FORMAT_CATEGORICAL) {
	    return true;
	  }

	  return false;
	} // applied domain includes the field "display numerical value as"
	// multiplied by the domain

	function appliedDomain(field, axis) {
	  var domain = [field.min, field.max];
	  if (axis && axis.scale) domain = axis.scale.domain();
	  return domain.map(function (v) {
	    return v * displayAsMultiplier$1(field);
	  });
	}
	function appliedDomainRange(field, axis) {
	  var domain = appliedDomain(field, axis);
	  return Math.abs(domain[1] - domain[0]);
	}
	function seriesDomain(series, domainFromZero) {
	  if (!series) return [0, 1];
	  var domain = extent(flattenArrays(series.map(function (d) {
	    // used cached min/max if available to speed things up
	    if (typeof d.min !== 'undefined' && typeof d.max !== 'undefined') {
	      return [d.min, d.max];
	    } else {
	      var tmpExtent = extent(d.data);

	      try {
	        d.min = tmpExtent[0];
	        d.max = tmpExtent[1];
	      } catch (err) {
	        console.log('Immutable Object cannot apply series Domain');
	      }

	      return tmpExtent;
	    }
	  }))); // needed for bar charts

	  if (domainFromZero) {
	    domain[0] = Math.min(0, domain[0]);
	    domain[1] = Math.max(0, domain[1]);
	  } // cast strings to numbers


	  domain[0] = Number(domain[0]);
	  domain[1] = Number(domain[1]);
	  return domain;
	}
	function stackedDomainFromFields(fields) {
	  var minMax = [0, 0];
	  if (!(fields[0] && fields[0].data)) return minMax;
	  var flatData = fields[0].data.map(function (r, rowIndex) {
	    return fields.map(function (field) {
	      return field.data[rowIndex];
	    });
	  });
	  flatData.forEach(function (d, i) {
	    var numbers = d.map(function (v) {
	      return Number(v);
	    });
	    var positiveSum = numbers.filter(function (v) {
	      return v >= 0;
	    }).reduce(function (a, b) {
	      return a + b;
	    }, 0);
	    var negativeSum = numbers.filter(function (v) {
	      return v < 0;
	    }).reduce(function (a, b) {
	      return a + b;
	    }, 0);
	    minMax[0] = Math.min(negativeSum, minMax[0]);
	    minMax[1] = Math.max(positiveSum, minMax[1]);
	  });
	  return minMax;
	}
	function stackedDomain(chartData) {
	  var minMax = [0, 0];
	  chartData.data.forEach(function (d, i) {
	    var numbers = d.slice(1).map(function (v) {
	      return Number(v);
	    });
	    var positiveSum = numbers.filter(function (v) {
	      return v >= 0;
	    }).reduce(function (a, b) {
	      return a + b;
	    }, 0);
	    var negativeSum = numbers.filter(function (v) {
	      return v < 0;
	    }).reduce(function (a, b) {
	      return a + b;
	    }, 0);
	    minMax[0] = Math.min(negativeSum, minMax[0]);
	    minMax[1] = Math.max(positiveSum, minMax[1]);
	  });
	  return minMax;
	} // provide a method for sorting values on a field while keeping
	// a map of original indices to newly sorted values

	function sortAllFields(chartData, options) {
	  var defaults = {
	    direction: 'descending',
	    sortPrimaryAxisTime: false,
	    stacked: false
	  };
	  options = _extends(defaults, options); // default sort is on the primary field

	  var sort = function sort(a, b) {
	    return b[1] - a[1];
	  };

	  if (options.direction === 'ascending') {
	    sort = function sort(a, b) {
	      return a[1] - b[1];
	    };
	  } // if stacked sort on total value of all fields


	  if (options.stacked) {
	    var add = function add(a, b) {
	      return Math.abs(a) + Math.abs(b);
	    };

	    sort = function sort(a, b) {
	      return b.slice(1).reduce(add, 0) - a.slice(1).reduce(add, 0);
	    };

	    if (options.direction === 'ascending') {
	      sort = function sort(a, b) {
	        return a.slice(1).reduce(add, 0) - b.slice(1).reduce(add, 0);
	      };
	    }
	  }

	  if (options.sortPrimaryAxisTime) {
	    if (options.reverse) {
	      chartData.data.reverse();
	      sort = null;
	    } else {
	      var parse = fieldDateParser(chartData.fields[0]);

	      sort = function sort(a, b) {
	        return parse(a[0]).toDate().getTime() - parse(b[1]).toDate().getTime();
	      };
	    }
	  }

	  if (options.customSort) sort = options.customSort;
	  if (sort) chartData.data.sort(sort);
	  chartData.fields.forEach(function (field, i) {
	    field.data = chartData.data.map(function (d) {
	      return d[i];
	    });
	  });
	} // for dashed line segments return a list of invalid
	// segments for rendering

	function getInvalidSegments(chartData) {
	  var filterFunction = function filterFunction(seg) {
	    return seg.is_valid === false;
	  };

	  return getSegments(chartData, filterFunction);
	}
	function getSegments(chartData, filter) {
	  var series = getSeries(chartData);
	  var seriesSegments = [];
	  series.forEach(function (field, i) {
	    var length = field.data.length;
	    var segments = [];
	    var segment = [];
	    var segValid = true;
	    var segIndex = 0;

	    while (segIndex < length) {
	      var dataValid = field.data[segIndex] != null;

	      if (dataValid && segValid) {
	        segment.push({
	          value: field.data[segIndex],
	          index: segIndex
	        });
	      } else if (!dataValid && segValid) {
	        // If the first segment is invalid, it will not be drawn
	        if (segment.length > 0) {
	          segments.push({
	            data: segment,
	            is_valid: segValid
	          });
	          segment = [segment[segment.length - 1]];
	          segValid = false;
	        }
	      } else if (dataValid && !segValid) {
	        segment.push({
	          value: field.data[segIndex],
	          index: segIndex
	        });
	        segments.push({
	          data: segment,
	          is_valid: segValid
	        });
	        segment = [{
	          value: field.data[segIndex],
	          index: segIndex
	        }];
	        segValid = true;
	      }

	      segIndex++;
	    } // If the last segment is invalid, it will not be drawn


	    if (segment.length >= 1 && segValid) {
	      segments.push({
	        data: segment,
	        is_valid: segValid
	      });
	    }

	    if (filter) {
	      segments = segments.filter(filter);
	    }

	    seriesSegments.push(segments);
	  });
	  var l = seriesSegments.reduce(function (sum, arr) {
	    return sum + arr.length;
	  }, 0);
	  if (l === 0) seriesSegments = null;
	  return seriesSegments;
	} // this function is called for tooltips that are in the dashed
	// zone between values. basically find the nearest neighbors and
	// interpolate between them

	function interpolateBetweenValues(env, dataIndex, seriesIndex) {
	  var series = getSeries(env.data);

	  if (series[seriesIndex] && series[seriesIndex].data) {
	    // seek forward for the nextValue
	    var values = series[seriesIndex].data;

	    var _getFirstValue = getFirstValue(values, dataIndex, true),
	        _getFirstValue2 = _slicedToArray(_getFirstValue, 2),
	        nextIndex = _getFirstValue2[0],
	        nextVal = _getFirstValue2[1];

	    var _getLastValue = getLastValue(values, dataIndex, true),
	        _getLastValue2 = _slicedToArray(_getLastValue, 2),
	        prevIndex = _getLastValue2[0],
	        prevVal = _getLastValue2[1];

	    if (valueOrNull(nextVal) == null) return null;
	    if (valueOrNull(prevVal) == null) return null; // if (nextVal && prevVal == null) return nextVal
	    // if (prevVal && nextVal == null) return prevVal

	    var interpAmount = (dataIndex - prevIndex) / (nextIndex - prevIndex);
	    return prevVal + (nextVal - prevVal) * interpAmount;
	  }

	  return null;
	} // need a way to read the index of a value in a field
	// while casting to type "string" / "number" / "date"
	// get rid of newline and âµ characters

	function fieldIndexOf(field, value) {
	  var parser = fieldDateParser(field);
	  var firstValue = getFirstValue(field.data);

	  var firstValueType = _typeof(firstValue);

	  var index = -1;

	  if (firstValueType === 'string') {
	    index = field.data.indexOf(String(value));
	  } else if (firstValueType === 'number') {
	    index = field.data.indexOf(Number(value));
	  } else if (firstValueType === 'object' && firstValue.getDate) {
	    index = field.data.indexOf(parser(value));
	  } else {
	    index = field.data.indexOf(value);
	  }

	  if (index === -1) {
	    // if we haven't found the date, it might be alredy cast to Date()
	    if (field.taxonomy.isDate) {
	      var compareDate = parser(value);
	      field.data.forEach(function (d, i) {
	        if (parser(d).diff(compareDate) === 0) {
	          index = i;
	        }
	      });
	    } else {
	      // if field is categorical try and do string compare
	      // to get rid of whitespace
	      var compareVal = value.replace(/\s|âµ|\n/g, '');
	      field.data.forEach(function (d, i) {
	        if (String(d).replace(/\s|âµ|\n/g, '') === compareVal) {
	          index = i;
	        }
	      });
	    }
	  }

	  return index;
	} // returns a function that reads the chartOptions hightlightValue
	// field to hightlight bars, values etc.

	function valueHighlighter(chartData, options) {
	  options = options || {};
	  var highlight = [];

	  if (chartData.config && chartData.config.highlight_values) {
	    highlight = String(chartData.config.highlight_values).split(',').map(function (v) {
	      return Number(v) - 1;
	    });
	  }

	  if (!highlight.length && options.zeroHighlight) {
	    highlight = [0];
	  }

	  return function (d, i) {
	    return highlight.indexOf(i) !== -1;
	  };
	} // returns whether any values are highlighted

	function highlightSupported(chartData) {
	  return chartData.config && chartData.config.highlight_values;
	}
	function hasCustomDomain(chartData, field) {
	  if (field && field.numericProperties) {
	    var _field$numericPropert = field.numericProperties,
	        scaleStart = _field$numericPropert.scaleStart,
	        scaleEnd = _field$numericPropert.scaleEnd,
	        scaleStep = _field$numericPropert.scaleStep;
	    return scaleStart != null || scaleEnd != null || scaleStep != null;
	  }

	  if (chartData.chartOptions && (chartData.chartOptions.scaleStart != null || chartData.chartOptions.scaleEnd != null || chartData.chartOptions.scaleStep != null)) {
	    return true;
	  }

	  return false;
	}
	function hasCustomDomainStep(chartData, field, isPrimaryAxis) {
	  if (field && field.numericProperties) {
	    var scaleStep = field.numericProperties.scaleStep;
	    return scaleStep != null;
	  }

	  if (chartData.chartOptions && chartData.chartOptions.scaleStep != null) {
	    return true;
	  }

	  return false;
	} // ensure [min, max] value

	function sortedDomain(domain) {
	  if (domain[0] <= domain[1]) return domain;
	  return [domain[1], domain[0]];
	}

	moment_min.suppressDeprecationWarnings = true;

	function isQuarter(val) {
	  return getQuarterRegex(val) !== null;
	}

	function testQuarter(field) {
	  return !isForceCategorical(field) && isQuarter(getFirstValue(field.data)) && isQuarter(getLastValue(field.data));
	}

	function testDate(field) {
	  return !isForceCategorical(field) && !isFieldStringYear(field) && !isFieldStringMonth(field) && isDate(getFirstValue(field.data)) && isDate(getLastValue(field.data));
	} // convert D/M/YY to M/D/YY and vice versa
	// Function to read chartData and try to determine the
	// field types, possible chart types, etc.
	//
	// save a taxonomy config object back to chartData so we
	// can allow an editor to specify fields directly.

	function buildTaxonomy(chartData) {
	  var forceRebuildOpt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
	  var forceRebuild = forceRebuildOpt || options.forceRebuild;
	  if (chartData.taxonomy && !forceRebuild) return;
	  chartData.config = chartData.config || {};
	  chartData.chartOptions = chartData.chartOptions || {};
	  var tzOffset = (chartData.config.time_zone || 0) * 60;
	  var yearsAsContinuous = options.yearsAsContinuous,
	      _options$dateAnyColum = options.dateAnyColumn,
	      dateAnyColumn = _options$dateAnyColum === void 0 ? false : _options$dateAnyColum;
	  var taxonomy = {
	    version: '0.1' // taxonomy schema

	  }; // because the IDs differ between the axes and the fields, we need to stash them...

	  var ids = chartData.fields.map(function (field) {
	    return field.id;
	  });

	  if (!options.preventAxisPropertyOverrides) {
	    if (chartData.primaryAxis && chartData.fields[0]) {
	      _extends(chartData.fields[0], chartData.primaryAxis);
	    }

	    if (chartData.secondaryAxis && chartData.fields[1]) {
	      _extends(chartData.fields[1], chartData.secondaryAxis);
	    }
	  } // .. and restore the field ids later


	  chartData.fields.forEach(function (field, i) {
	    field.id = ids[i];
	  });
	  chartData.fields.forEach(function (field, i) {
	    var fieldTaxonomy = {
	      isContinuous: true
	    };
	    field.taxonomy = forceRebuild ? fieldTaxonomy : field.taxonomy || fieldTaxonomy; // normalize Table displayFormat to use older display_as

	    if (field.displayFormat && !field.display_as) {
	      field.display_as = field.displayFormat;
	    }

	    if (i === 0) {
	      fieldTaxonomy.primaryField = true;
	    } // handle the case of year values being exported as numbers from
	    // excel by converting to strings locally


	    if (i === 0 && field.type === FIELD_TYPE_NUMERIC && isFieldNumericYear(field)) {
	      field.type = FIELD_TYPE_STRING;
	      fieldTaxonomy.isYears = true;
	      castNumericToString(field, chartData);
	    } // i === 0 because we only want this test on Categorical axis


	    if ((i === 0 || dateAnyColumn) && field.type === FIELD_TYPE_STRING) {
	      var _chartData$chartOptio;

	      // if a date format is specified, we convert to time stamps
	      if (chartData.chartOptions.dateInputFormat) {
	        field.taxonomy.customFormatter = chartData.chartOptions.dateInputFormat;
	      }

	      fieldTaxonomy.isLikelyCategorical = chartData === null || chartData === void 0 ? void 0 : (_chartData$chartOptio = chartData.chartOptions) === null || _chartData$chartOptio === void 0 ? void 0 : _chartData$chartOptio.isCategorical;
	      fieldTaxonomy.forceCategorical = makeForceCategorical(field, chartData);

	      if (testDate(field) && !testQuarter(field)) {
	        fieldTaxonomy.isDate = true;
	        fieldTaxonomy.customFormatter = getCustomDateFormat(getFirstValue(field.data));
	        fieldTaxonomy.isContinuous = true;
	        fieldTaxonomy.duration = dateRange(field);
	        fieldTaxonomy.timeZoneOffset = tzOffset;
	      } else if (testQuarter(field)) {
	        // no longer applying any methods to taxonomy
	        // fieldTaxonomy.valueParser = buildValueParser(getFirstValue(field.data))
	        // fieldTaxonomy.dateParser = quarterlyDateParser(fieldTaxonomy.valueParser)
	        fieldTaxonomy.isQuarters = true;
	        fieldTaxonomy.isDate = true;
	        fieldTaxonomy.isContinuous = false;
	        fieldTaxonomy.duration = quarterDateRange(field);
	        fieldTaxonomy.timeZoneOffset = tzOffset;
	      } else {
	        fieldTaxonomy.isContinuous = false;

	        if (isFieldStringYear(field)) {
	          // allow lines / bars to treat years as discrete/continuous
	          fieldTaxonomy.isContinuous = yearsAsContinuous || false;
	          fieldTaxonomy.isDate = fieldTaxonomy.isYears = true;
	          fieldTaxonomy.customFormatter = 'YYYY';
	          fieldTaxonomy.duration = dateRange(field);
	          fieldTaxonomy.timeZoneOffset = tzOffset;
	        } else if (isFieldStringMonth(field)) {
	          fieldTaxonomy.isContinuous = true;
	          fieldTaxonomy.isDate = fieldTaxonomy.isMonths = true;
	          fieldTaxonomy.noYears = true; // months have no Year val attaached

	          fieldTaxonomy.customFormatter = getCustomDateFormat(getFirstValue(field.data), DATE_INPUT_MONTH);
	          fieldTaxonomy.duration = dateRange(field);
	          fieldTaxonomy.timeZoneOffset = tzOffset;
	        }
	      }
	    } // attempt to read a default decimal place from the data


	    if (field.type === FIELD_TYPE_NUMERIC) {
	      field.defaultDecimals = readDecimalsFromData(field);
	    }

	    if (field.type === FIELD_TYPE_JUMBLE) {
	      fieldTaxonomy.isContinuous = false;
	    }
	  }); // if primary axis is date and reversed, sort it

	  var dateSortingDisabled = options.disableDateSorting || chartData.config.disable_date_sorting;

	  if (!dateSortingDisabled && chartData.fields[0] && chartData.fields[0].taxonomy && chartData.fields[0].taxonomy.dateStart && chartData.fields[0].taxonomy.dateEnd) {
	    if (chartData.fields[0].taxonomy.dateEnd < chartData.fields[0].taxonomy.dateStart) {
	      sortAllFields(chartData, {
	        sortPrimaryAxisTime: true,
	        reverse: true
	      });
	      var swap = chartData.fields[0].taxonomy.dateEnd;
	      chartData.fields[0].taxonomy.dateEnd = chartData.fields[0].taxonomy.dateStart;
	      chartData.fields[0].taxonomy.dateStart = swap;
	    }
	  }

	  chartData.taxonomy = taxonomy;
	}


	function isFieldNumericYear(field) {
	  return field.min > NUMERIC_YEAR_MIN && field.max < NUMERIC_YEAR_MAX;
	} // can we convert first and last values to numbers and do they
	// fall within the year bounds

	function isValidYear(str) {
	  return str.length === 4 && !isNaN(Number(str)) && Number(str) > NUMERIC_YEAR_MIN && Number(str) < NUMERIC_YEAR_MAX;
	}
	function isFieldStringYear(field) {
	  return isValidYear(getFirstValue(field.data)) && isValidYear(getLastValue(field.data));
	} // check if the values are "months" like "Jan" "January" etc.

	function isFieldStringMonth(field) {
	  var testString = function testString(str) {
	    return getCustomDateFormat(str, DATE_INPUT_MONTH) !== null;
	  };

	  return testString(getFirstValue(field.data)) && testString(getLastValue(field.data));
	}
	function castNumericToString(field, chartData) {
	  field.data = field.data.map(function (n) {
	    if (n == null) return null;
	    return String(n);
	  });
	  chartData.data.forEach(function (d, i) {
	    d[0] = field.data[i];
	  });
	} // changing this to use the minimum decimal display

	function readDecimalsFromData(field) {
	  var data = field.data;
	  var decimalPlaces = null;

	  var places = function places(num) {
	    if (!num || !num.split) num = String(num);
	    return (num.split('.')[1] || []).length;
	  };

	  for (var i = 0; i < data.length; i++) {
	    if (data[i] === null) continue;
	    var currentPlaces = Math.min(places(data[i]), 3); // max 3

	    if (decimalPlaces === null) {
	      decimalPlaces = currentPlaces;
	    } else {
	      if (decimalPlaces !== currentPlaces) {
	        if (currentPlaces < decimalPlaces && currentPlaces !== 0) {
	          decimalPlaces = currentPlaces;
	        }
	      }
	    }
	  }

	  if (appliedDomainRange(field) > 5) {
	    decimalPlaces = Math.min(decimalPlaces, 2);
	  }

	  if (appliedDomainRange(field) > 10) {
	    decimalPlaces = Math.min(decimalPlaces, 1);
	  }

	  return decimalPlaces;
	} // some common validator functions

	function isMultipleValues(chartData) {
	  return chartData.data.length > 1;
	}
	function isSingleSeries(chartData) {
	  return chartData.fields.length === 2;
	}
	function isDoubleSeries(chartData) {
	  return chartData.fields.length === 3;
	}
	function isQuadSeries(chartData) {
	  return chartData.fields.length <= 5;
	}
	function isTimeSeries(chartData) {
	  return chartData.fields[0] && chartData.fields[0].taxonomy && chartData.fields[0].taxonomy.isDate;
	}
	function isContinuousTimeSeries(chartData) {
	  return chartData.fields[0] && chartData.fields[0].taxonomy && chartData.fields[0].taxonomy.isContinuous && chartData.fields[0].taxonomy.isDate;
	}
	function isPositiveDomain(chartData) {
	  var domain = seriesDomain(getSeries(chartData));
	  return domain[0] >= 0 && domain[1] >= 0;
	} // only true if domain min and max are negative

	function isNegativeDomain(chartData) {
	  var domain = seriesDomain(getSeries(chartData));
	  return domain[0] < 0 && domain[1] < 0;
	} // only true if domain has positive and negative values

	function isMixedDomain(chartData) {
	  return !isPositiveDomain(chartData) && !isNegativeDomain(chartData);
	}
	// a single series chart - in this case for every column there will be only one
	// non-zero value

	function isSingleSeriesStackedDomain(chartData) {
	  if (chartData.fields.length === 2) return true;
	  var isSingleSeries = true;

	  for (var r = 0; r < chartData.data.length; r++) {
	    if (!isSingleSeries) break;
	    var row = chartData.data[r];
	    var total = 0;
	    var lastVal = 0;

	    for (var i = 1; i < row.length; i++) {
	      if (row[i]) {
	        total += row[i];
	        lastVal = row[i];
	      }
	    }

	    if (total !== lastVal) isSingleSeries = false;
	  }

	  return isSingleSeries;
	} // used to check if the user is providing a spreadsheet

	function isTimeSeriesYearQuarterMonth(chartData) {
	  if (isTimeSeries(chartData)) {
	    var field = chartData.fields[0];
	    if (field.taxonomy.duration === DURATION_QUARTERS) return true;
	    if (field.taxonomy.isYears) return true;

	    if (field.dateFormat === 'YYYY' || field.customFormatter === 'YYYY' || field.type === 'year') {
	      return true;
	    }

	    if (chartData.chartOptions) {
	      if (chartData.chartOptions.dateOutputFormat === OUTPUT_FORMAT_YEARS) {
	        return true;
	      } else if (chartData.chartOptions.dateOutputFormat === OUTPUT_FORMAT_QUARTERS) {
	        return true;
	      } else if (chartData.chartOptions.dateOutputFormat === OUTPUT_FORMAT_MONTHS) {
	        return true;
	      }
	    }

	    return false;
	  }

	  return false;
	} // some validators that are shared between bar and stacked bar
	// used for determining the best axis formatting

	function dateRange(field, fieldIndex) {
	  // we could loop through all values, but for now just use first / last
	  var parser = fieldDateParser(field);
	  var start = parser(String(getFirstValue(field.data))).toDate();
	  var end = parser(String(getLastValue(field.data))).toDate();
	  var numDays = Math.abs(end - start) / MS_IN_DAY;
	  field.taxonomy.dateStart = start;
	  field.taxonomy.dateEnd = end;

	  if (numDays < 2) {
	    return DURATION_HOURS;
	  } else if (numDays >= 2 && numDays < 16) {
	    return DURATION_DAYS;
	  } else if (numDays >= 14 && numDays < 120) {
	    return DURATION_WEEKS;
	  } else if (numDays >= 120 && numDays < 365 * 4) {
	    return DURATION_MONTHS;
	  } else if (numDays >= 365 * 2 && numDays < 365 * 8) {
	    return DURATION_MULTIYEAR;
	  } else if (numDays >= 365 * 5 && numDays < 365 * 15) {
	    return DURATION_DECADE;
	  } else if (numDays >= 365 * 15 && numDays < 365 * 100) {
	    return DURATION_MULTIDECADE;
	  } else {
	    return DURATION_CENTURY;
	  }
	}
	function quarterDateRange(field) {
	  var valueParser = quarterSplitValueParser(field);
	  var start = valueParser(String(getFirstValue(field.data)));
	  var end = valueParser(String(getLastValue(field.data)));
	  var numDays = Math.abs(end - start) / MS_IN_DAY; // if it's more than 5 years just show it as years not quarters

	  if (numDays >= 365 * 5) return DURATION_DECADE;
	  return DURATION_QUARTERS;
	} // get number of years between two dates (as array)
	// first check field for min / max convenience method for a duratoin()

	function getDurationYears(field, dateArray) {
	  if (field.min && field.max) {
	    return Math.abs(field.max - field.min);
	  }

	  return Math.abs(dateArray[1].getUTCFullYear() - dateArray[0].getUTCFullYear());
	}

	function isExcludedDateValue(val) {
	  var exclude = false;
	  Object.keys(REGEX_EXCLUDE).forEach(function (key) {
	    if (exclude) return;
	    exclude = REGEX_EXCLUDE[key].test(val);
	  });
	  return exclude;
	} // try to determine if a value is of type date


	function isDate(val) {
	  if (!isExcludedDateValue(val)) {
	    var _testDate = parseDate(val, null, true);

	    if (_testDate && _testDate.isValid()) {
	      return isValidYear('' + _testDate.year());
	    }

	    if (isQuarter(val)) {
	      return true;
	    }

	    return getCustomDateFormat(val) !== null;
	  }

	  return false;
	} // return true if field type is a date type
	// normally ie "Dec '17"

	function getCustomDateFormat(str, formats) {
	  var formatter = null;
	  formats = formats || DATE_INPUT_PARSERS;
	  formats.forEach(function (f) {
	    var d = moment_min.utc(str, f);

	    if (!formatter && d.isValid() && typeof str === 'string' && str.toUpperCase().trim() === d.format(f).toUpperCase()) {
	      formatter = f;
	    }
	  });
	  return formatter;
	} // this is a check on whether a given type (bar, hbar, dumbbell)

	var $values = objectToArray.values;

	// `Object.values` method
	// https://tc39.github.io/ecma262/#sec-object.values
	_export({ target: 'Object', stat: true }, {
	  values: function values(O) {
	    return $values(O);
	  }
	});

	// This is a brute force way of reading the current
	// transition state from all of the active nodes since
	// d3 doesn't have a way of getting it directly
	function readTransitionTimes(transitions) {
	  return transitions.map(function (t) {
	    var _t = t.node().__transition;

	    if (_t) {
	      var obj = Object.values(_t)[0];
	      var timer = obj.timer;
	      return timer._time;
	    }

	    return null;
	  });
	} // the corrollary to reading the times is taking times
	// from a previous pause and applying them to the current
	// transition so that playback begins where the pause stopped

	function applyTransitionTimes(transitions, duration) {
	  transitions.forEach(function (t, index) {
	    var _t = t.node().__transition;

	    if (_t) {
	      var obj = Object.values(_t)[0];
	      var timer = obj.timer,
	          time = obj.time;
	      obj.time = time - duration;

	      if (timer) {
	        timer.restart(timer._call, null, timer._time - duration);
	      }
	    }
	  });
	}
	function now$4() {
	  return window.performance.now();
	}

	// the animation manager delegates the actual
	// animation to each type but sets up hooks and
	// animation properties
	// Animation lifecycle
	// 1) Stage -- put everything into hidden/empty state
	// 2) Animate
	// 3) Cleanup -- provide hooks for cleanup

	function transition(target, env) {
	  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
	  var defaults = {
	    delay: 300,
	    duration: 2000,
	    easing: 'linear',
	    // if this is set to true we run right away
	    playOnLoad: false,
	    stageOnLoad: false,
	    // handlers for custom transitions
	    // these are defined by each toaster type
	    stageHandler: undefined,
	    playHandler: undefined,
	    interruptHandler: undefined,
	    cleanupHandler: undefined,
	    // each renderer can provide it's own options
	    // for animation: ie staggered
	    type: 'default',
	    // allow a list of pauses at transition
	    // times or scale values
	    pauses: undefined,
	    // allow option to wait until JS is free to avoid jank
	    delayUntilFreeCycles: true,
	    delayUntilFreeCyclesMaxWait: 2000
	  };

	  var opts = _merge(defaults, options);

	  var defaultHandler = function defaultHandler() {
	    return null;
	  };

	  var activePlayback;
	  var pauseState;

	  var stage = function stage() {
	    // stage must be called with a rendered state
	    if (activePlayback) {
	      env.options.forceResize();
	    }

	    var _opts$stageHandler = opts.stageHandler,
	        stageHandler = _opts$stageHandler === void 0 ? defaultHandler : _opts$stageHandler;
	    stageHandler(target, env, opts);
	  };

	  var play = function play() {
	    var _opts$cleanupHandler = opts.cleanupHandler,
	        cleanupHandler = _opts$cleanupHandler === void 0 ? defaultHandler : _opts$cleanupHandler,
	        _opts$playHandler = opts.playHandler,
	        playHandler = _opts$playHandler === void 0 ? defaultHandler : _opts$playHandler; // make sure transition-stage class is no longer on target

	    target.getEl().classed('transition-stage', false);
	    activePlayback = playHandler(target, env, opts); // if pauseState continue where we left off

	    if (pauseState) {
	      activePlayback.startTime -= pauseState.pauseDuration;
	      applyTransitionTimes(activePlayback.transitions, pauseState.pauseDuration);
	      pauseState = null;
	    }

	    if (activePlayback && activePlayback.execution) {
	      activePlayback.execution.then(function () {
	        cleanupHandler(target, env, opts);
	        activePlayback = null;
	      });
	    }

	    return activePlayback;
	  };

	  var pause = function pause() {
	    if (activePlayback && activePlayback.stop) {
	      // read pause state
	      pauseState = {
	        times: readTransitionTimes(activePlayback.transitions),
	        pauseDuration: now$4() - activePlayback.startTime
	      };
	      activePlayback.stop();
	    }
	  };

	  var replay = function replay() {
	    pauseState = null;
	    stage();
	    play();
	  };

	  if (opts.playOnLoad) {
	    stage();
	    play();
	  } else if (opts.stageOnLoad) {
	    stage();
	  }

	  return {
	    stage: stage,
	    play: play,
	    pause: pause,
	    replay: replay
	  };
	} // test to check whether a chart is configured with
	// playOnLoad or stageOnLoad so that the chart render can
	// be hidden until play begins -- to avoid a quick
	// render flash before animation starts

	function stageForTransition() {
	  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	  if (options.transition && (options.transition.playOnLoad || options.transition.stageOnLoad)) {
	    return true;
	  }

	  return false;
	}

	// we've needed a way to expose the ENV (scale, data etc.) back
	// out of the factory as well as provide a way to add custom
	// layers. These are those tools
	// each layer will have [{el, env}]
	// postRender allows for a few hooks:
	// with options you can specify options.layers and provide custom renderers that will
	// be applied to each selection, as well as provide options.onRenderComplete
	// for an external callback

	function makeLayerPrototype(target, selections, options) {
	  target.selections = function () {
	    return selections;
	  }; // 99.9% of toaster-charts get applied to a single selection, so make it easy


	  target.getEnv = function () {
	    if (selections[0] && selections[0].env) return selections[0].env;
	    return null;
	  };

	  target.getEl = function () {
	    if (selections[0] && selections[0].el) return selections[0].el;
	    return null;
	  };

	  target.postRender = function () {
	    if (options.layers) {
	      options.layers.forEach(function (layer, i) {
	        selections.forEach(function (sel, selectIndex) {
	          var env = sel.env,
	              el = sel.el;
	          var renderTarget = env.layout.draw();

	          var opts = _extends({
	            seriesOffset: i,
	            selectIndex: selectIndex
	          }, options);

	          layer(renderTarget, el, env, opts);
	        });
	      });
	    }

	    if (options.onRenderComplete) {
	      options.onRenderComplete(options.customLayerElement || target.getEl(), options.customLayerEnv || target.getEnv(), options);
	    }

	    if (options.transition) {
	      var transitionInterface = transition(target, target.getEnv(), options.transition); // expose transition play/pause/replay

	      _extends(target, transitionInterface);
	    }
	  };

	  return target;
	}

	function noop() { }
	function assign(tar, src) {
	    // @ts-ignore
	    for (const k in src)
	        tar[k] = src[k];
	    return tar;
	}
	function run(fn) {
	    return fn();
	}
	function blank_object() {
	    return Object.create(null);
	}
	function run_all(fns) {
	    fns.forEach(run);
	}
	function is_function(thing) {
	    return typeof thing === 'function';
	}
	function safe_not_equal(a, b) {
	    return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
	}
	function is_empty(obj) {
	    return Object.keys(obj).length === 0;
	}
	function subscribe(store, ...callbacks) {
	    if (store == null) {
	        return noop;
	    }
	    const unsub = store.subscribe(...callbacks);
	    return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
	}
	function component_subscribe(component, store, callback) {
	    component.$$.on_destroy.push(subscribe(store, callback));
	}
	function create_slot(definition, ctx, $$scope, fn) {
	    if (definition) {
	        const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
	        return definition[0](slot_ctx);
	    }
	}
	function get_slot_context(definition, ctx, $$scope, fn) {
	    return definition[1] && fn
	        ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))
	        : $$scope.ctx;
	}
	function get_slot_changes(definition, $$scope, dirty, fn) {
	    if (definition[2] && fn) {
	        const lets = definition[2](fn(dirty));
	        if ($$scope.dirty === undefined) {
	            return lets;
	        }
	        if (typeof lets === 'object') {
	            const merged = [];
	            const len = Math.max($$scope.dirty.length, lets.length);
	            for (let i = 0; i < len; i += 1) {
	                merged[i] = $$scope.dirty[i] | lets[i];
	            }
	            return merged;
	        }
	        return $$scope.dirty | lets;
	    }
	    return $$scope.dirty;
	}
	function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
	    if (slot_changes) {
	        const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
	        slot.p(slot_context, slot_changes);
	    }
	}
	function get_all_dirty_from_scope($$scope) {
	    if ($$scope.ctx.length > 32) {
	        const dirty = [];
	        const length = $$scope.ctx.length / 32;
	        for (let i = 0; i < length; i++) {
	            dirty[i] = -1;
	        }
	        return dirty;
	    }
	    return -1;
	}
	function exclude_internal_props(props) {
	    const result = {};
	    for (const k in props)
	        if (k[0] !== '$')
	            result[k] = props[k];
	    return result;
	}
	function null_to_empty(value) {
	    return value == null ? '' : value;
	}
	function action_destroyer(action_result) {
	    return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;
	}
	function append(target, node) {
	    target.appendChild(node);
	}
	function append_styles(target, style_sheet_id, styles) {
	    const append_styles_to = get_root_for_style(target);
	    if (!append_styles_to.getElementById(style_sheet_id)) {
	        const style = element('style');
	        style.id = style_sheet_id;
	        style.textContent = styles;
	        append_stylesheet(append_styles_to, style);
	    }
	}
	function get_root_for_style(node) {
	    if (!node)
	        return document;
	    const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
	    if (root && root.host) {
	        return root;
	    }
	    return node.ownerDocument;
	}
	function append_stylesheet(node, style) {
	    append(node.head || node, style);
	    return style.sheet;
	}
	function insert(target, node, anchor) {
	    target.insertBefore(node, anchor || null);
	}
	function detach(node) {
	    if (node.parentNode) {
	        node.parentNode.removeChild(node);
	    }
	}
	function destroy_each(iterations, detaching) {
	    for (let i = 0; i < iterations.length; i += 1) {
	        if (iterations[i])
	            iterations[i].d(detaching);
	    }
	}
	function element(name) {
	    return document.createElement(name);
	}
	function svg_element(name) {
	    return document.createElementNS('http://www.w3.org/2000/svg', name);
	}
	function text(data) {
	    return document.createTextNode(data);
	}
	function space() {
	    return text(' ');
	}
	function empty() {
	    return text('');
	}
	function listen(node, event, handler, options) {
	    node.addEventListener(event, handler, options);
	    return () => node.removeEventListener(event, handler, options);
	}
	function attr(node, attribute, value) {
	    if (value == null)
	        node.removeAttribute(attribute);
	    else if (node.getAttribute(attribute) !== value)
	        node.setAttribute(attribute, value);
	}
	function to_number(value) {
	    return value === '' ? null : +value;
	}
	function children(element) {
	    return Array.from(element.childNodes);
	}
	function set_data(text, data) {
	    data = '' + data;
	    if (text.wholeText !== data)
	        text.data = data;
	}
	function set_input_value(input, value) {
	    input.value = value == null ? '' : value;
	}
	function set_style(node, key, value, important) {
	    if (value === null) {
	        node.style.removeProperty(key);
	    }
	    else {
	        node.style.setProperty(key, value, important ? 'important' : '');
	    }
	}
	function select_option(select, value) {
	    for (let i = 0; i < select.options.length; i += 1) {
	        const option = select.options[i];
	        if (option.__value === value) {
	            option.selected = true;
	            return;
	        }
	    }
	    select.selectedIndex = -1; // no option should be selected
	}
	function select_value(select) {
	    const selected_option = select.querySelector(':checked') || select.options[0];
	    return selected_option && selected_option.__value;
	}
	// unfortunately this can't be a constant as that wouldn't be tree-shakeable
	// so we cache the result instead
	let crossorigin;
	function is_crossorigin() {
	    if (crossorigin === undefined) {
	        crossorigin = false;
	        try {
	            if (typeof window !== 'undefined' && window.parent) {
	                void window.parent.document;
	            }
	        }
	        catch (error) {
	            crossorigin = true;
	        }
	    }
	    return crossorigin;
	}
	function add_resize_listener(node, fn) {
	    const computed_style = getComputedStyle(node);
	    if (computed_style.position === 'static') {
	        node.style.position = 'relative';
	    }
	    const iframe = element('iframe');
	    iframe.setAttribute('style', 'display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; ' +
	        'overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;');
	    iframe.setAttribute('aria-hidden', 'true');
	    iframe.tabIndex = -1;
	    const crossorigin = is_crossorigin();
	    let unsubscribe;
	    if (crossorigin) {
	        iframe.src = "data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}</script>";
	        unsubscribe = listen(window, 'message', (event) => {
	            if (event.source === iframe.contentWindow)
	                fn();
	        });
	    }
	    else {
	        iframe.src = 'about:blank';
	        iframe.onload = () => {
	            unsubscribe = listen(iframe.contentWindow, 'resize', fn);
	        };
	    }
	    append(node, iframe);
	    return () => {
	        if (crossorigin) {
	            unsubscribe();
	        }
	        else if (unsubscribe && iframe.contentWindow) {
	            unsubscribe();
	        }
	        detach(iframe);
	    };
	}
	function custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
	    const e = document.createEvent('CustomEvent');
	    e.initCustomEvent(type, bubbles, cancelable, detail);
	    return e;
	}
	class HtmlTag {
	    constructor(is_svg = false) {
	        this.is_svg = false;
	        this.is_svg = is_svg;
	        this.e = this.n = null;
	    }
	    c(html) {
	        this.h(html);
	    }
	    m(html, target, anchor = null) {
	        if (!this.e) {
	            if (this.is_svg)
	                this.e = svg_element(target.nodeName);
	            else
	                this.e = element(target.nodeName);
	            this.t = target;
	            this.c(html);
	        }
	        this.i(anchor);
	    }
	    h(html) {
	        this.e.innerHTML = html;
	        this.n = Array.from(this.e.childNodes);
	    }
	    i(anchor) {
	        for (let i = 0; i < this.n.length; i += 1) {
	            insert(this.t, this.n[i], anchor);
	        }
	    }
	    p(html) {
	        this.d();
	        this.h(html);
	        this.i(this.a);
	    }
	    d() {
	        this.n.forEach(detach);
	    }
	}
	function construct_svelte_component(component, props) {
	    return new component(props);
	}

	let current_component;
	function set_current_component(component) {
	    current_component = component;
	}
	function get_current_component() {
	    if (!current_component)
	        throw new Error('Function called outside component initialization');
	    return current_component;
	}
	/**
	 * Schedules a callback to run immediately after the component has been updated.
	 *
	 * The first time the callback runs will be after the initial `onMount`
	 */
	function afterUpdate(fn) {
	    get_current_component().$$.after_update.push(fn);
	}
	/**
	 * Creates an event dispatcher that can be used to dispatch [component events](/docs#template-syntax-component-directives-on-eventname).
	 * Event dispatchers are functions that can take two arguments: `name` and `detail`.
	 *
	 * Component events created with `createEventDispatcher` create a
	 * [CustomEvent](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent).
	 * These events do not [bubble](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#Event_bubbling_and_capture).
	 * The `detail` argument corresponds to the [CustomEvent.detail](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/detail)
	 * property and can contain any type of data.
	 *
	 * https://svelte.dev/docs#run-time-svelte-createeventdispatcher
	 */
	function createEventDispatcher() {
	    const component = get_current_component();
	    return (type, detail, { cancelable = false } = {}) => {
	        const callbacks = component.$$.callbacks[type];
	        if (callbacks) {
	            // TODO are there situations where events could be dispatched
	            // in a server (non-DOM) environment?
	            const event = custom_event(type, detail, { cancelable });
	            callbacks.slice().forEach(fn => {
	                fn.call(component, event);
	            });
	            return !event.defaultPrevented;
	        }
	        return true;
	    };
	}
	/**
	 * Associates an arbitrary `context` object with the current component and the specified `key`
	 * and returns that object. The context is then available to children of the component
	 * (including slotted content) with `getContext`.
	 *
	 * Like lifecycle functions, this must be called during component initialisation.
	 *
	 * https://svelte.dev/docs#run-time-svelte-setcontext
	 */
	function setContext(key, context) {
	    get_current_component().$$.context.set(key, context);
	    return context;
	}
	// TODO figure out if we still want to support
	// shorthand events, or if we want to implement
	// a real bubbling mechanism
	function bubble(component, event) {
	    const callbacks = component.$$.callbacks[event.type];
	    if (callbacks) {
	        // @ts-ignore
	        callbacks.slice().forEach(fn => fn.call(this, event));
	    }
	}

	const dirty_components = [];
	const binding_callbacks = [];
	const render_callbacks = [];
	const flush_callbacks = [];
	const resolved_promise = Promise.resolve();
	let update_scheduled = false;
	function schedule_update() {
	    if (!update_scheduled) {
	        update_scheduled = true;
	        resolved_promise.then(flush);
	    }
	}
	function add_render_callback(fn) {
	    render_callbacks.push(fn);
	}
	// flush() calls callbacks in this order:
	// 1. All beforeUpdate callbacks, in order: parents before children
	// 2. All bind:this callbacks, in reverse order: children before parents.
	// 3. All afterUpdate callbacks, in order: parents before children. EXCEPT
	//    for afterUpdates called during the initial onMount, which are called in
	//    reverse order: children before parents.
	// Since callbacks might update component values, which could trigger another
	// call to flush(), the following steps guard against this:
	// 1. During beforeUpdate, any updated components will be added to the
	//    dirty_components array and will cause a reentrant call to flush(). Because
	//    the flush index is kept outside the function, the reentrant call will pick
	//    up where the earlier call left off and go through all dirty components. The
	//    current_component value is saved and restored so that the reentrant call will
	//    not interfere with the "parent" flush() call.
	// 2. bind:this callbacks cannot trigger new flush() calls.
	// 3. During afterUpdate, any updated components will NOT have their afterUpdate
	//    callback called a second time; the seen_callbacks set, outside the flush()
	//    function, guarantees this behavior.
	const seen_callbacks = new Set();
	let flushidx = 0; // Do *not* move this inside the flush() function
	function flush() {
	    const saved_component = current_component;
	    do {
	        // first, call beforeUpdate functions
	        // and update components
	        while (flushidx < dirty_components.length) {
	            const component = dirty_components[flushidx];
	            flushidx++;
	            set_current_component(component);
	            update(component.$$);
	        }
	        set_current_component(null);
	        dirty_components.length = 0;
	        flushidx = 0;
	        while (binding_callbacks.length)
	            binding_callbacks.pop()();
	        // then, once components are updated, call
	        // afterUpdate functions. This may cause
	        // subsequent updates...
	        for (let i = 0; i < render_callbacks.length; i += 1) {
	            const callback = render_callbacks[i];
	            if (!seen_callbacks.has(callback)) {
	                // ...so guard against infinite loops
	                seen_callbacks.add(callback);
	                callback();
	            }
	        }
	        render_callbacks.length = 0;
	    } while (dirty_components.length);
	    while (flush_callbacks.length) {
	        flush_callbacks.pop()();
	    }
	    update_scheduled = false;
	    seen_callbacks.clear();
	    set_current_component(saved_component);
	}
	function update($$) {
	    if ($$.fragment !== null) {
	        $$.update();
	        run_all($$.before_update);
	        const dirty = $$.dirty;
	        $$.dirty = [-1];
	        $$.fragment && $$.fragment.p($$.ctx, dirty);
	        $$.after_update.forEach(add_render_callback);
	    }
	}
	const outroing = new Set();
	let outros;
	function group_outros() {
	    outros = {
	        r: 0,
	        c: [],
	        p: outros // parent group
	    };
	}
	function check_outros() {
	    if (!outros.r) {
	        run_all(outros.c);
	    }
	    outros = outros.p;
	}
	function transition_in(block, local) {
	    if (block && block.i) {
	        outroing.delete(block);
	        block.i(local);
	    }
	}
	function transition_out(block, local, detach, callback) {
	    if (block && block.o) {
	        if (outroing.has(block))
	            return;
	        outroing.add(block);
	        outros.c.push(() => {
	            outroing.delete(block);
	            if (callback) {
	                if (detach)
	                    block.d(1);
	                callback();
	            }
	        });
	        block.o(local);
	    }
	    else if (callback) {
	        callback();
	    }
	}
	function outro_and_destroy_block(block, lookup) {
	    transition_out(block, 1, 1, () => {
	        lookup.delete(block.key);
	    });
	}
	function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {
	    let o = old_blocks.length;
	    let n = list.length;
	    let i = o;
	    const old_indexes = {};
	    while (i--)
	        old_indexes[old_blocks[i].key] = i;
	    const new_blocks = [];
	    const new_lookup = new Map();
	    const deltas = new Map();
	    i = n;
	    while (i--) {
	        const child_ctx = get_context(ctx, list, i);
	        const key = get_key(child_ctx);
	        let block = lookup.get(key);
	        if (!block) {
	            block = create_each_block(key, child_ctx);
	            block.c();
	        }
	        else if (dynamic) {
	            block.p(child_ctx, dirty);
	        }
	        new_lookup.set(key, new_blocks[i] = block);
	        if (key in old_indexes)
	            deltas.set(key, Math.abs(i - old_indexes[key]));
	    }
	    const will_move = new Set();
	    const did_move = new Set();
	    function insert(block) {
	        transition_in(block, 1);
	        block.m(node, next);
	        lookup.set(block.key, block);
	        next = block.first;
	        n--;
	    }
	    while (o && n) {
	        const new_block = new_blocks[n - 1];
	        const old_block = old_blocks[o - 1];
	        const new_key = new_block.key;
	        const old_key = old_block.key;
	        if (new_block === old_block) {
	            // do nothing
	            next = new_block.first;
	            o--;
	            n--;
	        }
	        else if (!new_lookup.has(old_key)) {
	            // remove old block
	            destroy(old_block, lookup);
	            o--;
	        }
	        else if (!lookup.has(new_key) || will_move.has(new_key)) {
	            insert(new_block);
	        }
	        else if (did_move.has(old_key)) {
	            o--;
	        }
	        else if (deltas.get(new_key) > deltas.get(old_key)) {
	            did_move.add(new_key);
	            insert(new_block);
	        }
	        else {
	            will_move.add(old_key);
	            o--;
	        }
	    }
	    while (o--) {
	        const old_block = old_blocks[o];
	        if (!new_lookup.has(old_block.key))
	            destroy(old_block, lookup);
	    }
	    while (n)
	        insert(new_blocks[n - 1]);
	    return new_blocks;
	}

	function get_spread_update(levels, updates) {
	    const update = {};
	    const to_null_out = {};
	    const accounted_for = { $$scope: 1 };
	    let i = levels.length;
	    while (i--) {
	        const o = levels[i];
	        const n = updates[i];
	        if (n) {
	            for (const key in o) {
	                if (!(key in n))
	                    to_null_out[key] = 1;
	            }
	            for (const key in n) {
	                if (!accounted_for[key]) {
	                    update[key] = n[key];
	                    accounted_for[key] = 1;
	                }
	            }
	            levels[i] = n;
	        }
	        else {
	            for (const key in o) {
	                accounted_for[key] = 1;
	            }
	        }
	    }
	    for (const key in to_null_out) {
	        if (!(key in update))
	            update[key] = undefined;
	    }
	    return update;
	}
	function get_spread_object(spread_props) {
	    return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};
	}
	function create_component(block) {
	    block && block.c();
	}
	function mount_component(component, target, anchor, customElement) {
	    const { fragment, after_update } = component.$$;
	    fragment && fragment.m(target, anchor);
	    if (!customElement) {
	        // onMount happens before the initial afterUpdate
	        add_render_callback(() => {
	            const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
	            // if the component was destroyed immediately
	            // it will update the `$$.on_destroy` reference to `null`.
	            // the destructured on_destroy may still reference to the old array
	            if (component.$$.on_destroy) {
	                component.$$.on_destroy.push(...new_on_destroy);
	            }
	            else {
	                // Edge case - component was destroyed immediately,
	                // most likely as a result of a binding initialising
	                run_all(new_on_destroy);
	            }
	            component.$$.on_mount = [];
	        });
	    }
	    after_update.forEach(add_render_callback);
	}
	function destroy_component(component, detaching) {
	    const $$ = component.$$;
	    if ($$.fragment !== null) {
	        run_all($$.on_destroy);
	        $$.fragment && $$.fragment.d(detaching);
	        // TODO null out other refs, including component.$$ (but need to
	        // preserve final state?)
	        $$.on_destroy = $$.fragment = null;
	        $$.ctx = [];
	    }
	}
	function make_dirty(component, i) {
	    if (component.$$.dirty[0] === -1) {
	        dirty_components.push(component);
	        schedule_update();
	        component.$$.dirty.fill(0);
	    }
	    component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
	}
	function init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {
	    const parent_component = current_component;
	    set_current_component(component);
	    const $$ = component.$$ = {
	        fragment: null,
	        ctx: [],
	        // state
	        props,
	        update: noop,
	        not_equal,
	        bound: blank_object(),
	        // lifecycle
	        on_mount: [],
	        on_destroy: [],
	        on_disconnect: [],
	        before_update: [],
	        after_update: [],
	        context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
	        // everything else
	        callbacks: blank_object(),
	        dirty,
	        skip_bound: false,
	        root: options.target || parent_component.$$.root
	    };
	    append_styles && append_styles($$.root);
	    let ready = false;
	    $$.ctx = instance
	        ? instance(component, options.props || {}, (i, ret, ...rest) => {
	            const value = rest.length ? rest[0] : ret;
	            if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
	                if (!$$.skip_bound && $$.bound[i])
	                    $$.bound[i](value);
	                if (ready)
	                    make_dirty(component, i);
	            }
	            return ret;
	        })
	        : [];
	    $$.update();
	    ready = true;
	    run_all($$.before_update);
	    // `false` as a special case of no DOM component
	    $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
	    if (options.target) {
	        if (options.hydrate) {
	            const nodes = children(options.target);
	            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
	            $$.fragment && $$.fragment.l(nodes);
	            nodes.forEach(detach);
	        }
	        else {
	            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
	            $$.fragment && $$.fragment.c();
	        }
	        if (options.intro)
	            transition_in(component.$$.fragment);
	        mount_component(component, options.target, options.anchor, options.customElement);
	        flush();
	    }
	    set_current_component(parent_component);
	}
	/**
	 * Base class for Svelte components. Used when dev=false.
	 */
	class SvelteComponent {
	    $destroy() {
	        destroy_component(this, 1);
	        this.$destroy = noop;
	    }
	    $on(type, callback) {
	        if (!is_function(callback)) {
	            return noop;
	        }
	        const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
	        callbacks.push(callback);
	        return () => {
	            const index = callbacks.indexOf(callback);
	            if (index !== -1)
	                callbacks.splice(index, 1);
	        };
	    }
	    $set($$props) {
	        if (this.$$set && !is_empty($$props)) {
	            this.$$.skip_bound = true;
	            this.$$set($$props);
	            this.$$.skip_bound = false;
	        }
	    }
	}

	const subscriber_queue = [];
	/**
	 * Create a `Writable` store that allows both updating and reading by subscription.
	 * @param {*=}value initial value
	 * @param {StartStopNotifier=}start start and stop notifications for subscriptions
	 */
	function writable(value, start = noop) {
	    let stop;
	    const subscribers = new Set();
	    function set(new_value) {
	        if (safe_not_equal(value, new_value)) {
	            value = new_value;
	            if (stop) { // store is ready
	                const run_queue = !subscriber_queue.length;
	                for (const subscriber of subscribers) {
	                    subscriber[1]();
	                    subscriber_queue.push(subscriber, value);
	                }
	                if (run_queue) {
	                    for (let i = 0; i < subscriber_queue.length; i += 2) {
	                        subscriber_queue[i][0](subscriber_queue[i + 1]);
	                    }
	                    subscriber_queue.length = 0;
	                }
	            }
	        }
	    }
	    function update(fn) {
	        set(fn(value));
	    }
	    function subscribe(run, invalidate = noop) {
	        const subscriber = [run, invalidate];
	        subscribers.add(subscriber);
	        if (subscribers.size === 1) {
	            stop = start(set) || noop;
	        }
	        run(value);
	        return () => {
	            subscribers.delete(subscriber);
	            if (subscribers.size === 0) {
	                stop();
	                stop = null;
	            }
	        };
	    }
	    return { set, update, subscribe };
	}

	var dimensions = writable([-1, -1, -1, -1]);
	var range$1 = writable([-1, -1, -1, -1]);
	// from layout-interface.. this ensures compatability with old renderers

	var layout = writable(); // store the axis objects (with access to scale etc.)

	var xAxis = writable();
	var yAxis = writable();
	var scaleAxis = writable(); // any third axes can go here

	var nullHandler$1 = function nullHandler() {
	  return null;
	};

	function factoryWrapper(SvelteType, setupFunction, optionsFunction) {
	  var factory = function factory(el, data) {
	    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
	    var env = {
	      el: el,
	      data: data,
	      options: options,
	      svelteWrapper: true
	    };
	    var target = el.querySelector('.chart');

	    if (setupFunction) {
	      setupFunction(env, data, options);
	    } // provide options and set hooks for postRender callbacks


	    if (optionsFunction) {
	      _extends(options, optionsFunction(env, data, options));
	    }

	    makeData(data, options);
	    buildTaxonomy(data, true, options); // subscribe to stores and write back into the root env object
	    // the env object is what read by older layers/renderers

	    layout.subscribe(function (value) {
	      if (value) {
	        _extends(env, {
	          layout: value
	        });
	      }
	    });
	    xAxis.subscribe(function (value) {
	      _extends(env, {
	        x: value
	      });
	    });
	    yAxis.subscribe(function (value) {
	      _extends(env, {
	        y: value
	      });
	    });
	    scaleAxis.subscribe(function (value) {
	      _extends(env, {
	        scale: value
	      });
	    });
	    dimensions.subscribe(function (value) {
	      _extends(env, {
	        dimensions: value
	      });
	    });
	    var props = {
	      env: env,
	      chartData: data,
	      options: options,
	      onRender: function onRender() {
	        // allow resize events to be triggered after the render fully
	        // finishes instead of right away
	        if (env.options.afterRenderCallbacks) {
	          env.options.afterRenderCallbacks.forEach(function (cb) {
	            return cb();
	          });
	        }
	      }
	    }; // to prevent entire rerenders when we can just update
	    // the svelte context we use globalState to keep a ref
	    // to the svelte instance

	    var component;

	    if (globalState(data.id, 'svelteTypeFactory')) {
	      component = globalState(data.id, 'svelteTypeFactory');
	      component.$$set(props);
	    } else {
	      target.innerHTML = '';
	      component = new SvelteType({
	        target: target,
	        props: props
	      });
	      globalState(data.id, 'svelteTypeFactory', component);
	    } // instance is returned, and will have onResize, render methods attached


	    var instance = makeLayerPrototype(component, [{
	      el: env.el,
	      env: env
	    }], options);
	    debugEnv(env);
	    return instance;
	  }; // mark as svelteFactory and expose the options and setup function


	  factory.isSvelteFactory = true;
	  factory.svelteFactorySetup = setupFunction !== null && setupFunction !== void 0 ? setupFunction : nullHandler$1;

	  factory.svelteFactoryOptions = function (env, data, opts) {
	    var _options$afterRenderC;

	    var options = makeOptions(opts, data); // no longer using old secondaryAxis primaryAxis objects

	    options.preventAxisPropertyOverrides = true; // make sure we allow for the after renderCallbacks

	    options.afterRenderCallbacks = (_options$afterRenderC = options.afterRenderCallbacks) !== null && _options$afterRenderC !== void 0 ? _options$afterRenderC : [];

	    options.addAfterRenderCallback = function (cb) {
	      options.afterRenderCallbacks.push(cb);
	    };

	    if (optionsFunction) {
	      return optionsFunction(env, data, options);
	    }

	    return options;
	  };

	  return factory;
	}

	// `Array.prototype.fill` method implementation
	// https://tc39.github.io/ecma262/#sec-array.prototype.fill
	var arrayFill = function fill(value /* , start = 0, end = @length */) {
	  var O = toObject(this);
	  var length = toLength(O.length);
	  var argumentsLength = arguments.length;
	  var index = toAbsoluteIndex(argumentsLength > 1 ? arguments[1] : undefined, length);
	  var end = argumentsLength > 2 ? arguments[2] : undefined;
	  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);
	  while (endPos > index) O[index++] = value;
	  return O;
	};

	// `Array.prototype.fill` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.fill
	_export({ target: 'Array', proto: true }, {
	  fill: arrayFill
	});

	// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
	addToUnscopables('fill');

	// use the list of types to iterate over and select a format
	// that succeeds

	function determineType(types, data, options) {
	  var typeMatch = null;
	  Object.keys(types).forEach(function (key) {
	    var type = types[key];

	    if (!typeMatch) {
	      if (typeCheck(type, data, options, function () {
	        return null;
	      })) {
	        typeMatch = type;
	      }
	    }
	  });
	  return typeMatch;
	} // Apply type check will test the data against a single
	// type validator, and respond with warning messages back
	// to the editor

	function typeCheck(type, data, options, postMessage) {
	  if (type.validateData) {
	    var valid = type.validateData(data);

	    if (!valid()) {
	      postMessage(valid.messages());
	    }

	    return valid();
	  } else {
	    return true; // if no validator then we assume it's valid
	  }
	} // Used for the editor to run validation over the available types
	// and provide a report of what types apply

	function typeReport(types, data, options, postMessage) {
	  var typeReport = {};
	  Object.keys(types).forEach(function (typeName) {
	    var type = types[typeName];

	    if (type.validateData) {
	      var valid = type.validateData(data);
	      typeReport[typeName] = {
	        valid: valid(),
	        messages: valid.messages()
	      };
	    } else {
	      typeReport[typeName] = 'no validation method provided';
	    }
	  });
	  postMessage(typeReport);
	} // simple closure to record responses

	function validator(data) {
	  var res = {
	    valid: true,
	    messages: []
	  };

	  var validate = function validate(message, condition) {
	    if (message && condition) {
	      if (!condition(data)) {
	        res.valid = false;
	        res.messages.push(message);
	      }
	    } else {
	      // when called with no arguments return the valid state
	      return res.valid;
	    }
	  };

	  validate.messages = function () {
	    return res.messages;
	  };

	  return validate;
	}

	var TIME_SERIES_COLUMN_MAX_FORMATTED = 40;
	var TIME_SERIES_COLUMN_MAX = 50;
	var MIN_COLUMN_WIDTH_FOR_BAND = 5;
	function renderChartAsTimeSeries(el, chartData, options) {
	  var columnWidth = getColumnWidth(el, chartData, options);
	  var isDate = isTimeSeries(chartData);
	  var yearOrQuarter = isTimeSeriesYearQuarterMonth(chartData);

	  if (chartData.chartOptions && chartData.chartOptions.dateOutputFormat && columnWidth > TIME_SERIES_COLUMN_MAX_FORMATTED) {
	    return false; // bar chart using output format for years etc.
	  }

	  if (isForceCategorical(chartData.fields[0])) return false;

	  if (isDate) {
	    if (yearOrQuarter) return false;
	    if (columnWidth > TIME_SERIES_COLUMN_MAX) return false;
	    return true;
	  }

	  return false;
	} // for columns we really only want to treat these as time series if the column
	// widths are so minimal that the chart is effectively an area chart
	//
	// NOTE :: this will only get called when it is already identified as
	// a time series column, so we can skip the checks from renderChartAsTimeSeries

	function renderAxisAsContinuous(el, chartData, options) {
	  var columnWidth = getColumnWidth(el, chartData, options);

	  if (columnWidth < MIN_COLUMN_WIDTH_FOR_BAND) {
	    return true;
	  }

	  return false;
	}
	function getColumnWidth(el, chartData, options) {
	  var isStacked = options.stackedBand;
	  var columnCount = chartData.data.length * (chartData.fields.length - 1);
	  if (isStacked) columnCount = chartData.data.length;
	  var width = el.node().offsetWidth;
	  return width / columnCount;
	} // number of columns from the data

	function getNumberOfColumns(chartData, isStacked) {
	  if (isStacked) {
	    return chartData.data.length;
	  } else {
	    return chartData.data.length * getSeries(chartData).length;
	  }
	}

	var TOP$1 = 'top';
	var BOTTOM$1 = 'bottom';
	var LEFT$1 = 'left';
	var RIGHT$1 = 'right';
	var HORIZONTAL = 'horizontal';
	var VERTICAL = 'vertical';
	var X = 'x';
	var Y = 'y';
	var MOBILE_AXIS_WIDTH = 375;
	var AXIS_MAP = {};
	AXIS_MAP[TOP$1] = axisTop;
	AXIS_MAP[BOTTOM$1] = axisBottom;
	AXIS_MAP[LEFT$1] = axisLeft;
	AXIS_MAP[RIGHT$1] = axisRight;
	function bottomLabel(options) {
	  return function (selection, env, chartData) {
	    if (!chartData.config) return;
	    if (env.options.disableLabels) return; // todo move to generics

	    selection.selectAll('.label-bottom').remove();

	    if (chartData.config.labelPrimary === undefined && isCreatedPriorToV3(chartData)) {
	      if (chartData.primaryAxis) {
	        var label = chartData.primaryAxis.label || chartData.primaryAxis.caption;

	        if (label) {
	          selection.selectAppend('div.chart-footer').append('div').classed('label-bottom', true).text(label);
	        }
	      }
	    } else {
	      if (chartData.config.labelPrimary) {
	        selection.selectAppend('div.chart-footer').append('div').classed('label-bottom', true).text(chartData.config.labelPrimary);
	      }
	    }
	  };
	} // determine if grid should be default or to display in a
	//   also: all negative values and bar chart (zero on top)

	function shouldDisplayGrid(env) {
	  if (env.options.disableGrid) return false;
	  if (env.data.config.grid_style === 'no-grid') return false;
	  if (env.data.config.grid_style === 'no-grid-no-domain') return false;
	  if (env.data.config.grid_style === 'force-grid-force-domain') return true;
	  if (env.data.config.grid_style === 'force-grid') return true;
	  if (env.data.annotations && env.data.annotations.length) return false;
	  if (isMixedDomain(env.data)) return false;
	  if (isNegativeDomain(env.data)) return false; // keep terminal themes with gridlines for now

	  if (['terminal', 'coth', 'bizweek', 'bizweek-dark'].indexOf(env.data.theme) !== -1) {
	    return true;
	  } // else if (['opinion'].indexOf(env.data.theme) !== -1) {
	  //   return true // WAITING FOR CONFIRMATION
	  // }


	  if (env.data.chartType === 'line') return true;
	  if (env.data.chartType === 'scatterPlot') return true;
	  return false;
	}
	function shouldDisplayGridY(env) {
	  if (env.data.config.grid_style === 'grid-y-only') return true;
	  if (env.data.config.grid_style === 'grid-x-only') return false;
	  return shouldDisplayGrid(env);
	}
	function shouldDisplayGridX(env) {
	  if (env.data.config.grid_style === 'grid-x-only') return true;
	  if (env.data.config.grid_style === 'grid-y-only') return false;
	  return shouldDisplayGrid(env);
	} // for charts that go from positive to negative we want to
	// default to hiding the x-axis and showing the zero axis

	function shouldDisplayDomain(env) {
	  if (env.options.disableDomain) return false;
	  if (env.data.config.grid_style === 'no-grid-no-domain') return false;
	  if (env.data.config.grid_style === 'force-grid-force-domain') return true;
	  if (env.data.config.grid_style === 'grid-y-only') return true;
	  if (isMixedDomain(env.data)) return false;
	  if (isNegativeDomain(env.data)) return false;
	  return true;
	} // we allow domain ticks to be hidden only when the type is a bar chart
	// and also only when the bar chart is not a time series chart

	function shouldDisplayDomainTicks(env) {
	  if (isMixedDomain(env.data)) return true;
	  if (['line', 'area', 'barline'].indexOf(env.data.chartType) !== -1) return true; // specifically for column types

	  var columnWidth = getColumnWidth(env.el, env.data, env.options);
	  if (columnWidth < 50) return true;
	  if (renderChartAsTimeSeries(env.el, env.data, env.options)) return true;
	  return false;
	} // We use the Axis bounds to determine how big an area
	// to render into, so we need to draw an invisible line
	// spanning the axis

	function makeAxisBounds(selection, axis) {
	  // set bounds of range with invisible dom
	  if (axis.orientation() === HORIZONTAL) {
	    selection.selectAppend('line.bounds').attr('y', 0).attr('x1', axis.scale.range()[0]).attr('x2', axis.scale.range()[1]).style('stroke', 'transparent');
	  } else {
	    selection.selectAppend('line.bounds').attr('x', 0).attr('y1', axis.scale.range()[0]).attr('y2', axis.scale.range()[1]).style('stroke', 'transparent');
	  }
	} // defaultScaffold provides titles and footers within the chart
	// allow maxRatio to be defined for terminal screenshots so we
	// don't get tall images for terminal

	function getAspectRatio(chartData, defaultRatio) {
	  var layout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
	  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
	  var ratio = defaultRatio || '5:2';

	  if (chartData.chartOptions && chartData.chartOptions.aspectRatio) {
	    ratio = chartData.chartOptions.aspectRatio;
	  }

	  if (options.embedAspectRatio) {
	    ratio = options.embedAspectRatio;
	  }

	  if (options.aspectRatio) {
	    ratio = options.aspectRatio;
	  }

	  if (typeof ratio === 'string') {
	    ratio = ratio.split(':')[0] / ratio.split(':')[1];
	  }

	  if (layout.maxAspectRatioForTerminal && options.isDarkTheme && options.screenshotMode === 'avmm') {
	    ratio = Math.max(ratio, layout.maxAspectRatioForTerminal);
	  }

	  return ratio;
	} // return css properties from an element as an array
	// pass in properties as array of arguments

	function getCSSProperties(node) {
	  var properties = Array.prototype.slice.call(arguments, 1);
	  var style = window.getComputedStyle(node, null);
	  return properties.map(function (prop) {
	    return style.getPropertyValue(prop);
	  });
	} // return sum of padding-top / padding-bottom

	function getPaddingHeight(node) {
	  var heights = getCSSProperties(node, 'padding-top', 'padding-bottom');
	  return heights.map(function (val) {
	    return Number(val.replace('px', ''));
	  }).reduce(function (val, sum) {
	    return val + sum;
	  });
	} // return sum of padding-top / padding-bottom

	function getMarginHeight(node) {
	  var heights = getCSSProperties(node, 'margin-top', 'margin-bottom');
	  return heights.map(function (val) {
	    return Number(val.replace('px', ''));
	  }).reduce(function (val, sum) {
	    return val + sum;
	  });
	}

	function simpleColumn(options) {
	  var defaults = {
	    verticalColumnMinLength: 1,
	    horizontalColumnMinLength: 2
	  };
	  options = _extends(defaults, options);
	  var xScale = options.xScale;
	  var yScale = options.yScale;
	  var seriesOffset = options.seriesOffset || 0;

	  function simpleColumn(selection) {
	    selection.each(function (chartData) {
	      var el = select(this).classed('simple-column', true); // create a child element that encapsulates the entire range in order
	      // to force bounding box to match the "nice()" domain.

	      el.selectAll('.bounding-rect').remove();
	      el.append('rect').classed('bounding-rect', true).attr('x', xScale.range()[0]).attr('width', xScale.range()[1]).attr('y', yScale.range()[1]).attr('height', yScale.range()[0]).attr('fill', 'transparent');
	      var categoricalData = getFieldIndexValueParser(chartData, true, true);
	      var series = options.seriesData || getSeries(chartData);
	      var seriesScale = band().domain(range$2(series.length));

	      if (options.orientation === HORIZONTAL) {
	        seriesScale.range([0, xScale.bandwidth()]);
	      } else {
	        seriesScale.range([0, yScale.bandwidth()]);
	      } // function to highlight a value by index


	      var isHighlighted = valueHighlighter(chartData);

	      if (seriesScale.bandwidth() < 1) {
	        console.warn(chartData.id, 'Column width is less than 1px', chartData.data.length + ' columns');
	      }

	      var cseries = el.selectAll('.series').data(series);
	      cseries.exit().remove();
	      cseries = cseries.enter().append('g').attr('class', function (d, i) {
	        return 'series f series-' + (i + seriesOffset);
	      }).merge(cseries);

	      if (options.orientation === HORIZONTAL) {
	        cseries.attr('transform', function (d, i) {
	          return 'translate(' + seriesScale(i) + ',0)';
	        });
	      } else {
	        cseries.attr('transform', function (d, i) {
	          return 'translate(0, ' + seriesScale(i) + ')';
	        });
	      }

	      var columns = cseries.selectAll('.column').data(function (d) {
	        return d.data;
	      });
	      columns.exit().remove(); // HORIZONTAL equals vertical bars

	      if (options.orientation === HORIZONTAL) {
	        columns.enter().append('rect').attr('class', 'column').merge(columns).classed('highlight', isHighlighted).attr('x', function (d, i) {
	          return xScale(categoricalData(i));
	        }).attr('y', function (d) {
	          return yScale(Math.max(0, numberOrNull(d)));
	        }).attr('width', Math.max(1, seriesScale.bandwidth())).attr('height', function (d) {
	          if (d == null) return 0;
	          return Math.max(Math.abs(yScale(numberOrNull(d)) - yScale(0)), options.verticalColumnMinLength);
	        });
	      } else {
	        // these are horizontal bars
	        columns.enter().append('rect').attr('class', 'column').merge(columns).classed('highlight', isHighlighted).attr('y', function (d, i) {
	          return yScale(categoricalData(i));
	        }).attr('x', function (d, i) {
	          return xScale(Math.min(0, numberOrNull(d)));
	        }).attr('height', seriesScale.bandwidth()).attr('width', function (d) {
	          if (d == null) return 0;
	          return Math.max(Math.abs(xScale(numberOrNull(d)) - xScale(0)), options.horizontalColumnMinLength);
	        });
	      }
	    });
	  }

	  simpleColumn.xScale = function (_) {
	    return arguments.length ? (xScale = _, simpleColumn) : xScale; // eslint-disable-line
	  };

	  simpleColumn.yScale = function (_) {
	    return arguments.length ? (yScale = _.copy(), simpleColumn) : yScale; // eslint-disable-line
	  };

	  return simpleColumn;
	}

	// standardize the creation of the default env
	// TODO :: standardize this into stub axes and layout manager
	function makeEnv(el, data, options) {
	  return {
	    el: el,
	    // required
	    data: data,
	    // required
	    x: null,
	    // simpleAxis({orientation: 'x'}),
	    y: null,
	    // simpleAxis({orientation: 'y'}),
	    z: null,
	    // simpleAxis({orientation: 'y'}),
	    r: null,
	    layout: null,
	    // simpleLayout(),
	    layers: [],
	    options: _extends({}, options) // shallow copy

	  };
	}

	function tooltip(selection, tooltipRender, env) {
	  // TODO: provide timeout to check whether mouse is offscreen
	  var isEnabled = false;

	  function enable() {
	    if (isEnabled) return;
	    selection.selectAll('.tooltip').classed('tooltip-hidden', false);
	    isEnabled = true;
	  }

	  function disable() {
	    if (!isEnabled) return;
	    selection.selectAll('.tooltip').classed('tooltip-hidden', true);
	    isEnabled = false;
	  }

	  function mouseMove(event) {
	    var pos = eventPosition(selection.node(), event);
	    tooltipRender(pos, enable, disable);
	  } // removeListener(selection, 'mouseover.tooltip, mouseout.tooltip, mousemove.tooltip')
	  // removeListener(selection, 'touchstart.tooltip, touchend.tooltip, touchmove.tooltip')


	  addListener(selection, 'mouseover.tooltip, touchstart.tooltip', enable);
	  addListener(selection, 'mouseout.tooltip, touchend.tooltip', disable);
	  addListener(selection, 'mousemove.tooltip, touchmove.tooltip', mouseMove);

	  if (isOptionNotFalse(env.options.interactive)) {
	    selection.style('pointer-events', 'all');
	  }
	}
	function lineTooltip(opts) {
	  // ---- NOTE : going to cleanup and move all the tooltip stuff
	  // just here for convenience factor
	  var env = opts.env,
	      chart = opts.chart,
	      area = opts.area;
	  var xAxis = env.x;
	  var yAxis = env.y; // append tooltip to our selection

	  chart.selectAll('.tooltip').remove();
	  var series = getSeries(env.data);
	  var singleSeries = isSingleSeries(env.data);
	  var tContainer = chart.selectAppend('div.tooltip-container');
	  var tLabelBox = tContainer.append('div').attr('class', 'tooltip tooltip-hidden tooltip-label-box');
	  var tLabel = tLabelBox.append('div').attr('class', 'tooltip-label');
	  var tValues = tLabelBox.selectAppend('div.tooltip-values');
	  var margin = env.layout.margin();
	  var isStacked = env.y.stackedDomain();
	  var gTooltip = area.selectAppend('g.tooltip-container');
	  var tGridline = gTooltip.append('line').attr('class', 'tooltip tooltip-hidden tooltip-gridline');
	  var tAnchors = [];
	  tAnchors.push(gTooltip.append('circle').attr('class', 'tooltip tooltip-hidden tooltip-anchor series-0-stroke'));
	  tAnchors.push(gTooltip.append('circle').attr('class', 'tooltip tooltip-hidden tooltip-anchor series-1-stroke'));
	  tAnchors.push(gTooltip.append('circle').attr('class', 'tooltip tooltip-hidden tooltip-anchor series-2-stroke'));
	  tAnchors.push(gTooltip.append('circle').attr('class', 'tooltip tooltip-hidden tooltip-anchor series-3-stroke'));
	  tAnchors.push(gTooltip.append('circle').attr('class', 'tooltip tooltip-hidden tooltip-anchor series-4-stroke'));
	  tAnchors.push(gTooltip.append('circle').attr('class', 'tooltip tooltip-hidden tooltip-anchor series-5-stroke'));
	  var formatOptions = {
	    defaultDecimals: 1,
	    isTooltip: true
	  };
	  var formatPrimary = valueFormatter(env.x, env, formatOptions);
	  var formatSecondary = valueFormatter(env.y, env, formatOptions);
	  applyColors(tContainer.node(), env.data, env.options);

	  function tooltipRender(pos, enableTooltip, disableTooltip) {
	    var boundingBox = area.node().getBoundingClientRect();
	    var padLeft = env.layout.yAxisInnerPadding();
	    var posNormalized = [(pos[0] - padLeft) / xAxis.scale.range()[1], 1.0 - pos[1] / yAxis.scale.range()[0]];
	    var primaryAxisData = xAxis.getDataAtPosition(posNormalized[0]);
	    enableTooltip(); // won't do anything if already enabled

	    if (!primaryAxisData) return; // set 0 as min seriesIndex for cases when no hit registered

	    if (primaryAxisData.seriesIndex == null) {
	      primaryAxisData.seriesIndex = 0;
	    }

	    var anchorPositionX = xAxis.getPositionFromIndex(primaryAxisData.dataIndex, 'ignoreSeries');
	    if (!env.data.data[primaryAxisData.dataIndex]) return;
	    var labelValue = env.data.data[primaryAxisData.dataIndex][0];
	    var dataValue = primaryAxisData.data.map(function (val, i) {
	      if (valueOrNull(val) == null) {
	        return interpolateBetweenValues(env, primaryAxisData.dataIndex, i);
	      }

	      return val;
	    }); // do nothing if no active items

	    if (!dataValue.filter(function (v) {
	      return v != null;
	    }).length) return;
	    var xPos = anchorPositionX * xAxis.scale.range()[1];
	    var yPos = dataValue.map(function (val) {
	      return yAxis.scale(val);
	    });

	    if (isStacked) {
	      var yPosTotal = 0;
	      var yNegTotal = 0;
	      yPos = yPos.map(function (v, i) {
	        if (dataValue[i] < 0) {
	          yNegTotal += v;
	          return yNegTotal;
	        } else {
	          yPosTotal += yAxis.rangeLength() - v;
	          return yAxis.rangeLength() - yPosTotal;
	        }
	      });
	    }

	    var lowestPos = yPos.reduce(function (a, b) {
	      return Math.min(a, b);
	    });
	    tGridline.attr('x1', xPos).attr('x2', xPos).attr('y1', yAxis.scale.range()[0]).attr('y2', yAxis.scale.range()[1]);
	    tAnchors.forEach(function (tAnchor, i) {
	      var showAnchor = xAxis.series()[i] && dataValue[i] != null;
	      tAnchor.attr('r', env.options.tooltipAnchorSize).attr('cx', xPos || 0).attr('cy', yPos[i] || 0).style('display', showAnchor ? 'block' : 'none');
	    }); // to speed things up, calculate out of bounds
	    // before placing the label box - determine what
	    // if we need to flip to the other side etc.

	    var pad = env.layout.yAxisInnerPadding();
	    var labelX = xPos + margin.left + pad + env.options.tooltipOffsetX;
	    var labelY = lowestPos + margin.top + env.options.tooltipOffsetY;
	    var adjustClass = null;
	    var heightEst = env.options.tooltipLineHeight * (series.length + 1);
	    var widthEst = env.options.tooltipMaxWidth;
	    var flipHorizontal = false;
	    var flipVertical = false;

	    if (labelX + widthEst > boundingBox.width) {
	      labelX = Math.max(xPos + pad + margin.left - env.options.tooltipOffsetX, widthEst);
	      adjustClass = 'flipHorizontal';
	      flipHorizontal = true;
	    }

	    if (labelY + heightEst > boundingBox.height) {
	      labelY = Math.max(lowestPos + margin.top - env.options.tooltipOffsetY, heightEst);
	      adjustClass = 'flipVertical';
	      flipVertical = true;
	    }

	    if (flipVertical && flipHorizontal) {
	      adjustClass = 'flipVH';
	    }

	    tLabelBox.style('left', labelX + 'px').style('top', labelY + 'px').classed('flipHorizontal', adjustClass === 'flipHorizontal').classed('flipVertical', adjustClass === 'flipVertical').classed('flipVH', adjustClass === 'flipVH').classed('single-series', singleSeries);
	    tLabel.text(formatPrimary(labelValue));
	    var valueDivs = tValues.selectAll('.tooltip-value').data(dataValue);
	    valueDivs.exit().remove();
	    valueDivs.enter().append('div').classed('tooltip-value', true).merge(valueDivs).style('display', function (d) {
	      return d == null ? 'none' : 'block';
	    }).html(function (d, i) {
	      return "\n            <span class=\"swatch bg series-".concat(i, "\"></span>\n            <span class=\"val\">").concat(formatSecondary(d), "</span>\n          ");
	    });
	    applyColors(tLabelBox.node(), env.data, env.options);

	    if (env.options.tooltipPostRender) {
	      env.options.tooltipPostRender(env, tLabelBox, dataValue, primaryAxisData.dataIndex);
	    }
	  }

	  return tooltip(chart, tooltipRender, env);
	} //
	// Tooltip implementation specific to columns
	// we also share it for the stacked column

	function columnTooltip(opts) {
	  // eslint-disable-line no-unused-vars
	  // append tooltip to our selection
	  opts.chart.selectAll('.tooltip').remove();
	  var env = opts.env;
	  if (env.options.labelCaps) return; // no tooltips with labels

	  var series = opts.seriesData || getSeries(opts.env.data);
	  var singleSeries = isSingleSeries(opts.env.data);
	  var tContainer = opts.chart.selectAppend('div.tooltip-container');
	  var tLabelBox = tContainer.append('div').attr('class', 'tooltip tooltip-hidden tooltip-label-box');
	  var tLabel = tLabelBox.append('div').attr('class', 'tooltip-label');
	  var tValues = tLabelBox.selectAppend('div.tooltip-values'); // HorizontalBar is equal to a vertical primary axis

	  var isHorizontal = env.layout.orientation() === VERTICAL;
	  var margin = env.layout.margin();
	  var innerPadding = !isHorizontal ? env.layout.yAxisInnerPadding() : 0;
	  var isStacked = (env.options.stackedBand || env.y.stackedDomain()) && !opts.disableStacked;
	  var isDumbbell = opts.isDumbbell;
	  var ignoreSeries = isStacked || opts.barline || isDumbbell;
	  var gTooltip = opts.area.selectAppend('g.tooltip-container');
	  var tGridline = gTooltip.append('line').attr('class', 'tooltip tooltip-hidden tooltip-gridline');
	  var tAnchor = gTooltip.append('circle').attr('class', 'tooltip tooltip-hidden tooltip-anchor');
	  applyColors(tContainer.node(), env.data, env.options);
	  var singleSeriesStacked = false; // called on mousemove to position tooltip

	  function tooltipRender(pos, enableTooltip, disableTooltip) {
	    var boundingBox = opts.area.node().getBoundingClientRect();
	    var posNormalized = [Math.max(0, pos[0] - margin.left - innerPadding) / env.x.rangeLength(), 1.0 - (pos[1] - margin.top) / env.y.rangeLength()]; // wait until tooltip active to save initial render time
	    // if stacked domain check if singleseriesstacked

	    if (isStacked && env.options.singleSeriesStacked == null) {
	      singleSeriesStacked = isSingleSeriesStackedDomain(env.data);
	      env.options.singleSeriesStacked = singleSeriesStacked;
	    }

	    var primaryAxis = isHorizontal ? env.y : env.x;
	    var secondaryAxis = isHorizontal ? env.x : env.y;
	    var formatOptions = {
	      defaultDecimals: 1,
	      isTooltip: true
	    };
	    var formatPrimary = valueFormatter(primaryAxis, env, formatOptions);
	    var formatSecondary = valueFormatter(secondaryAxis, env, formatOptions);
	    var primaryAxisData = null;
	    var anchorPositionX = null;

	    if (isHorizontal) {
	      posNormalized[1] = 1.0 - posNormalized[1];
	      primaryAxisData = env.y.getDataAtPosition(posNormalized[1]);
	    } else {
	      primaryAxisData = env.x.getDataAtPosition(posNormalized[0]);
	    }

	    if (!primaryAxisData || env.data.data[primaryAxisData.dataIndex] === undefined) {
	      disableTooltip();
	      return;
	    }

	    enableTooltip(); // won't do anything if already enabled
	    // for stacked tooltip we only want our sliced data

	    if (opts.seriesOffset && primaryAxisData.data) {
	      primaryAxisData.data = primaryAxisData.data.slice(opts.seriesOffset);
	    } // remove null values from tooltip


	    var nullValues = primaryAxisData.data.map(function (v, i) {
	      return [v, i];
	    }).filter(function (v) {
	      return v[0] == null;
	    }); // allow a way to get the original index with nulls filtered out

	    var getIndexWithNullRemoved = function getIndexWithNullRemoved(i) {
	      var nullValuesBefore = nullValues.filter(function (v) {
	        return v[1] <= i;
	      }).reduce(function (acc, cur) {
	        return acc + 1;
	      }, 0);
	      return i + nullValuesBefore;
	    };

	    primaryAxisData.data = primaryAxisData.data.filter(function (v) {
	      return v != null;
	    });

	    if (isHorizontal) {
	      anchorPositionX = env.y.getPositionFromIndex([primaryAxisData.dataIndex, primaryAxisData.seriesIndex], ignoreSeries);
	    } else {
	      anchorPositionX = env.x.getPositionFromIndex([primaryAxisData.dataIndex, primaryAxisData.seriesIndex], ignoreSeries);
	    } // for barline we only use the bar series


	    if (opts.barline) primaryAxisData.seriesIndex = 0;
	    var labelValue = env.data.data[primaryAxisData.dataIndex][0];
	    var dataValue = primaryAxisData.data[primaryAxisData.seriesIndex];

	    if (isStacked) {
	      dataValue = primaryAxisData.data.reduce(function (a, b) {
	        return Number(a) + Number(b);
	      }, 0);
	      primaryAxisData.seriesIndex = 'X'; // nullify this value
	    }

	    var xPos = anchorPositionX * env.x.rangeLength();
	    var yPos = env.y.scale(dataValue);

	    if (isHorizontal) {
	      yPos = anchorPositionX * env.y.rangeLength();
	      xPos = env.x.scale(dataValue);
	    }

	    var values = series.map(function (s) {
	      return s.data[primaryAxisData.dataIndex];
	    }).filter(function (v) {
	      return v != null;
	    });
	    if (isNaN(yPos) || isNaN(xPos)) return;

	    if (isHorizontal) {
	      tGridline.attr('x1', xPos).attr('x2', xPos).attr('y1', env.y.scale.range()[0]).attr('y2', env.y.scale.range()[1]);
	    } else {
	      tGridline.attr('x1', env.x.scale.range()[0]).attr('x2', env.x.scale.range()[1]).attr('y1', yPos).attr('y2', yPos);
	    }

	    tAnchor.attr('r', env.options.tooltipAnchorSize).attr('cx', xPos || 0).attr('cy', yPos || 0); // to speed things up, calculate out of bounds
	    // before placing the label box - determine what
	    // if we need to flip to the other side etc.

	    var pad = env.layout.yAxisInnerPadding();
	    var labelX = xPos + pad + margin.left + env.options.tooltipOffsetX;
	    var labelY = yPos + margin.top + env.options.tooltipOffsetY;
	    var adjustClass = null;
	    var heightEst = env.options.tooltipLineHeight * (series.length + 1);
	    var widthEst = env.options.tooltipMaxWidth;
	    var flipHorizontal = false;
	    var flipVertical = false;

	    if (isStacked) {
	      heightEst = env.options.tooltipLineHeight * (series.length + 2);
	    }

	    if (labelX + widthEst > boundingBox.width) {
	      labelX = Math.max(xPos + pad + margin.left - env.options.tooltipOffsetX, widthEst);
	      adjustClass = 'flipHorizontal';
	      flipHorizontal = true;
	    }

	    if (labelY + heightEst > boundingBox.height) {
	      labelY = Math.max(yPos + margin.top - env.options.tooltipOffsetY, heightEst);
	      adjustClass = 'flipVertical';
	      flipVertical = true;
	    }

	    if (flipVertical && flipHorizontal) {
	      adjustClass = 'flipVH';
	    }

	    tLabelBox.style('left', labelX + 'px').style('top', labelY + 'px').classed('flipHorizontal', adjustClass === 'flipHorizontal').classed('flipVertical', adjustClass === 'flipVertical').classed('flipVH', adjustClass === 'flipVH').classed('single-series', singleSeries || singleSeriesStacked);
	    tLabel.text(formatPrimary(labelValue));
	    var valueDivs = tValues.selectAll('.tooltip-value').data(values);
	    valueDivs.exit().remove();
	    valueDivs.enter().append('div').classed('tooltip-value', true).merge(valueDivs).classed('active', function (d, i) {
	      var index = getIndexWithNullRemoved(i);
	      return index === primaryAxisData.seriesIndex;
	    }).html(function (d, i) {
	      var index = getIndexWithNullRemoved(i);
	      return "\n            <span class=\"swatch bg series-".concat(index, "\"></span>\n            <span class=\"val\">").concat(formatSecondary(d), "</span>\n          ");
	    }).style('display', function (d) {
	      if (!singleSeriesStacked) return 'flex';
	      return d ? 'flex' : 'none';
	    });

	    if (isStacked && !singleSeriesStacked) {
	      tLabelBox.classed('stacked', true);
	      tValues.append('div').classed('tooltip-value', true).classed('total', true).html(function () {
	        return "\n            <span class=\"left\">Total</span>\n            <span class=\"val\">".concat(formatSecondary(dataValue), "</span>\n          ");
	      });
	    }

	    applyColors(tLabelBox.node(), env.data, env.options);
	  }

	  tooltip(opts.chart, tooltipRender, env);
	}

	var ANNOTATION_RADIUS = 4;
	var ANNOTATION_WIDTH = 120;
	var ANNOTATION_WIDTH_MOBILE = 100;
	var PAD_ANNOTATION_LINE = 8;
	var TYPE_LINE = 'line'; // const TYPE_TEXT_MARKER = 'text-plus-marker'

	var TYPE_TEXT_ONLY = 'text-only';
	var TYPE_SHORT_LINE = 'short-line';
	var MOBILE_HIDE = 'hide-on-mobile';
	var LINE_OFFSETS = [{
	  x: -10,
	  y: -5,
	  alignX: 'right',
	  alignY: 'bottom'
	}, {
	  x: -10,
	  y: -30,
	  alignX: 'right',
	  alignY: 'bottom'
	}, {
	  x: -10,
	  y: -60,
	  alignX: 'right',
	  alignY: 'bottom'
	}, {
	  x: -10,
	  y: -100,
	  alignX: 'right',
	  alignY: 'bottom'
	}, {
	  x: -10,
	  y: -180,
	  alignX: 'right',
	  alignY: 'bottom'
	}, {
	  x: 10,
	  y: -5,
	  alignX: 'left',
	  alignY: 'bottom'
	}, {
	  x: 10,
	  y: -30,
	  alignX: 'left',
	  alignY: 'bottom'
	}, {
	  x: 10,
	  y: -60,
	  alignX: 'left',
	  alignY: 'bottom'
	}, {
	  x: 10,
	  y: -100,
	  alignX: 'left',
	  alignY: 'bottom'
	}, {
	  x: 10,
	  y: -180,
	  alignX: 'left',
	  alignY: 'bottom'
	}, {
	  x: -10,
	  y: 5,
	  alignX: 'right',
	  alignY: 'top'
	}, {
	  x: -10,
	  y: 30,
	  alignX: 'right',
	  alignY: 'top'
	}, {
	  x: -10,
	  y: 60,
	  alignX: 'right',
	  alignY: 'top'
	}, {
	  x: -10,
	  y: 100,
	  alignX: 'right',
	  alignY: 'top'
	}, {
	  x: -10,
	  y: 180,
	  alignX: 'right',
	  alignY: 'top'
	}, {
	  x: 10,
	  y: 5,
	  alignX: 'left',
	  alignY: 'top'
	}, {
	  x: 10,
	  y: 30,
	  alignX: 'left',
	  alignY: 'top'
	}, {
	  x: 10,
	  y: 60,
	  alignX: 'left',
	  alignY: 'top'
	}, {
	  x: 10,
	  y: 100,
	  alignX: 'left',
	  alignY: 'top'
	}, {
	  x: 10,
	  y: 180,
	  alignX: 'left',
	  alignY: 'top'
	}];
	var LINE_OFFSETS_NORTH = [{
	  x: -10,
	  y: -5,
	  alignX: 'right',
	  alignY: 'bottom'
	}, {
	  x: 10,
	  y: -5,
	  alignX: 'left',
	  alignY: 'bottom'
	}, {
	  x: -10,
	  y: -30,
	  alignX: 'right',
	  alignY: 'bottom'
	}, {
	  x: 10,
	  y: -30,
	  alignX: 'left',
	  alignY: 'bottom'
	}, {
	  x: -10,
	  y: -60,
	  alignX: 'right',
	  alignY: 'bottom'
	}, {
	  x: 10,
	  y: -60,
	  alignX: 'left',
	  alignY: 'bottom'
	}, {
	  x: -10,
	  y: -100,
	  alignX: 'right',
	  alignY: 'bottom'
	}, {
	  x: 10,
	  y: -100,
	  alignX: 'left',
	  alignY: 'bottom'
	}, {
	  x: -10,
	  y: -180,
	  alignX: 'right',
	  alignY: 'bottom'
	}, {
	  x: 10,
	  y: -180,
	  alignX: 'left',
	  alignY: 'bottom'
	}];
	var LINE_OFFSETS_SOUTH = [{
	  x: -10,
	  y: 5,
	  alignX: 'right',
	  alignY: 'top'
	}, {
	  x: 10,
	  y: 5,
	  alignX: 'left',
	  alignY: 'top'
	}, {
	  x: -10,
	  y: 30,
	  alignX: 'right',
	  alignY: 'top'
	}, {
	  x: 10,
	  y: 30,
	  alignX: 'left',
	  alignY: 'top'
	}, {
	  x: -10,
	  y: 60,
	  alignX: 'right',
	  alignY: 'top'
	}, {
	  x: 10,
	  y: 60,
	  alignX: 'left',
	  alignY: 'top'
	}, {
	  x: -10,
	  y: 100,
	  alignX: 'right',
	  alignY: 'top'
	}, {
	  x: 10,
	  y: 100,
	  alignX: 'left',
	  alignY: 'top'
	}, {
	  x: -10,
	  y: 180,
	  alignX: 'right',
	  alignY: 'top'
	}, {
	  x: 10,
	  y: 180,
	  alignX: 'left',
	  alignY: 'top'
	}];
	var LINE_OFFSETS_NORTHEAST = [{
	  x: 10,
	  y: -5,
	  alignX: 'left',
	  alignY: 'bottom'
	}, {
	  x: 10,
	  y: -30,
	  alignX: 'left',
	  alignY: 'bottom'
	}, {
	  x: 10,
	  y: -60,
	  alignX: 'left',
	  alignY: 'bottom'
	}, {
	  x: 10,
	  y: -100,
	  alignX: 'left',
	  alignY: 'bottom'
	}, {
	  x: 10,
	  y: -180,
	  alignX: 'left',
	  alignY: 'bottom'
	}];
	var LINE_OFFSETS_NORTHWEST = [{
	  x: -10,
	  y: -5,
	  alignX: 'right',
	  alignY: 'bottom'
	}, {
	  x: -10,
	  y: -30,
	  alignX: 'right',
	  alignY: 'bottom'
	}, {
	  x: -10,
	  y: -60,
	  alignX: 'right',
	  alignY: 'bottom'
	}, {
	  x: -10,
	  y: -100,
	  alignX: 'right',
	  alignY: 'bottom'
	}, {
	  x: -10,
	  y: -180,
	  alignX: 'right',
	  alignY: 'bottom'
	}];
	var LINE_OFFSETS_SOUTHEAST = [{
	  x: 10,
	  y: 5,
	  alignX: 'left',
	  alignY: 'top'
	}, {
	  x: 10,
	  y: 30,
	  alignX: 'left',
	  alignY: 'top'
	}, {
	  x: 10,
	  y: 60,
	  alignX: 'left',
	  alignY: 'top'
	}, {
	  x: 10,
	  y: 100,
	  alignX: 'left',
	  alignY: 'top'
	}, {
	  x: 10,
	  y: 180,
	  alignX: 'left',
	  alignY: 'top'
	}];
	var LINE_OFFSETS_SOUTHWEST = [{
	  x: -10,
	  y: 5,
	  alignX: 'right',
	  alignY: 'top'
	}, {
	  x: -10,
	  y: 30,
	  alignX: 'right',
	  alignY: 'top'
	}, {
	  x: -10,
	  y: 60,
	  alignX: 'right',
	  alignY: 'top'
	}, {
	  x: -10,
	  y: 100,
	  alignX: 'right',
	  alignY: 'top'
	}, {
	  x: -10,
	  y: 180,
	  alignX: 'right',
	  alignY: 'top'
	}];
	var OFFSET_MAP = {
	  north: LINE_OFFSETS_NORTH,
	  northwest: LINE_OFFSETS_NORTHWEST,
	  northeast: LINE_OFFSETS_NORTHEAST,
	  east: LINE_OFFSETS_NORTHWEST,
	  west: LINE_OFFSETS_NORTHEAST,
	  south: LINE_OFFSETS_SOUTH,
	  southwest: LINE_OFFSETS_SOUTHWEST,
	  southeast: LINE_OFFSETS_SOUTHEAST
	}; // new style to replace OFFSET_MAP above

	var DEFAULT_OFFSETS = {
	  north: {
	    x: 0,
	    y: -5,
	    alignX: 'middle',
	    alignY: 'bottom'
	  },
	  northwest: {
	    x: -8,
	    y: -5,
	    alignX: 'right',
	    alignY: 'bottom'
	  },
	  northeast: {
	    x: 8,
	    y: -5,
	    alignX: 'left',
	    alignY: 'bottom'
	  },
	  east: {
	    x: 8,
	    y: 8,
	    alignX: 'left',
	    alignY: 'bottom'
	  },
	  west: {
	    x: -8,
	    y: 8,
	    alignX: 'right',
	    alignY: 'bottom'
	  },
	  south: {
	    x: 0,
	    y: 9,
	    alignX: 'middle',
	    alignY: 'top'
	  },
	  southwest: {
	    x: -8,
	    y: 5,
	    alignX: 'right',
	    alignY: 'top'
	  },
	  southeast: {
	    x: 8,
	    y: 5,
	    alignX: 'left',
	    alignY: 'top'
	  }
	};
	var BAR_OFFSETS = [{
	  x: 0,
	  y: -66,
	  alignX: 'middle',
	  alignY: 'bottom'
	}, {
	  x: 0,
	  y: -33,
	  alignX: 'middle',
	  alignY: 'bottom'
	}, {
	  x: 0,
	  y: -16,
	  alignX: 'middle',
	  alignY: 'bottom'
	}];
	var HORIZONTAL_BAR_OFFSETS = [{
	  x: 46,
	  y: 0,
	  alignX: 'left',
	  alignY: 'middle'
	}];
	/**
	  The difficult part of placing annotations is determining where
	  a label can be placed without intersecting the value chart

	*/

	function isIntersectingChart(box, env) {
	  var xNormalized = [box[0] / env.x.scale.range()[1], box[2] / env.x.scale.range()[1]]; // if we are out of bounds return intersection

	  if (box[0] < 0 - env.layout.xAxisInnerPadding() || box[2] > env.x.scale.range()[1] + env.layout.xAxisInnerPadding() || box[1] < 0 - env.layout.yAxisInnerPadding() || box[1] > env.y.scale.range()[0] + env.layout.yAxisInnerPadding()) {
	    return true;
	  }

	  var minMaxPt = [99999, -99999];
	  var points = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; // take ~10 samples over range to determine max/min

	  points.forEach(function (pt) {
	    var x = xNormalized[0] + pt / (points.length - 1) * (xNormalized[1] - xNormalized[0]); // run through each datapoint (if there are multiple lines)

	    var xData = env.x.getDataAtPosition(x);
	    if (xData == null) return;
	    xData.data.forEach(function (d) {
	      if (!d) return;
	      var pos = env.y.scale(d);
	      if (isNaN(pos)) return;
	      minMaxPt[0] = Math.min(minMaxPt[0], pos);
	      minMaxPt[1] = Math.max(minMaxPt[1], pos);
	    });
	  });

	  if (minMaxPt[0] >= box[1] && minMaxPt[0] <= box[3] || minMaxPt[1] >= box[1] && minMaxPt[1] <= box[3]) {
	    return true;
	  } // sometimes the minmax range encompasses the box
	  // no longer doing encompass pass
	  // if (minMaxPt[0] < box[1] && minMaxPt[1] > box[3]) {
	  //   return true
	  // }


	  return false;
	} // Merge old rails underscore properties into mixed case
	// and merge in annotationOptions object into single form


	function normalizeAnnotations(annotations, annotationOptions) {
	  return annotations.map(function (annotation, index) {
	    var item = _objectSpread2(_objectSpread2({}, annotation), annotationOptions[index]);

	    if (item.mobile_display != null) item.mobileDisplay = item.mobile_display;
	    if (item.categorical_value != null) item.categoricalValue = item.categorical_value;
	    if (item.offset_x != null) item.offsetX = item.offset_x;
	    if (item.offset_y != null) item.offsetY = item.offset_y;
	    return item;
	  });
	}

	function lineAnnotations(container, oldAnnotations, env) {
	  if (env.options.disableAnnotations) return;
	  var textAnnotations = env.data.config.textAnnotations;
	  var isStacked = env.data.chartType === 'area';
	  var annotationConfig = env.data.config.annotation_options || {};
	  var annotations = normalizeAnnotations(textAnnotations && textAnnotations.length ? textAnnotations : oldAnnotations || [], annotationConfig);
	  var ga = container.selectAppend('g.annotations');
	  ga.selectAll('*').remove(); // cleanup all existing annotations

	  env.layout.container().selectAll('.annotations-footer *').remove();
	  var cBounds = container.node().getBoundingClientRect();
	  var origin = [cBounds.left + env.layout.yAxisInnerPadding(), cBounds.top + env.layout.xAxisInnerPadding()];
	  annotations.forEach(function (annotation, annotationIndex) {
	    // NOTE:: categorical_value just comes from the v1 editor as the name
	    // of the primary axis, it isn't necessarily categorical
	    var index = fieldIndexOf(env.data.fields[0], annotation.categoricalValue);

	    if (index === -1) {
	      return;
	    } // get type of annotation via annotation id and annotationOptions


	    var type = annotation.type || TYPE_LINE;
	    var hideOnMobile = annotation.mobileDisplay === MOBILE_HIDE;
	    if (env.data.data[index] == null) return;
	    var dataValue = env.data.data[index][annotation.series];

	    if (isStacked) {
	      dataValue = stackedSum(env.data.data[index].slice(1, annotation.series + 1));
	    }

	    var yPos = env.y.scale(dataValue);
	    var xPos = env.x.getPositionFromIndex(index, true);
	    var offsets = OFFSET_MAP[annotation.direction] || LINE_OFFSETS;
	    var radius = env.options.annotationAnchorSize || ANNOTATION_RADIUS;

	    if (type === TYPE_LINE) {
	      ga.append('line').classed("annotation-".concat(annotationIndex), true).classed('annotation-hide-on-mobile', hideOnMobile).attr('x1', xPos * env.x.rangeLength()).attr('x2', xPos * env.x.rangeLength()).attr('y1', env.y.scale.range()[0]).attr('y2', env.y.scale.range()[1]);
	    }

	    var shortLine;

	    if (type === TYPE_SHORT_LINE) {
	      shortLine = ga.append('line').classed("annotation-".concat(annotationIndex), true).classed('annotation-hide-on-mobile', hideOnMobile).attr('x1', xPos * env.x.rangeLength()).attr('x2', xPos * env.x.rangeLength()).attr('y1', yPos).attr('y2', yPos);
	    }

	    if (type !== TYPE_TEXT_ONLY) {
	      ga.append('circle').classed("annotation-".concat(annotationIndex), true).classed('annotation-hide-on-mobile', hideOnMobile).classed('f', true) // for setting fill color to series-1
	      .classed('series-' + (annotation.series - 1), true).attr('cx', xPos * env.x.rangeLength()).attr('cy', yPos).attr('r', radius);
	    }

	    var textItem = ga.append('text').classed("annotation-".concat(annotationIndex), true).classed('annotation-hide-on-mobile', hideOnMobile).attr('x', xPos * env.x.scale.range()[1] + offsets[0].x).attr('y', yPos + offsets[0].y).text(annotation.caption);
	    var wrapWidth = ANNOTATION_WIDTH;
	    if (isMobileWidth(env.layout.width(), env.options)) wrapWidth = ANNOTATION_WIDTH_MOBILE;
	    textItem.each(wrapText$1(wrapWidth));
	    var pad = 12;
	    var box = null;
	    var bounds = textItem.node().getBoundingClientRect();
	    var successfullyPlaced = false;

	    var makePlacement = function makePlacement(offset, i, forcePlacement) {
	      if (successfullyPlaced) return;
	      if (!offset) return;
	      var newX = xPos * env.x.scale.range()[1] + offset.x;
	      var newY = yPos + offset.y;

	      if (!forcePlacement) {
	        newY = Math.min(env.y.scale.range()[0] - bounds.height - pad / 2, newY);
	      }

	      var textY = newY;

	      if (offset.alignY === 'bottom') {
	        textY -= bounds.height;
	      }

	      textItem.attr('x', newX).attr('y', textY).style('text-anchor', function () {
	        if (offset.alignX === 'right') return 'end';
	        if (offset.alignX === 'middle') return 'middle';
	        return 'start';
	      });
	      textItem.selectAll('tspan').attr('x', newX).attr('y', textY);

	      if (shortLine) {
	        shortLine.attr('y2', newY);
	      }

	      bounds = textItem.node().getBoundingClientRect();
	      box = [bounds.left - origin[0], bounds.top - origin[1] - pad, bounds.right - origin[0], bounds.bottom - origin[1] + pad];

	      if (forcePlacement === 'force') {
	        return;
	      }

	      if (!isIntersectingChart(box, env)) {
	        successfullyPlaced = offset;
	      }
	    }; // use custom x y offset from editor


	    if (annotation.direction === 'auto') {
	      offsets.forEach(makePlacement);
	    } else {
	      var customOffset = _extends({}, DEFAULT_OFFSETS[annotation.direction]);

	      if (annotation.offsetX) {
	        customOffset.x = Number(annotation.offsetX);
	      }

	      if (annotation.offsetY) {
	        customOffset.y = Number(annotation.offsetY) * -1;
	      }

	      makePlacement(customOffset, 0, 'force');
	      successfullyPlaced = customOffset;
	    } // if every offset fails we just make sure that the
	    // label is not overshooting the right edge if it is we
	    // swap it to the left side


	    if (!successfullyPlaced && annotation.direction === 'auto') {
	      var newOffset = offsets[offsets.length - 1];
	      newOffset.alignX = 'right';
	      newOffset.x = 10;
	      makePlacement();
	    } // placeRectangleUnderneath(origin, textItem)

	  });
	} // build annotations for column charts

	function columnAnnotations(container, oldAnnotations, env) {
	  if (env.options.disableAnnotations) return;
	  var textAnnotations = env.data.config.textAnnotations;
	  var annotationConfig = env.data.config.annotation_options || {};
	  var annotations = normalizeAnnotations(textAnnotations && textAnnotations.length ? textAnnotations : oldAnnotations || [], annotationConfig); // if anything doesn't fit it becomes a condensed annotation

	  var toCondense = [];
	  var ga = container.selectAppend('g.annotations');
	  ga.selectAll('*').remove();
	  env.layout.container().selectAll('.annotations-footer *').remove(); // note that this means layout is vertical

	  var isHorizontal = env.layout.orientation() === VERTICAL;
	  var isStacked = env.options.stackedBand;
	  var isDumbbell = env.options.isDumbbell;
	  var ignoreSeries = isStacked || env.options.barline || isDumbbell;
	  annotations.forEach(function (annotation, annotationIndex) {
	    // NOTE:: categorical_value just comes from the v1 editor as the name
	    // of the primary axis, it isn't necessarily categorical
	    var index = fieldIndexOf(env.data.fields[0], annotation.categoricalValue);
	    if (env.data.data[index] == null) return;
	    var dataValue = env.data.data[index][annotation.series];
	    var yPos, xPos, textItem, lineItem, offsets, bounds, newVal;

	    if (isStacked) {
	      dataValue = stackedSum(env.data.data[index].slice(1));
	    }

	    var isNegative = dataValue < 0; // get type of annotation via annotation id and annotationOptions

	    var type = annotation.type || TYPE_LINE;
	    var hideOnMobile = annotation.mobileDisplay === MOBILE_HIDE;

	    if (isHorizontal) {
	      dataValue = Math.max(0, dataValue); // we annotate at zero

	      xPos = env.x.scale(dataValue) + PAD_ANNOTATION_LINE;
	      yPos = env.y.getPositionFromIndex([index, annotation.series - 1], ignoreSeries) * env.y.rangeLength();
	      offsets = HORIZONTAL_BAR_OFFSETS; // if we are using labels on horizontal charts
	      // set left value to label left

	      if (env.options.labelCaps) {
	        var label = select('.label-' + index);

	        if (label.node()) {
	          var labelWidth = label.node().getBoundingClientRect().width;
	          xPos += labelWidth + PAD_ANNOTATION_LINE;
	        }
	      }
	    } else {
	      yPos = env.y.scale(dataValue) - PAD_ANNOTATION_LINE;
	      xPos = env.x.getPositionFromIndex([index, annotation.series - 1], ignoreSeries) * env.x.rangeLength();
	      if (isNegative) yPos += 2 * PAD_ANNOTATION_LINE; // offset the pad

	      offsets = BAR_OFFSETS;
	    }

	    var hasPlaced = false;

	    var makePlacement = function makePlacement(offset) {
	      if (hasPlaced) return;

	      if (isHorizontal) {
	        textItem = ga.append('text').classed("annotation-".concat(annotationIndex), true).attr('x', xPos + offset.x).attr('y', yPos + offset.y).style('text-anchor', 'start').text(annotation.caption).classed('annotation-hide-on-mobile', hideOnMobile);

	        if (type === TYPE_LINE || type === TYPE_SHORT_LINE) {
	          lineItem = ga.append('line').classed("annotation-".concat(annotationIndex), true).attr('x1', xPos).attr('x2', xPos + offset.x - PAD_ANNOTATION_LINE).attr('y1', yPos).attr('y2', yPos).classed('annotation-hide-on-mobile', hideOnMobile);
	        }
	      } else {
	        textItem = ga.append('text').classed("annotation-".concat(annotationIndex), true).attr('x', xPos + offset.x).attr('y', yPos + offset.y).style('text-anchor', 'middle').text(annotation.caption).classed('annotation-hide-on-mobile', hideOnMobile); // if west set text anchor at start

	        if (annotation.direction.indexOf('west') !== -1) {
	          textItem.style('text-anchor', 'end');
	        } else if (annotation.direction.indexOf('east') !== -1) {
	          textItem.style('text-anchor', 'start');
	        }

	        var offsetLine = offset.y + PAD_ANNOTATION_LINE;
	        if (dataValue < 0) offsetLine *= -1;

	        if (type === TYPE_LINE || type === TYPE_SHORT_LINE) {
	          lineItem = ga.append('line').classed("annotation-".concat(annotationIndex), true).attr('x1', xPos).attr('x2', xPos).attr('y1', yPos).attr('y2', yPos + offsetLine).classed('annotation-hide-on-mobile', hideOnMobile);
	        }
	      }

	      var wrapWidth = ANNOTATION_WIDTH;
	      if (isMobileWidth(env.layout.width(), env.options)) wrapWidth = ANNOTATION_WIDTH_MOBILE;
	      textItem.each(wrapText$1(wrapWidth)); // vertically align text

	      if (isHorizontal) {
	        bounds = textItem.node().getBoundingClientRect();
	        newVal = yPos + offset.y - bounds.height / 2 + PAD_ANNOTATION_LINE / 4;
	        textItem.attr('y', newVal);
	        textItem.selectAll('tspan').attr('y', newVal);

	        if (xPos + offset.x + bounds.width > env.x.rangeLength()) {
	          if (textItem) textItem.remove();
	          if (lineItem) lineItem.remove();
	        } else {
	          hasPlaced = true;
	        }
	      } else {
	        bounds = textItem.node().getBoundingClientRect(); // if it's a negative value we inverse the offset.y and height

	        if (isNegative) {
	          newVal = yPos - offset.y;
	          textItem.attr('y', newVal);
	          textItem.selectAll('tspan').attr('y', newVal);

	          if (yPos - offset.y + bounds.height > env.y.rangeLength()) {
	            if (textItem) textItem.remove();
	            if (lineItem) lineItem.remove();
	          } else {
	            hasPlaced = true;
	          }
	        } else {
	          newVal = yPos + offset.y - bounds.height;
	          textItem.attr('y', newVal);
	          textItem.selectAll('tspan').attr('y', newVal);

	          if (yPos + offset.y - bounds.height < 0) {
	            if (textItem) textItem.remove();
	            if (lineItem) lineItem.remove();
	          } else {
	            hasPlaced = true;
	          }
	        }
	      }
	    }; // use custom x y offset from editor


	    if (annotation.direction === 'auto') {
	      offsets.forEach(makePlacement);
	    } else {
	      var offsetByDirection = isHorizontal ? HORIZONTAL_BAR_OFFSETS[0] : DEFAULT_OFFSETS[annotation.direction];

	      var customOffset = _extends({}, offsetByDirection);

	      if (annotation.offsetX) {
	        customOffset.x = Number(annotation.offsetX);
	      }

	      if (annotation.offsetY) {
	        customOffset.y = Number(annotation.offsetY) * -1;
	      }

	      makePlacement(customOffset);
	    }

	    if (!hasPlaced) toCondense.push(annotation);
	  });

	  if (!env.options.preventCondensedAnnotations) {
	    condensedAnnotations(container, toCondense, env);
	  }
	} // for the cases where there are really no good solutions for display
	// we use an annotation marker and then place the text underneath the
	// chart

	function condensedAnnotations(container, oldAnnotations, env) {
	  var textAnnotations = env.data.config.textAnnotations;
	  var annotationConfig = env.data.config.annotation_options || {};
	  var annotations = normalizeAnnotations(textAnnotations && textAnnotations.length ? textAnnotations : oldAnnotations || [], annotationConfig);
	  if (!annotations.length) return;
	  var ga = container.selectAppend('g.annotations');
	  var footer = env.layout.container().selectAppend('div.annotations-footer');
	  footer.selectAll('*').remove(); // note that this means layout is vertical

	  var isHorizontal = env.layout.orientation() === VERTICAL;
	  var isStacked = env.options.stackedBand;
	  var ignoreSeries = isStacked || env.options.barline;
	  annotations.forEach(function (annotation, j) {
	    var index = fieldIndexOf(env.data.fields[0], annotation.categoricalValue);

	    if (index === -1) {
	      return;
	    }

	    var dataValue = env.data.data[index][annotation.series];

	    if (isStacked) {
	      dataValue = stackedSum(env.data.data[index].slice(1));
	    }

	    var yPos = null;
	    var xPos = null;
	    var isNegative = dataValue < 0;

	    if (isHorizontal) {
	      xPos = env.x.scale(dataValue) + PAD_ANNOTATION_LINE;
	      yPos = env.y.getPositionFromIndex([index, annotation.series], ignoreSeries) * env.y.rangeLength();
	      yPos -= env.y.scale.bandwidth() / 2;
	      yPos += PAD_ANNOTATION_LINE / 2;

	      if (env.options.labelCaps) {
	        var label = select('.label-' + index);

	        if (label.node()) {
	          var labelWidth = label.node().getBoundingClientRect().width;
	          xPos += labelWidth + PAD_ANNOTATION_LINE;
	        }
	      }
	    } else {
	      yPos = env.y.scale(dataValue) - PAD_ANNOTATION_LINE - PAD_ANNOTATION_LINE;
	      xPos = env.x.getPositionFromIndex([index, annotation.series], ignoreSeries) * env.x.rangeLength();
	      if (isNegative) yPos += 2 * PAD_ANNOTATION_LINE; // offset the pad
	    }

	    var textItem = ga.append('text').classed('condensed-annotation', true).classed('horizontal', isHorizontal).attr('x', xPos).attr('y', yPos + PAD_ANNOTATION_LINE + PAD_ANNOTATION_LINE / 2).text(Array(j + 2).join('*'));

	    if (!isHorizontal) {
	      textItem.style('text-anchor', 'middle').attr('x', xPos);
	    }

	    footer.append('div').html('<span class="star">' + Array(j + 2).join('*') + '</span> ' + annotation.caption);
	  });
	}

	function bandwidthOffset(bandwidth, seriesLength) {
	  return Math.min(5, Math.max(3, 3 / (bandwidth / seriesLength / 32)));
	} // For now this only applies to horizontal bar charts


	function drawColumnLabels(chart, env) {
	  var labelAxis = env.x;
	  var fieldAxis = env.y;
	  var labelGroup = chart.selectAppend('g.label-container');
	  var valFormatter = valueFormatter(env.x, env, {
	    defaultDecimals: 1
	  });
	  var valFormatterAlt = valueFormatter(env.x, env, {
	    bareValue: true,
	    defaultDecimals: 1
	  });
	  var formatter = singleUseFormatter(valFormatter, valFormatterAlt);
	  labelGroup.selectAll('*').remove();
	  labelAxis.field().data.forEach(function (d, index) {
	    labelAxis.series().forEach(function (s, seriesIndex) {
	      var fieldVal = env.data.data[index][0];
	      var fieldPos = fieldAxis.scale(fieldVal);
	      fieldPos += fieldAxis.seriesScale(seriesIndex);
	      var val = env.data.data[index][1 + seriesIndex];
	      var valPos = labelAxis.scale(numberOrNull(val));
	      var seriesLength = labelAxis.series().length;
	      var vOffset = bandwidthOffset(fieldAxis.scale.bandwidth(), seriesLength);
	      var text = labelGroup.append('text').classed('column-label', true).classed('label-' + index, true).text(formatter(val)).attr('x', valPos + env.options.columnLabelOffset).attr('y', fieldPos + fieldAxis.scale.bandwidth() / (seriesLength * 2) + vOffset);

	      if (val < 0) {
	        text.attr('x', valPos - env.options.columnLabelOffset).style('text-anchor', 'end');
	      }
	    });
	  });
	} // These labels are for "table style" horizontal bar charts where the
	// value labels are at the end rather than at bar width

	function drawColumnTableLabels(chart, env) {
	  var labelAxis = env.x;
	  var fieldAxis = env.y;
	  var labelGroup = chart.selectAppend('g.label-container');
	  var valFormatter = valueFormatter(env.x, env, {
	    defaultDecimals: 1
	  });
	  var valFormatterAlt = valueFormatter(env.x, env, {
	    bareValue: true,
	    defaultDecimals: 1
	  });
	  var formatter = singleUseFormatter(valFormatter, valFormatterAlt);
	  labelGroup.selectAll('*').remove();
	  labelAxis.field().data.forEach(function (d, index) {
	    labelAxis.series().forEach(function (s, seriesIndex) {
	      var fieldVal = env.data.data[index][0];
	      var fieldPos = fieldAxis.scale(fieldVal);
	      fieldPos += fieldAxis.seriesScale(seriesIndex);
	      var val = env.data.data[index][1 + seriesIndex];
	      var valPos = env.layout.width();
	      var seriesLength = labelAxis.series().length;
	      var vOffset = bandwidthOffset(fieldAxis.scale.bandwidth(), seriesLength);
	      labelGroup.append('text').classed('column-label', true).classed('label-' + index, true).text(formatter(val)).style('text-anchor', 'start').attr('x', valPos + env.options.columnLabelOffset).attr('y', fieldPos + fieldAxis.scale.bandwidth() / (seriesLength * 2) + vOffset);
	    });
	  });
	} // move into toaster labels
	// label has position, orientation, and text

	function placeOffsetLabel(container, label, env) {
	  var g = container.append('g.label').attr('index', label.index).attr('orientation', label.orientation).attr('extend', label.extend).classed('highlight', label.highlight).attr('transform', "translate(".concat(label.position[0], ", ").concat(label.position[1], ")"));
	  var barStart = [0, 0];
	  var barEnd = [0, 0];
	  var barOffset = env.options.labelLineOffset;

	  if (label.extend === 'top' || label.extend === 'bottom') {
	    // draw a two-level line
	    var barStart0 = [0, 0];
	    var barLength0 = label.extendLength || env.options.labelExtendLength;
	    var barEnd0 = [0, 0];

	    if (label.extend === 'top') {
	      barStart0[1] -= barOffset;
	      barEnd0 = barStart0.slice(0);
	      barEnd0[1] -= barLength0;
	    } else if (label.extend === 'bottom') {
	      barStart0[1] += barOffset;
	      barEnd0 = barStart0.slice(0);
	      barEnd0[1] += barLength0;
	    }

	    g.append('line').attr('x1', barStart0[0] + 'px').attr('y1', barStart0[1] + 'px').attr('x2', barEnd0[0] + 'px').attr('y2', barEnd0[1] + 'px');
	    barStart = barEnd0; // start the next line at the end

	    barOffset = 0;
	  }

	  if (label.orientation === 'right') {
	    barStart[0] += barOffset;
	    barEnd = barStart.slice(0);
	    barEnd[0] += env.options.labelLineLength;
	  } else if (label.orientation === 'left') {
	    barStart[0] -= barOffset;
	    barEnd = barStart.slice(0);
	    barEnd[0] -= env.options.labelLineLength;
	  }

	  g.append('line').attr('x1', barStart[0] + 'px').attr('y1', barStart[1] + 'px').attr('x2', barEnd[0] + 'px').attr('y2', barEnd[1] + 'px');
	  var textObject = {
	    orientation: label.orientation,
	    position: barEnd,
	    line1: label.valueText,
	    line2: label.labelText
	  };
	  placeMultiLineText(g, textObject, env);
	}

	function gridlines(options) {
	  var defaults = {
	    orientation: X,
	    verticalGridLength: 8,
	    extendAllVerticalTicks: false,
	    extendVerticalZeroTick: false,
	    hideBottomValueTick: true,
	    gridTransform: null,
	    useInnerPadding: false,
	    fromDualAxisLayout: false // for different behavior in svelte

	  };
	  options = _extends(defaults, options);

	  function render(selection, env) {
	    var horizontalGrid = options.orientation === X;
	    var axis = horizontalGrid ? env.y : env.x;
	    var grid = AXIS_MAP[axis.position()](axis.scale);
	    var gridPad = options.gridTransform || [env.layout.xAxisInnerPadding() * -1, env.layout.yAxisInnerPadding() * -1];
	    var length = options.length;

	    if (axis.position() === LEFT$1) {
	      length *= -1;
	    } // close the gap on the right


	    if (horizontalGrid && !options.fromDualAxisLayout) {
	      length += env.layout.yAxisPadding();
	    }

	    if (axis.model().tickValues()) {
	      grid.tickValues(axis.model().tickValues());
	    } else {
	      grid.ticks(axis.numTicks());
	    }

	    grid.tickSize(length).tickFormat('');
	    selection.call(grid).classed('vertical-grid', !horizontalGrid);

	    if (options.useInnerPadding) {
	      selection.style('transform', "translate(".concat(gridPad[1], "px, ").concat(gridPad[0], "px)"));
	    } else {
	      if (horizontalGrid) {
	        selection.style('transform', "translate(".concat(gridPad[1], "px, 0px)"));
	      } else {
	        selection.style('transform', "translate(".concat(gridPad[0], "px, 0px)"));
	      }
	    } // set class for zero line


	    selection.selectAll('g.tick').filter(function (d, i) {
	      return d === 0 && i !== 0;
	    }).select('line').attr('class', 'zero-line'); // hide lines at the bottom

	    if (options.hideBottomValueTick) {
	      selection.selectAll('g.tick').filter(function (d) {
	        return Math.abs(axis.range()[0] - axis.scale(d)) < 5;
	      }).select('line').attr('class', 'hide-line');
	    } // make sure vertical ticks are only small ticks


	    if (!horizontalGrid && !options.extendAllVerticalTicks) {
	      selection.selectAll('g.tick').select('line').attr('y1', function () {
	        var el = select(this);

	        if (options.extendVerticalZeroTick && el.classed('zero-line')) {
	          return el.attr('y1');
	        }

	        var y2 = Number(el.attr('y2'));
	        return y2 - options.verticalGridLength;
	      });
	    }

	    return selection;
	  }

	  return render;
	}

	var MIN_WIDTH_ABBREVIATE = 70;
	var MIN_WIDTH_START_CAP = 80;
	var MIN_PIXELS_PER_TICK = 38;
	var MIN_TICKS_FOR_DENSITY = 3;
	var MIN_TICKS_FOR_BAND_DENSITY = 20;
	var MIN_WIDTH_YEAR_CALC = 135;
	var MIN_WIDTH_BAND_TICK = 70;
	var DEFAULT_TICK_PADDING = 4;
	var DEFAULT_AXIS_PADDING = 18;
	var DEFAULT_TIMELINE_AXIS_PADDING = 25;
	var DEFAULT_YEAR_TICK_WIDTH = 40;
	var DEFAULT_YEAR_TICK_THRESHOLD = 55;
	var HALF_YEAR_MONTH = 7; // represents July or later

	var MAX_IDEAL_TICKS = 10;
	/**
	* Each duration type will have a specific padding associated with it in order
	* for labels to be properly aligned to the end caps
	*/

	function axisPadding(chartData) {
	  if (chartData.fields[0] && chartData.fields[0].taxonomy) {
	    if (chartData.fields[0].taxonomy.duration === DURATION_HOURS || chartData.fields[0].taxonomy.duration === DURATION_DAYS || chartData.fields[0].taxonomy.duration === DURATION_WEEKS) {
	      return DEFAULT_TIMELINE_AXIS_PADDING;
	    } else if (chartData.fields[0].taxonomy.duration === DURATION_QUARTERS) {
	      return 0; // 0 because band axis
	    }

	    if (isForceCategorical(chartData.fields[0])) {
	      return 0; // forced to band axis
	    }
	  }

	  return DEFAULT_AXIS_PADDING;
	}
	/**
	* A utility function to run through and hide ticks when they are too
	* densely packed and have gone through the formatter already
	*/

	function hideOverlappingTicks(selection, axis, tickOptions) {
	  var options = tickOptions || {};
	  var checkOnly = options.checkOnly;
	  var ignoreStartEnd = options.ignoreStartEnd;
	  var ticks = getVisibleTicks(selection);
	  if (ticks.length < MIN_TICKS_FOR_DENSITY) return;
	  var hasOverlaps = false;
	  var lastTick = null;
	  var lastTickBounds = null; // store because it's an expensive call

	  var padding = options.padding || DEFAULT_TICK_PADDING;
	  ticks.forEach(function (t, i) {
	    if (!lastTick) {
	      lastTick = t;
	      lastTickBounds = t.getBoundingClientRect();
	      return;
	    }

	    if (checkOnly && hasOverlaps) return;
	    var bounds = t.getBoundingClientRect();

	    if (lastTickBounds.right + padding > bounds.left) {
	      hasOverlaps = true;
	      if (checkOnly) return;
	      var currentTick = select(t);

	      if (ignoreStartEnd) {
	        currentTick.classed('hide-tick', true);
	      } else {
	        // special case for axes that define start/end caps
	        if (!currentTick.classed('start-tick') && !currentTick.classed('end-tick')) {
	          currentTick.classed('hide-tick', true);
	        } else if (lastTick) {
	          select(lastTick).classed('hide-tick', true);
	        }

	        if (currentTick.classed('end-tick')) {
	          currentTick.classed('hide-tick', false);
	        }
	      }
	    } else {
	      lastTick = t;
	      lastTickBounds = bounds;
	    }
	  });
	  return hasOverlaps;
	}
	/**
	* A utility function to run through and hide ticks when they are too
	* densely packed and have gone through the formatter already
	*/

	function showOnlyFirstAndLastTicks(selection, axis, tickOptions) {
	  var ticks = getVisibleTicks(selection);
	  ticks.forEach(function (t, i) {
	    var currentTick = select(t);

	    if (!(currentTick.classed('start-tick') || currentTick.classed('end-tick'))) {
	      currentTick.classed('hide-tick', true);
	    }
	  });
	  return true;
	} // This formatter is geared towards taking a categorical
	// year display and choosing the best iteration of values
	// to display. In the case of sparse values on original
	// ticks that don't match rounded values (%2 and %5) we use the
	// original ticks, all other cases use rounded values.

	function formatYearDisplay(selection, axis, options) {
	  var opts = _objectSpread2({
	    spacing: DEFAULT_YEAR_TICK_WIDTH,
	    threshold: DEFAULT_YEAR_TICK_THRESHOLD,
	    minWidth: MIN_WIDTH_YEAR_CALC,
	    maxIdealTicks: MAX_IDEAL_TICKS
	  }, options); // get all ticks, not just visible ones


	  var ticks = selection.selectAll('.tick').nodes(); // skip when too few values to avoid unneccessary calc

	  if (axis.rangeLength() / ticks.length > opts.threshold) {
	    return;
	  }

	  var toYear = function toYear(v) {
	    return Number(parseDate(v).format('YYYY'));
	  };

	  var priorValues = ticks.map(function (t) {
	    return Number(select(t).attr('tick-value'));
	  });
	  var domain = axis.scale.domain();
	  var domainYear = [toYear(domain[0]), toYear(domain[domain.length - 1])];
	  var idealNumTicks = Math.min(opts.maxIdealTicks, axis.rangeLength() / opts.spacing);
	  var roundValues = d3ticks(domainYear[0], domainYear[1], idealNumTicks); // if priorValues don't contain roundValues it's an oddly spaced set
	  // and we can simply use hideOverlaps

	  var intersection = priorValues.filter(function (x) {
	    return roundValues.includes(x);
	  });

	  if (intersection.length < roundValues.length - 1 || roundValues.length < 2 || axis.rangeLength() < opts.minWidth) {
	    return hideOverlappingTicks(selection);
	  }

	  var yearVisible = {};
	  ticks.forEach(function (t, i) {
	    var tick = select(t);
	    var yearVal = Number(tick.attr('tick-value'));

	    if (roundValues.indexOf(yearVal) !== -1 && !yearVisible[yearVal]) {
	      yearVisible[yearVal] = true;
	      tick.classed('hide-tick', false);
	    } else {
	      tick.classed('hide-tick', true);
	    } // if start / end make sure it's unnabreviated


	    tick.classed('start-tick', yearVal === roundValues[0]).classed('end-tick', yearVal === roundValues[roundValues.length - 1]);
	  });
	}
	function abbreviateYears(selection, axis) {
	  var ticks = getVisibleTicks(selection);
	  var tickWidth = axis.rangeLength() / ticks.length;

	  if (tickWidth < MIN_WIDTH_ABBREVIATE) {
	    ticks.forEach(function (t, i) {
	      if (i !== 0 && i !== ticks.length - 1) {
	        select(t).select('tspan').text(function () {
	          return "'".concat(select(this).text().slice(2));
	        });
	      }

	      if (i === 0) {
	        select(t).classed('tick-start', true);
	      } else if (i === ticks.length - 1) {
	        select(t).classed('tick-end', true);
	      }
	    });
	  }
	} // return ticks that are visible as nodes
	// if start-tick and end-tick nodes exist position them
	// in the proper order

	function getVisibleTicks(selection) {
	  var ticks = selection.selectAll('.tick').nodes();
	  var filtered = ticks.filter(function (tickNode, i) {
	    var t = select(tickNode);
	    return !(t.classed('hide-text') || t.classed('hide-tick') || t.classed('start-tick') || t.classed('end-tick'));
	  });
	  var startTick = selection.select('.start-tick');
	  var endTick = selection.select('.end-tick');
	  if (startTick.size()) filtered.unshift(startTick.node());
	  if (endTick.size()) filtered.push(endTick.node());
	  return filtered;
	} // apply start-tick and end-tick to ticks

	function applyStartEndTick(selection) {
	  var ticks = selection.selectAll('.tick').nodes();

	  if (ticks[0]) {
	    select(ticks[0]).classed('start-tick', true);
	  }

	  if (ticks[ticks.length - 1]) {
	    select(ticks[ticks.length - 1]).classed('end-tick', true);
	  }
	}
	/**
	* Check if the chart falls under mobile width constraints and hide
	* all ticks between first and last
	* When start-tick / end-tick present just use those
	*/

	function hideIntermediateTicksMobile(selection, axis) {
	  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
	  var isBand = options.isBand;
	  var ticks = getVisibleTicks(selection);
	  var avoidOnBand = isBand && axis.rangeLength() / ticks.length > MIN_WIDTH_BAND_TICK;

	  if (axis.rangeLength() <= MOBILE_AXIS_WIDTH && !avoidOnBand) {
	    if (selection.select('.start-tick').size()) {
	      selection.selectAll('.tick').classed('hide-tick', true);
	      selection.select('.start-tick').classed('hide-tick', false);
	      selection.select('.end-tick').classed('hide-tick', false);
	    } else {
	      selection.selectAll('.tick').filter(function (t, i) {
	        return i !== 0 && i !== ticks.size() - 1;
	      }).classed('hide-tick', true);
	    }
	  }
	}
	/**
	* A utility function to run through and hide any repeated ticks
	*/

	function hideDuplicates(selection, axis) {
	  var ticks = getVisibleTicks(selection);
	  var lastTickText = null;
	  ticks.forEach(function (tick) {
	    tick = select(tick);

	    if (!lastTickText) {
	      lastTickText = tick.text();
	      return;
	    }

	    if (tick.text() === lastTickText) {
	      tick.classed('hide-tick', true);
	    } else {
	      lastTickText = tick.text();
	    }
	  });
	}
	/**
	* A utility function to run through and hide line2 text that is
	* repeated. (ie Jan 2018 will only show year on first appearance)
	*/

	function hideLine2Duplicates(selection, axis) {
	  var ticks = getVisibleTicks(selection);
	  var field = axis.field(); // hide all years on yearless sets (months)

	  if (field.taxonomy && field.taxonomy.noYears) {
	    selection.selectAll('.tick').classed('hide-line2', true);
	    return;
	  }

	  var lastTickText = null;
	  ticks.forEach(function (tick) {
	    tick = select(tick);
	    if (!tick.select('.line2').size()) return;

	    if (!lastTickText) {
	      lastTickText = tick.select('.line2').text();
	      return;
	    }

	    if (tick.select('.line2').text() === lastTickText) {
	      tick.classed('hide-line2', true);
	    } else {
	      lastTickText = tick.select('.line2').text();
	    }
	  });
	}
	/**
	* When a custom density is applied we run through and hide ticks as
	* necessary.
	*/

	function applyLabelDensity(selection, axis) {
	  var density = labelDensity(axis);
	  if (density === 1) return;
	  var ticks = getVisibleTicks(selection); // get rid of the first and last

	  ticks = ticks.slice(1, ticks.length - 1);
	  ticks.forEach(function (tick, i) {
	    var $tick = select(tick);
	    $tick.classed('hide-tick', (i + 1) % density !== 0 && !$tick.classed('do-not-hide'));
	  }); // always apply another hideOverlappingTicks afterwards
	  // since we want to keep the first and last from overlapping anything else

	  hideOverlappingTicks(selection);
	}
	function labelDensity(axis) {
	  var field = axis.field();

	  if (!field.auto_density && field.label_density) {
	    return Math.max(field.label_density, 1);
	  }

	  return 1;
	}
	/**
	* By default we don't actually want to hide any band axis ticks
	* (because they should be categorical text) but to prevent situations
	* where too many ticks make it unreadable (when date parsing fails for example)
	* we apply automatic label density only when it overflows.
	*/

	function bandLabelDensity(selection, axis, tickOptions) {
	  var options = tickOptions || {
	    minDensity: MIN_PIXELS_PER_TICK
	  };
	  var ticks = getVisibleTicks(selection);
	  var width = selection.node().getBBox().width;
	  var density = ticks.length / width;
	  if (ticks.length < MIN_TICKS_FOR_BAND_DENSITY) return false;
	  if (density > options.minDensity) return false; // now apply hide overlapping ticks because we are past the
	  // threshold of ticks

	  return hideOverlappingTicks(selection, axis, options);
	}
	function quarterLabelDensity(selection, axis) {
	  // we need custom label density hiding for quarters
	  if (labelDensity(axis) > 1) {
	    var ticks = selection.selectAll('.tick').nodes();
	    ticks.forEach(function (tick) {
	      tick = select(tick);
	      tick.classed('hide-tick', Number(tick.attr('quarter')) !== 1);
	    });
	    applyLabelDensity(selection, axis);
	  }
	}
	function drawDomain(selection, axis, env) {
	  var isVertical = axis.orientation() === VERTICAL; // get rid of the hanging chads on the domain line

	  if (isVertical) {
	    selection.select('.domain').attr('d', 'M' + env.layout.xAxisInnerPadding() * -1 + ',0V0H' + (axis.axisScale.range()[0] + env.layout.xAxisInnerPadding()) + 'V0').classed('vertical-baseline', true);
	  } else {
	    selection.select('.domain').attr('d', 'M' + env.layout.yAxisInnerPadding() * -1 + ',0L' + (axis.axisScale.range()[1] + env.layout.yAxisInnerPadding()) + ',0').classed('horizontal-baseline', true);
	  }
	}
	/**
	* Simple utility function to check if hide_year_display is enabled
	* and remove the second (YEAR) display formatter
	*/

	function filterYearFormatter(formatters, env) {
	  if (env.data.config && env.data.config.hide_year_display) {
	    return [formatters[0]];
	  }

	  return formatters;
	} // The start cap for year display is tricky
	// if in first half of year and enough room between years we
	// include one

	function yearStartCapEnabled(axis, numTicks, env) {
	  var domain = axis.scale.domain();
	  var tickWidth = axis.rangeLength() / numTicks;
	  var startMonth = Number(parseDate(domain[0]).format('M'));

	  if (startMonth < HALF_YEAR_MONTH && tickWidth > MIN_WIDTH_START_CAP) {
	    return true;
	  }

	  return false;
	} // for the bottom zero-axis tick we extend out the domain line to match
	// where the bottom tick would otherwise be

	function extendXAxisDomainBaseline(env) {
	  var widestTickNode = env.el.querySelector('.axis-y .tick:last-child line');
	  if (!widestTickNode) return;
	  var widestTickWidth = widestTickNode.getBoundingClientRect().width;
	  var width = env.layout.outerWidth() + widestTickWidth;
	  select('.grid-x .zero-line').attr('x2', width);
	}

	// - builds a start and end cap
	// - applies date formatters to all ticks
	// - hides elements that collide with start and end cap

	function applyDateAxis (selection, axis, formatters, env, options) {
	  var opts = _objectSpread2({
	    labelGutter: 10,
	    disableStartEndCaps: false,
	    noStartCap: false,
	    noEndCap: true,
	    endCapPriority: false
	  }, options);

	  var labelGutter = opts.labelGutter,
	      noStartCap = opts.noStartCap,
	      noEndCap = opts.noEndCap,
	      disableStartEndCaps = opts.disableStartEndCaps;
	  var showStartCap = !noStartCap && !disableStartEndCaps;
	  var showEndCap = !noEndCap && !disableStartEndCaps;
	  var parseDate = fieldDateParser(axis.field());
	  var initialTicks = selection.selectAll('g.tick');
	  var first = select(initialTicks.nodes()[0]);
	  var last = select(initialTicks.nodes()[initialTicks.size() - 1]);
	  var start;
	  var end;
	  drawDomain(selection, axis, env); // add start / end cap manually

	  if (showStartCap) {
	    start = selection.append('g').classed('start-tick', true);
	    buildDefaultTick(start);
	  }

	  var startVal = '';

	  if (axis.dateScale.domain()[0] && axis.dateScale.domain()[0].toUTCString) {
	    startVal = dateToUTCString(axis.dateScale.domain()[0], axis.field());
	  }

	  var endVal = '';

	  if (axis.dateScale.domain()[1] && axis.dateScale.domain()[1].toUTCString) {
	    endVal = dateToUTCString(axis.dateScale.domain()[1], axis.field());
	  }

	  if (showStartCap) {
	    start.select('text').classed('start-text', true).text(startVal);
	  } // default is no endcaps, but it can be set to false


	  if (showEndCap) {
	    end = selection.append('g').classed('end-tick', true).attr('transform', 'translate(' + axis.dateScale.range()[1] + ',0)');
	    buildDefaultTick(end);
	    end.select('text').classed('end-text', true).text(endVal);
	  }

	  var ticks = selection.selectAll('g.tick').select('text').each(function (d, i) {
	    var textElement = select(this);
	    var textVal = textElement.text();
	    var yText = textElement.attr('y');
	    var f = formatters;

	    if (opts.startCapFormatters && textElement.classed('start-text')) {
	      if (opts.requiresFormatting) {
	        if (opts.requiresFormatting(textVal)) {
	          f = opts.startCapFormatters;
	        }
	      } else {
	        f = opts.startCapFormatters;
	      }
	    } // textElement.attr('text-anchor', 'start')


	    textElement.text(null);
	    textElement.append('tspan').attr('x', 0).attr('y', yText).attr('dy', axis.axisTextMarginHorizontal() + 'px').classed('line1', true).text(f[0](parseDate(textVal))); // allow a month display unless data is years only

	    if (f[1] && !opts.axisTextSingleLine) {
	      textElement.append('tspan').attr('x', 0).attr('y', yText).attr('dy', axis.axisTextMarginHorizontal() + axis.axisTextLineHeight() + 'px').classed('line2', true).text(f[1](parseDate(textVal)));
	    }
	  });
	  var visibleCount = 2 + initialTicks.size(); // hide the first tick text if it overlaps with start item

	  initialTicks.each(function () {
	    if (showStartCap && (start.node().getBoundingClientRect().right > this.getBoundingClientRect().left - labelGutter || start.text() === select(this).text())) {
	      select(this).classed('hide-tick', true);
	      visibleCount--;
	    }

	    if (showEndCap && (this.getBoundingClientRect().right + labelGutter > end.node().getBoundingClientRect().left || end.text() === select(this).text())) {
	      if (opts.endCapPriority) {
	        select(this).classed('hide-tick', true);
	      } else {
	        end.classed('hide-tick', true);
	      }

	      visibleCount--;
	    }
	  });
	  return {
	    initial: initialTicks,
	    all: ticks,
	    first: first,
	    last: last,
	    start: start,
	    end: end,
	    visibleCount: visibleCount
	  };
	}

	function buildDefaultTick(sel) {
	  sel.classed('tick', true);
	  sel.append('line').attr('x1', 0.5).attr('x2', 0.5).attr('y2', 6);
	  sel.append('text').attr('y', 9).attr('x', 0.5).attr('dy', '0.71em').attr('text-anchor', 'middle');
	}

	function hourlyAxis(selection, axis, env, options) {
	  var numTicks = Math.max(2, Math.floor(axis.range()[1] / axis.tickStepHorizontal()));
	  var _env$options$hourlyFo = env.options.hourlyFormat,
	      hourlyFormat = _env$options$hourlyFo === void 0 ? 'HH:mm' : _env$options$hourlyFo;
	  var formatters = [function (v) {
	    return v.format(hourlyFormat);
	  }, function (v) {
	    return v.format('MMM D');
	  }];

	  if (axis.range()[1] < 600) {
	    numTicks *= 1.5;
	  }

	  numTicks /= labelDensity(axis);
	  axis.model().ticks(numTicks).tickFormat(function (d, i) {
	    return dateToUTCString(d, axis.field());
	  });
	  selection.call(axis.model());
	  applyDateAxis(selection, axis, formatters, env);
	  hideOverlappingTicks(selection);
	  hideLine2Duplicates(selection, axis);
	  return selection;
	}

	function dayAxis(selection, axis, env, options) {
	  var numTicks = Math.max(2, Math.floor(axis.rangeLength() / axis.tickStepHorizontal()));
	  var formatters = [function (v) {
	    return v.format('ddd');
	  }, function (v) {
	    return v.format('MMM D');
	  }];
	  numTicks /= labelDensity(axis);
	  axis.model().ticks(numTicks).tickFormat(function (d, i) {
	    return dateToUTCString(d, axis.field());
	  });
	  selection.call(axis.model());
	  applyDateAxis(selection, axis, formatters, env, {
	    noEndCap: false
	  });
	  hideDuplicates(selection);
	  hideOverlappingTicks(selection);
	  hideLine2Duplicates(selection, axis);
	  return selection;
	}

	/**
	  Each type of axis formatting will have it's own builder - defining the
	  optimal number of ticks, applying to selection and then a postRender
	  function to separate multiple lines and clean things up.
	*/

	function monthPlusAxis(selection, axis, env, options) {
	  var formatters = filterYearFormatter([function (v) {
	    return v.format('MMM D');
	  }, function (v) {
	    return v.format('YYYY');
	  }], env);

	  var opts = _objectSpread2(_objectSpread2({}, options), {}, {
	    noEndCap: false,
	    endCapPriority: true
	  });

	  axis.model().ticks(d3timeDay).tickFormat(function (d, i) {
	    return dateToUTCString(d, axis.field());
	  });
	  selection.call(axis.model());
	  var ticks = applyDateAxis(selection, axis, formatters, env, opts); // now the tricky part hide sequential years
	  // also hide anything that isn't 1st or 15th of the month

	  var isFirstOr15th = function isFirstOr15th(text) {
	    var tokens = text.split(' ');
	    return ['1', '15'].indexOf(tokens[tokens.length - 1]) !== -1;
	  };

	  ticks.initial.each(function () {
	    var tick = select(this);
	    if (tick.classed('hide-tick')) return;

	    if (!isFirstOr15th(tick.select('.line1').text())) {
	      tick.classed('hide-tick', true);
	    }
	  }); // if there are less than 3 visible ticks ignore the first or fifteen approach
	  // and just show every 5 ticks

	  var visibleTicks = getVisibleTicks(selection);

	  if (visibleTicks.length < 3) {
	    ticks.initial.each(function (val, i) {
	      select(this).classed('hide-tick', function () {
	        return i % 5 !== 0;
	      });
	    });
	  }

	  hideDuplicates(selection);
	  hideOverlappingTicks(selection);
	  applyLabelDensity(selection, axis);
	  hideLine2Duplicates(selection, axis);
	  return selection;
	}

	var MIN_TICKS = 2;
	/**
	  Each type of axis formatting will have it's own builder - defining the
	  optimal number of ticks, applying to selection and then a postRender
	  function to separate multiple lines and clean things up.
	*/

	function monthlyAxis(selection, axis, env, options) {
	  var opts = options || {};
	  var density = labelDensity(axis);
	  var formatters = filterYearFormatter([function (v) {
	    return v.format('MMM');
	  }, function (v) {
	    return v.format('YYYY');
	  }], env);
	  var numTicks = Math.max(MIN_TICKS, Math.floor(axis.rangeLength() / axis.tickStepHorizontal()));
	  numTicks /= density;

	  if (density > 2) {
	    opts.noEndCap = false;
	  } // when the chart has Quarterly defined present as quarters


	  if (env.data.chartOptions && env.data.chartOptions.dateOutputFormat) {
	    if (env.data.chartOptions.dateOutputFormat === OUTPUT_FORMAT_QUARTERS) {
	      formatters[0] = formatDateAsQuarter;
	    } else if (env.data.chartOptions.dateOutputFormat === OUTPUT_FORMAT_YEARS) {
	      formatters = [function (v) {
	        return v.format('YYYY');
	      }];
	    }
	  }

	  axis.model().ticks(numTicks).tickFormat(function (d, i) {
	    return dateToUTCString(d, axis.field());
	  });
	  selection.call(axis.model());
	  applyDateAxis(selection, axis, formatters, env, opts); // apply fixes post render

	  hideDuplicates(selection);
	  hideOverlappingTicks(selection);
	  hideLine2Duplicates(selection, axis);
	  return selection;
	}

	/**
	  Each type of axis formatting will have it's own builder - defining the
	  optimal number of ticks, applying to selection and then a postRender
	  function to separate multiple lines and clean things up.
	*/

	function decadeAxis(selection, axis, env, options) {
	  var numTicks = Math.max(2, Math.floor(axis.range()[1] / axis.tickStepHorizontal()));
	  var durationYears = getDurationYears(axis.field(), axis.dateScale.domain());
	  var formatters = [function (v) {
	    return v.format('YYYY');
	  }];

	  var opts = _objectSpread2({
	    noStartCap: false,
	    noEndCap: true,
	    endCapPriority: false
	  }, options);

	  var isMobile = axis.rangeLength() <= MOBILE_AXIS_WIDTH;
	  var isVertical = axis.orientation() === VERTICAL;
	  var noAbbreviation = isMobile || isForceCategorical(axis.field());
	  numTicks = Math.min(numTicks, durationYears);
	  numTicks /= labelDensity(axis); // some cases we want the startCap

	  opts.noStartCap = !yearStartCapEnabled(axis, numTicks); // for mobile we need the endcap

	  if (isMobile) {
	    opts.noEndCap = false;
	    opts.noStartCap = false;
	  }

	  axis.model().ticks(numTicks).tickFormat(function (d, i) {
	    return dateToUTCString(d, axis.field());
	  });
	  selection.call(axis.model());
	  applyDateAxis(selection, axis, formatters, env, opts);

	  if (!noAbbreviation && !isVertical) {
	    hideDuplicates(selection);
	    abbreviateYears(selection, axis);
	  } else {
	    hideDuplicates(selection);
	  }

	  if (isMobile) {
	    hideIntermediateTicksMobile(selection, axis);
	  } else {
	    hideOverlappingTicks(selection);
	  }

	  return selection;
	}

	function decadePlusAxis(selection, axis, env) {
	  var numTicks = Math.max(2, Math.floor(axis.rangeLength() / (axis.tickStepHorizontal() * 2.0)));
	  var durationYears = getDurationYears(axis.field(), axis.dateScale.domain());
	  var formatters = [function (v) {
	    return v.format('YYYY');
	  }];
	  var options = {
	    axisTextSingleLine: true,
	    labelGutter: 30,
	    noEndCap: false,
	    endCapPriority: false
	  };
	  numTicks = Math.min(numTicks, durationYears);
	  numTicks /= labelDensity(axis);
	  axis.model().ticks(numTicks).tickFormat(function (d, i) {
	    return dateToUTCString(d, axis.field());
	  });
	  selection.call(axis.model());
	  applyDateAxis(selection, axis, formatters, env, options);
	  hideIntermediateTicksMobile(selection, axis);
	  hideDuplicates(selection);
	  formatYearDisplay(selection, axis);
	  var isVertical = axis.orientation() === VERTICAL;
	  var noAbbreviation = isForceCategorical(axis.field());

	  if (!noAbbreviation && !isVertical) {
	    abbreviateYears(selection, axis);
	  }

	  applyLabelDensity(selection, axis);
	  return selection;
	}

	var MAX_VERTICAL_TICKS = 8;
	var MAX_VERTICAL_TICKS_CUSTOM = 14;
	var MIN_TICK_HEIGHT = 25;
	var TICK_WIDTH_OFFSET = 8; // caps out at 10 but increases until we get a whole number divisor

	var getNumTicksFromDomain = function getNumTicksFromDomain(numTicks, domain) {
	  var foundValue = false;

	  while (!foundValue && numTicks < MAX_VERTICAL_TICKS) {
	    var tickValues = d3ticks(domain[0], domain[1], numTicks);

	    if (tickValues[tickValues.length - 1] === domain[1]) {
	      foundValue = true;
	    } else {
	      numTicks++;
	    }
	  }

	  return numTicks;
	};

	function applyCustomStep(step, domain) {
	  var numTicks = Math.floor(Math.min(MAX_VERTICAL_TICKS_CUSTOM, Math.max(2, Math.abs(domain[1] - domain[0]) / step)));
	  var customSteps = range$2(numTicks + 1).map(function (i) {
	    return domain[0] + i * step;
	  });
	  var customDomain = [customSteps[0], customSteps[customSteps.length - 1]];
	  return [customSteps, customDomain];
	}

	var displayAsMultiplier = function displayAsMultiplier(axis) {
	  var multiplier = 1;

	  if (axis.field().display_as && DISPLAY_AS_MULTIPLIERS[axis.field().display_as]) {
	    multiplier = DISPLAY_AS_MULTIPLIERS[axis.field().display_as];
	  }

	  return function (v) {
	    return v * multiplier;
	  };
	};
	/**
	  Right now this is both vertical and horizontal
	*/


	function numericAxis(selection, axis, env) {
	  var valueMultiplier = displayAsMultiplier(axis);
	  var field = axis.field();
	  var isVertical = axis.orientation() === VERTICAL;
	  var rangeMax = isVertical ? axis.range()[0] : axis.range()[1];
	  var tickStep = isVertical ? axis.tickStepVertical() : axis.tickStepHorizontal();
	  var customDomain = hasCustomDomain(env.data, axis.field());
	  var tickAtDomainTop = customDomain || env.options.forceTickAtDomainTop;
	  var minTicks = env.options.minimumTicks == null ? 3 : env.options.minimumTicks;
	  var forceNoTicks = env.options.forceNoTicks;
	  var offsetPadding = env.layout.yAxisPadding();
	  var bwStyleTicks = isSingleCharLabel(field) && (env.data.theme === 'bizweek' || env.data.theme === 'bizweek-dark' || env.options.bwStyleTicks);

	  var _ref = field.numericProperties ? field.numericProperties : env.data.chartOptions,
	      scaleStep = _ref.scaleStep;

	  var formatOptions = _objectSpread2({
	    bareValue: true,
	    voidDecimals: true,
	    forceCommaDisplay: env.options.forceCommaDisplay || env.data.config.force_comma_display
	  }, field.numericProperties);

	  formatOptions.decimalPlaces = formatOptions.decimals;
	  var formatter = valueFormatter(axis, env, formatOptions);
	  var domain = axis.axisScale.domain();
	  var numTicks = Math.min(MAX_VERTICAL_TICKS, Math.max(minTicks, Math.floor(rangeMax / tickStep)));
	  var tickValues; // apply nice() with numTicks only if not a customDomain

	  if (!customDomain) {
	    axis.axisScale.nice(Math.max(numTicks, minTicks));
	    domain = axis.axisScale.domain();
	  }

	  axis.numTicks(numTicks);
	  axis.model().ticks(numTicks).tickFormat(formatter); // custom domain step

	  if (tickAtDomainTop) {
	    numTicks = getNumTicksFromDomain(minTicks, domain);
	    tickValues = d3ticks(domain[0], domain[1], numTicks);

	    if (tickValues.length > numTicks && isMixedDomain(env.data)) {
	      var customStep = greatestCommonDivisor(domain[0], domain[1]);

	      var _applyCustomStep = applyCustomStep(customStep, domain),
	          _applyCustomStep2 = _slicedToArray(_applyCustomStep, 1),
	          customSteps = _applyCustomStep2[0];

	      if (customSteps.length < tickValues.length) {
	        numTicks = customSteps.length;
	        tickValues = customSteps;
	      }
	    }

	    axis.numTicks(numTicks);
	    axis.model().tickValues(tickValues);
	  }

	  if (hasCustomDomainStep(env.data, axis.field())) {
	    domain = axis.axisScale.domain();

	    var _applyCustomStep3 = applyCustomStep(scaleStep, domain),
	        _applyCustomStep4 = _slicedToArray(_applyCustomStep3, 2),
	        _customSteps = _applyCustomStep4[0],
	        _customDomain = _applyCustomStep4[1];

	    numTicks = _customSteps.length;
	    axis.numTicks(numTicks);
	    axis.model().tickValues(_customSteps);
	    axis.axisScale.domain(_customDomain);
	  } // this apparatus is to determine the best way to display the
	  // axis values based on the values themselves


	  var mDomain = domain.map(valueMultiplier);
	  tickValues = d3ticks(mDomain[0], mDomain[1], numTicks);

	  if (forceNoTicks) {
	    tickValues = mDomain;
	    axis.model().tickValues(tickValues);
	  }

	  formatOptions = prepareTickFormatOptions(tickValues, formatOptions, axis, env);
	  formatter = valueFormatter(axis, env, formatOptions);
	  axis.model().tickFormat(formatter);
	  var axisNode = selection.call(axis.model()).classed(axis.position(), true) // TODO :: move to layout
	  .classed('vcenter', !!axis.val('axisTextCenterVertical'));
	  var enoughSpaceForTickUnderneath = axis.rangeLength() / tickValues.length > MIN_TICK_HEIGHT;
	  axis.isCondensedAxis(!enoughSpaceForTickUnderneath);

	  if (isVertical && !enoughSpaceForTickUnderneath) {
	    var validate = validator(env.data);
	    validate('Too many ticks for proper grid display. Please set custom step.', function () {
	      return true;
	    });
	  }

	  axisNode.classed('no-line', isVertical && enoughSpaceForTickUnderneath && !shouldDisplayGridY(env) || !isVertical && !shouldDisplayGridX(env));
	  axisNode.classed('variant-above', isVertical && enoughSpaceForTickUnderneath); // IF NEW STYLE AXIS

	  if (isVertical) {
	    axisNode.classed('no-domain', true);
	  }

	  if (isVertical && enoughSpaceForTickUnderneath) {
	    var cWidth = 0;
	    var postWidth = 0;
	    var texts = axisNode.selectAll('.tick text');
	    texts.each(function (d, i) {
	      var el = select(this);
	      var text = el.text();
	      var numeric = text.replace(/[^\d,.-]/g, '');
	      var rest = text.split(numeric); // keep pre
	      // zero line logic -- always apply in the middle and optionally apply
	      // when it's at the base

	      if (Number(numeric) === 0) {
	        var skipZeroAxisLabel = i === 0 && axis.showZeroLineAtBase() === false;

	        if (!skipZeroAxisLabel) {
	          select(el.node().parentElement).classed('zero-line', true);
	        }
	      }

	      if (i === texts.size() - 1) {
	        el.html("<tspan class=\"pre\">".concat(rest[0], "</tspan><tspan class=\"val\">").concat(numeric, "</tspan><tspan class=\"post\">").concat(rest[1], "</tspan>"));
	      } else {
	        el.html("<tspan class=\"val\">".concat(numeric, "</tspan>"));
	      }
	    }); // calculate width of widest tick

	    axisNode.selectAll('.tick tspan.val').each(function (d, i) {
	      if (this.getComputedTextLength) {
	        cWidth = Math.max(cWidth, this.getComputedTextLength());
	      }
	    });
	    axisNode.selectAll('.tick tspan.post').each(function (d, i) {
	      if (this.getComputedTextLength) {
	        postWidth = Math.max(postWidth, this.getComputedTextLength());
	      }
	    });
	    axisNode.select('.tick').classed('base', true).classed('negative', function (d) {
	      return d < 0;
	    });
	    axisNode.selectAll('.tick').each(function (d, i) {
	      // without the weirdOffset the lines don't perfectly match
	      var weirdOffset = i === 0 ? -0.5 : 0;
	      var tick = select(this);

	      var _parseSvg = parseSvg(tick.attr('transform')),
	          translateY = _parseSvg.translateY;

	      var translate = [cWidth - offsetPadding, translateY + weirdOffset];
	      tick.attr('transform', "translate(".concat(translate[0], ", ").concat(translate[1], ")"));
	    });
	    axisNode.selectAll('.tick text').attr('dy', '-9px');
	    var gridExtendOffset = shouldDisplayGridY(env) ? 5 : 0;
	    axisNode.selectAll('.tick line').style('visibility', 'visible').style('display', 'block').attr('x1', cWidth * -1 + offsetPadding).attr('x2', function () {
	      return bwStyleTicks && shouldDisplayGridY(env) ? offsetPadding + 1 + gridExtendOffset + postWidth : offsetPadding + 1 + gridExtendOffset;
	    });

	    if (!axis.skipYAxisExtend()) {
	      var extendWidth = bwStyleTicks && shouldDisplayGridY(env) ? cWidth + gridExtendOffset + postWidth : cWidth + gridExtendOffset;
	      extendTick(axisNode.select('.tick.base'), extendWidth, env);
	    }
	  }

	  if (!isVertical) {
	    var verticalTickLength = axis.verticalTickLength() || 6;
	    axisNode.selectAll('.tick text').attr('dy', "".concat(verticalTickLength + TICK_WIDTH_OFFSET, "px"));
	    axisNode.selectAll('.tick line').attr('y2', verticalTickLength);

	    if (axis.leftAlignStartTick()) {
	      axisNode.select('.tick text').classed('left-align', true).attr('transform', 'translate(-5, 0)');
	    }

	    drawDomain(selection, axis, env);
	  }

	  selection.node().getBoundingClientRect();
	  var ticks = selection.selectAll('g.tick');
	  var negativeAxis = axis.axisScale.domain()[0] < 0; // hide every other label and the first (at bottom)

	  if (axis.tickLabelAlternate()) {
	    var modHide = ticks.size() % 2 === 0 ? 0 : 1;
	    var hideFirstTick = ticks.size() > 5;
	    ticks.each(function (d, i) {
	      if (negativeAxis) {
	        if (i % 2 === modHide) {
	          select(this).classed('hide-text', true);
	        }
	      } else {
	        if (hideFirstTick && i === 0 || i % 2 === modHide) {
	          select(this).classed('hide-text', true);
	        }
	      }
	    });
	  } // if only one tick is visible we must show the bottom tick
	  // to build a range


	  if (getVisibleTicks(selection).length === 1) {
	    select(ticks.nodes()[0]).classed('hide-text', false);
	  }

	  return selection;
	} // This is a tricky one -- in order to get the domain to match
	// up 100% with the bottom tick it's better to extend the domain
	// out to the edge rather than try to line it up. So we do this:

	function extendTick(baseTick, tickWidth, env, postWidth) {
	  // && baseTick.classed('zero-line')
	  if (shouldDisplayDomain(env)) {
	    env.layout.addPostLayoutHandler('extendTick', function (el, env, layout) {
	      var domain = env.layout.g().select('.axis-x .domain');
	      var dTokens = domain.attr('d').split('L'); // MX,0,LX2,0   --  M-22,0V0H512V0

	      var width = layout.outerWidth() - layout.yAxisInnerPadding();
	      width += tickWidth + layout.yAxisPadding();
	      domain.attr('d', "".concat(dTokens[0], "L").concat(width, ",0"));
	      domain.attr('tick-extend-has-executed', true);
	      baseTick.select('line').style('display', 'none');
	    });
	  } else {
	    env.layout.removePostLayoutHandler('extendTick');
	    baseTick.select('line').style('display', 'block');
	  }
	}

	var TICK_SPACE = -6;
	var LINE_PAD = 1;
	function bandAxis(selection, axis, env, options) {
	  var isVertical = axis.orientation() === VERTICAL;
	  var pad = axis.axisTextPadding();
	  axis.model().tickFormat(function (d) {
	    if (env.options.categoricalFormatter) {
	      return env.options.categoricalFormatter(d);
	    } else {
	      return d;
	    }
	  });
	  selection.call(axis.model()).classed('no-ticks', false);
	  selection.selectAll('g.tick text').each(function (p, i) {
	    var t = select(this);
	    var textVal = t.text();
	    select(t.node().parentNode).attr('tick-value', textVal);
	  }); // draw invisible bounds on the axis

	  makeAxisBounds(selection, axis);
	  drawDomain(selection, axis, env);

	  if (isVertical) {
	    selection.selectAll('g.tick line').attr('display', 'none'); // multiline becomes single line in HBar mode

	    if (env.options.multilineFormatter) {
	      selection.selectAll('g.tick text').each(renderMultiLineText({
	        margin: axis.axisTextMarginHorizontal(),
	        lineHeight: axis.axisTextLineHeight(),
	        isHorizontalText: true
	      }));
	    }

	    if (env.options.mobileColumnChart) {
	      var offsetLabel = axis.axisScale.bandwidth() / 2 * -1;
	      offsetLabel -= env.options.mobileColumnOffset || 0;
	      selection.selectAll('g.tick text').classed('left-align', true).attr('dy', offsetLabel + 'px');
	    } else if (axis.verticalAxisWrapWidth) {
	      selection.selectAll('g.tick text').each(wrapText(axis.verticalAxisWrapWidth(), axis));
	    }
	  } else {
	    if (env.options.multilineFormatter) {
	      selection.selectAll('g.tick text').each(renderMultiLineText({
	        margin: axis.axisTextMarginHorizontal(),
	        lineHeight: axis.axisTextLineHeight()
	      }));
	    } else if (axis.axisScale.step) {
	      selection.selectAll('g.tick text').each(wrapText(axis.axisScale.step() - pad, axis));
	    } // no tick style for column / bar charts
	    // only apply when domain is displayed


	    if (shouldDisplayDomain(env) && !shouldDisplayDomainTicks(env)) {
	      selection.classed('no-ticks', true);
	      selection.selectAll('g.tick').each(function () {
	        var tick = select(this);

	        var _parseSvg = parseSvg(tick.attr('transform')),
	            translateX = _parseSvg.translateX;

	        tick.attr('transform', "translate(".concat(translateX, ", ").concat(TICK_SPACE, ")"));
	      });
	    }
	  }

	  if (!isVertical) {
	    hideDuplicates(selection);
	    hideLine2Duplicates(selection, axis); // apparently some people want to apply labelDensity to categorical

	    if (labelDensity(axis) === 1) {
	      // DISABLE OVERLAP for discrete bands
	      // hideOverlappingTicks(selection, axis, { discrete: true })
	      bandLabelDensity(selection, axis);
	    } else {
	      applyLabelDensity(selection, axis);
	    }
	  }

	  return selection;
	} // if a label is longer than the width of an axis band, wrap it over
	// multiple lines.

	function wrapText(width, axis) {
	  return function (d) {
	    var newLineToken = '<N>';
	    var text = select(this);
	    var textVal = text.text().replace(/\n|<br>/g, ' ' + newLineToken + ' ');
	    var isVertical = axis.orientation() === VERTICAL;
	    var y = Number(text.attr('y'));
	    var words = textVal.trim().split(/\s+/).reverse();
	    var word;
	    var lineNumber = 0;
	    var newWidth = Number(width);
	    var lineHeight = axis.axisTextLineHeight(); // px

	    var dy = axis.axisTextMarginHorizontal();

	    if (axis.orientation() === VERTICAL) {
	      dy = axis.axisTextMarginVertical();
	    }

	    var tspan = text.text(null).attr('dy', null).append('tspan').attr('x', 0).attr('y', y + dy + 'px');
	    var hasWrapped = false;
	    var line = []; // vertical axis === horizontal bars

	    if (isVertical) {
	      lineHeight = axis.axisTextLineHeightHorizontal();
	    }

	    if (words.length === 1) {
	      newWidth = 9999; // basically disable wrap
	    }

	    var pushCount = 0;

	    while (word = words.pop()) {
	      line.push(word);
	      pushCount++;
	      tspan.text(line.join(' '));
	      tspan.classed('line-' + (lineNumber + 1));
	      tspan.attr('yval', lineNumber * lineHeight + dy);

	      if (tspan.node().getComputedTextLength() > newWidth && pushCount > 1 || word === newLineToken) {
	        if (word === newLineToken) word = '';
	        hasWrapped = true;
	        line.pop();
	        tspan.text(line.join(' ').trim());
	        line = [word];
	        tspan = text.append('tspan').attr('x', 0).attr('y', y).attr('y', ++lineNumber * (lineHeight + LINE_PAD) + y + dy + 'px').attr('yval', lineNumber * (lineHeight + LINE_PAD) + y + dy).text(word);
	      }
	    } // middle alignment happens in vertical layouts


	    if (hasWrapped && axis.orientation() === VERTICAL) {
	      var textHeight = text.node().getBoundingClientRect().height;
	      var adjust = (textHeight - lineHeight) / 2;
	      text.style('transform', "translateY(".concat(Math.min(0, adjust * -1), "px)"));
	    }
	  };
	}

	function yearBandAxis(selection, axis, env, options) {
	  bandAxis(selection, axis, env);
	  applyStartEndTick(selection);
	  hideIntermediateTicksMobile(selection, axis, {
	    isBand: true
	  });
	  formatYearDisplay(selection, axis);
	  var isVertical = axis.orientation() === VERTICAL;
	  var noAbbreviation = isForceCategorical(axis.field());

	  if (!noAbbreviation && !isVertical) {
	    abbreviateYears(selection, axis);
	  }

	  applyLabelDensity(selection, axis);
	  return selection;
	}

	/**
	  Each type of axis formatting will have it's own builder - defining the
	  optimal number of ticks, applying to selection and then a postRender
	  function to separate multiple lines and clean things up.
	*/

	function quarterAxis(selection, axis, env, options) {
	  var field = axis.field();
	  var valueParser = quarterSplitValueParser(field);
	  axis.model().tickFormat(function (d) {
	    return d;
	  });
	  selection.call(axis.model());
	  drawDomain(selection, axis, env);
	  var textItems = selection.selectAll('g.tick text');
	  var firstText = select(textItems.nodes()[0]).text();
	  var firstQuarter = valueParser(firstText)[1];
	  var qOffset = firstQuarter % 2 === 0 ? 0 : 1;
	  textItems.each(function (d, i) {
	    var textElement = select(this);
	    var textVal = textElement.text();
	    var yText = textElement.attr('y');
	    var quarterText;

	    var _valueParser = valueParser(textVal),
	        _valueParser2 = _slicedToArray(_valueParser, 2),
	        year = _valueParser2[0],
	        quarter = _valueParser2[1];

	    var yearText = year;
	    quarterText = 'Q' + quarter;

	    if (i !== 0 && axis.axisScale.bandwidth() <= 25 && axis.axisScale.bandwidth() > 15) {
	      quarterText = i % 2 === qOffset ? '' : quarterText;
	    } else if (i !== 0 && axis.axisScale.bandwidth() <= 15) {
	      quarterText = quarter === 1 ? quarterText : '';
	    }

	    select(this.parentNode).attr('quarter', quarter);
	    textElement.text(null);
	    textElement.append('tspan').attr('x', 0).attr('y', yText).attr('dy', axis.axisTextMarginHorizontal() + 'px').classed('line1', true).text(quarterText);
	    textElement.append('tspan').attr('x', 0).attr('y', yText).attr('dy', axis.axisTextMarginHorizontal() + axis.axisTextLineHeight() + 'px').classed('line2', true).text(yearText);

	    if (quarterText === '') {
	      select(textElement.node().parentNode).classed('hide-tick', true);
	    }
	  });
	  quarterLabelDensity(selection, axis); // using padding -10 because of year line

	  hideOverlappingTicks(selection, axis, {
	    padding: -10
	  });
	  hideLine2Duplicates(selection, axis);
	  return selection;
	}

	var TICK_YVAL = 6;
	var TEXT_YVAL = 9;
	var TEXT_DYVAL = '0.71em';
	/**
	  The Periodic axis is different from year / month etc. in that it
	  doesn't use a timeline but rather places ticks by iterating over
	  the data and labelling values based off the rounded value at the
	  data position.

	  This essentially "rounds" the timeline from the given output format
	  rather than using a d3 time-based tick.
	*/

	function periodicAxis(selection, axis, env, options) {
	  var opts = options || {};
	  var field = axis.field();
	  var parseDate = fieldDateParser(field);
	  var outputFormat = opts.dateOutputFormat || env.data.chartOptions.dateOutputFormat;
	  var formatter = valFormatter(outputFormat, parseDate, env);
	  var formattedValues = [];
	  var tickValues = [];
	  var firstAndLastTicksOnly = env.options.firstAndLastTicksOnly || env.data.config.firstAndLastTicksOnly;
	  var lastVal = null;
	  field.data.forEach(function (d, i) {
	    if (d) {
	      var fVal = formatter(d);

	      if (fVal !== lastVal) {
	        tickValues.push([d, i]);
	        formattedValues.push(fVal);
	        lastVal = fVal;
	      }
	    }
	  });
	  axis.model().ticks(0);
	  selection.call(axis.model());
	  drawDomain(selection, axis, env);
	  var ticks = selection.selectAll('.tick').data(tickValues);
	  ticks.exit().remove();
	  ticks.enter().append('g').attr('class', 'tick').attr('transform', function (d) {
	    return "translate(".concat(axis.dateScale(parseDate(d[0])), ", 0)");
	  }).append('line').attr('stroke', '#000').attr('y2', TICK_YVAL);
	  var tickEls = selection.selectAll('.tick');
	  tickEls.each(function (d, i) {
	    var tick = select(this);
	    tick.select('text').remove();
	    tick.classed('start-tick', i === 0);
	    tick.classed('end-tick', i === tickEls.size() - 1);
	    var fVals = formattedValues[i].split('//');
	    var text = tick.append('text').attr('fill', '#000').attr('y', TEXT_YVAL).attr('dy', TEXT_DYVAL);
	    text.append('tspan').attr('x', 0).attr('y', TEXT_YVAL).attr('dy', axis.axisTextMarginHorizontal() + 'px').classed('line1', true).text(fVals[0]);

	    if (fVals[1] && !opts.axisTextSingleLine) {
	      text.append('tspan').attr('x', 0).attr('y', TEXT_YVAL).attr('dy', axis.axisTextMarginHorizontal() + axis.axisTextLineHeight() + 'px').classed('line2', true).text(fVals[1]);
	    }
	  });

	  if (firstAndLastTicksOnly) {
	    showOnlyFirstAndLastTicks(selection);
	  } else {
	    hideOverlappingTicks(selection);
	  }

	  hideLine2Duplicates(selection, axis);

	  if (outputFormat === OUTPUT_FORMAT_QUARTERS) {
	    selection.selectAll('.tick').each(function (d, i) {
	      var tick = select(this);
	      var qVal = formatDateAsQuarter(parseDate(tickValues[i]));
	      var qNum = Number(qVal.replace('Q', ''));
	      tick.attr('quarter', qNum);
	    });
	    quarterLabelDensity(selection, axis);
	  } else {
	    applyLabelDensity(selection, axis);
	  }

	  return selection;
	} // now supporting a config option to hide_year_display

	function valFormatter(format, parseDate, env) {
	  if (format === OUTPUT_FORMAT_YEARS) {
	    return function (val) {
	      return parseDate(val).format('YYYY');
	    };
	  } else if (format === OUTPUT_FORMAT_MONTHS) {
	    if (env.data.config && env.data.config.hide_year_display) {
	      return function (val) {
	        return parseDate(val).format('MMM');
	      };
	    }

	    return function (val) {
	      var d = parseDate(val);
	      return "".concat(d.format('MMM'), "//").concat(d.format('YYYY'));
	    };
	  } else if (format === OUTPUT_FORMAT_HOURS) {
	    return function (val) {
	      var d = parseDate(val);
	      return "".concat(d.format('H:mm'), "//").concat(d.format('MMM D'));
	    };
	  } else if (format === OUTPUT_FORMAT_DAYS) {
	    return function (val) {
	      var d = parseDate(val);
	      return d.format('MMM D');
	    };
	  } else if (format === OUTPUT_FORMAT_DAYS_OF_WEEK) {
	    return function (val) {
	      var d = parseDate(val);
	      return "".concat(d.format('ddd'), "//").concat(d.format('MMM D'));
	    };
	  } else if (format === OUTPUT_FORMAT_QUARTERS) {
	    if (env.data.config && env.data.config.hide_year_display) {
	      return function (val) {
	        return formatDateAsQuarter(parseDate(val));
	      };
	    }

	    return function (val) {
	      var pVal = parseDate(val);
	      var q = formatDateAsQuarter(pVal);
	      return "".concat(q, "//").concat(pVal.format('YYYY'));
	    };
	  } else {
	    // no formatting
	    return function (val) {
	      return val;
	    };
	  }
	}

	var SPACE_WIDTH = 3; // offset label placement for side tick values

	var SIDE_TICK_Y_OFFSET = 7; // no longer writing text down the side, we add a final label at the end
	// if it's longer than a single character
	// called after axis creation to allow background on top of chart

	function placeVerticalAxisLabel(env, isHorizontal) {
	  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
	  var chartOptions = env.data.chartOptions || {};
	  var axis = isHorizontal ? env.x : env.y;
	  var field = axis.field();
	  var textHeight = 15;
	  var paddingV = 9.5;
	  var boxPad = 4;
	  var displayAs = field.display_as;
	  var labelText = '';
	  var label = field.label || field.caption || chartOptions.label || '';
	  var labelLeft = field['label-left'] || field.unit_before || chartOptions.unitBefore || '';
	  var labelRight = field['label-right'] || field.unit_after || chartOptions.unitAfter || '';
	  var labelPre = '';
	  var labelPost = '';
	  var anchorPos = isHorizontal ? 'middle' : 'end'; // env.layout.g().select('g.axis-label-box').remove()
	  // when horizontal columns with labels just return

	  if (env.options.labelCaps) return;
	  var axisGroup = env.layout.yAxis();
	  var isSingleChar = isSingleCharLabel(field);

	  if (isHorizontal) {
	    axisGroup = env.layout.xAxis();
	  }

	  var ticks = axisGroup.selectAll('g.tick');
	  var lastTick = select(ticks.nodes()[ticks.nodes().length - 1]); // now read existing text from the lastTick, read pre/post as well
	  // prevent running multiple times

	  if (!lastTick.size()) return;
	  if (lastTick.node().dataset.hasExecutedLabelPlacement) return; // now read the values into pre/post

	  if (lastTick.select('text .val').size()) {
	    labelText = lastTick.select('text .val').text();

	    if (lastTick.select('text .pre').size()) {
	      labelPre = lastTick.select('text .pre').text();
	    }

	    if (lastTick.select('text .post').size()) {
	      labelPost = lastTick.select('text .post').text();
	    }
	  } else {
	    labelText = lastTick.select('text').text();
	  } // remove hide-text on lastTick to ensure we get a width/height


	  lastTick.classed('hide-text', false);

	  if (displayAs && displayAs !== '%' && displayAs === labelRight) {
	    labelRight = '';
	  } // make sure spaces are kept in place


	  labelLeft = labelLeft.replace(/ /g, '&nbsp;');
	  labelRight = labelRight.replace(/ /g, '&nbsp;'); // weird thing about terminal font - it has a lot of spacing

	  var postOffsetSpace = isWideText(env) ? 1.5 : 0; // note post is before pre and then we move it over to the right of val

	  var labelPreText = labelLeft + labelPre;
	  var labelRightText = label ? "&nbsp;".concat(label) : labelRight;
	  var labelHtml = "\n    <tspan class=\"pre\">".concat(labelPreText, "</tspan>\n    <tspan class=\"val\" dx=\"").concat(SPACE_WIDTH * -1, "\">").concat(labelText, "</tspan>\n    <tspan class=\"post\" dx=\"").concat(SPACE_WIDTH * -1 - postOffsetSpace, "\">").concat(labelPost).concat(labelRightText, "</tspan>\n  ");

	  if (!isHorizontal) {
	    // singleChar labels don't get a box, but we set the text directly
	    // also singleChar is up to 3 characters
	    if (isSingleChar && !isHorizontal) {
	      var textEl = lastTick.select('text');
	      textEl.html(labelHtml); // calculate offset to rightAlign only when using full width
	      // ticks and not the condensed mode (ticks to left of values)

	      if (!axis.isCondensedAxis()) {
	        var currentX = Number(textEl.attr('x'));
	        var widthSpaceNeeded = labelPreText.length && !(labelPost + labelRight).length ? 0 : SPACE_WIDTH;
	        var postWidth = 0;

	        if (textEl.select('.post').node()) {
	          postWidth = textEl.select('.post').node().getComputedTextLength() + widthSpaceNeeded;
	        }

	        textEl.attr('x', currentX + postWidth);
	      }
	    } else {
	      var drawBounds = env.layout.draw().node().getBoundingClientRect();
	      var extents = env.layout.extents().node().getBoundingClientRect();
	      var axisBounds = axisGroup.node().getBoundingClientRect();
	      var isTickAbove = axisGroup.classed('variant-above');
	      var lastTickBounds = lastTick.node().getBoundingClientRect();
	      var innerPadding = env.layout.yAxisInnerPadding();
	      var innerPaddingAlt = env.layout.xAxisInnerPadding();
	      var yDiff = extents.top - drawBounds.top;
	      var xPos = axisBounds.right - drawBounds.left;
	      var yPos = lastTickBounds.bottom - drawBounds.top - innerPaddingAlt - paddingV - yDiff; // scatter plot and new forms don't have the innerPadding constraint

	      xPos -= options.noLabelPadding ? 0 : innerPadding;
	      var labelBox = env.layout.draw().selectAppend('g.axis-label-box');
	      if (!labelPreText) xPos += SPACE_WIDTH;
	      if (!isTickAbove) yPos += SIDE_TICK_Y_OFFSET;
	      labelBox.attr('transform', "translate(".concat(xPos, ", ").concat(yPos, ")"));
	      var textItem = labelBox.selectAppend('text').attr('text-anchor', anchorPos).html(labelHtml);
	      var textWidth = textItem.node().getBoundingClientRect().width;
	      var xOffset = isHorizontal ? textWidth / 2 : 0; // we have to go around d3 for insertBefore

	      var rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
	      rect.setAttribute('x', 0 - textWidth - boxPad - xOffset);
	      rect.setAttribute('y', 0 - textHeight - boxPad / 2);
	      rect.setAttribute('width', textWidth + boxPad);
	      rect.setAttribute('height', textHeight + boxPad);
	      labelBox.node().insertBefore(rect, textItem.node());
	    }
	  } else {
	    lastTick.select('text').attr('x', 0).html(labelHtml);
	  } // mark the node as having a label, otherwise it will get multiple labels


	  lastTick.node().dataset.hasExecutedLabelPlacement = true;
	}
	function placeHorizontalAxisLabel(env) {
	  placeVerticalAxisLabel(env, true);
	}

	function isWideText(env) {
	  return ['terminal', 'coth'].indexOf(env.data.theme) !== -1;
	}

	/**
	  Axis-specific formatting. Separate from the formatter in utils/data

	  Beware of date formatting converting to local time:
	  ie:  new Date('2004')     -->   Wed Dec 31 2003 19:00:00 GMT-0500 (EST)
	*/
	/**
	 *  This whole thing is the core of axis display taxonomy.
	 */

	function buildAxis(selection, axis, env, options) {
	  options = options || {};
	  var field = axis.field();
	  if (!field) return; // if defined output format and line chart

	  if (axis.isPrimaryAxis() && env.data.chartOptions.dateOutputFormat && env.data.chartType === 'line' && !options.forceBand) {
	    return periodicAxis.apply(this, arguments);
	  } // if defined output format


	  if (axis.isPrimaryAxis() && env.data.chartOptions.dateOutputFormat) {
	    var outFormat = env.data.chartOptions.dateOutputFormat;
	    var df = dateFormatter;

	    if (outFormat !== OUTPUT_FORMAT_CATEGORICAL) {
	      if (outFormat === OUTPUT_FORMAT_YEARS) {
	        env.options.categoricalFormatter = df('YYYY');
	        return yearBandAxis.apply(this, arguments);
	      }

	      return periodicAxis.apply(this, arguments);
	    }
	  } // band axis can be years / quarters / months etc.


	  if (options.forceBand) {
	    if (env.layout.orientation() !== VERTICAL && field.taxonomy && field.taxonomy.isDate) {
	      if (field.taxonomy.duration === DURATION_QUARTERS) {
	        return quarterAxis.apply(this, arguments);
	      }

	      if (field.taxonomy.isYears) {
	        return yearBandAxis.apply(this, arguments);
	      }
	    }

	    return bandAxis.apply(this, arguments);
	  }

	  if (field.taxonomy && field.taxonomy.isDate) {
	    if (field.taxonomy.duration === DURATION_MONTHS) {
	      return monthlyAxis.apply(this, arguments);
	    } else if (field.taxonomy.duration === DURATION_MULTIYEAR || field.taxonomy.duration === DURATION_DECADE) {
	      return decadeAxis.apply(this, arguments);
	    } else if (field.taxonomy.duration === DURATION_MULTIDECADE || field.taxonomy.duration === DURATION_CENTURY) {
	      return decadePlusAxis.apply(this, arguments);
	    } else if (field.taxonomy.duration === DURATION_WEEKS) {
	      return monthPlusAxis.apply(this, arguments);
	    } else if (field.taxonomy.duration === DURATION_DAYS) {
	      return dayAxis.apply(this, arguments);
	    } else if (field.taxonomy.duration === DURATION_HOURS) {
	      return hourlyAxis.apply(this, arguments);
	    } else {
	      return decadeAxis.apply(this, arguments);
	    }
	  } else if (field.taxonomy.isContinuous) {
	    // linear numbers
	    return numericAxis.apply(this, arguments);
	  } else {
	    // band ordinal axis
	    return bandAxis.apply(this, arguments);
	  }
	}

	function objectAccessor(applyTo, obj) {
	  Object.keys(obj).forEach(function (key) {
	    applyTo[key] = function (__) {
	      if (typeof __ === 'undefined') {
	        return obj[key];
	      }

	      obj[key] = __;
	      return applyTo;
	    };
	  }); // also need a get/set to avoid "function does not exist"

	  applyTo.val = function (key, val) {
	    if (typeof val === 'undefined') {
	      return applyTo[key];
	    }

	    applyTo[key] = val;
	    return applyTo;
	  };
	}

	function linearAxisProvider(options, override) {
	  var state = {
	    type: 'linear',
	    orientation: VERTICAL,
	    position: RIGHT$1,
	    range: [0, 500],
	    rangeMax: null,
	    data: null,
	    model: null,
	    series: null,
	    field: null,
	    customField: null,
	    customSeries: null,
	    isPrimaryAxis: false,
	    // may be x axis but secondary field
	    isCondensedAxis: false,
	    // mark the y axis as condensed mode (side ticks and not above)
	    tickStepVertical: 100,
	    // ideal pixels between steps old: 38
	    tickStepHorizontal: 100,
	    tickLabelAlternate: false,
	    // early comps had labels every other tick
	    axisTextMarginHorizontal: 19,
	    axisTextMarginVertical: 2,
	    axisTextLineHeight: 16,
	    axisTextPadding: 6,
	    axisTextCenterVertical: true,
	    axisLabelPaddingVertical: 16,
	    verticalTickLength: 6,
	    leftAlignStartTick: false,
	    labelReducer: null,
	    // set reduce values for "1000000 -> 1M etc."
	    noDomainLine: true,
	    // hide the domain line and ticks
	    stackedDomain: false,
	    // for stacked columns combine all
	    customStackedDomain: false,
	    // allows a mix of stacked and non stacked
	    customStandardFields: [],
	    customStackedFields: [],
	    defaultHeight: 30,
	    // defaultHeight for bottom axis (when flipped)
	    lineDensityBreakpoint: 250,
	    lineDensityMultiplier: 0.75,
	    padLabelLineHeight: 16,
	    numTicks: 1,
	    // used to store number of ticks used
	    skipYAxisExtend: false,
	    // don't extend the base tick to match domain
	    showZeroLineAtBase: true // highlight zero differently if at base (off on scatterplot)

	  };
	  state = _extends(state, options || {});
	  override = override || {}; // bind to the element we want to draw to

	  var axis = function axis(selection, env) {
	    selection.selectAll('*').remove(); // clear
	    // if axis height is less than 250 we increase density of lines

	    if (axis.rangeLength() < state.lineDensityBreakpoint) {
	      state.tickStepVertical *= state.lineDensityMultiplier;
	      state.tickStepHorizontal *= state.lineDensityMultiplier;
	    }

	    if (!env.options.disableAxis) {
	      buildAxis(selection, axis, env); // axis, field, options)
	    }

	    return selection;
	  }; // turn the whole thing into one giant accessor


	  objectAccessor(axis, state); // scale and seriesScale are all no longer part of the
	  // state accessor - this is because they are all callable functions

	  axis.scale = linear();
	  axis.axisScale = null;
	  axis.dateScale = null; // this is needed to initialize scale, range etc.

	  axis.data = function (data) {
	    if (data) {
	      var series = state.customField ? [state.customField] : getSeries(data);
	      axis.series(series);
	      axis.field(state.customField || override.field || state.field || getField(data, state.isPrimaryAxis));
	      var domain = null;

	      if (axis.customStackedDomain()) {
	        var _stackedDomain = stackedDomainFromFields(state.customStackedFields);

	        var standardDomain = seriesDomain(state.customStackedFields, state.domainFromZero);
	        domain = [Math.min(_stackedDomain[0], standardDomain[0]), Math.max(_stackedDomain[1], standardDomain[1])];
	      } else if (axis.stackedDomain()) {
	        domain = stackedDomain(data);
	      } else {
	        domain = seriesDomain(axis.series(), state.domainFromZero);
	      } // apply nice domain before applying custom start/end


	      axis.scale.domain(domain).nice();
	      domain = axis.scale.domain(); // look for field.numericProperties first

	      if (axis.field().numericProperties) {
	        if (axis.field().numericProperties.scaleStart != null) {
	          domain[0] = axis.field().numericProperties.scaleStart;
	        }

	        if (axis.field().numericProperties.scaleEnd != null) {
	          domain[1] = axis.field().numericProperties.scaleEnd;
	        }
	      } else {
	        // if scale_start scale_end defined in data use that
	        if (data.chartOptions && data.chartOptions.scaleStart != null) {
	          domain[0] = data.chartOptions.scaleStart;
	        }

	        if (data.chartOptions && data.chartOptions.scaleEnd != null) {
	          domain[1] = data.chartOptions.scaleEnd;
	        }
	      }

	      axis.scale.domain(domain).range(state.range);
	      axis.axisScale = axis.scale;
	      axis.dateScale = axis.scale;
	      axis.model(AXIS_MAP[state.position](axis.axisScale));
	      state.data = data;
	      return axis;
	    } else {
	      return state.data;
	    }
	  }; // initialize data right away if provided in options


	  if (state.data) {
	    axis.data(state.data);
	  } // return the axis scale value from item index


	  axis.scaleIndex = function (index) {
	    return axis.scale(axis.field()[index]);
	  }; // given an x,y coordinate get the data at that position for
	  // tooltips etc.


	  axis.getDataAtPosition = function (position) {};

	  axis.rangeLength = function () {
	    return Math.abs(axis.scale.range()[1] - axis.scale.range()[0]);
	  };

	  return axis;
	}

	function bandAxisProvider(options) {
	  var state = _objectSpread2({
	    type: 'band',
	    isBandAxis: true,
	    // just a way to check
	    isPrimaryAxis: true,
	    // this axis is typically the secondary (x) axis
	    orientation: HORIZONTAL,
	    position: BOTTOM$1,
	    range: [0, 500],
	    data: null,
	    model: null,
	    series: null,
	    field: null,
	    domain: [0, 100],
	    padding: 0.3,
	    outerPadding: 0.0,
	    tickStep: 30,
	    // ideal pixels between steps
	    tickStepHorizontal: 100,
	    tickStepHorizontalDate: 80,
	    tickStepVertical: 60,
	    axisTextMarginHorizontal: 16,
	    axisTextMarginVertical: 4,
	    axisTextLineHeight: 18,
	    axisTextLineHeightMobile: 14,
	    axisTextLineHeightHorizontal: 15,
	    axisTextPadding: 6,
	    horizontalBarHeight: 32,
	    horizontalBarPadding: 0.2,
	    verticalAxisWrapWidth: 300,
	    tickLabelAlternate: false,
	    stackedBand: false,
	    stackedDomain: false,
	    isDateAxis: false,
	    isContinuousAxis: false,
	    // when columns are tiny
	    numTicks: 1
	  }, options); // bind to the element we want to draw to


	  var axis = function axis(selection, env) {
	    selection.selectAll('*').remove(); // clear

	    if (isMobileWidth(env.el.node().offsetWidth, env.options)) {
	      axis.axisTextMarginHorizontal(10);
	      axis.axisTextLineHeight(state.axisTextLineHeightMobile);
	    }

	    if (!env.options.disableAxis) {
	      buildAxis(selection, axis, env, {
	        forceBand: !axis.isDateAxis(),
	        disableStartEndCaps: true // !axis.isDateAxis()

	      });
	    }

	    return selection;
	  }; // turn the whole thing into one giant accessor


	  objectAccessor(axis, state); // scale and seriesScale are all no longer part of the
	  // state accessor - this is because they are all callable functions

	  axis.scale = band();
	  axis.seriesScale = band();
	  axis.axisScale = null;
	  axis.dateScale = null; // this is needed to initialize scale, range etc.

	  axis.data = function (data) {
	    if (data) {
	      axis.series(getSeries(data));
	      axis.field(getField(data, state.isPrimaryAxis));
	      var field = axis.field();
	      axis.scale.domain(field.data).paddingInner(state.padding).paddingOuter(state.outerPadding).range(state.range);

	      if (state.orientation === VERTICAL) {
	        var barHeight = state.horizontalBarHeight * axis.series().length;

	        if (axis.stackedBand()) {
	          barHeight = state.horizontalBarHeight;
	        }

	        state.range[0] = 0;
	        state.range[1] = state.field.data.length * barHeight;
	        axis.scale.range(state.range).padding(state.horizontalBarPadding).bandwidth(barHeight);
	      }

	      axis.seriesScale.domain(range$2(axis.series().length)).range([0, axis.scale.bandwidth()]); // create a date scale when dealing with date data as bands
	      // but only render the axis as a date axis when
	      // columns are very small

	      if (axis.isDateAxis()) {
	        axis.dateScale = scaleTime().domain([field.taxonomy.dateStart, field.taxonomy.dateEnd]).range(axis.range()); // match the tick size for line charts

	        axis.tickStepHorizontal(axis.tickStepHorizontalDate());

	        if (axis.isContinuousAxis()) {
	          axis.axisScale = axis.dateScale;
	        }
	      }

	      axis.axisScale = axis.axisScale || axis.scale;
	      axis.model(AXIS_MAP[state.position](axis.axisScale));
	      state.data = data;
	      return axis;
	    } else {
	      return state.data;
	    }
	  }; // initialize data right away if data provided in options


	  if (state.data) {
	    axis.data(state.data);
	  } // return the axis scale value from item index


	  axis.scaleIndex = function (index) {
	    return axis.scale(axis.field()[index]);
	  }; // given a normalized range coordinate return the data at that position


	  axis.getDataAtPosition = function (position) {
	    var band = getBandFromPosition(axis.scale, position);
	    var data = [];
	    var seriesBand = {
	      index: 0
	    };

	    if (axis.series().length > 1) {
	      seriesBand = getBandFromPosition(axis.seriesScale, band.position);
	    }

	    if (band.index === -1 || axis.data().fields[seriesBand.index + 1] === undefined) {
	      return null;
	    }

	    axis.series().forEach(function (field) {
	      data.push(field.data[band.index]);
	    });
	    return {
	      dataIndex: band.index,
	      seriesIndex: seriesBand.index,
	      data: data
	    };
	  }; // given a data index [bandIndex, seriesIndex] return the normalized
	  // position where an anchor would be set (ie center of the column)


	  axis.getPositionFromIndex = function (index, ignoreSeries) {
	    var bandIndex = index;
	    var seriesIndex = 0;
	    var leftPx;

	    if (axis.series().length === 1) {
	      ignoreSeries = true;
	    }

	    if (index.length) {
	      bandIndex = index[0];
	      seriesIndex = index[1] || 0;
	    }

	    leftPx = axis.scale(axis.field().data[bandIndex]); // force position evaluation as single series bar

	    if (ignoreSeries) {
	      leftPx += axis.scale.bandwidth() * 0.5;
	    } else {
	      leftPx += axis.seriesScale(seriesIndex);
	      leftPx += axis.seriesScale.bandwidth() * 0.5;
	    }

	    return leftPx / axis.rangeLength();
	  };

	  axis.rangeLength = function () {
	    return Math.abs(axis.scale.range()[1] - axis.scale.range()[0]);
	  };

	  return axis;
	} // reverse lookup from a normalized range value to the band
	// https://raw.githubusercontent.com/d3/d3-scale/master/img/band.png

	function getBandFromPosition(scale, pos) {
	  var outerPadding = scale.step() * scale.paddingOuter();
	  var rangePos = pos * Math.abs(scale.range()[1] - scale.range()[0]); // subtract outerPadding and divide by step to get band index

	  rangePos -= outerPadding;
	  var bandIndex = Math.floor(rangePos / scale.step());
	  var data = scale.domain()[bandIndex]; // now return the band and the normalized position within the band
	  // so that we can determine the series

	  var bandPos = rangePos - scale(data) + outerPadding;

	  if (bandPos > scale.bandwidth()) {
	    // we are in the padding
	    return {
	      index: -1,
	      position: 0.0
	    };
	  } else {
	    return {
	      index: bandIndex,
	      position: bandPos / scale.bandwidth()
	    };
	  }
	}

	function dateAxisProvider(options) {
	  var state = _objectSpread2({
	    type: 'date',
	    isPrimaryAxis: true,
	    // this axis is typically the primary (x) axis
	    orientation: HORIZONTAL,
	    position: BOTTOM$1,
	    data: null,
	    model: null,
	    field: null,
	    series: null,
	    range: [0, 500],
	    domain: [0, 100],
	    padding: 0,
	    tickStep: 30,
	    // ideal pixels between steps
	    tickStepHorizontal: 80,
	    axisTextMarginHorizontal: 16,
	    axisTextLineHeight: 18,
	    axisTextPadding: 6,
	    tickLabelAlternate: false,
	    numTicks: 1
	  }, options); // bind to the element we want to draw to


	  var axis = function axis(selection, env) {
	    selection.selectAll('*').remove(); // clear

	    if (isMobileWidth(env.el.offsetWidth, env.options)) {
	      axis.axisTextMarginHorizontal(10);
	      axis.axisTextLineHeight(14);
	    }

	    if (!env.options.disableAxis) {
	      buildAxis(selection, axis, env);
	    }

	    return selection;
	  }; // turn the whole thing into one giant accessor


	  objectAccessor(axis, state); // scale and seriesScale are all no longer part of the
	  // state accessor - this is because they are all callable functions

	  axis.scale = point$1();
	  axis.axisScale = null;
	  axis.dateScale = null; // this is needed to initialize scale, range etc.

	  axis.data = function (data) {
	    if (data) {
	      axis.series(getSeries(data));
	      axis.field(getField(data, state.isPrimaryAxis));
	      var field = axis.field();
	      axis.scale.domain(field.data).range(axis.range()); // .padding(0)

	      var continuousOrYears = field.taxonomy.isContinuous || field.taxonomy.isYears;

	      if (field.taxonomy && field.taxonomy.isDate && continuousOrYears) {
	        var timeRange = [field.taxonomy.dateStart, field.taxonomy.dateEnd];
	        var dateAxis = scaleUtc().domain(timeRange).range(axis.range()); // TODO :: this should be default

	        if (data.config.forceDateScale) axis.scale.domain(timeRange);
	        axis.scale = dateAxis;
	      } // set model to d3.axisBottom / axisLeft etc.
	      // date scale uses the same scale throughout but setup
	      // an axisScale and dateScale reference to match band scales


	      axis.axisScale = axis.scale;
	      axis.dateScale = axis.scale;
	      axis.model(AXIS_MAP[state.position](axis.axisScale));
	      state.data = data;
	      return axis;
	    } else {
	      return state.data;
	    }
	  }; // return the axis scale value from item index


	  axis.scaleIndex = function (index) {
	    return axis.scale(axis.field()[index]);
	  }; // given an x,y coordinate get the data at that position for
	  // tooltips etc.


	  axis.getDataAtPosition = function (position) {
	    var data = [];
	    var targetPos = position * axis.rangeLength();
	    var getVal = fieldValueParser(axis.field(), options.forceCategorical);
	    var closestIndex = 0;
	    var closestDistance = 9999999; // now loop through data and for index closest to targetVal

	    axis.field().data.forEach(function (val, i) {
	      var dVal = getVal(val);

	      if (Math.abs(axis.scale(dVal) - targetPos) < closestDistance) {
	        closestDistance = Math.abs(axis.scale(dVal) - targetPos);
	        closestIndex = i;
	      }
	    });
	    axis.series().forEach(function (field) {
	      data.push(field.data[closestIndex]);
	    });
	    return {
	      dataIndex: closestIndex,
	      data: data
	    };
	  }; // parse the value at index, and return that as percentage of range


	  axis.getPositionFromIndex = function (index) {
	    var parser = getFieldIndexValueParser(state.data, state.isPrimaryAxis);
	    var pos = axis.scale(parser(index));
	    return pos / axis.rangeLength();
	  };

	  axis.rangeLength = function () {
	    return Math.abs(axis.scale.range()[1] - axis.scale.range()[0]);
	  };

	  return axis;
	}

	/**
	  Provide layout options and return an interface to chart elements

	  A goal here is to determine when to swap orientation between
	  horizontal and vertical and keep each axis independent

	  Added InnerPadding to support a range that is inside the drawing area,
	  this allows a drawing area and axis length that is wider than the range()

	  I had to change the name from chartLayout for an odd naming collision
	*/

	function layoutManager(config, options) {
	  var state = {
	    primaryAxis: linearAxisProvider(),
	    secondaryAxis: linearAxisProvider(),
	    orientation: HORIZONTAL,
	    secondaryOrientation: VERTICAL,
	    xAxisPosition: BOTTOM$1,
	    yAxisPosition: RIGHT$1,
	    yAxisPadding: 8,
	    yAxisInnerPadding: 10,
	    yAxisInnerPaddingLeft: 0,
	    yAxisInnerPaddingRight: 0,
	    yAxisTickWidth: 0,
	    // used to set width from 'mini-ticks'
	    xAxisInnerPadding: 0,
	    xAxisMinHeight: 30,
	    yAxisForceZeroWidth: false,
	    xAxisForceZeroWidth: false,
	    xAxisExtendRight: 0,
	    yAxisMaxWidth: '55%',
	    width: 0,
	    outerWidth: 0,
	    height: 0,
	    minHeight: null,
	    minHeightHorizontal: 240,
	    minHeightVertical: 0,
	    outerHeight: 0,
	    legend: null,
	    xAxis: null,
	    yAxis: null,
	    container: null,
	    svg: null,
	    g: null,
	    // g.margin
	    draw: null,
	    // draw area
	    extents: null,
	    // draw area extents
	    fitToContainer: false,
	    // instead of aspectRatio fill the container
	    aspectDrivenHeight: true,
	    // disable to fill to space (flex)
	    aspectRatio: '5:2',
	    // target aspect ratio
	    maxAspectHeight: 620,
	    maxAspectRatioForTerminal: 1.0,
	    // 1:1
	    isMobile: false,
	    // mobile
	    isMedium: false,
	    // phablet
	    isLarge: true,
	    // large size
	    chartFrameMarginWidth: 30,
	    // 15px margins on either side
	    verticalAxisShift: 5,
	    // amount to shift vertical axis towards bars
	    padding: 0,
	    verticalBandHeight: 80,
	    expectedFrameHeight: 160,
	    margin: {
	      top: 10,
	      right: 0,
	      bottom: 0,
	      left: 0
	    },
	    padBottom: 8,
	    fixedHeightSizing: false,
	    // set a specific height to fill
	    fixedHeight: 385 // set a height to matches

	  };
	  state = _extends(state, config);
	  var postLayoutHandlers = [];

	  var layout = function layout(selection, env) {
	    var chart = selection;
	    var margin = layout.margin();
	    var width = chart.node().offsetWidth;
	    var outerWidth = width;
	    var outerWidthMargins = outerWidth + state.chartFrameMarginWidth;
	    var height = chart.node().offsetHeight;
	    var outerHeight = height;
	    var xAxisProvider = layout.primaryAxis();
	    var yAxisProvider = layout.secondaryAxis(); // apply self at top to allow axis functions to reference layout

	    env.layout = layout; // use aspectRatio to determine ideal height

	    if (layout.aspectDrivenHeight()) {
	      var ratio = getAspectRatio(env.data, layout.aspectRatio(), state, env.options); // height offset is used specifically for COTH

	      var heightOffset = 0;

	      if (env.options.ratioHeightOffset) {
	        heightOffset = state.expectedFrameHeight;
	      }

	      height = Math.min(layout.maxAspectHeight(), layout.heightOrMin(width / ratio - heightOffset));
	    } // use aspectRatio to determine ideal height, we read the CSS properties
	    // to determine specific height for chart


	    if (layout.fixedHeightSizing() || layout.fitToContainer()) {
	      var targetHeight = layout.fitToContainer() ? window.innerHeight : layout.fixedHeight();
	      var chartNode = chart.node();
	      var parentNode = select(chartNode.parentNode);
	      var header = parentNode.select('.header').node();
	      var legend = parentNode.select('.legend').node();
	      var footer = parentNode.select('.footer').node();
	      var totalMargins = getPaddingHeight(parentNode.node()); // TODO :: resolve why this is needed
	      // -- there is a bug when the extent from a custom scale
	      // is smaller than the min/max of the actual domain

	      layout.xAxisMinHeight(0);

	      if (header.offsetHeight) {
	        totalMargins += header.offsetHeight + getMarginHeight(header);
	      } // legend margin is there even when hidden


	      totalMargins += legend.offsetHeight + getMarginHeight(legend);

	      if (chartNode.offsetTop) {
	        totalMargins = Math.max(totalMargins, chartNode.offsetTop);
	      }

	      if (footer.offsetHeight) {
	        totalMargins += footer.offsetHeight + getMarginHeight(footer);
	      }

	      height = targetHeight - totalMargins;
	      chart.style('height', height + 'px');
	    } // swap primary / secondary axis


	    if (layout.orientation() === VERTICAL) {
	      xAxisProvider = layout.secondaryAxis();
	      yAxisProvider = layout.primaryAxis(); // calculate height by number of bands

	      height = layout.verticalBandHeight() * env.data.data.length;
	      height += margin.top + margin.bottom;
	      height = Math.round(height);
	    } // classify as mobile / medium / or large


	    var breakMobile = env.options.mobileBreakpoint || MOBILE_BREAKPOINT;
	    var breakLarge = env.options.largeBreakpoint || LARGE_BREAKPOINT;

	    if (outerWidthMargins <= breakLarge && outerWidthMargins > breakMobile) {
	      layout.isLarge(false).isMedium(true);
	    } else if (outerWidthMargins <= breakMobile) {
	      layout.isLarge(false).isMobile(true);
	    } // instead of setting width / height explicitly, if
	    // we use viewBox="0 0 w h" we can have the svg scale to fit it's
	    // container just like an image. This will allow an SVG to be
	    // embedded directly without JS
	    // NOTE :: viewBox disabled because phantomjs doesn't support it yet


	    height = layout.heightOrMin(height);
	    var svg = chart.selectAppend('svg').style('width', width + 'px').style('height', height + 'px');
	    var gMargin = svg.selectAppend('g.margin');
	    height -= margin.top + margin.bottom + layout.padBottom();

	    if (layout.orientation() === HORIZONTAL) {
	      height -= layout.xAxisMinHeight();
	    }

	    yAxisProvider.orientation(VERTICAL).position(layout.yAxisPosition()).range([height, 0]).data(env.data);
	    var yAxis = gMargin.selectAppend('g.axis.axis-y').classed('position-right', layout.yAxisPosition() === RIGHT$1).classed('position-left', layout.yAxisPosition() !== RIGHT$1).call(yAxisProvider, env);
	    var yAxisBounds = yAxis.node().getBoundingClientRect();
	    var yAxisBoundsWidth = yAxisBounds.width; // bounds object is read only

	    if (layout.yAxisForceZeroWidth()) yAxisBoundsWidth = 0;

	    if (layout.yAxisPosition() === RIGHT$1) {
	      margin.right = Math.max(margin.right, Math.ceil(yAxisBoundsWidth));
	      outerWidth -= margin.right + margin.left;
	      yAxis.attr('transform', 'translate(' + (outerWidth + layout.yAxisPadding()) + ', 0)');
	    } else {
	      margin.left = Math.max(margin.left, Math.ceil(yAxisBoundsWidth));
	      outerWidth -= margin.right + margin.left;
	    } // adjust height to height of chart


	    if (layout.orientation() === VERTICAL) {
	      height = layout.heightOrMin(yAxisProvider.rangeLength());
	      outerHeight = height;
	      svg.style('width', width + 'px').style('height', height + margin.top + margin.bottom + layout.padBottom() + 'px');

	      if (layout.yAxisPosition() === LEFT$1) {
	        yAxis.attr('transform', "translate(".concat(state.verticalAxisShift, ", 0)"));
	      }
	    }

	    gMargin.attr('transform', 'translate(' + [margin.left, margin.top] + ')').attr('data-transform-x', margin.left).attr('data-transform-y', margin.top);
	    width = outerWidth - layout.yAxisInnerPadding() * 2;
	    xAxisProvider.orientation(HORIZONTAL).position(layout.xAxisPosition()).range([0, width - layout.xAxisExtendRight()]).data(env.data);
	    var xAxis = gMargin.selectAppend('g.axis.axis-x').attr('transform', "translate(".concat(layout.yAxisInnerPadding(), ", ").concat(height, ")")).call(xAxisProvider, env); // READ THE HEIGHT of xAxis, adjust and redraw if needed

	    var xAxisHeight = xAxis.node().getBoundingClientRect().height;

	    if (layout.orientation() === HORIZONTAL && xAxisHeight > layout.xAxisMinHeight()) {
	      height = height - (xAxisHeight - layout.xAxisMinHeight());
	      xAxis.attr('transform', "translate(".concat(layout.yAxisInnerPadding(), ", ").concat(height, ")"));
	      yAxisProvider.range([height, 0]).data(env.data);
	      yAxis.call(yAxisProvider, env); // call again
	    } // if vertical we have a different style for x-axis


	    if (layout.orientation() === VERTICAL) {
	      yAxisProvider.range([0, height]);
	      xAxis.attr('transform', "translate(".concat(layout.yAxisInnerPadding(), ", ").concat(height, ")")).classed('axis-secondary', true);
	    }

	    var draw = gMargin.selectAppend('g.draw-container').attr('transform', "translate(".concat(layout.yAxisInnerPadding(), ", 0)")); // draw extends onto area to avoid bounds lookup not showing
	    // the true draw region bounds

	    var extents = draw.selectAppend('rect.extents').attr('x', 0).attr('y', 0).attr('width', xAxisProvider.rangeLength()).attr('height', yAxisProvider.rangeLength());
	    layout.g(gMargin);
	    layout.draw(draw);
	    layout.extents(extents);
	    layout.container(chart);
	    layout.xAxis(xAxis);
	    layout.yAxis(yAxis);
	    layout.svg(svg);
	    layout.margin(margin);
	    layout.width(width);
	    layout.outerWidth(outerWidth);
	    layout.height(height);
	    layout.outerHeight(outerHeight);
	    env.y = yAxisProvider;
	    env.x = xAxisProvider;
	    env.g = gMargin;
	    layout.emitPostLayout(selection, env);
	    return selection;
	  }; // read width / height of components and update margins


	  layout.update = function () {}; // if our gMargin is larger than the svg it will cut off text and
	  // whatnot so we use transform scale to bring it back to normal
	  // OLD WEBKIT (in phantomjs) only supports scale origin top left
	  // so we have to do manual shifting
	  // TODO :: resolve 10px min for translateY


	  layout.overflowScale = function () {
	    var svgBounds = layout.svg().node().getBoundingClientRect();
	    var gBounds = layout.g().node().getBBox();
	    var margin = layout.margin();
	    var minHeight = Math.max(svgBounds.height, gBounds.height);
	    var translateY = Math.max(margin.top, gBounds.y * -1);
	    var translateX = 0;

	    if (gBounds.x < 0) {
	      translateX += gBounds.x * -1;
	    }

	    var transform = "translate(".concat(translateX, ", ").concat(translateY, ")");

	    if (gBounds.width > svgBounds.width) {
	      var ratio = svgBounds.width / gBounds.width;
	      transform = "translate(".concat(translateX, ", ").concat(translateY, ") scale(").concat(ratio, ")");
	    }

	    layout.svg().style('height', "".concat(minHeight, "px"));
	    layout.g().style('transform-origin', 'top left').style('-webkit-transform-origin', 'top left').attr('transform', transform).style('transform', transform).style('-webkit-transform', transform);
	  };

	  layout.getMinHeight = function () {
	    if (layout.fixedHeightSizing()) return 0;
	    if (layout.fitToContainer()) return 0;

	    if (layout.minHeight() !== null) {
	      return layout.minHeight();
	    } else {
	      if (layout.orientation() === HORIZONTAL) {
	        return layout.minHeightHorizontal();
	      } else {
	        return layout.minHeightVertical();
	      }
	    }
	  };

	  layout.heightOrMin = function (h) {
	    return Math.max(layout.getMinHeight(), h);
	  }; // there are some things that need to be done
	  // after all axes have been drawn. so that is done by adding a handler
	  // to the layout manager here


	  layout.addPostLayoutHandler = function (name, callback) {
	    postLayoutHandlers.push([name, callback]);
	  };

	  layout.removePostLayoutHandler = function (name) {
	    var i = postLayoutHandlers.indexOf(function (_ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	          n = _ref2[0];

	      return n === name;
	    });
	    postLayoutHandlers.splice(i, 1);
	  };

	  layout.emitPostLayout = function (el, env) {
	    postLayoutHandlers.forEach(function (_ref3) {
	      var _ref4 = _slicedToArray(_ref3, 2),
	          cb = _ref4[1];

	      cb(el, env, layout);
	    });
	  };

	  objectAccessor(layout, state);
	  return layout;
	}

	// exclude line/area since they can have the highlight range
	// be precisely on the scale

	function isBandAxisType(axis, chartData) {
	  if (axis.isBandAxis && axis.isBandAxis()) {
	    return !['line', 'area'].includes(chartData.chartType);
	  }

	  return false;
	} // only returns if band axis and line/area


	function isBandAxisLineType(axis, chartData) {
	  if (axis.isBandAxis && axis.isBandAxis()) {
	    return ['line', 'area'].includes(chartData.chartType);
	  }

	  return false;
	}

	function highlightRanges(opts) {
	  var options = _objectSpread2({
	    orientation: X,
	    rangeStyle: 'existingValues',
	    // customDate, percentage
	    ranges: [],
	    isColumnType: false
	  }, opts);

	  function render(selection, env) {
	    var horizontalGrid = options.orientation === X;
	    var primaryAxis = horizontalGrid ? env.x : env.y;
	    var numericAxis = horizontalGrid ? env.y : env.x;
	    var forceCategorical = options.isColumnType;
	    var parseAxisValue = getFieldValueParser(env.data, true, forceCategorical);
	    var rangeElements = selection.selectAll('.range-highlight').data(options.ranges);
	    rangeElements.exit().remove();
	    rangeElements.enter().append('rect').attr('class', 'range-highlight').merge(rangeElements).attr('x', function (d, i) {
	      if (options.rangeStyle === 'percentage') {
	        return primaryAxis.rangeLength() * Number(d.from / 100);
	      } // weird case where band axis lines start before actual marker


	      if (isBandAxisLineType(primaryAxis, env.data)) {
	        return primaryAxis.scale(parseAxisValue(d.from)) + primaryAxis.scale.bandwidth() / 2;
	      }

	      return primaryAxis.scale(parseAxisValue(d.from));
	    }).attr('y', function (d) {
	      return numericAxis.range()[1];
	    }).attr('width', function (d, i) {
	      if (options.rangeStyle === 'percentage') {
	        return Math.max(primaryAxis.rangeLength() * (Number(d.to / 100) - Number(d.from / 100)), 2);
	      } // for band scales we need to return a highlight of the beginning of the band
	      // to the end of the band


	      if (isBandAxisType(primaryAxis, env.data)) {
	        return Math.max(primaryAxis.scale(parseAxisValue(d.to)) - primaryAxis.scale(parseAxisValue(d.from)) + primaryAxis.scale.bandwidth(), 2);
	      }

	      return Math.max(primaryAxis.scale(parseAxisValue(d.to)) - primaryAxis.scale(parseAxisValue(d.from)), 2);
	    }).attr('height', function (d) {
	      return numericAxis.range()[0];
	    });
	    return selection;
	  }

	  return render;
	}

	var LABEL_PAD = 5;
	var LABEL_HEIGHT = 10;
	function thresholdLines(opts) {
	  var options = _objectSpread2({
	    orientation: X,
	    thresholds: [],
	    thresholdColor: null,
	    thresholdBackgroundColor: null,
	    disableThresholdLabelShadow: null
	  }, opts); // only deal with line and angled line here


	  var thresholds = options.thresholds.filter(function (t) {
	    return t.type === 'singleThreshold' || t.type === 'angledThreshold';
	  });

	  function render(selection, env) {
	    var horizontalGrid = options.orientation === X;
	    var primaryAxis = horizontalGrid ? env.x : env.y;
	    var numericAxis = horizontalGrid ? env.y : env.x;
	    var padding = env.layout.yAxisInnerPadding();
	    var thresholdBackgroundLines = selection.selectAll('.threshold-line-background').data(thresholds);
	    var thresholdLines = selection.selectAll('.threshold-line').data(thresholds);
	    var drawLine = d3line().x(function (d, i) {
	      return d[0];
	    }).y(function (d) {
	      return d[1];
	    });
	    thresholdBackgroundLines.exit().remove();
	    thresholdLines.exit().remove();
	    thresholdBackgroundLines.enter().append('path').attr('class', 'threshold-line-background').merge(thresholdBackgroundLines).style('stroke', options.thresholdBackgroundColor).attr('d', function (item) {
	      var start = item.start,
	          end = item.end,
	          type = item.type;
	      var startValue = Number(start);
	      var endValue = type === 'singleThreshold' ? Number(start) : Number(end);
	      var lineData = [[primaryAxis.range()[0] - padding, numericAxis.scale(startValue)], [primaryAxis.range()[1] + padding, numericAxis.scale(endValue)]];
	      return drawLine(lineData);
	    });
	    thresholdLines.enter().append('path').attr('class', 'threshold-line').merge(thresholdLines).style('stroke', options.thresholdColor).attr('d', function (item) {
	      var start = item.start,
	          end = item.end,
	          type = item.type;
	      var startValue = Number(start);
	      var endValue = type === 'singleThreshold' ? Number(start) : Number(end);
	      var lineData = [[primaryAxis.range()[0] - padding, numericAxis.scale(startValue)], [primaryAxis.range()[1] + padding, numericAxis.scale(endValue)]];
	      return drawLine(lineData);
	    }); // now draw the labels

	    var thresholdLabels = selection.selectAll('.threshold-label').data(thresholds);
	    thresholdLabels.exit().remove();
	    thresholdLabels.enter().append('text').classed('threshold-label', true).classed('disable-shadow', options.disableThresholdLabelShadow).text(function (d) {
	      return d.label;
	    }).style('fill', options.thresholdColor).merge(thresholdLabels).attr('text-anchor', function (d) {
	      if (d.labelOrientation === 'above-end' || d.labelOrientation === 'below-end') {
	        return 'end';
	      }

	      return 'start';
	    }).attr('x', function (d) {
	      if (d.labelOrientation === 'above-end' || d.labelOrientation === 'below-end') {
	        return primaryAxis.range()[1];
	      }

	      return primaryAxis.range()[0] - padding;
	    }).attr('y', function (d) {
	      var start = d.start,
	          end = d.end,
	          type = d.type,
	          labelOrientation = d.labelOrientation;
	      var startValue = Number(start);
	      var endValue = type === 'singleThreshold' ? Number(start) : Number(end);

	      if (labelOrientation === 'below-start') {
	        return numericAxis.scale(startValue) + LABEL_PAD + LABEL_HEIGHT;
	      } else if (labelOrientation === 'above-end') {
	        return numericAxis.scale(endValue) - LABEL_PAD;
	      } else if (labelOrientation === 'below-end') {
	        return numericAxis.scale(endValue) + LABEL_PAD + LABEL_HEIGHT;
	      } // default to above-start


	      return numericAxis.scale(startValue) - LABEL_PAD;
	    });
	    return selection;
	  }

	  return render;
	}

	var ITERATOR = wellKnownSymbol('iterator');
	var TO_STRING_TAG = wellKnownSymbol('toStringTag');
	var ArrayValues = es_array_iterator.values;

	for (var COLLECTION_NAME in domIterables) {
	  var Collection = global_1[COLLECTION_NAME];
	  var CollectionPrototype = Collection && Collection.prototype;
	  if (CollectionPrototype) {
	    // some Chrome versions have non-configurable methods on DOMTokenList
	    if (CollectionPrototype[ITERATOR] !== ArrayValues) try {
	      createNonEnumerableProperty(CollectionPrototype, ITERATOR, ArrayValues);
	    } catch (error) {
	      CollectionPrototype[ITERATOR] = ArrayValues;
	    }
	    if (!CollectionPrototype[TO_STRING_TAG]) {
	      createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME);
	    }
	    if (domIterables[COLLECTION_NAME]) for (var METHOD_NAME in es_array_iterator) {
	      // some Chrome versions have non-configurable methods on DOMTokenList
	      if (CollectionPrototype[METHOD_NAME] !== es_array_iterator[METHOD_NAME]) try {
	        createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, es_array_iterator[METHOD_NAME]);
	      } catch (error) {
	        CollectionPrototype[METHOD_NAME] = es_array_iterator[METHOD_NAME];
	      }
	    }
	  }
	}

	// promises and allows for all the transitions to be
	// interrupted for pauses

	function playInterface(playHandler) {
	  return function (target, env, transitionOptions) {
	    var transitions = playHandler(target, env, transitionOptions); // weird d3 thing is that only the last transition resolves
	    // the rest reject so we use allSettled

	    var promises = transitions.map(function (transition) {
	      return transition.end();
	    });
	    var execution = Promise.allSettled(promises);

	    var stop = function stop() {
	      transitions.forEach(function (transition) {
	        transition.selection().interrupt();
	      });
	    }; // at this point we have all of the d3 transition
	    // objects and can provide an interface for pausing/playing
	    // now execute all of the promises


	    return {
	      startTime: now$4(),
	      transitions: transitions,
	      execution: execution,
	      stop: stop
	    };
	  };
	}

	// progresses along

	function stageAnnotationTransition(target, env, transitionOptions) {
	  target.selectAll('g.annotations > *').style('opacity', 0);
	}
	function playAnnotationTransition(target, env, transitionOptions) {
	  var data = env.data;
	  var annotations = data.annotations;
	  var delay = transitionOptions.delay,
	      duration = transitionOptions.duration,
	      _transitionOptions$an = transitionOptions.annotationDelay,
	      annotationDelay = _transitionOptions$an === void 0 ? 300 : _transitionOptions$an,
	      _transitionOptions$an2 = transitionOptions.annotationDuration,
	      annotationDuration = _transitionOptions$an2 === void 0 ? 500 : _transitionOptions$an2;
	  var horizontalBars = env.layout.orientation() === 'vertical';
	  var transitions = [];
	  if (!annotations) return;
	  annotations.forEach(function (annotation, index) {
	    var dataIndex = fieldIndexOf(env.data.fields[0], annotation.categorical_value);
	    var pos = horizontalBars ? env.y.getPositionFromIndex(dataIndex, true) : env.x.getPositionFromIndex(dataIndex, true);
	    var aDelay = delay + annotationDelay + duration * pos;
	    var els = target.selectAll(".annotation-".concat(index));
	    var t = els.transition().duration(annotationDuration).delay(aDelay).style('opacity', 1);
	    transitions.push(t);
	  });
	  return transitions;
	}

	// progresses along

	function stageBarLabelTransition(target, env, transitionOptions) {
	  target.selectAll('g.label-container > text').style('opacity', 0);
	}
	function playBarLabelTransition(target, env, transitionOptions) {
	  var data = env.data;
	  var delay = transitionOptions.delay,
	      duration = transitionOptions.duration,
	      _transitionOptions$an = transitionOptions.annotationDelay,
	      annotationDelay = _transitionOptions$an === void 0 ? 300 : _transitionOptions$an,
	      _transitionOptions$an2 = transitionOptions.annotationDuration,
	      annotationDuration = _transitionOptions$an2 === void 0 ? 500 : _transitionOptions$an2;
	  var dataLength = data.data.length;
	  var transitions = [];
	  target.selectAll('g.label-container > text').each(function (d, index) {
	    var node = select(this);
	    var aDelay = delay + annotationDelay + duration * (index / dataLength);
	    var t = node.transition().duration(annotationDuration).delay(aDelay).style('opacity', 1);
	    transitions.push(t);
	  });
	  return transitions;
	}

	function barTransitions(target, chartData, options) {
	  var _options$transition = options.transition,
	      transition = _options$transition === void 0 ? {} : _options$transition;
	  var _transition$type = transition.type,
	      type = _transition$type === void 0 ? 'default' : _transition$type;

	  if (type === 'synced') {
	    return _objectSpread2(_objectSpread2({}, syncedTransition$2()), transition);
	  } else if (type === 'chained') {
	    return _objectSpread2(_objectSpread2({}, chainedTransition$2()), transition);
	  } else if (type !== 'none') {
	    return _objectSpread2(_objectSpread2({}, staggeredTransition$4()), transition);
	  }
	}

	function makeStageHandler$4(type) {
	  return function (target, env, transitionOptions) {
	    var nodes = target.selectAll('rect.column').nodes();
	    var horizontalBars = env.layout.orientation() === 'vertical';
	    var valProp = 'y',
	        lengthProp = 'height';

	    if (horizontalBars) {
	      valProp = 'x';
	      lengthProp = 'width';
	    }

	    nodes.forEach(function (node, index) {
	      var bar = select(node);
	      var length = Number(bar.attr(lengthProp));
	      var val = Number(bar.attr(valProp));
	      var zeroVal = horizontalBars ? env.x.scale(0) : env.y.scale(0);
	      bar.attr(lengthProp, 0).attr(valProp, zeroVal).attr("data-transition-".concat(valProp), val).attr("data-transition-".concat(lengthProp), length);
	    });
	    stageAnnotationTransition(target);
	    stageBarLabelTransition(target);
	  };
	}

	function makePlayHandler$4(type) {
	  return playInterface(function (target, env, transitionOptions) {
	    var data = env.data;
	    var delay = transitionOptions.delay,
	        duration = transitionOptions.duration,
	        normalizeSpeed = transitionOptions.normalizeSpeed,
	        _transitionOptions$ba = transitionOptions.barDuration,
	        barDuration = _transitionOptions$ba === void 0 ? 800 : _transitionOptions$ba;
	    var nodes = target.selectAll('rect.column').nodes();
	    var durationOffset = duration - barDuration;
	    var barDelay = type === 'staggered' ? durationOffset / (data.data.length * (data.fields.length - 1)) : durationOffset;
	    var rangeLength = env.y.rangeLength();
	    var transitions = [];
	    var valProp = 'y',
	        lengthProp = 'height';
	    var horizontalBars = env.layout.orientation() === 'vertical';

	    if (horizontalBars) {
	      valProp = 'x';
	      lengthProp = 'width';
	    }

	    nodes.forEach(function (node, index) {
	      var bar = select(node);
	      var length = Number(bar.attr("data-transition-".concat(lengthProp)));
	      var val = Number(bar.attr("data-transition-".concat(valProp)));
	      var speedRatio = normalizeSpeed ? length / rangeLength : 1.0;
	      var t = bar.transition().duration(barDelay + barDuration * speedRatio).delay(delay + index * barDelay).attr(lengthProp, length).attr(valProp, val);
	      transitions.push(t);
	    });
	    transitions.concat(playAnnotationTransition(target, env, transitionOptions));
	    transitions.concat(playBarLabelTransition(target, env, transitionOptions));
	    return transitions;
	  });
	} // staggered transition will render one, then the other next


	function staggeredTransition$4(container, chartData, options) {
	  var stageHandler = makeStageHandler$4();
	  var playHandler = makePlayHandler$4('staggered');

	  var interruptHandler = function interruptHandler() {
	    return null;
	  };

	  return {
	    duration: 3000,
	    normalizeSpeed: false,
	    stageHandler: stageHandler,
	    playHandler: playHandler,
	    interruptHandler: interruptHandler
	  };
	}
	function chainedTransition$2(container, chartData, options) {
	  var stageHandler = makeStageHandler$4();
	  var playHandler = makePlayHandler$4('chained');

	  var interruptHandler = function interruptHandler() {
	    return null;
	  };

	  return {
	    duration: 2000,
	    normalizeSpeed: false,
	    stageHandler: stageHandler,
	    playHandler: playHandler,
	    interruptHandler: interruptHandler
	  };
	} // synced transition will render all lines at the same time

	function syncedTransition$2(target, options) {
	  var stageHandler = makeStageHandler$4();
	  var playHandler = makePlayHandler$4('synced');
	  return {
	    normalizeSpeed: false,
	    stageHandler: stageHandler,
	    playHandler: playHandler
	  };
	}

	var CATEGORICAL_COLUMN_MIN = 5;
	var CATEGORICAL_COLUMN_MAX = 12;
	var APPLIED_ASPECT = 2.3;
	var MIN_ASPECT = 0.6;
	var MAX_ASPECT = 3.0;
	var HORIZONTAL_TYPES = ['hbar', 'horizontalColumn', 'horizontalColumnStacked', 'horizontalBar', 'stackedHbar', 'horizontalDumbbell'];
	function column(target, chartData, options) {
	  var defaults = {
	    // this is set from the outside to drive JS sizing relative
	    // to a CSS font size.  1.0 == 14px
	    fontSizeRatio: 1.0,
	    // some settings for horizontal layout switching
	    // min width for column before horizontal layout
	    columnWidthBreakpointMin: 30,
	    // max width for column (basically disabled at 1000+)
	    columnWidthBreakpointMax: 1250,
	    // how many characters triggers long text breakpoints
	    textLengthBreakpoint: 20,
	    // if long text min width of column
	    columnWidthLongTextBreakpoint: 80,
	    // everything under this width is horizontal
	    smallWidthBreakpoint: 500,
	    // everything under this width is horizontal table layout
	    mobileWidthBreakpoint: 380,
	    // amount to offset label for mobile view
	    mobileColumnOffset: 6,
	    // distance tooltip box is away from point
	    tooltipOffsetX: 7,
	    // distance tooltip box is away from point
	    tooltipOffsetY: 7,
	    // tooltip box line for height estimation
	    tooltipLineHeight: 30,
	    // tooltip max width
	    tooltipMaxWidth: 160,
	    // radius of tooltip anchor
	    tooltipAnchorSize: 4,
	    // replaces axis inner padding for date axes
	    dateAxisInnerPadding: 15,
	    // Max lines before condensed mode
	    maxLinesBeforeCondense: 15,
	    // Max lines before single series condense
	    maxLinesBeforeCondenseSingle: 15,
	    // space between horizontal column and label
	    columnLabelOffset: 8,
	    // disable * condensed annotations
	    preventCondensedAnnotations: true,
	    // configuration options for layout manager
	    layoutManager: {
	      yAxisInnerPadding: 0,
	      xAxisExtendRight: 7,
	      margin: {
	        top: 10,
	        right: 0,
	        bottom: 0,
	        left: 0
	      }
	    },
	    // configuration for the chart axes
	    bandAxis: {
	      horizontalBarHeight: 32,
	      horizontalBarHeightCondensed: 24,
	      horizontalBarPadding: 0.2,
	      horizontalBarPaddingCondensed: 0.12,
	      horizontalBarHeightMin: 10,
	      axisTextLineHeight: 18,
	      axisTextLineHeightHorizontal: 18,
	      minHeightHorizontal: 0
	    },
	    dateAxis: {},
	    linearAxis: {},
	    // configuration for animation
	    transition: _objectSpread2({}, barTransitions(target, chartData, options))
	  };

	  var opts = _merge(defaults, options || {});

	  var el = select(target).classed('toaster-chart-column', true).classed('bar-colors', true).classed('quad-colors', isQuadSeries(chartData)).classed('transition-stage', stageForTransition(opts));
	  columnTaxonomy(chartData, opts);
	  var env = makeEnv(el, chartData, opts); // confusing but stackedHbar is vertical

	  var orientation = HORIZONTAL;
	  var yAxisPosition = RIGHT$1;
	  var isHorizontal = isChartHorizontal(el, chartData, env.options);
	  var isDateAxis = false;
	  var isContinuousAxis = false;

	  if (!isHorizontal) {
	    isDateAxis = renderChartAsTimeSeries(el, chartData, env.options);
	    isContinuousAxis = renderAxisAsContinuous(el, chartData, env.options);
	  }

	  if (isHorizontal) {
	    // if horizontal and sort enabled
	    if (chartData.config && chartData.config.sort_by_value && !isTimeSeries(chartData)) {
	      if (isNegativeDomain(chartData)) {
	        sortAllFields(chartData, {
	          direction: 'ascending'
	        });
	      } else {
	        sortAllFields(chartData);
	      }
	    }

	    orientation = VERTICAL;
	    yAxisPosition = LEFT$1; // endcaps by default on single series

	    env.options.labelCaps = true;
	    env.options.tableLabels = false;
	    env.options.disableGrid = true;
	    env.options.layoutManager.margin.top = 0;
	    env.options.layoutManager.margin.bottom = 20;
	    env.options.layoutManager.margin.right = 30;
	    env.options.layoutManager.margin.left = 0;
	    env.options.layoutManager.yAxisInnerPadding = 0;
	    env.options.layoutManager.verticalAxisShift = 0;
	    var series = getSeries(chartData);
	    var vRatio = getHeightRatio(env);
	    var minHeight = env.options.layoutManager.minHeight;
	    var minBarHeight = 0;

	    if (minHeight) {
	      minBarHeight = minHeight / getNumberOfColumns(env.data);
	    }

	    if (env.options.mobileColumnChart) {
	      env.options.bandAxis.horizontalBarHeight = 30 + 25 / series.length;
	      env.options.bandAxis.horizontalBarPadding = 0.2 + 0.35 / series.length;
	      env.options.layoutManager.yAxisInnerPadding = 0;
	      env.options.layoutManager.yAxisForceZeroWidth = true;
	      env.options.layoutManager.verticalAxisShift = 8;
	    } else {
	      var w = el.node().offsetWidth; // make sure labels don't go over half screen

	      env.options.bandAxis.verticalAxisWrapWidth = w / 2;
	      env.options.bandAxis.horizontalBarHeight *= vRatio; // env.options.bandAxis.horizontalBarPadding *= 0.8
	      // if screenshot mode calculate horizontalBarHeight

	      if (env.options.screenshotMode) {
	        env.options.bandAxis.horizontalBarHeight = Math.max(minBarHeight, env.options.bandAxis.horizontalBarHeight);
	      }

	      if (isMobileWidth(w, env.options)) {
	        env.options.bandAxis.axisTextLineHeightHorizontal = 12;
	      }
	    } // go to a condensed view when too many values
	    // condensed view has no labels


	    if (!env.options.mobileColumnChart && (series.length > 1 && chartData.data.length * series.length > env.options.maxLinesBeforeCondense || chartData.data.length > env.options.maxLinesBeforeCondenseSingle)) {
	      env.options.condensedView = true;
	      env.options.labelCaps = false;
	      env.options.disableGrid = false;
	      env.options.bandAxis.horizontalBarHeight = Math.max(minBarHeight, env.options.bandAxis.horizontalBarHeightMin, env.options.bandAxis.horizontalBarHeightCondensed * vRatio / series.length);
	      env.options.bandAxis.horizontalBarPadding = env.options.bandAxis.horizontalBarPaddingCondensed;
	    }

	    if (env.options.labelCaps && !env.options.mobileColumnChart) {
	      env.options.layoutManager.yAxisInnerPadding = 8;
	    } else if (!env.options.labelCaps && !env.options.mobileColumnChart) {
	      env.options.layoutManager.verticalAxisShift = -5;
	    } // if horizontal chart with mixed domain (positive and negative)
	    // we render tableLabels (all values at the end)


	    if (env.options.labelCaps && isMixedDomain(chartData)) {
	      env.options.labelCaps = false;
	      env.options.tableLabels = true;
	      env.options.layoutManager.margin.right = 60;
	      env.options.bandAxis.horizontalBarPadding = 0.4;
	      env.options.bandAxis.horizontalBarHeight *= 0.8;
	    } // if negative domain we draw label caps to the right of
	    // negative chart values rather than the left


	    if (env.options.labelCaps && isNegativeDomain(chartData)) {
	      yAxisPosition = RIGHT$1;
	    }
	  }

	  el.classed('vertical-flow', isHorizontal); // cleanup horizontal/vertical bits on layout change

	  if (el.attr('toaster-flow') && el.attr('toaster-flow') !== orientation) {
	    el.select('.chart').selectAll('*').remove();
	  }

	  el.attr('toaster-flow', orientation);

	  var bandAxisConfig = _objectSpread2({
	    isPrimaryAxis: true,
	    isDateAxis: isDateAxis,
	    isContinuousAxis: isContinuousAxis
	  }, env.options.bandAxis);

	  var linearAxisConfig = _objectSpread2({
	    isPrimaryAxis: false,
	    domainFromZero: true
	  }, env.options.linearAxis); // allow every component of the layout to be
	  // overriden by external options


	  var layoutConfig = _objectSpread2({
	    primaryAxis: bandAxisProvider(bandAxisConfig),
	    secondaryAxis: linearAxisProvider(linearAxisConfig),
	    orientation: orientation,
	    yAxisPosition: yAxisPosition
	  }, env.options.layoutManager);

	  if (isDateAxis) {
	    layoutConfig.yAxisInnerPadding = env.options.dateAxisInnerPadding;
	  }

	  var chartLayout = layoutManager(layoutConfig, env.options);
	  var chart = el.selectAppend('div.chart');
	  chart.selectAll('*').remove();
	  chart.call(chartLayout, env);
	  var column = chartLayout.draw().classed('column', true);
	  var gridLength = env.x.rangeLength() + chartLayout.xAxisExtendRight() + 2 * chartLayout.yAxisInnerPadding(); // grid is now a render layer

	  var showGrid = isHorizontal && !env.options.disableGrid || shouldDisplayGrid(env);
	  el.classed('no-grid', !showGrid).classed('no-domain', !shouldDisplayDomain(env)).classed('no-axis', env.options.disableGrid);

	  if (!isHorizontal) {
	    column.selectAppend('g.grid').call(gridlines({
	      length: gridLength
	    }), env);
	  } else {
	    gridLength = env.y.rangeLength() + 2 * chartLayout.xAxisInnerPadding();
	    column.selectAppend('g.grid').call(gridlines({
	      length: gridLength,
	      orientation: Y
	    }), env);
	  }

	  if (!isHorizontal) {
	    // allow a layer for highlighting ranges below the chart
	    if (chartData.config.highlightRanges) {
	      var _chartData$config$hig = chartData.config.highlightRanges,
	          ranges = _chartData$config$hig.ranges,
	          rangeStyle = _chartData$config$hig.rangeStyle;
	      column.selectAppend('g.highlight-ranges').call(highlightRanges({
	        ranges: ranges,
	        rangeStyle: rangeStyle,
	        isColumnType: true
	      }), env);
	    }
	  }

	  column.call(simpleColumn({
	    xScale: env.x.scale,
	    yScale: env.y.scale,
	    orientation: orientation
	  }), env);

	  if (env.options.labelCaps) {
	    drawColumnLabels(column, env);
	  } else if (env.options.tableLabels) {
	    drawColumnTableLabels(column, env);
	  }

	  placeVerticalAxisLabel(env, isHorizontal);
	  columnAnnotations(column, chartData.annotations, env);

	  if (!isHorizontal) {
	    // allow horizontal line thresholds
	    if (chartData.config.thresholds) {
	      column.selectAppend('g.threshold-lines').call(thresholdLines(_objectSpread2(_objectSpread2({}, env.options), {}, {
	        thresholds: chartData.config.thresholds
	      })), env);
	    }
	  } // create bottom label if needed


	  chart.call(bottomLabel(), env, chartData); // overflow layout call

	  chartLayout.overflowScale();

	  if (!(env.options.disableTooltip || chartData.config.disableTooltip)) {
	    columnTooltip({
	      chart: chart,
	      area: column,
	      env: env
	    });
	  }

	  debugEnv(env);
	  return makeLayerPrototype(column, [{
	    el: el,
	    env: env
	  }], opts);
	} // we need to apply a height ratio based on the aspectRatio
	// provided - but applied for vertical height

	function getHeightRatio(env, numBars) {
	  var ratio = '5:2';

	  if (env.data.chartOptions && env.data.chartOptions.aspectRatio) {
	    ratio = env.data.chartOptions.aspectRatio;
	  }

	  if (typeof ratio === 'string') {
	    ratio = ratio.split(':')[0] / ratio.split(':')[1];
	  } // specific sizing to COTH


	  if (env.options.ratioHeightOffset) {
	    ratio += 1.0;
	  }

	  return Math.max(MIN_ASPECT, Math.min(MAX_ASPECT, APPLIED_ASPECT / ratio));
	} // This is for columns and stacked columns to determine by data
	// and element width alone if the chart should be vertical or
	// horizontal
	// NOTE: this has side-effect of setting options.mobileColumnChart

	function isChartHorizontal(el, chartData, options) {
	  var width = el.node().offsetWidth;
	  var isHorizontal = HORIZONTAL_TYPES.includes(chartData.chartType) || options.forceHorizontalColumns; // these two options are set by the user but should not apply to
	  // mobile width charts

	  if (width > options.smallWidthBreakpoint) {
	    if (options.forceVerticalColumns) return false;
	    if (chartData.config.force_vertical_bars) return false;
	  }

	  if (options.verticalBarsOnly) return false;
	  if (isHorizontal) return isHorizontal;
	  var isStacked = options.stackedBand;
	  var columnCount = chartData.data.length * (chartData.fields.length - 1);
	  if (isStacked) columnCount = chartData.data.length;
	  var columnWidth = width / columnCount;
	  if (columnCount <= 2) return true; // when time series is cast to categorical maintain V Bars

	  if (chartData.chartOptions.isCategoricalTime) return false;
	  if (isTimeSeries(chartData)) return false;

	  if (columnWidth < options.columnWidthBreakpointMin || columnWidth > options.columnWidthBreakpointMax) {
	    return true;
	  } // if the primary field is a date field (years or quarters)
	  // keep the chart as a vertical bar


	  var field = chartData.fields[0];

	  if (field.taxonomy && field.taxonomy.isDate) {
	    return false;
	  } // now perform a check for long text


	  var longestText = 0;
	  chartData.fields[0].data.forEach(function (val) {
	    if (val == null || val.length == null) return;
	    longestText = Math.max(longestText, val.length);
	  });

	  if (longestText > options.textLengthBreakpoint && columnWidth < options.columnWidthLongTextBreakpoint) {
	    isHorizontal = true;
	  }

	  if (width < options.smallWidthBreakpoint) {
	    isHorizontal = true; // set horizontal chart style to mobile

	    if ((width < options.mobileWidthBreakpoint || longestText > options.textLengthBreakpoint) && !isStacked && isPositiveDomain(chartData)) {
	      options.mobileColumnChart = true;
	    }
	  }

	  return isHorizontal;
	} // We need to keep core taxonomy functions agnostic to the
	// chart type, but sometimes we want to refine
	// the taxonomy (ie, categorical axes for bar charts vs line)

	function columnTaxonomy(data, options) {
	  buildTaxonomy(data, false, options);
	  data.chartOptions = data.chartOptions || {};
	  data.chartOptions.isCategorical = true; // because categorical will override isTimeSeries

	  if (data.chartOptions.isCategoricalTime == null) {
	    data.chartOptions.isCategoricalTime = isTimeSeries(data);
	  }

	  if (isContinuousTimeSeries(data) && data.data.length >= CATEGORICAL_COLUMN_MIN || isTimeSeries(data) && data.data.length >= CATEGORICAL_COLUMN_MAX) {
	    data.chartOptions.isCategorical = false;
	  }

	  buildTaxonomy(data, true, options); // force rebuild taxonomy
	}

	function simpleColumnStacked(options) {
	  options = options || {};
	  var xScale = options.xScale;
	  var yScale = options.yScale;
	  var seriesOffset = options.seriesOffset || 0;

	  function simpleColumnStacked(selection) {
	    selection.each(function (chartData) {
	      var el = select(this).classed('simple-column-stacked', true);
	      var categoricalData = getFieldIndexValueParser(chartData, true, true);
	      var series = options.seriesData || getSeries(chartData);
	      var dataAsObject = series[0].data.map(function (d, i) {
	        var rowObj = {};
	        chartData.data[i].forEach(function (val, index) {
	          rowObj[index - 1 - seriesOffset] = val;
	        });
	        return rowObj;
	      });
	      var stackedData = d3stack().keys(range$2(0, series.length)).offset(stackOffsetDiverging)(dataAsObject);
	      var cSeries = el.selectAll('.series').data(stackedData);
	      cSeries.exit().remove();
	      cSeries = cSeries.enter().append('g').attr('class', function (d, i) {
	        return 'series f series-' + (i + seriesOffset);
	      }).merge(cSeries);
	      var columns = cSeries.selectAll('.column').data(function (d) {
	        return d;
	      });
	      columns.exit().remove(); // HORIZONTAL layout equals vertical bars

	      if (options.orientation === HORIZONTAL) {
	        columns.enter().append('rect').attr('class', 'column').merge(columns).attr('x', function (d, i) {
	          return xScale(categoricalData(i));
	        }).attr('y', function (d, i) {
	          return yScale(d[1]);
	        }).attr('width', Math.max(1, xScale.bandwidth())).attr('height', function (d) {
	          return yScale(d[0]) - yScale(d[1]);
	        });
	      } else {
	        // these are horizontal bars
	        columns.enter().append('rect').attr('class', 'column').merge(columns).attr('y', function (d, i) {
	          return yScale(categoricalData(i));
	        }).attr('x', function (d, i) {
	          return xScale(d[0]);
	        }).attr('height', yScale.bandwidth()).attr('width', function (d) {
	          return xScale(d[1]) - xScale(d[0]);
	        });
	      }
	    });
	  }

	  simpleColumnStacked.xScale = function (_) {
	    return arguments.length ? (xScale = _, simpleColumnStacked) : xScale; // eslint-disable-line
	  };

	  simpleColumnStacked.yScale = function (_) {
	    return arguments.length ? (yScale = _.copy(), simpleColumnStacked) : yScale; // eslint-disable-line
	  };

	  return simpleColumnStacked;
	}

	function stackedBarTransitions(target, chartData, options) {
	  var _options$transition = options.transition,
	      transition = _options$transition === void 0 ? {} : _options$transition;
	  return _objectSpread2(_objectSpread2({}, staggeredTransition$3()), transition);
	}

	function makeStageHandler$3(staggered) {
	  return function (target, env, transitionOptions) {
	    var columns = getOrderedStackedNodes(target, env);
	    var horizontalBars = env.layout.orientation() === 'vertical';
	    var zeroVal = horizontalBars ? env.x.scale(0) : env.y.scale(0);
	    var valProp = 'y',
	        lengthProp = 'height';

	    if (horizontalBars) {
	      valProp = 'x';
	      lengthProp = 'width';
	    }

	    columns.forEach(function (column, index) {
	      column.forEach(function (node) {
	        var bar = select(node);
	        var length = Number(bar.attr(lengthProp));
	        var val = Number(bar.attr(valProp)); // inverse for negative bars

	        if (!horizontalBars && val >= zeroVal || horizontalBars) {
	          bar.attr(lengthProp, 0).attr(valProp, val).attr("data-transition-".concat(valProp), val).attr("data-transition-".concat(lengthProp), length);
	        } else {
	          bar.attr(lengthProp, 0).attr(valProp, val + length).attr("data-transition-".concat(valProp), val).attr("data-transition-".concat(lengthProp), length);
	        }
	      });
	    });
	  };
	}

	function makePlayHandler$3(staggered) {
	  return playInterface(function (target, env, transitionOptions) {
	    var data = env.data;
	    var duration = transitionOptions.duration,
	        normalizeSpeed = transitionOptions.normalizeSpeed;
	    var barDelay = duration / (data.data.length * (data.fields.length - 1));
	    var barDuration = duration / 2;
	    var rangeLength = env.y.rangeLength();
	    var transitions = [];
	    var valProp = 'y',
	        lengthProp = 'height';
	    var horizontalBars = env.layout.orientation() === 'vertical';

	    if (horizontalBars) {
	      valProp = 'x';
	      lengthProp = 'width';
	    }

	    var columns = getOrderedStackedNodes(target, env);
	    columns.forEach(function (column, index) {
	      var sectionDelay = 0;
	      var columnDelay = barDelay * index;
	      var columnLength = column.reduce(function (len, node) {
	        return len + Number(select(node).attr("data-transition-".concat(lengthProp)));
	      }, 0);
	      var speedRatio = normalizeSpeed ? columnLength / rangeLength : 1.0;
	      column.forEach(function (node) {
	        var bar = select(node);
	        var length = Number(bar.attr("data-transition-".concat(lengthProp)));
	        var val = Number(bar.attr("data-transition-".concat(valProp)));
	        var sectionDuration = length / columnLength * (barDuration * speedRatio);
	        var instance = bar.transition().ease(linear$1).duration(sectionDuration).delay(columnDelay + sectionDelay).attr(lengthProp, length).attr(valProp, val); // build each section animation as a delay

	        sectionDelay += sectionDuration;
	        transitions.push(instance);
	      });
	    });
	    return transitions;
	  });
	} // staggered transition will render one, then the other next


	function staggeredTransition$3(container, chartData, options) {
	  var stageHandler = makeStageHandler$3();
	  var playHandler = makePlayHandler$3();

	  var interruptHandler = function interruptHandler() {
	    return null;
	  };

	  return {
	    duration: 2000,
	    normalizeSpeed: false,
	    stageHandler: stageHandler,
	    playHandler: playHandler,
	    interruptHandler: interruptHandler
	  };
	} // getting the columns in the proper animation order is
	// tricky for stacked columns, as it has

	function getOrderedStackedNodes(target, env) {
	  var data = env.data;
	  var seriesVals = getSeries(data).map(function (field, i) {
	    return target.selectAll(".series-".concat(i, " rect.column")).nodes();
	  });
	  return seriesVals[0].map(function (v, index) {
	    var nodes = [];
	    seriesVals.forEach(function (set) {
	      nodes.push(set[index]);
	    });
	    return nodes;
	  });
	}

	function columnStacked(target, chartData, options) {
	  var defaults = {
	    // some settings for horizontal layout switching
	    // min width for column before horizontal layout
	    columnWidthBreakpointMin: 30,
	    // max width for column (disabled for now)
	    columnWidthBreakpointMax: 1250,
	    // how many characters triggers long text breakpoints
	    textLengthBreakpoint: 12,
	    // if long text min width of column
	    columnWidthLongTextBreakpoint: 110,
	    // everything under this width is horizontal
	    smallWidthBreakpoint: 500,
	    // everything under this width is horizontal table layout
	    mobileWidthBreakpoint: 380,
	    // distance tooltip box is away from point
	    tooltipOffsetX: 7,
	    // distance tooltip box is away from point
	    tooltipOffsetY: 7,
	    // tooltip box line for height estimation
	    tooltipLineHeight: 30,
	    // tooltip max width
	    tooltipMaxWidth: 160,
	    // radius of tooltip anchor
	    tooltipAnchorSize: 4,
	    // replaces axis inner padding for date axes
	    dateAxisInnerPadding: 15,
	    // 15,
	    // disable * condensed annotations
	    preventCondensedAnnotations: true,
	    stackedBand: true,
	    // configuration options for layout manager
	    layoutManager: {
	      yAxisInnerPadding: 0,
	      xAxisExtendRight: 7,
	      margin: {
	        top: 10,
	        right: 0,
	        bottom: 0,
	        left: 0
	      }
	    },
	    // configuration for the chart axes
	    bandAxis: {
	      horizontalBarPadding: 0.2,
	      horizontalBarPaddingCondensed: 0.12,
	      horizontalBarHeight: 32,
	      horizontalBarHeightLarge: 50,
	      // custom value for HBar charts
	      horizontalBarHeightCondensed: 24,
	      // custom value for HBar charts
	      axisTextLineHeightHorizontal: 15,
	      axisTextLineHeight: 18,
	      verticalAxisWrapWidth: 300
	    },
	    linearAxis: {},
	    // configuration for animation
	    transition: _objectSpread2({}, stackedBarTransitions(target, chartData, options))
	  };

	  var opts = _merge(defaults, options || {});

	  var el = select(target).classed('toaster-chart-column', true).classed('bar-colors', true).classed('quad-colors', isQuadSeries(chartData)).classed('transition-stage', stageForTransition(opts));
	  columnTaxonomy(chartData, opts);
	  var env = makeEnv(el, chartData, opts); // confusing but stackedHbar is vertical

	  var w = el.node().offsetWidth;
	  var orientation = HORIZONTAL;
	  var yAxisPosition = RIGHT$1;
	  var isHorizontal = isChartHorizontal(el, chartData, env.options);
	  var isDateAxis = false;
	  var isContinuousAxis = false;

	  if (!isHorizontal) {
	    isDateAxis = renderChartAsTimeSeries(el, chartData, env.options);
	    isContinuousAxis = renderAxisAsContinuous(el, chartData, env.options);
	  }

	  var minHeight = env.options.layoutManager.minHeight;
	  var minBarHeight = 0;

	  if (minHeight) {
	    minBarHeight = minHeight / getNumberOfColumns(env.data, true);
	  }

	  if (isHorizontal) {
	    // if horizontal sort descending
	    if (chartData.config && chartData.config.sort_by_value && !isTimeSeries(chartData)) {
	      if (isNegativeDomain(chartData)) {
	        sortAllFields(chartData, {
	          stacked: true,
	          direction: 'ascending'
	        });
	      } else {
	        sortAllFields(chartData, {
	          stacked: true
	        });
	      }
	    }

	    orientation = VERTICAL;
	    yAxisPosition = LEFT$1; // endcaps by default on single series

	    env.options.labelCaps = false;
	    env.options.disableGrid = false;

	    if (chartData.data.length <= 5) {
	      env.options.bandAxis.horizontalBarHeight = env.options.bandAxis.horizontalBarHeightLarge;
	    } else if (chartData.data.length > 15) {
	      env.options.bandAxis.horizontalBarHeight = env.options.bandAxis.horizontalBarHeightCondensed;
	    } // if screenshot mode calculate horizontalBarHeight


	    if (env.options.screenshotMode) {
	      env.options.bandAxis.horizontalBarHeight = Math.max(minBarHeight, env.options.bandAxis.horizontalBarHeight);
	    } // make sure labels don't go over half screen


	    env.options.bandAxis.verticalAxisWrapWidth = w / 2;

	    if (isMobileWidth(w, env.options)) {
	      env.options.bandAxis.axisTextLineHeightHorizontal = 12;
	    }

	    env.options.layoutManager.margin.top = 0;
	    env.options.layoutManager.margin.bottom = 20;
	    env.options.layoutManager.margin.right = 30;
	    env.options.layoutManager.margin.left = 0;
	    env.options.layoutManager.yAxisInnerPadding = 0;
	    env.options.layoutManager.verticalAxisShift = -5;
	  }

	  el.classed('vertical-flow', isHorizontal);

	  var bandAxisConfig = _objectSpread2({
	    isPrimaryAxis: true,
	    stackedBand: true,
	    isDateAxis: isDateAxis,
	    isContinuousAxis: isContinuousAxis
	  }, env.options.bandAxis);

	  var linearAxisConfig = _objectSpread2({
	    isPrimaryAxis: false,
	    domainFromZero: true,
	    stackedDomain: true
	  }, env.options.linearAxis);

	  var layoutConfig = _objectSpread2({
	    orientation: orientation,
	    yAxisPosition: yAxisPosition,
	    primaryAxis: bandAxisProvider(bandAxisConfig),
	    secondaryAxis: linearAxisProvider(linearAxisConfig)
	  }, env.options.layoutManager);

	  if (isDateAxis) {
	    layoutConfig.yAxisInnerPadding = env.options.dateAxisInnerPadding;
	  }

	  var chartLayout = layoutManager(layoutConfig);
	  var chart = el.selectAppend('div.chart');
	  chart.selectAll('*').remove();
	  chart.call(chartLayout, env);
	  var column = chartLayout.draw().classed('column', true);
	  var gridLength = env.x.rangeLength() + chartLayout.xAxisExtendRight() + 2 * chartLayout.yAxisInnerPadding(); // grid is now a render layer

	  var showGrid = isHorizontal && !env.options.disableGrid || shouldDisplayGrid(env);
	  el.classed('no-grid', !showGrid).classed('no-domain', !shouldDisplayDomain(env)).classed('no-axis', env.options.disableGrid);

	  if (orientation === HORIZONTAL) {
	    column.selectAppend('g.grid').call(gridlines({
	      length: gridLength
	    }), env);
	  } else {
	    gridLength = env.y.rangeLength() + 2 * chartLayout.xAxisInnerPadding();
	    column.selectAppend('g.grid').call(gridlines({
	      length: gridLength,
	      orientation: Y
	    }), env);
	  }

	  if (!isHorizontal) {
	    // allow a layer for highlighting ranges below the chart
	    if (chartData.config.highlightRanges) {
	      var _chartData$config$hig = chartData.config.highlightRanges,
	          ranges = _chartData$config$hig.ranges,
	          rangeStyle = _chartData$config$hig.rangeStyle;
	      column.selectAppend('g.highlight-ranges').call(highlightRanges({
	        ranges: ranges,
	        rangeStyle: rangeStyle,
	        isColumnType: true
	      }), env);
	    }
	  }

	  column.call(simpleColumnStacked({
	    xScale: env.x.scale,
	    yScale: env.y.scale,
	    orientation: orientation
	  }), env);
	  placeVerticalAxisLabel(env, isHorizontal);
	  columnAnnotations(column, chartData.annotations, env);

	  if (!isHorizontal) {
	    // allow horizontal line thresholds
	    if (chartData.config.thresholds) {
	      column.selectAppend('g.threshold-lines').call(thresholdLines(_objectSpread2(_objectSpread2({}, env.options), {}, {
	        thresholds: chartData.config.thresholds
	      })), env);
	    }
	  } // create bottom label if needed


	  chart.call(bottomLabel(), env, chartData); // overflow layout call

	  chartLayout.overflowScale();

	  if (!(env.options.disableTooltip || chartData.config.disableTooltip)) {
	    columnTooltip({
	      chart: chart,
	      area: column,
	      env: env
	    });
	  }

	  debugEnv(env);
	  return makeLayerPrototype(column, [{
	    env: env,
	    el: el
	  }], opts);
	} // Validation is a static method to check if the class
	// supports the chartData before building the chart

	columnStacked.validateData = function (chartData) {
	  var validate = validator(chartData);
	  return validate;
	};

	function simpleArea(options) {
	  options = options || {};

	  function simpleArea(selection, env) {
	    selection.each(function (chartData, i) {
	      var el = select(this).classed('simple-area', true);
	      var series = getSeries(chartData).slice(0); // clone

	      var xData = getFieldIndexValueParser(chartData);
	      var xScale = env.x.scale;

	      var yScale = function yScale(v) {
	        return Math.min(env.y.scale(v), Math.floor(env.y.rangeLength()));
	      }; // determine baseline by checking if 0 is within the domain
	      // or at one of the edges


	      var baseline = env.y.scale.domain()[0];
	      var domain = sortedDomain(env.y.scale.domain());

	      if (domain[0] === 0 || domain[1] === 0 || domain[0] < 0 && domain[1] > 0) {
	        baseline = 0;
	      }

	      var areaGroup = el.selectAppend('g.area-group');
	      var areas = areaGroup.selectAll('.line-area').data(series);

	      if (options.xOffset) {
	        areaGroup.attr('transform', "translate(".concat(options.xOffset, ")"));
	      }

	      var area = d3area().x(function (d, i) {
	        return xScale(xData(i));
	      }).y1(yScale(baseline)).y0(function (d) {
	        return yScale(d);
	      }).defined(isDefined);
	      areas.exit().remove();
	      areas.enter().append('path').attr('class', function (d, i) {
	        return "line-area f s series-".concat(i);
	      }).merge(areas).attr('d', function (d) {
	        return area(d.data);
	      });
	    });
	    return selection;
	  }

	  return simpleArea;
	}

	function simpleAreaStacked(options) {
	  options = options || {};

	  function simpleAreaStacked(selection, env) {
	    selection.each(function (chartData, i) {
	      var el = select(this).classed('simple-area', true);
	      var xScale = env.x.scale;
	      var xData = getFieldIndexValueParser(chartData);

	      var yScale = function yScale(v) {
	        return Math.min(env.y.scale(v), Math.floor(env.y.rangeLength()));
	      };

	      var stackedKeys = range$2(1, chartData.data[0].length);
	      var stackedData = d3stack().keys(stackedKeys)(chartData.data);
	      var areaGroup = el.selectAppend('g.area-group');
	      var areas = areaGroup.selectAll('.line-area').data(stackedData);

	      if (options.xOffset) {
	        areaGroup.attr('transform', "translate(".concat(options.xOffset, ")"));
	      }

	      var area = d3area().x(function (d, i) {
	        return xScale(xData(i));
	      }).y0(function (d) {
	        return yScale(d[0]);
	      }).y1(function (d) {
	        return yScale(d[1]);
	      }).defined(function (d) {
	        var isDefined = true;
	        stackedKeys.forEach(function (k) {
	          if (isNaN(d[k])) return false;
	          if (d[k] === null || d[k] === undefined) return false;
	        });
	        return isDefined;
	      });
	      areas.exit().remove();
	      areas.enter().append('path').attr('class', function (d, i) {
	        return "line-area f series-".concat(i);
	      }).merge(areas).attr('d', function (d) {
	        return area(d);
	      });
	    });
	    return selection;
	  }

	  return simpleAreaStacked;
	}

	var curveTypes$1 = {
	  step: curveStep,
	  stepAfter: stepAfter,
	  stepBefore: stepBefore,
	  smooth: curveBasis
	};
	function simpleLine(options) {
	  var xScale = options.xScale;
	  var yScale = options.yScale;
	  var seriesOffset = options.seriesOffset || 0;

	  function simpleLine(selection) {
	    selection.each(function (chartData, i) {
	      var el = select(this).classed('simple-line', true); // bar+line will pass in options.forceCategorical

	      var xData = getFieldIndexValueParser(chartData, true, options.forceCategorical);

	      var series = _toConsumableArray(options.seriesData || getSeries(chartData)).reverse();

	      var lineGroup = el.selectAppend('g.line-group');
	      var lines = lineGroup.selectAll('.line').data(series);

	      var reverseIndex = function reverseIndex(i) {
	        return series.length - 1 - i;
	      };

	      if (options.xOffset) {
	        lineGroup.attr('transform', "translate(".concat(options.xOffset, ")"));
	      }

	      var line = d3line().x(function (d, i) {
	        return xScale(xData(i));
	      }).y(function (d, i) {
	        return yScale(d);
	      }).defined(isDefined);

	      if (options.curve && curveTypes$1[options.curve]) {
	        line.curve(curveTypes$1[options.curve]);
	      }

	      lines.exit().remove(); // we now reverse

	      lines.enter().append('path').attr('class', function (d, i) {
	        return 'line s series-' + (reverseIndex(i) + seriesOffset);
	      }).merge(lines).attr('d', function (d) {
	        return line(d.data);
	      });
	    });
	  }

	  simpleLine.xScale = function (_) {
	    return arguments.length ? (xScale = _, simpleLine) : xScale; // eslint-disable-line
	  };

	  simpleLine.yScale = function (_) {
	    return arguments.length ? (yScale = _, simpleLine) : yScale; // eslint-disable-line
	  };

	  return simpleLine;
	}

	var curveTypes = {
	  step: curveStep,
	  stepAfter: stepAfter,
	  stepBefore: stepBefore,
	  smooth: curveBasis
	}; // this renderer is specifically for filling in the gaps of a
	// chart that contains gaps

	function dashedLine(options) {
	  var xScale = options.xScale,
	      yScale = options.yScale,
	      segments = options.segments,
	      curve = options.curve,
	      _options$seriesOffset = options.seriesOffset,
	      seriesOffset = _options$seriesOffset === void 0 ? 0 : _options$seriesOffset,
	      _options$isSolid = options.isSolid,
	      isSolid = _options$isSolid === void 0 ? false : _options$isSolid;

	  function dashedLine(selection) {
	    selection.each(function (chartData, i) {
	      var el = select(this).classed('simple-line', true);
	      var xData = getFieldIndexValueParser(chartData);
	      var lineGroup = el.selectAppend('g.line-group');
	      var lines = lineGroup.selectAll('.dashed-line').data(segments);
	      var line = d3line().x(function (d) {
	        return xScale(xData(d.index));
	      }).y(function (d) {
	        return yScale(d.value);
	      });

	      if (curve && curveTypes[curve]) {
	        line.curve(curveTypes[curve]);
	      }

	      lines.exit().remove();
	      lines.enter().append('path').attr('class', function (d, i) {
	        return "dashed-line s series-".concat(i + seriesOffset);
	      }).merge(lines).classed('show-solid-line', isSolid).attr('d', function (d) {
	        return d.reduce(function (str, segment) {
	          str += line(segment.data);
	          return str;
	        }, '');
	      });
	    });
	  }

	  return dashedLine;
	}

	function valueTag(options) {
	  var xScale = options.xScale;
	  var yScale = options.yScale;
	  var seriesOffset = options.seriesOffset || 0;

	  function valueTag(selection) {
	    selection.each(function (chartData, i) {
	      var el = select(this).classed('simple-line', true);
	      var formatOptions = {
	        defaultDecimals: 1,
	        bareValue: true,
	        isTooltip: true
	      };
	      var format = valueFormatter(options.env.y, options.env, formatOptions);
	      var xData = getFieldIndexValueParser(chartData);
	      var series = options.seriesData || getSeries(chartData);
	      var tagGroup = el.selectAppend('g.value-tag-group');
	      var tags = tagGroup.selectAll('.tags').data(series);

	      if (options.xOffset) {
	        tagGroup.attr('transform', "translate(".concat(options.xOffset, ")"));
	      }

	      var pathD = function pathD(w) {
	        return "M".concat(w - 1, ",0.8c0,7.5,0,15,0,22.5c-22,0-").concat(w / 2 + 4, ",0-").concat(w - 14, ",0c-4-3.8-8-7.7-12-11.5c4-3.7,8-7.3,12-11C35,0.8,").concat(w - 23, ",0.8,").concat(w - 1, ",0.8z");
	      };

	      tags.exit().remove();
	      var tagEntries = tags.enter().append('g').attr('class', 'tag').merge(tags).style('display', function (d) {
	        return d.data[d.data.length - 1] ? 'block' : 'none';
	      }).attr('transform', function (d) {
	        var lastIndex = d.data.length - 1;
	        var lastPoint = d.data[lastIndex];
	        return "translate(".concat(xScale(xData(lastIndex)), ", ").concat(yScale(lastPoint), ")");
	      }); // const paths = tags.selectAll('path').data(series)
	      // tags.enter().selectAll('g.tag')

	      tagEntries.append('path').attr('class', function (d, i) {
	        return 'f series-' + (i + seriesOffset);
	      }).style('transform', 'translate(-2, -10) scale(0.85)').merge(tagEntries).attr('d', pathD(64)); // const texts = tags.selectAll('text').data(series)
	      // tags.enter().selectAll('g.tag')

	      tagEntries.append('text').merge(tagEntries).style('fill', 'white').attr('x', 13).attr('y', 5).text(function (d) {
	        return format(d.data[d.data.length - 1]);
	      }); // after text is in place use text length to crop the tag

	      tagGroup.selectAll('g.tag').each(function () {
	        var width = select(this).select('text').node().getComputedTextLength();
	        select(this).select('path').attr('d', pathD(width + 30));
	      });
	    });
	  }

	  return valueTag;
	}

	function lineTransitions(target, chartData, options) {
	  // need to ensure options.transition exists
	  if (!options.transition) options.transition = {};
	  var transition = options.transition;
	  var _transition$type = transition.type,
	      type = _transition$type === void 0 ? 'default' : _transition$type;

	  if (type === 'synced') {
	    return _objectSpread2(_objectSpread2({}, syncedTransition$1()), transition);
	  } else if (type === 'chained') {
	    return _objectSpread2(_objectSpread2({}, chainedTransition$1(target, chartData)), transition);
	  } else if (type !== 'none') {
	    return _objectSpread2(_objectSpread2({}, staggeredTransition$2(target, chartData, options)), transition);
	  }
	}

	function makeStageHandler$2(transitionType) {
	  return function (target, env, transitionOptions) {
	    target.selectAll('.line-group path').each(function () {
	      var pathLength = this.getTotalLength();
	      select(this).attr('stroke-dasharray', "".concat(pathLength, " ").concat(pathLength)).attr('stroke-dashoffset', pathLength);
	      return pathLength;
	    });
	    stageAnnotationTransition(target);
	  };
	}

	function makePlayHandler$2(type) {
	  return playInterface(function (target, env, transitionOptions) {
	    var delay = transitionOptions.delay,
	        duration = transitionOptions.duration,
	        staggerDelay = transitionOptions.staggerDelay;
	    var nodes = target.selectAll('path.line').nodes();
	    var lineDuration = duration;

	    if (type === 'chained') {
	      lineDuration = duration / nodes.length;
	    } else if (type === 'staggered') {
	      lineDuration = duration - nodes.length * staggerDelay;
	    }

	    var transitions = [];
	    nodes.forEach(function (node, i) {
	      var lineDelay = delay;

	      if (type === 'chained') {
	        lineDelay = delay + i * lineDuration;
	      } else if (type === 'staggered') {
	        lineDelay = delay + i * staggerDelay;
	      }

	      var t = select(node).transition().delay(lineDelay).duration(lineDuration).attr('stroke-dashoffset', 0);
	      transitions.push(t);
	    });
	    transitions.concat(playAnnotationTransition(target, env, transitionOptions));
	    return transitions;
	  });
	} // staggered transition will render one, then the other next


	function staggeredTransition$2(container, chartData, options) {
	  var stageHandler = makeStageHandler$2();
	  var playHandler = makePlayHandler$2('staggered');

	  var interruptHandler = function interruptHandler() {
	    return null;
	  };

	  var _options$transition$s = options.transition.staggerDelay,
	      staggerDelay = _options$transition$s === void 0 ? 500 : _options$transition$s;
	  return {
	    duration: 2000 + staggerDelay * getSeries$1(chartData).length,
	    staggerDelay: staggerDelay,
	    stageHandler: stageHandler,
	    playHandler: playHandler,
	    interruptHandler: interruptHandler
	  };
	} // staggered transition will render one, then the other next

	function chainedTransition$1(container, chartData, options) {
	  var stageHandler = makeStageHandler$2();
	  var playHandler = makePlayHandler$2('chained');

	  var interruptHandler = function interruptHandler() {
	    return null;
	  };

	  return {
	    duration: 2000 * getSeries$1(chartData).length,
	    stageHandler: stageHandler,
	    playHandler: playHandler,
	    interruptHandler: interruptHandler
	  };
	} // synced transition will render all lines at the same time

	function syncedTransition$1(target, options) {
	  var stageHandler = makeStageHandler$2();
	  var playHandler = makePlayHandler$2('synced');
	  return {
	    stageHandler: stageHandler,
	    playHandler: playHandler
	  };
	}

	function line(target, chartData, options) {
	  var defaults = {
	    // distance tooltip box is away from point
	    tooltipOffsetX: 7,
	    // distance tooltip box is away from point
	    tooltipOffsetY: 7,
	    // tooltip box line for height estimation
	    tooltipLineHeight: 30,
	    // tooltip max width
	    tooltipMaxWidth: 160,
	    // radius of tooltip anchor
	    tooltipAnchorSize: 4,
	    // radius of annotation anchor
	    annotationAnchorSize: 4,
	    // display value tag at end of line
	    displayValueTags: false,
	    // treat year values as continuous rather than discrete
	    yearsAsContinuous: true,
	    // curve type stepped etc.
	    curveType: null,
	    // configuration options for layout manager
	    layoutManager: {},
	    // configuration for the chart axes
	    dateAxis: {},
	    bandAxis: {
	      outerPadding: 0.0
	    },
	    linearAxis: {// tickStepVertical: 80,
	      // tickLabelAlternate: false
	    },
	    // configuration for animation
	    transition: _objectSpread2({}, lineTransitions(target, chartData, options))
	  };

	  var opts = _merge(defaults, options);

	  var el = select(target).classed('toaster-chart-line', true).classed('bar-colors', false) // clear this on chart type change
	  .classed('quad-colors', isQuadSeries(chartData)).classed('transition-stage', stageForTransition(opts)); // ensure we have a taxonomy specified on the data

	  buildTaxonomy(chartData, false, opts);
	  var env = makeEnv(el, chartData, opts); // render as area chart with options provided

	  var isAreaChart = env.options.renderAreaChart;
	  var isAreaChartStacked = isAreaChart && !isSingleSeries(chartData); // depending on the data we either render dateAxis or
	  // bandAxis (for Quarters)

	  var field = chartData.fields[0];
	  var emptySegments = getInvalidSegments(chartData);
	  var fillEmptySegments = chartData.config.fill_empty_segments;
	  var isBandAxis = renderWithBandScale(field);
	  var xOffset = 0;
	  var layoutConfig = {
	    orientation: HORIZONTAL,
	    yAxisInnerPadding: axisPadding(chartData)
	  };

	  _extends(layoutConfig, env.options.layoutManager);

	  var linearAxisConfig = {
	    isPrimaryAxis: false,
	    domainFromZero: isAreaChart,
	    stackedDomain: isAreaChartStacked
	  };

	  _extends(linearAxisConfig, env.options.linearAxis);

	  layoutConfig.secondaryAxis = linearAxisProvider(linearAxisConfig);

	  if (isBandAxis) {
	    var bandAxisConfig = {
	      isPrimaryAxis: true
	    };

	    _extends(bandAxisConfig, env.options.bandAxis);

	    layoutConfig.primaryAxis = bandAxisProvider(bandAxisConfig);
	  } else {
	    var dateAxisConfig = {
	      isPrimaryAxis: true
	    };

	    _extends(dateAxisConfig, env.options.dateAxis);

	    layoutConfig.primaryAxis = dateAxisProvider(dateAxisConfig);
	  }

	  var chartLayout = layoutManager(layoutConfig);
	  var chart = el.selectAppend('div.chart');
	  chart.selectAll('*').remove();
	  chart.call(chartLayout, env);
	  var line = chartLayout.draw().classed('line-container', true);
	  var curveType = options.curveType || chartData.config.curve_type; // grid is now essentially a render layer
	  // secondaryAxis.gridlines(line.selectAppend('g.grid'), width)

	  el.classed('no-grid', !shouldDisplayGrid(env)).classed('no-domain', !shouldDisplayDomain(env)).classed('no-axis', env.options.disableGrid);
	  line.selectAppend('g.grid').call(gridlines({
	    length: chartLayout.outerWidth()
	  }), env); // allow a layer for highlighting ranges below the chart

	  if (chartData.config.highlightRanges) {
	    var _chartData$config$hig = chartData.config.highlightRanges,
	        ranges = _chartData$config$hig.ranges,
	        rangeStyle = _chartData$config$hig.rangeStyle;
	    line.selectAppend('g.highlight-ranges').call(highlightRanges({
	      ranges: ranges,
	      rangeStyle: rangeStyle
	    }), env);
	  }

	  if (isBandAxis) xOffset = env.x.scale.bandwidth() / 2;

	  if (isAreaChart) {
	    el.classed('toaster-chart-area', true);
	    el.classed('toaster-chart-area-stacked', isAreaChartStacked);
	    el.classed('area-colors', true);

	    if (isAreaChartStacked) {
	      line.call(simpleAreaStacked({
	        xOffset: xOffset
	      }), env);
	    } else {
	      line.call(simpleArea({
	        xOffset: xOffset
	      }), env);
	    }
	  }

	  if (!isAreaChart && !isAreaChartStacked) {
	    line.call(simpleLine({
	      xScale: env.x.scale,
	      yScale: env.y.scale,
	      drawArea: env.options.renderSingleSeriesAreaChart,
	      xOffset: xOffset,
	      curve: curveType
	    }), env); // draw dashed line to fill in gaps

	    if (emptySegments) {
	      line.call(dashedLine({
	        xScale: env.x.scale,
	        yScale: env.y.scale,
	        drawArea: env.options.renderSingleSeriesAreaChart,
	        xOffset: xOffset,
	        segments: emptySegments,
	        isSolid: fillEmptySegments,
	        curve: curveType
	      }), env);
	    } // TODO :: valueTags


	    if (options.displayValueTags) {
	      line.call(valueTag({
	        env: env,
	        xScale: env.x.scale,
	        yScale: env.y.scale,
	        drawArea: env.options.renderSingleSeriesAreaChart,
	        xOffset: xOffset
	      }), env);
	    }
	  } // allow horizontal line thresholds on top of lines


	  if (chartData.config.thresholds) {
	    line.selectAppend('g.threshold-lines').call(thresholdLines(_objectSpread2(_objectSpread2({}, env.options), {}, {
	      thresholds: chartData.config.thresholds
	    })), env);
	  } // after drawing we place the y axis label
	  // on top of everything


	  placeVerticalAxisLabel(env);
	  lineAnnotations(line, chartData.annotations, env); // create bottom label if needed

	  chart.call(bottomLabel(), env, chartData); // overflow layout call

	  chartLayout.overflowScale(); // build out the default tooltip renderer

	  if (!(env.options.disableTooltip || chartData.config.disableTooltip)) {
	    lineTooltip({
	      chart: chart,
	      area: line,
	      env: env
	    });
	  } // add line class to legend swatches


	  if (!env.options.renderAreaChart) {
	    el.selectAll('.simple-legend .swatch:not(.highlight-range-legend)').classed('line', true);
	  }

	  debugEnv(env);
	  return makeLayerPrototype(line, [{
	    el: el,
	    env: env
	  }], opts);
	} // For line charts to determine if the data is discrete bands
	// or a continous dateScale
	// it looks like our previous version was too quick to convert to bandScale
	// when dealing with year inputs

	function renderWithBandScale(field) {
	  if (isForceCategorical(field)) return true;
	  if (field.type === FIELD_TYPE_NUMERIC) return true;

	  if (field.taxonomy && !field.taxonomy.isContinuous && !field.taxonomy.isYears) {
	    return true;
	  }

	  return false;
	}

	// but for now we pass everything through

	function area(target, data, options) {
	  var defaults = {
	    renderAreaChart: true,
	    areaChartMultiseries: true
	  };
	  options = _extends(defaults, options);
	  return line(target, data, options);
	}

	/**

	  A barline chart combines a line chart and a column chart by splitting
	  the series data between two charts.

	*/

	function barline(target, chartData, options) {
	  var defaults = {
	    barline: true,
	    // distance tooltip box is away from point
	    tooltipOffsetX: 7,
	    // distance tooltip box is away from point
	    tooltipOffsetY: 7,
	    // tooltip box line for height estimation
	    tooltipLineHeight: 30,
	    // tooltip max width
	    tooltipMaxWidth: 160,
	    // radius of tooltip anchor
	    tooltipAnchorSize: 4,
	    // replaces axis inner padding for date axes
	    dateAxisInnerPadding: 8,
	    // disable * condensed annotations
	    preventCondensedAnnotations: true,
	    // curve type stepped etc.
	    curveType: null,
	    // configuration options for layout manager
	    layoutManager: {
	      yAxisInnerPadding: 0,
	      xAxisExtendRight: 7
	    },
	    // configuration for the chart axes
	    dateAxis: {},
	    bandAxis: {},
	    linearAxis: {}
	  };

	  var opts = _merge(defaults, options || {});

	  var el = select(target).classed('toaster-chart-barline', true).classed('bar-colors', true).classed('quad-colors', isQuadSeries(chartData)); // ensure we have a taxonomy specified on the data

	  columnTaxonomy(chartData, opts);
	  var env = makeEnv(el, chartData, opts);
	  var isDateAxis = renderChartAsTimeSeries(el, chartData, env.options);
	  var isContinuousAxis = renderAxisAsContinuous(el, chartData, env.options); // determine the barline type and breakdown of fields

	  var _lineBarSeriesBreakdo = lineBarSeriesBreakdown(chartData),
	      linesFirst = _lineBarSeriesBreakdo.linesFirst,
	      lineOffset = _lineBarSeriesBreakdo.lineOffset,
	      barOffset = _lineBarSeriesBreakdo.barOffset,
	      lineSeriesData = _lineBarSeriesBreakdo.lineSeriesData,
	      barSeriesData = _lineBarSeriesBreakdo.barSeriesData,
	      isStackedColumns = _lineBarSeriesBreakdo.isStackedColumns;

	  var linearAxisConfig = _objectSpread2({
	    isPrimaryAxis: false,
	    domainFromZero: true,
	    stackedDomain: isStackedColumns,
	    customStackedDomain: isStackedColumns,
	    customStandardFields: lineSeriesData,
	    customStackedFields: barSeriesData
	  }, env.options.linearAxis);

	  var bandAxisConfig = _objectSpread2({
	    isPrimaryAxis: true,
	    stackedBand: isStackedColumns,
	    isDateAxis: isDateAxis,
	    isContinuousAxis: isContinuousAxis
	  }, env.options.bandAxis);

	  var layoutConfig = _objectSpread2({
	    orientation: HORIZONTAL,
	    primaryAxis: bandAxisProvider(bandAxisConfig),
	    secondaryAxis: linearAxisProvider(linearAxisConfig)
	  }, env.options.layoutManager);

	  if (isDateAxis) {
	    layoutConfig.yAxisInnerPadding = env.options.dateAxisInnerPadding;
	  }

	  var chartLayout = layoutManager(layoutConfig);
	  var chart = el.selectAppend('div.chart');
	  chart.selectAll('*').remove();
	  chart.call(chartLayout, env);
	  var line = chartLayout.draw().classed('line-container', true);
	  var curveType = options.curveType || chartData.config.curve_type;
	  var gridLength = env.x.rangeLength() + 2 * chartLayout.yAxisInnerPadding(); // grid is now essentially a render layer

	  el.classed('no-grid', !shouldDisplayGrid(env)).classed('no-domain', !shouldDisplayDomain(env)).classed('no-axis', env.options.disableGrid);
	  line.selectAppend('g.grid').call(gridlines({
	    length: gridLength
	  }), env); // allow a layer for highlighting ranges below the chart

	  if (chartData.config.highlightRanges) {
	    var _chartData$config$hig = chartData.config.highlightRanges,
	        ranges = _chartData$config$hig.ranges,
	        rangeStyle = _chartData$config$hig.rangeStyle;
	    line.selectAppend('g.highlight-ranges').call(highlightRanges({
	      ranges: ranges,
	      rangeStyle: rangeStyle,
	      isColumnType: true
	    }), env);
	  }

	  var columnOptions = {
	    xScale: env.x.scale,
	    yScale: env.y.scale,
	    seriesData: barSeriesData,
	    seriesOffset: barOffset,
	    orientation: HORIZONTAL
	  };
	  var lineOptions = {
	    xScale: env.x.scale,
	    yScale: env.y.scale,
	    seriesData: lineSeriesData,
	    seriesOffset: lineOffset,
	    xOffset: env.x.scale.bandwidth() / 2,
	    curve: curveType,
	    forceCategorical: true // drive

	  }; // [DH] an option to switch between using lines or
	  // columns as the primary rendering type

	  if (linesFirst) {
	    el.selectAll('.simple-legend .swatch').each(function (d, i) {
	      select(this).classed('line', i < barOffset);
	    });
	  } else {
	    el.selectAll('.simple-legend .swatch').each(function (d, i) {
	      select(this).classed('line', i >= lineOffset);
	    });
	  }

	  if (isStackedColumns) {
	    line.call(simpleColumnStacked(columnOptions), env);
	  } else {
	    line.call(simpleColumn(columnOptions), env);
	  }

	  line.call(simpleLine(lineOptions), env); // after drawing we place the y axis label
	  // on top of everything

	  placeVerticalAxisLabel(env); // allow horizontal line thresholds

	  if (chartData.config.thresholds) {
	    line.selectAppend('g.threshold-lines').call(thresholdLines(_objectSpread2(_objectSpread2({}, env.options), {}, {
	      thresholds: chartData.config.thresholds
	    })), env);
	  }

	  columnAnnotations(line, chartData.annotations, env); // create bottom label if needed

	  chart.call(bottomLabel(), env, chartData); // overflow layout call

	  chartLayout.overflowScale(); // build out the default tooltip renderer

	  if (!(env.options.disableTooltip || chartData.config.disableTooltip)) {
	    columnTooltip({
	      chart: chart,
	      area: line,
	      env: env,
	      barline: true,
	      disableStacked: true
	    });
	  }

	  debugEnv(env);
	  return makeLayerPrototype(barline, [{
	    env: env,
	    el: el
	  }], opts);
	} // Validation is a static method to check if the class
	// supports the chartData before building the chart

	barline.validateData = function (chartData) {
	  var validate = validator(chartData);
	  validate('Barline chart must have more than one value.', isMultipleValues);
	  validate('Barline chart requires a series of 2 fields of data.', isDoubleSeries);
	  validate('Barline chart must be time series data', isTimeSeries);
	  return validate;
	};

	function lineBarSeriesBreakdown(chartData) {
	  var configs = {
	    'bar-then-lines': {
	      linesFirst: false,
	      lineOffset: 1,
	      barOffset: 0,
	      lineSeriesData: chartData.fields.slice(2),
	      barSeriesData: [chartData.fields[1]],
	      isStackedColumns: false
	    },
	    'two-stacked-bars-then-lines': {
	      linesFirst: false,
	      lineOffset: 2,
	      barOffset: 0,
	      lineSeriesData: chartData.fields.slice(3),
	      barSeriesData: chartData.fields.slice(1, 3),
	      isStackedColumns: true
	    },
	    'two-bars-then-lines': {
	      linesFirst: false,
	      lineOffset: 2,
	      barOffset: 0,
	      lineSeriesData: chartData.fields.slice(3),
	      barSeriesData: chartData.fields.slice(1, 3),
	      isStackedColumns: false
	    },
	    'three-stacked-bars-then-lines': {
	      linesFirst: false,
	      lineOffset: 3,
	      barOffset: 0,
	      lineSeriesData: chartData.fields.slice(4),
	      barSeriesData: chartData.fields.slice(1, 4),
	      isStackedColumns: true
	    },
	    'three-bars-then-lines': {
	      linesFirst: false,
	      lineOffset: 3,
	      barOffset: 0,
	      lineSeriesData: chartData.fields.slice(4),
	      barSeriesData: chartData.fields.slice(1, 4),
	      isStackedColumns: false
	    },
	    'line-then-stacked-bars': {
	      linesFirst: true,
	      lineOffset: 0,
	      barOffset: 1,
	      lineSeriesData: [chartData.fields[1]],
	      barSeriesData: chartData.fields.slice(2),
	      isStackedColumns: true
	    },
	    'line-then-bars': {
	      linesFirst: true,
	      lineOffset: 0,
	      barOffset: 1,
	      lineSeriesData: [chartData.fields[1]],
	      barSeriesData: chartData.fields.slice(2),
	      isStackedColumns: false
	    },
	    'two-lines-then-stacked-bars': {
	      linesFirst: true,
	      lineOffset: 0,
	      barOffset: 2,
	      lineSeriesData: chartData.fields.slice(1, 3),
	      barSeriesData: chartData.fields.slice(3),
	      isStackedColumns: true
	    },
	    'two-lines-then-bars': {
	      linesFirst: true,
	      lineOffset: 0,
	      barOffset: 2,
	      lineSeriesData: chartData.fields.slice(1, 3),
	      barSeriesData: chartData.fields.slice(3),
	      isStackedColumns: false
	    },
	    'three-lines-then-stacked-bars': {
	      linesFirst: true,
	      lineOffset: 0,
	      barOffset: 3,
	      lineSeriesData: chartData.fields.slice(1, 4),
	      barSeriesData: chartData.fields.slice(4),
	      isStackedColumns: true
	    },
	    'three-lines-then-bars': {
	      linesFirst: true,
	      lineOffset: 0,
	      barOffset: 3,
	      lineSeriesData: chartData.fields.slice(1, 4),
	      barSeriesData: chartData.fields.slice(4),
	      isStackedColumns: true
	    }
	  };
	  var type = 'bar-then-lines';

	  if (chartData.config.barline_bar_series) {
	    type = 'line-then-bars';
	  }

	  if (chartData.config.barlineType) {
	    type = chartData.config.barlineType;
	  }

	  return configs[type];
	}

	var $some = arrayIteration.some;



	var STRICT_METHOD$1 = arrayMethodIsStrict('some');
	var USES_TO_LENGTH$1 = arrayMethodUsesToLength('some');

	// `Array.prototype.some` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.some
	_export({ target: 'Array', proto: true, forced: !STRICT_METHOD$1 || !USES_TO_LENGTH$1 }, {
	  some: function some(callbackfn /* , thisArg */) {
	    return $some(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	/** `Object#toString` result references. */
	var symbolTag$2 = '[object Symbol]';

	/**
	 * Checks if `value` is classified as a `Symbol` primitive or object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
	 * @example
	 *
	 * _.isSymbol(Symbol.iterator);
	 * // => true
	 *
	 * _.isSymbol('abc');
	 * // => false
	 */
	function isSymbol$2(value) {
	  return typeof value == 'symbol' ||
	    (isObjectLike$2(value) && baseGetTag$1(value) == symbolTag$2);
	}

	/** Used to match property names within property paths. */
	var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
	    reIsPlainProp = /^\w*$/;

	/**
	 * Checks if `value` is a property name and not a property path.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {Object} [object] The object to query keys on.
	 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
	 */
	function isKey(value, object) {
	  if (isArray$2(value)) {
	    return false;
	  }
	  var type = typeof value;
	  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
	      value == null || isSymbol$2(value)) {
	    return true;
	  }
	  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
	    (object != null && value in Object(object));
	}

	/** Error message constants. */
	var FUNC_ERROR_TEXT$3 = 'Expected a function';

	/**
	 * Creates a function that memoizes the result of `func`. If `resolver` is
	 * provided, it determines the cache key for storing the result based on the
	 * arguments provided to the memoized function. By default, the first argument
	 * provided to the memoized function is used as the map cache key. The `func`
	 * is invoked with the `this` binding of the memoized function.
	 *
	 * **Note:** The cache is exposed as the `cache` property on the memoized
	 * function. Its creation may be customized by replacing the `_.memoize.Cache`
	 * constructor with one whose instances implement the
	 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
	 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Function
	 * @param {Function} func The function to have its output memoized.
	 * @param {Function} [resolver] The function to resolve the cache key.
	 * @returns {Function} Returns the new memoized function.
	 * @example
	 *
	 * var object = { 'a': 1, 'b': 2 };
	 * var other = { 'c': 3, 'd': 4 };
	 *
	 * var values = _.memoize(_.values);
	 * values(object);
	 * // => [1, 2]
	 *
	 * values(other);
	 * // => [3, 4]
	 *
	 * object.a = 2;
	 * values(object);
	 * // => [1, 2]
	 *
	 * // Modify the result cache.
	 * values.cache.set(object, ['a', 'b']);
	 * values(object);
	 * // => ['a', 'b']
	 *
	 * // Replace `_.memoize.Cache`.
	 * _.memoize.Cache = WeakMap;
	 */
	function memoize(func, resolver) {
	  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
	    throw new TypeError(FUNC_ERROR_TEXT$3);
	  }
	  var memoized = function() {
	    var args = arguments,
	        key = resolver ? resolver.apply(this, args) : args[0],
	        cache = memoized.cache;

	    if (cache.has(key)) {
	      return cache.get(key);
	    }
	    var result = func.apply(this, args);
	    memoized.cache = cache.set(key, result) || cache;
	    return result;
	  };
	  memoized.cache = new (memoize.Cache || MapCache$1);
	  return memoized;
	}

	// Expose `MapCache`.
	memoize.Cache = MapCache$1;

	/** Used as the maximum memoize cache size. */
	var MAX_MEMOIZE_SIZE = 500;

	/**
	 * A specialized version of `_.memoize` which clears the memoized function's
	 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
	 *
	 * @private
	 * @param {Function} func The function to have its output memoized.
	 * @returns {Function} Returns the new memoized function.
	 */
	function memoizeCapped(func) {
	  var result = memoize(func, function(key) {
	    if (cache.size === MAX_MEMOIZE_SIZE) {
	      cache.clear();
	    }
	    return key;
	  });

	  var cache = result.cache;
	  return result;
	}

	/** Used to match property names within property paths. */
	var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

	/** Used to match backslashes in property paths. */
	var reEscapeChar = /\\(\\)?/g;

	/**
	 * Converts `string` to a property path array.
	 *
	 * @private
	 * @param {string} string The string to convert.
	 * @returns {Array} Returns the property path array.
	 */
	var stringToPath = memoizeCapped(function(string) {
	  var result = [];
	  if (string.charCodeAt(0) === 46 /* . */) {
	    result.push('');
	  }
	  string.replace(rePropName, function(match, number, quote, subString) {
	    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
	  });
	  return result;
	});

	var stringToPath$1 = stringToPath;

	/**
	 * A specialized version of `_.map` for arrays without support for iteratee
	 * shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the new mapped array.
	 */
	function arrayMap(array, iteratee) {
	  var index = -1,
	      length = array == null ? 0 : array.length,
	      result = Array(length);

	  while (++index < length) {
	    result[index] = iteratee(array[index], index, array);
	  }
	  return result;
	}

	/** Used as references for various `Number` constants. */
	var INFINITY$2 = 1 / 0;

	/** Used to convert symbols to primitives and strings. */
	var symbolProto$1 = Symbol$3 ? Symbol$3.prototype : undefined,
	    symbolToString$1 = symbolProto$1 ? symbolProto$1.toString : undefined;

	/**
	 * The base implementation of `_.toString` which doesn't convert nullish
	 * values to empty strings.
	 *
	 * @private
	 * @param {*} value The value to process.
	 * @returns {string} Returns the string.
	 */
	function baseToString(value) {
	  // Exit early for strings to avoid a performance hit in some environments.
	  if (typeof value == 'string') {
	    return value;
	  }
	  if (isArray$2(value)) {
	    // Recursively convert values (susceptible to call stack limits).
	    return arrayMap(value, baseToString) + '';
	  }
	  if (isSymbol$2(value)) {
	    return symbolToString$1 ? symbolToString$1.call(value) : '';
	  }
	  var result = (value + '');
	  return (result == '0' && (1 / value) == -INFINITY$2) ? '-0' : result;
	}

	/**
	 * Converts `value` to a string. An empty string is returned for `null`
	 * and `undefined` values. The sign of `-0` is preserved.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 * @example
	 *
	 * _.toString(null);
	 * // => ''
	 *
	 * _.toString(-0);
	 * // => '-0'
	 *
	 * _.toString([1, 2, 3]);
	 * // => '1,2,3'
	 */
	function toString$1(value) {
	  return value == null ? '' : baseToString(value);
	}

	/**
	 * Casts `value` to a path array if it's not one.
	 *
	 * @private
	 * @param {*} value The value to inspect.
	 * @param {Object} [object] The object to query keys on.
	 * @returns {Array} Returns the cast property path array.
	 */
	function castPath(value, object) {
	  if (isArray$2(value)) {
	    return value;
	  }
	  return isKey(value, object) ? [value] : stringToPath$1(toString$1(value));
	}

	/** Used as references for various `Number` constants. */
	var INFINITY$1 = 1 / 0;

	/**
	 * Converts `value` to a string key if it's not a string or symbol.
	 *
	 * @private
	 * @param {*} value The value to inspect.
	 * @returns {string|symbol} Returns the key.
	 */
	function toKey(value) {
	  if (typeof value == 'string' || isSymbol$2(value)) {
	    return value;
	  }
	  var result = (value + '');
	  return (result == '0' && (1 / value) == -INFINITY$1) ? '-0' : result;
	}

	/**
	 * The base implementation of `_.get` without support for default values.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path of the property to get.
	 * @returns {*} Returns the resolved value.
	 */
	function baseGet(object, path) {
	  path = castPath(path, object);

	  var index = 0,
	      length = path.length;

	  while (object != null && index < length) {
	    object = object[toKey(path[index++])];
	  }
	  return (index && index == length) ? object : undefined;
	}

	/**
	 * Gets the value at `path` of `object`. If the resolved value is
	 * `undefined`, the `defaultValue` is returned in its place.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.7.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path of the property to get.
	 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
	 * @returns {*} Returns the resolved value.
	 * @example
	 *
	 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	 *
	 * _.get(object, 'a[0].b.c');
	 * // => 3
	 *
	 * _.get(object, ['a', '0', 'b', 'c']);
	 * // => 3
	 *
	 * _.get(object, 'a.b.c', 'default');
	 * // => 'default'
	 */
	function get(object, path, defaultValue) {
	  var result = object == null ? undefined : baseGet(object, path);
	  return result === undefined ? defaultValue : result;
	}

	/**
	 * The base implementation of `_.findIndex` and `_.findLastIndex` without
	 * support for iteratee shorthands.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {Function} predicate The function invoked per iteration.
	 * @param {number} fromIndex The index to search from.
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function baseFindIndex(array, predicate, fromIndex, fromRight) {
	  var length = array.length,
	      index = fromIndex + (fromRight ? 1 : -1);

	  while ((fromRight ? index-- : ++index < length)) {
	    if (predicate(array[index], index, array)) {
	      return index;
	    }
	  }
	  return -1;
	}

	/**
	 * The base implementation of `_.isNaN` without support for number objects.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
	 */
	function baseIsNaN(value) {
	  return value !== value;
	}

	/**
	 * A specialized version of `_.indexOf` which performs strict equality
	 * comparisons of values, i.e. `===`.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} value The value to search for.
	 * @param {number} fromIndex The index to search from.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function strictIndexOf(array, value, fromIndex) {
	  var index = fromIndex - 1,
	      length = array.length;

	  while (++index < length) {
	    if (array[index] === value) {
	      return index;
	    }
	  }
	  return -1;
	}

	/**
	 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} value The value to search for.
	 * @param {number} fromIndex The index to search from.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function baseIndexOf(array, value, fromIndex) {
	  return value === value
	    ? strictIndexOf(array, value, fromIndex)
	    : baseFindIndex(array, baseIsNaN, fromIndex);
	}

	/** `Object#toString` result references. */
	var stringTag$1 = '[object String]';

	/**
	 * Checks if `value` is classified as a `String` primitive or object.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a string, else `false`.
	 * @example
	 *
	 * _.isString('abc');
	 * // => true
	 *
	 * _.isString(1);
	 * // => false
	 */
	function isString(value) {
	  return typeof value == 'string' ||
	    (!isArray$2(value) && isObjectLike$2(value) && baseGetTag$1(value) == stringTag$1);
	}

	/** Used as references for various `Number` constants. */
	var NAN$1 = 0 / 0;

	/** Used to match leading and trailing whitespace. */
	var reTrim$1 = /^\s+|\s+$/g;

	/** Used to detect bad signed hexadecimal string values. */
	var reIsBadHex$1 = /^[-+]0x[0-9a-f]+$/i;

	/** Used to detect binary string values. */
	var reIsBinary$1 = /^0b[01]+$/i;

	/** Used to detect octal string values. */
	var reIsOctal$1 = /^0o[0-7]+$/i;

	/** Built-in method references without a dependency on `root`. */
	var freeParseInt$1 = parseInt;

	/**
	 * Converts `value` to a number.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to process.
	 * @returns {number} Returns the number.
	 * @example
	 *
	 * _.toNumber(3.2);
	 * // => 3.2
	 *
	 * _.toNumber(Number.MIN_VALUE);
	 * // => 5e-324
	 *
	 * _.toNumber(Infinity);
	 * // => Infinity
	 *
	 * _.toNumber('3.2');
	 * // => 3.2
	 */
	function toNumber$1(value) {
	  if (typeof value == 'number') {
	    return value;
	  }
	  if (isSymbol$2(value)) {
	    return NAN$1;
	  }
	  if (isObject$2(value)) {
	    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
	    value = isObject$2(other) ? (other + '') : other;
	  }
	  if (typeof value != 'string') {
	    return value === 0 ? value : +value;
	  }
	  value = value.replace(reTrim$1, '');
	  var isBinary = reIsBinary$1.test(value);
	  return (isBinary || reIsOctal$1.test(value))
	    ? freeParseInt$1(value.slice(2), isBinary ? 2 : 8)
	    : (reIsBadHex$1.test(value) ? NAN$1 : +value);
	}

	/** Used as references for various `Number` constants. */
	var INFINITY = 1 / 0,
	    MAX_INTEGER = 1.7976931348623157e+308;

	/**
	 * Converts `value` to a finite number.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.12.0
	 * @category Lang
	 * @param {*} value The value to convert.
	 * @returns {number} Returns the converted number.
	 * @example
	 *
	 * _.toFinite(3.2);
	 * // => 3.2
	 *
	 * _.toFinite(Number.MIN_VALUE);
	 * // => 5e-324
	 *
	 * _.toFinite(Infinity);
	 * // => 1.7976931348623157e+308
	 *
	 * _.toFinite('3.2');
	 * // => 3.2
	 */
	function toFinite(value) {
	  if (!value) {
	    return value === 0 ? value : 0;
	  }
	  value = toNumber$1(value);
	  if (value === INFINITY || value === -INFINITY) {
	    var sign = (value < 0 ? -1 : 1);
	    return sign * MAX_INTEGER;
	  }
	  return value === value ? value : 0;
	}

	/**
	 * Converts `value` to an integer.
	 *
	 * **Note:** This method is loosely based on
	 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to convert.
	 * @returns {number} Returns the converted integer.
	 * @example
	 *
	 * _.toInteger(3.2);
	 * // => 3
	 *
	 * _.toInteger(Number.MIN_VALUE);
	 * // => 0
	 *
	 * _.toInteger(Infinity);
	 * // => 1.7976931348623157e+308
	 *
	 * _.toInteger('3.2');
	 * // => 3
	 */
	function toInteger(value) {
	  var result = toFinite(value),
	      remainder = result % 1;

	  return result === result ? (remainder ? result - remainder : result) : 0;
	}

	/**
	 * The base implementation of `_.values` and `_.valuesIn` which creates an
	 * array of `object` property values corresponding to the property names
	 * of `props`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array} props The property names to get values for.
	 * @returns {Object} Returns the array of property values.
	 */
	function baseValues(object, props) {
	  return arrayMap(props, function(key) {
	    return object[key];
	  });
	}

	/**
	 * Creates an array of the own enumerable string keyed property values of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property values.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.values(new Foo);
	 * // => [1, 2] (iteration order is not guaranteed)
	 *
	 * _.values('hi');
	 * // => ['h', 'i']
	 */
	function values(object) {
	  return object == null ? [] : baseValues(object, keys(object));
	}

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMax$3 = Math.max;

	/**
	 * Checks if `value` is in `collection`. If `collection` is a string, it's
	 * checked for a substring of `value`, otherwise
	 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * is used for equality comparisons. If `fromIndex` is negative, it's used as
	 * the offset from the end of `collection`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Collection
	 * @param {Array|Object|string} collection The collection to inspect.
	 * @param {*} value The value to search for.
	 * @param {number} [fromIndex=0] The index to search from.
	 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
	 * @returns {boolean} Returns `true` if `value` is found, else `false`.
	 * @example
	 *
	 * _.includes([1, 2, 3], 1);
	 * // => true
	 *
	 * _.includes([1, 2, 3], 1, 2);
	 * // => false
	 *
	 * _.includes({ 'a': 1, 'b': 2 }, 1);
	 * // => true
	 *
	 * _.includes('abcd', 'bc');
	 * // => true
	 */
	function includes(collection, value, fromIndex, guard) {
	  collection = isArrayLike(collection) ? collection : values(collection);
	  fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;

	  var length = collection.length;
	  if (fromIndex < 0) {
	    fromIndex = nativeMax$3(length + fromIndex, 0);
	  }
	  return isString(collection)
	    ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)
	    : (!!length && baseIndexOf(collection, value, fromIndex) > -1);
	}

	function styleSheet() {
	  var sheet = function () {
	    // Create the <style> tag
	    var style = document.createElement('style'); // Add a media (and/or media query) here if you'd like!
	    // style.setAttribute("media", "screen")
	    // style.setAttribute("media", "only screen and (max-width : 1024px)")
	    // WebKit hack :(

	    style.appendChild(document.createTextNode('')); // Add the <style> element to the page

	    document.head.appendChild(style);
	    return style.sheet;
	  }();

	  function addCSSRule(selector, rules) {
	    // Backward searching of the selector matching cssRules
	    var index = Math.max(sheet.cssRules.length - 1, 0);

	    for (var i = index; i > 0; i--) {
	      var currentStyle = sheet.cssRules[i];

	      if (currentStyle.selectorText === selector) {
	        // Append the new rules to the current content of the cssRule;
	        rules = currentStyle.style.cssText + rules;
	        sheet.deleteRule(i);
	        index = i;
	      }
	    }

	    if (sheet.insertRule) {
	      sheet.insertRule(selector + '{' + rules + '}', index);
	    } else {
	      sheet.addRule(selector, rules, index);
	    }

	    return sheet.cssRules[index].cssText;
	  }

	  return {
	    addCSSRule: addCSSRule
	  };
	}

	function simpleTable(options) {
	  var defaults = {
	    hideAfter: null,
	    hideHeaders: false,
	    sortHeaders: true,
	    hideMobile: false
	  };
	  options = _extends(defaults, options);
	  var hideAfter = options.hideAfter;
	  var hideHeaders = options.hideHeaders;
	  var sortHeaders = options.sortHeaders;
	  var hideMobile = options.hideMobile;

	  function simpleTable(selection) {
	    selection.each(function (d) {
	      var el = select(this);

	      if (!hideMobile) {
	        el.each(renderMobile);
	      }

	      return el.each(render);
	    });
	  }

	  function applySort(sortIndex, tr, toggle) {
	    var i, ascending, selection;

	    if (sortIndex !== undefined) {
	      selection = select('thead th:nth-child(' + (sortIndex + 1) + ')');
	    } else {
	      selection = selectAll('thead th').filter(function () {
	        return select(this).classed('ascending') || select(this).classed('descending');
	      });
	    }

	    selection && selection.each(function (d) {
	      i = sortIndex !== undefined ? sortIndex : select(this).attr('data-index');

	      if (select(this).classed('ascending')) {
	        ascending = !toggle;
	      } else if (select(this).classed('descending')) {
	        ascending = Boolean(toggle);
	      } else {
	        ascending = true;
	      }

	      selectAll('th').classed('ascending', false).classed('descending', false);

	      var coerce = function coerce(v) {
	        return v;
	      };

	      if (select(this).classed('numeric')) {
	        coerce = function coerce(v) {
	          return Number(v);
	        };
	      }

	      if (ascending) {
	        tr.sort(function (a, b) {
	          return coerce(a[i]) > coerce(b[i]) ? 1 : -1;
	        });
	      } else {
	        tr.sort(function (a, b) {
	          return coerce(b[i]) > coerce(a[i]) ? 1 : -1;
	        });
	      }

	      select(this).classed('ascending', ascending);
	      select(this).classed('descending', !ascending);
	    });
	  }

	  function applyPrefixAndPostfix() {
	    selectAll('td').classed('top', false);
	    selectAll('tr:nth-child(1) td').classed('top', true);
	  }

	  function render(chartData) {
	    var el = select(this);
	    var formatters = chartData.fields.map(fieldFormatter);
	    var cellClass = chartData.fields.map(cellClasser);
	    var unitClass = chartData.fields.map(unitClasser);
	    var barClass = chartData.fields.map(barClasser);

	    var highlightRows = get(chartData, 'chartOptions.table.highlightRows', []);

	    var table = el.selectAppend('table.simple-table');
	    var thead = table.selectAppend('thead'); // var tfoot = table.selectAppend('tfoot')

	    var tbody = table.selectAppend('tbody'); // headers
	    // *******

	    if (!hideHeaders) {
	      var headerRow = thead.selectAppend('tr');
	      var th = headerRow.selectAll('th').data(function (d) {
	        return d.fields;
	      });
	      th.exit().remove();
	      th.merge(th.enter().append('th')).attr('scope', 'col').attr('data-index', function (d, i) {
	        return i;
	      }).attr('class', function (d) {
	        return d.type + (select(this).classed('ascending') ? ' ascending' : select(this).classed('descending') ? ' descending' : '');
	      }).html(function (d) {
	        return '<span ' + (sortHeaders ? 'class="sortable"' : '') + '>' + d.name + '</span>';
	      }).style('cursor', sortHeaders ? 'pointer' : '').on('click', function (d, i) {
	        if (sortHeaders) {
	          applySort(i, tr, true);
	          applyPrefixAndPostfix();
	        }
	      });
	    } // body
	    // ****


	    var tr = tbody.selectAll('tr').data(function (d) {
	      return d.data;
	    }).order();
	    tr.exit().remove();
	    tr = tr.enter().append('tr').merge(tr).classed('highlight', function (d, i) {
	      return includes(highlightRows, i);
	    }).classed('hidden', function (d, i) {
	      // TODO thing through this feature
	      return hideAfter && i > hideAfter;
	    });
	    var td = tr.selectAll('td').data(function (d) {
	      return d;
	    });
	    td.exit().remove();
	    td.enter().append('td').merge(td).attr('class', function (d, i) {
	      return cellClass[i](d) + ' ' + unitClass[i]();
	    }).html(function (d, i) {
	      var barWidth = barClass[i](d);
	      var textWidth = 0;
	      var out;

	      if (barWidth !== '') {
	        if (!isNaN(d)) {
	          textWidth = d.toString().length * 25; // TODO: Fix this mess, we need to calculate this better
	        }

	        out = '<div class="bar-container" style="min-width:' + textWidth + 'px"><span class="bar" style="width: ' + barWidth + 'px"' + '></span>';
	      } else {
	        out = '<div>';
	      }

	      return out + '<span class="value">' + formatters[i](d) + '</span></div></div>';
	    });

	    if (sortHeaders) {
	      applySort(undefined, tr);
	    }

	    applyPrefixAndPostfix(); // footer
	    // ******
	    // var footerRow = tfoot.selectAll('tr')
	    //  .data(function(d) {
	    //    return data.length > hideAfter ? [null] : []
	    //  })
	    // footerRow.exit().remove()
	    // footerRow = footerRow.merge(footerRow.enter().append('tr'))
	    // footerRow
	    //  .selectAppend('td.simple-table-expand')
	    //  .attr('colspan', function(d) {
	    //    return d.fields.length
	    //  })
	    //  .text(function(d) {
	    //    return 'View all ' + d.data.length + ' rows â¬'
	    //  })
	    //  .on('click', function() {
	    //    tr.classed('hidden', false)
	    //    tfoot.remove()
	    //  })
	  }

	  function renderMobile(chartData) {
	    var el = select(this);

	    var labelFieldIndex = get(chartData, 'chartOptions.table.labelFieldIndex', -1);

	    var rcl = removeLabelField(labelFieldIndex);

	    var highlightRows = get(chartData, 'chartOptions.table.highlightRows', []);

	    var fields = rcl(chartData.fields.slice());
	    var formatters = fields.map(fieldFormatter);
	    var cellClass = fields.map(cellClasser);
	    var table = el.selectAppend('table.simple-table-mobile'); // One tbody per row of the data
	    // yes, it's perfectly legal - https://www.w3.org/TR/html401/struct/tables.html#h-11.2.3

	    var tbodys = table.selectAll('tbody').data(function (d) {
	      return d.data;
	    }).enter().append('tbody');

	    if (labelFieldIndex > -1) {
	      tbodys.append('tr.label-field').append('th').attr('colspan', 2).text(function (d) {
	        return d[labelFieldIndex];
	      });
	    }

	    tbodys.classed('highlight', function (d, i) {
	      return includes(highlightRows, i);
	    });
	    var isListDisplay = fields.some(function (field) {
	      return field.displayInList;
	    });
	    var rows = tbodys.selectAll('tr.row').data(function (d) {
	      return rcl(d.slice());
	    }).enter().append('tr.row').classed('hidden', function (d, i) {
	      return isListDisplay && !fields[i].displayInList;
	    });
	    rows.append('th').text(function (d, i) {
	      return fields[i].name;
	    });
	    rows.append('td').attr('class', function (d, i) {
	      return cellClass[i](d);
	    }).text(function (d, i) {
	      return formatters[i](d);
	    });
	  }

	  simpleTable.hideHeaders = function (_) {
	    return arguments.length ? (hideHeaders = _, simpleTable) : hideHeaders; // eslint-disable-line
	  };

	  return simpleTable;
	}

	function identity(d) {
	  return d;
	}

	function blank(d) {
	  return '';
	}

	function defaultDecimalPlaces(decimalPlaces, fieldType) {
	  if (typeof decimalPlaces !== 'undefined' && decimalPlaces !== null) {
	    return decimalPlaces;
	  }

	  var typeDecimalPlaces = {
	    percent: 2,
	    change: 1,
	    numeric: 0
	  };
	  return fieldType in typeDecimalPlaces ? typeDecimalPlaces[fieldType] : 0;
	}

	function displayFormat(field, formatter) {
	  return function (d) {
	    switch (field.displayFormat) {
	      case 'Y':
	      case 'M':
	      case 'D':
	        if (field.displayFormat === 'Y') {
	          d = moment_min.utc(d).format('YYYY');
	        } else if (field.displayFormat === 'M') {
	          d = moment_min.utc(d).format('MMM YYYY');
	        } else if (field.displayFormat === 'D') {
	          d = moment_min.utc(d).format('MMM DD, YYYY');
	        }

	        break;

	      case 'K':
	        d /= 1e3;
	        break;

	      case 'ML':
	        d /= 1e6;
	        break;

	      case 'B':
	        d /= 1e9;
	        break;

	      case 'T':
	        d /= 1e12;
	        break;
	    }

	    return formatter(d);
	  };
	}

	function fieldFormatter(field) {
	  var dp = defaultDecimalPlaces(field.decimalPlaces, field.type);

	  if (typeof dp !== 'number') {
	    dp = 0;
	  }

	  switch (field.type) {
	    case FIELD_TYPE_PERCENT:
	      return displayFormat(field, format(',.' + dp + '%', field));

	    case FIELD_TYPE_NUMERIC:
	      return displayFormat(field, format(',.' + dp + 'f', field));

	    default:
	      return displayFormat(field, identity);
	  }
	}

	function cellClasser(field) {
	  var baseClassList = field.type;

	  if (field.displayChange) {
	    baseClassList += ' change';
	  }

	  if (field.displayAsSymbol) {
	    baseClassList += ' arrow';
	  }

	  return function (d) {
	    var classList = baseClassList;

	    if (field.displayChange || field.displayAsSymbol) {
	      classList += ' ';
	      classList += d === 0 ? 'no-change' : d > 0 ? 'positive' : 'negative';
	    }

	    return classList;
	  };
	} // TODO: Module instance, kinda suspect....


	var customStyleSheet;

	function unitClasser(field) {
	  var prefix = field.unitBefore && field.unitBefore.length ? field.unitBefore : undefined;
	  var postfix = field.unitAfter && field.unitAfter.length ? field.unitAfter : undefined;
	  var preClass, postClass;

	  if (prefix || postfix) {
	    if (!customStyleSheet) {
	      customStyleSheet = styleSheet();
	    }

	    if (prefix) {
	      preClass = 'prefix-' + toUnicodeNumber(prefix);
	      customStyleSheet.addCSSRule('.' + preClass + '.top .value::before', 'color: inherit; content: "\\' + toUnicode(prefix) + '"');
	    }

	    if (postfix) {
	      postClass = 'postfix-' + toUnicodeNumber(postfix);
	      customStyleSheet.addCSSRule('.' + postClass + ' .value::after', 'color: transparent; content: "\\' + toUnicode(postfix) + '"');
	      customStyleSheet.addCSSRule('.' + postClass + '.top .value::after', 'color: inherit; content: "\\' + toUnicode(postfix) + '"');
	    }
	  }

	  return function () {
	    if (prefix) {
	      return preClass;
	    }

	    if (postfix) {
	      return postClass;
	    }

	    return '';
	  };
	}

	function barClasser(field) {
	  if (field.displayBar) {
	    var linearScale = linear().domain([field.min, field.max]).range([5, 75]); // TODO: Should come from options

	    return function (d) {
	      return linearScale(d);
	    };
	  }

	  return blank;
	}

	function removeLabelField(index) {
	  if (index > -1) {
	    return function (array) {
	      array.splice(index, 1);
	      return array;
	    };
	  }

	  return function (array) {
	    return array;
	  };
	}

	function table(options) {
	  options = options || {};

	  function table(selection) {
	    selection.each(function (chartData) {
	      var el = select(this);
	      el.selectAppend('div.chart').selectAppend('div.toaster-chart-table').call(simpleTable(options));
	    });
	  }

	  return table;
	}

	function pieTransitions(target, chartData, options) {
	  var _options$transition = options.transition,
	      transition = _options$transition === void 0 ? {} : _options$transition;
	  return _objectSpread2(_objectSpread2({}, staggeredTransition$1()), transition);
	}

	function makeStageHandler$1() {
	  return function (target, env, transitionOptions) {
	    var pieOuterRadius = env.options.pieOuterRadius;
	    var arc = d3arc().innerRadius(0).outerRadius(pieOuterRadius);
	    env.el.selectAll('path.sector').each(function (d, i) {
	      var newData = _extends({}, d);

	      newData.endAngle = newData.startAngle;
	      select(this).attr('d', arc(newData));
	    });
	    env.el.selectAll('g.label').style('opacity', 0);
	  };
	}

	function makePlayHandler$1(stage) {
	  return playInterface(function (target, env, transitionOptions) {
	    var data = env.data,
	        options = env.options;
	    var pieOuterRadius = options.pieOuterRadius;
	    var duration = transitionOptions.duration,
	        delay = transitionOptions.delay,
	        _transitionOptions$se = transitionOptions.sectionDelay,
	        sectionDelay = _transitionOptions$se === void 0 ? 80 : _transitionOptions$se;
	    var sections = env.el.selectAll('path.sector');
	    var sectionTime = duration / data.data.length;
	    var transitions = [];
	    var arc = d3arc().innerRadius(0).outerRadius(pieOuterRadius);
	    sections.each(function (d, index) {
	      var section = select(this);

	      var fromData = _extends({}, d);

	      fromData.endAngle = fromData.startAngle;

	      var arcTween = function arcTween(a) {
	        var interp = interpolate$1(fromData, a);
	        return function (t) {
	          return arc(interp(t));
	        };
	      };

	      var instance = section.transition().ease(backOut).duration(sectionTime).delay(delay + index * (sectionTime - sectionDelay)).attrTween('d', arcTween);
	      transitions.push(instance);
	    });
	    env.el.selectAll('g.label').each(function (d, index) {
	      var instance = select(this).transition().duration(sectionTime - 200).delay(delay + index * (sectionTime + sectionDelay)).style('opacity', 1);
	      transitions.push(instance);
	    });
	    return transitions;
	  });
	} // staggered transition will render one, then the other next


	function staggeredTransition$1(container, chartData, options) {
	  var stageHandler = makeStageHandler$1();
	  var playHandler = makePlayHandler$1();

	  var interruptHandler = function interruptHandler() {
	    return null;
	  };

	  return {
	    duration: 2000,
	    normalizeSpeed: false,
	    stageHandler: stageHandler,
	    playHandler: playHandler,
	    interruptHandler: interruptHandler
	  };
	}

	function simplePie(options) {
	  var defaults = {
	    pieInnerRadius: 0,
	    pieOuterRadius: 120,
	    piePadAngle: 0,
	    pieSort: function pieSort(a, b) {
	      return b - a;
	    }
	  };
	  options = _extends(defaults, options);
	  var arc = d3arc();
	  var pie = d3pie();

	  function simplePie(selection) {
	    selection.each(function (chartData) {
	      if (chartData.chartOptions && chartData.chartOptions.pie) {
	        _extends(options, chartData.chartOptions.pie);
	      }

	      var series = getSeries(chartData)[0];
	      pie.padAngle(options.piePadAngle);

	      if (options.sortPieSeries) {
	        pie.sort(options.pieSort);
	      } else {
	        pie.sort(null);
	      }

	      arc.innerRadius(options.pieInnerRadius).outerRadius(options.pieOuterRadius); // function to highlight a value by index

	      var isHighlighted = valueHighlighter(chartData);
	      var el = select(this).classed('not-highlighted', !highlightSupported(chartData)).classed('highlighted', highlightSupported(chartData));
	      var sectors = el.selectAll('path.sector');
	      var pieData = pie(series.data);
	      sectors = sectors.data(pieData);
	      sectors.exit().remove();
	      sectors.enter().append('path').attr('data-outer-radius', options.pieOuterRadius).attr('d', arc).merge(sectors).attr('class', function (d) {
	        return 'sector f series-' + d.index;
	      }).classed('highlight', function (d) {
	        return isHighlighted(d, d.index);
	      });
	    });
	  }

	  return simplePie;
	}

	var PIE_MAX_SERIES = 6; // There is a positioning bug that only happens on safari, this is
	// the only way I could think of to avoid

	var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
	var safariL2Offset = isSafari ? 5 : 0;
	function pie(target, chartData, options) {
	  var defaults = {
	    // allow pie chart with no labels
	    disablePieLabels: false,
	    // allow small multiples to disable series sorting
	    sortPieSeries: true,
	    // distance of default label line
	    labelLineLength: 50,
	    // distance of vertical line in |__ label bar
	    labelExtendLength: 30,
	    // distance line sits from edge of pie
	    labelLineOffset: 2,
	    labelLine1Height: 26,
	    labelLine2Height: 16,
	    labelTextWrapWidth: 200,
	    verticalMargin: 40,
	    pieOuterRadius: 120,
	    pieMaxRadius: 150,
	    pieMinRadius: 60,
	    // set to false to force radius to provided value
	    automaticRadius: true,
	    phabletOptions: {
	      labelLine1Height: 20,
	      labelLine2Height: 13,
	      labelTextWrapWidth: 130,
	      labelLineLength: 35
	    },
	    mobileOptions: {
	      labelLine1Height: 18,
	      labelLine2Height: 13,
	      labelTextWrapWidth: 130,
	      labelLineLength: 35
	    },
	    // configuration for animation
	    transition: _objectSpread2({}, pieTransitions(target, chartData, options))
	  };

	  var opts = _merge(defaults, options);

	  buildTaxonomy(chartData, false, opts);
	  var el = select(target).classed('toaster-chart-pie', true).classed('pie-colors', true).classed('transition-stage', stageForTransition(opts));
	  var env = makeEnv(el, chartData, opts);

	  if (target.offsetWidth <= LARGE_BREAKPOINT && target.offsetWidth > MOBILE_BREAKPOINT) {
	    _extends(env.options, options.phabletOptions);
	  } else if (target.offsetWidth <= MOBILE_BREAKPOINT) {
	    _extends(env.options, options.mobileOptions);
	  }

	  env.options.labelLine2Height += safariL2Offset; // apply axis labels etc to the field

	  _extends(chartData.fields[1], chartData.secondaryAxis);

	  if (chartData.data.length > PIE_MAX_SERIES) {
	    throw new Error('Pie chart only supports up to 6 values');
	  }

	  var chart = el.selectAppend('div.chart').classed('toaster-chart-pie', true);
	  chart.selectAll('*').remove();
	  var width = chart.node().offsetWidth;
	  var height = 380;
	  var svg = chart.selectAppend('svg').style('width', width + 'px').style('height', height + 'px'); // uses aspectRatio to drive pie radius

	  if (env.options.automaticRadius) {
	    var ratioMultiplier = 6.0 / (3.0 + getAspectRatio(chartData));
	    env.options.pieOuterRadius = Math.max(Math.min(width * (1 / 8), env.options.pieMaxRadius), env.options.pieMinRadius) * ratioMultiplier;
	  }

	  var pan = svg.selectAppend('g.pie-container');
	  pan.selectAll('*').remove();
	  pan.call(simplePie(env.options));

	  if (!env.options.disablePieLabels) {
	    pieLabels(pan, env);
	  } // after labels drawn, adjust scale and offset


	  shiftAndScalePie(pan, svg, width, height, env);
	  debugEnv(env);
	  return makeLayerPrototype(pie, [{
	    env: env,
	    el: el
	  }], opts);
	} // used to disable legend before scaffold

	pie.makeOptions = function (options) {
	  return _extends({
	    hideLegend: true
	  }, options);
	}; // pie chart isn't using axes, but needs to pass one in
	// to the formatter


	function axisWrapper$1(data) {
	  return {
	    field: function field() {
	      return data.fields[1];
	    }
	  };
	}

	function shiftAndScalePie(pan, svg, width, height, env) {
	  // resize the view based on the size with labels
	  var bbox = pan.node().getBBox();
	  var yCenter = Math.abs(bbox.y - env.options.verticalMargin / 2);
	  var xCenter = width / 2;
	  var transformScale = 'scale(1.0)';
	  height = bbox.height;
	  height += env.options.verticalMargin;
	  svg.style('width', width + 'px').style('height', height + 'px'); // on mobile we shift the chart left/right to fit
	  // if adjustment isn't possible we scale down to fit box

	  if (bbox.width > width) {
	    transformScale = "scale(".concat(width / bbox.width, ") ");
	  }

	  pan.attr('transform', "translate(".concat(xCenter, ", ").concat(yCenter, ") ").concat(transformScale));
	}

	function pieLabels(container, env) {
	  var labels = [];
	  var field = getSeries(env.data)[0];
	  var pieData = d3pie()(field.data);
	  var highlightedLabels = [];

	  if (env.data.config && env.data.config.highlight_label) {
	    highlightedLabels = env.data.config.highlight_label.split(',').map(function (s) {
	      return Number(s);
	    });
	  } // for pie chart if domain extent between 1000 - 10000 use commas


	  var formatOptions = {};
	  var domainMax = Math.max(Math.abs(field.max), Math.abs(field.min));

	  if (domainMax >= 1000 && domainMax < 100000) {
	    formatOptions.forceCommaDisplay = true;
	  }

	  var format = valueFormatter(axisWrapper$1(env.data), env, formatOptions);
	  container.selectAll('.label').remove();
	  var labelArc = d3arc().outerRadius(env.options.pieOuterRadius).innerRadius(env.options.pieOuterRadius);
	  env.data.data.forEach(function (data, i) {
	    var pd = pieData[i];
	    var centerAngle = (pd.startAngle + pd.endAngle) / 2;
	    var diff = Math.PI / 8;
	    var label = {
	      position: labelArc.centroid(pd),
	      orientation: 'right',
	      extend: null,
	      extendLength: env.options.labelExtendLength,
	      valueText: format(pd.value),
	      // TODO :: support percentage option
	      labelText: data[0],
	      centerAngle: centerAngle,
	      pieIndex: pd.index,
	      highlight: highlightedLabels.indexOf(pd.index + 1) !== -1
	    };
	    if (pd.value <= 0 || isNaN(pd.value)) return;

	    if (centerAngle < diff) {
	      label.orientation = 'right';
	      label.extend = 'top';
	    } else if (centerAngle > Math.PI * 2 - diff) {
	      label.orientation = 'left';
	      label.extend = 'top';
	    } else if (centerAngle > Math.PI - diff && centerAngle <= Math.PI) {
	      label.orientation = 'right';
	      label.extend = 'bottom';
	    } else if (centerAngle < Math.PI + diff && centerAngle > Math.PI) {
	      label.orientation = 'left';
	      label.extend = 'bottom';
	    } else {
	      if (centerAngle < Math.PI) {
	        label.orientation = 'right';
	      } else {
	        label.orientation = 'left';
	      }
	    }

	    labels.push(label);
	  }); // before we draw, count the number of labels that stack up
	  // at the top (small values) and push up the extend value

	  if (env.options.sortPieSeries) {
	    labels.sort(function (a, b) {
	      return a.pieIndex - b.pieIndex;
	    });
	  }

	  var topExtenders = labels.filter(function (label) {
	    return label.extend === 'top';
	  });

	  if (topExtenders.length > 1) {
	    var labelHeight = env.options.labelLine1Height + env.options.labelLine2Height + env.options.labelLineOffset * 2;
	    topExtenders.forEach(function (label, i) {
	      label.extendLength = env.options.labelExtendLength + labelHeight * i;
	    });
	  }

	  labels.forEach(function (label) {
	    return placeOffsetLabel(container, label, env);
	  });
	}

	var dialSVG = "<svg id=\"dial-chart\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 620 310\">\n  <defs>\n    <marker id=\"arrowhead\" viewBox=\"-10 -10 20 20\" refX=\"0\" refY=\"0\" \n      markerUnits=\"userSpaceOnUse\" markerWidth=\"20\" markerHeight=\"20\" stroke-width=\"1\" orient=\"auto\">\n      <polyline stroke-linejoin=\"bevel\" points=\"-6,-4 0,0 -6,4\" fill=\"#000\"></polyline>\n    </marker>\n    <style>\n      .cls-1{fill:#00AEFF;}\n      .cls-2{fill:#44C4FF;}\n      .cls-3{fill:#89D9FE;}\n      .cls-4{fill:#d4d4d4;}\n      .cls-5{fill:#feb98d;}\n      .cls-6{fill:#ff8d46;}\n      .cls-7{fill:#ff6200;}\n      .cls-12,.cls-8{fill:#fff;}\n      .cls-10,.cls-11,.cls-13,.cls-14,.cls-9{fill:none;}\n      .cls-10,.cls-11,.cls-12,.cls-13,.cls-14,.cls-9{stroke:#000;}.cls-10,.cls-11,.cls-12,.cls-9{stroke-linecap:round;stroke-linejoin:round;}.cls-12,.cls-9{stroke-width:2px;}.cls-10,.cls-11,.cls-13,.cls-14{stroke-width:0.75px;}.cls-11{stroke-dasharray:1.01 3.03;}.cls-13,.cls-14{stroke-miterlimit:10;}.cls-14{stroke-dasharray:1.02 4.09;}.cls-15{font-size:15.4px;}.cls-15,.cls-16{font-family:BWHaasText-55Roman, BW Haas Text;}.cls-16{font-size:15.4px;}.cls-30{fill: #000;}\n    </style>\n  </defs>\n  <path class=\"cls-2\" d=\"M309,294.73,86,187.22a250.28,250.28,0,0,1,68.37-86.55Z\"/>\n  <path class=\"cls-3\" d=\"M309,294.73,154.33,100.67a248.64,248.64,0,0,1,99.28-48.78Z\"/>\n  <path class=\"cls-7\" d=\"M560.7,294.73H309L535.63,185.59A248.46,248.46,0,0,1,560.7,294.73Z\"/>\n  <path class=\"cls-6\" d=\"M535.63,185.59,309,294.73,465.43,98.58A250.71,250.71,0,0,1,535.63,185.59Z\"/>\n  <path class=\"cls-5\" d=\"M465.43,98.58,309,294.73,364.65,51A248.55,248.55,0,0,1,465.43,98.58Z\"/>\n  <path class=\"cls-4\" d=\"M364.65,51,309,294.73,253.61,51.89a251.45,251.45,0,0,1,111-.93Z\"/>\n  <path class=\"cls-1\" d=\"M309,294.73H61.67A248.33,248.33,0,0,1,86,187.22Z\"/>\n  <path id=\"dial-pad\" class=\"cls-8\" d=\"M310.43,295.43l-120.76,1v-1c0-66.25,54.51-120.76,120.76-120.76S431.2,229.18,431.2,295.43Z\"/>\n  \n  <line id=\"end-line\" class=\"cls-9\" x1=\"310\" y1=\"293\" x2=\"346.67\" y2=\"110.33\"/>\n  <line id=\"start-line\" class=\"cls-11\" x1=\"310\" y1=\"293\" x2=\"413.66\" y2=\"142.82\" />\n\n  <path class=\"cls-12\" d=\"M310.75,266.25a28.47,28.47,0,0,0-28.47,28.48h56.94A28.47,28.47,0,0,0,310.75,266.25Z\"/>\n  <path id=\"transition-path\" class=\"cls-14\" d=\"M370.13,44.87A247.14,247.14,0,0,1,452.44,80\" marker-end=\"url(#arrowhead)\"/>\n\n  <rect id=\"start-mark\" class=\"cls-30\" x=\"-2.5\" y=\"0\" width=\"5\" height=\"0.75\" transform=\"translate(140.64 420.06) rotate(-57.32)\"/>\n\n  <text id=\"val-1\" class=\"cls-15\" transform=\"translate(45.73 236.73) rotate(-75.59)\">1</text>\n  <text id=\"val-2\" class=\"cls-15\" transform=\"translate(97.12 130.37) rotate(-53.2)\">2</text>\n  <text id=\"val-3\" class=\"cls-16\" transform=\"matrix(0.9, -0.44, 0.44, 0.9, 189.61, 54.57)\">3</text>\n  <text id=\"val-4\" class=\"cls-16\" transform=\"translate(304.16 26.78) rotate(-1.45)\">4</text>\n  <text id=\"val-5\" class=\"cls-16\" transform=\"matrix(0.92, 0.4, -0.4, 0.92, 418.04, 48.77)\">5</text>\n  <text id=\"val-6\" class=\"cls-15\" transform=\"translate(513.14 119.17) rotate(50.3)\">6</text>\n  <text id=\"val-7\" class=\"cls-16\" transform=\"matrix(0.25, 0.97, -0.97, 0.25, 570.66, 230.77)\">7</text>\n</svg>";

	var Y_TOP = 293;
	var X_MID = 310;
	var INNER_RADIUS = 200;
	var OUTER_RADIUS = 256;
	function dial(options, styleIndex) {
	  var defaults = {};
	  options = _extends(defaults, options);

	  function dial(selection) {
	    selection.each(function (chartData) {
	      if (chartData.chartOptions && chartData.chartOptions.pie) {
	        _extends(options, chartData.chartOptions.pie);
	      }

	      var el = select(this);
	      el.html(dialSVG); // width 620

	      var rangle = function rangle(i) {
	        return (7 - i) * (Math.PI / 7) + Math.PI / 14;
	      };

	      var start = Number(chartData.fields[1].data[0]);
	      var end = Number(chartData.fields[1].data[1]);
	      var halfway = (end + start) / 2;
	      var noChange = start === end;
	      var arrow0 = [X_MID + Math.cos(rangle(start)) * OUTER_RADIUS, Y_TOP - Math.sin(rangle(start)) * OUTER_RADIUS];
	      var arrow1 = [X_MID + Math.cos(rangle(halfway)) * OUTER_RADIUS, Y_TOP - Math.sin(rangle(halfway)) * OUTER_RADIUS];
	      var arrow2 = [X_MID + Math.cos(rangle(end)) * OUTER_RADIUS, Y_TOP - Math.sin(rangle(end)) * OUTER_RADIUS];
	      el.select("#val-".concat(end)).classed('active', true); // end line

	      el.select('#end-line').attr('x2', X_MID + Math.cos(rangle(end)) * INNER_RADIUS).attr('y2', Y_TOP - Math.sin(rangle(end)) * INNER_RADIUS);
	      el.select('#start-line').attr('x2', X_MID + Math.cos(rangle(start)) * INNER_RADIUS).attr('y2', Y_TOP - Math.sin(rangle(start)) * INNER_RADIUS); // set

	      el.select('#transition-path').attr('d', calcCirclePath$1(arrow0, arrow2, arrow1)).style('display', noChange ? 'none' : 'block');
	      el.select('#start-mark').attr('transform', "translate(".concat(arrow0[0], ", ").concat(arrow0[1], ") rotate(").concat(rangle(start) * (180 / Math.PI) * -1, ")")).attr('d', "M".concat(arrow0[0], ",").concat(arrow0[1], "l.41.28")).style('display', noChange ? 'none' : 'block'); // override color values

	      var colorVals = styleIndex === 1 ? performanceChartRedGreen : performanceChartCyanOrange;
	      colorVals.forEach(function (color, i) {
	        el.select("path.cls-".concat(i + 1)).style('fill', color);
	      });
	    });
	  }

	  return dial;
	}

	function dist$2(a, b) {
	  return Math.sqrt(Math.pow(a[0] - b[0], 2) + Math.pow(a[1] - b[1], 2));
	} // used in the arrow function, pass in three points and it will return an
	// arc path going through all three


	function calcCirclePath$1(a, b, c) {
	  var A = dist$2(b, c);
	  var B = dist$2(c, a);
	  var C = dist$2(a, b);
	  var angle = Math.acos((A * A + B * B - C * C) / (2 * A * B)); // calc radius of circle

	  var K = 0.5 * A * B * Math.sin(angle);
	  var r = A * B * C / 4 / K;
	  r = Math.round(r * 1000) / 1000; // large arc flag

	  var laf = +(Math.PI / 2 > angle); // sweep flag

	  var saf = +((b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]) < 0);
	  return ['M', a, 'A', r, r, 0, laf, saf, b].join(' ');
	}

	function customPie(target, chartData, options) {
	  var defaults = {
	    // default options here
	    legendOffsetTop: -15,
	    legendLineHeight: 16,
	    customPieDisableLegend: false,
	    customPieLegendPercentage: false,
	    sortPieSeries: false
	  };
	  options = _merge(defaults, options);
	  var pieRenderer = pie(options);
	  console.log('PIE RENDER BROKEN', pieRenderer);
	  var el = select(target);
	  var pieField = getSeries(chartData)[0];
	  var env = {
	    data: chartData,
	    options: _extends({}, options)
	  };

	  if (!env.options.customPieDisableLegend) {
	    var formatPrimary = valueFormatter(axisWrapper(env.data), env);

	    var formatPercent = function formatPercent(val) {
	      return format('3d')(val * 100.0).replace(/ /g, '');
	    };

	    var legendOuter = el.selectAppend('div.legend-container-outer');
	    var legend = legendOuter.selectAppend('div.legend-container');
	    legendOuter.style('height', pieField.data.length * env.options.legendLineHeight + 'px');
	    var values = legend.selectAll('.legend-value').data(pieField.data);
	    var totalVal = pieField.data.reduce(function (a, b) {
	      return a + b;
	    });
	    values.exit().remove();
	    values.enter().append('div').classed('legend-value', true).merge(values).html(function (d, i) {
	      if (d === 0 || d === '0') {
	        return '';
	      }

	      var percentageContent = '';

	      if (env.options.customPieLegendPercentage) {
	        percentageContent = "(".concat(formatPercent(d / totalVal), "%)");
	      }

	      return "\n            <span class=\"swatch bg series-".concat(i, "\"></span>\n            <span class=\"val\">\n              ").concat(formatPrimary(d), " ").concat(percentageContent, "\n            </span>\n          ");
	    });
	  }

	  return makeLayerPrototype(customPie, [{
	    el: el,
	    env: env
	  }], options);
	} // pie chart isn't using axes, but needs to pass one in
	// to the formatter

	function axisWrapper(data) {
	  return {
	    field: function field() {
	      return data.fields[1];
	    }
	  };
	}

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeCeil = Math.ceil,
	    nativeMax$2 = Math.max;

	/**
	 * The base implementation of `_.range` and `_.rangeRight` which doesn't
	 * coerce arguments.
	 *
	 * @private
	 * @param {number} start The start of the range.
	 * @param {number} end The end of the range.
	 * @param {number} step The value to increment or decrement by.
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {Array} Returns the range of numbers.
	 */
	function baseRange(start, end, step, fromRight) {
	  var index = -1,
	      length = nativeMax$2(nativeCeil((end - start) / (step || 1)), 0),
	      result = Array(length);

	  while (length--) {
	    result[fromRight ? length : ++index] = start;
	    start += step;
	  }
	  return result;
	}

	/**
	 * Creates a `_.range` or `_.rangeRight` function.
	 *
	 * @private
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {Function} Returns the new range function.
	 */
	function createRange(fromRight) {
	  return function(start, end, step) {
	    if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {
	      end = step = undefined;
	    }
	    // Ensure the sign of `-0` is preserved.
	    start = toFinite(start);
	    if (end === undefined) {
	      end = start;
	      start = 0;
	    } else {
	      end = toFinite(end);
	    }
	    step = step === undefined ? (start < end ? 1 : -1) : toFinite(step);
	    return baseRange(start, end, step, fromRight);
	  };
	}

	/**
	 * Creates an array of numbers (positive and/or negative) progressing from
	 * `start` up to, but not including, `end`. A step of `-1` is used if a negative
	 * `start` is specified without an `end` or `step`. If `end` is not specified,
	 * it's set to `start` with `start` then set to `0`.
	 *
	 * **Note:** JavaScript follows the IEEE-754 standard for resolving
	 * floating-point values which can produce unexpected results.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Util
	 * @param {number} [start=0] The start of the range.
	 * @param {number} end The end of the range.
	 * @param {number} [step=1] The value to increment or decrement by.
	 * @returns {Array} Returns the range of numbers.
	 * @see _.inRange, _.rangeRight
	 * @example
	 *
	 * _.range(4);
	 * // => [0, 1, 2, 3]
	 *
	 * _.range(-4);
	 * // => [0, -1, -2, -3]
	 *
	 * _.range(1, 5);
	 * // => [1, 2, 3, 4]
	 *
	 * _.range(0, 20, 5);
	 * // => [0, 5, 10, 15]
	 *
	 * _.range(0, -4, -1);
	 * // => [0, -1, -2, -3]
	 *
	 * _.range(1, 4, 0);
	 * // => [1, 1, 1]
	 *
	 * _.range(0);
	 * // => []
	 */
	var range = createRange();

	var _range = range;

	var TYPE_MAP = {
	  line: line,
	  area: area,
	  bar: column,
	  pie: customPie
	};
	function spread$1(target, chartData, options) {
	  var defaults = {
	    // default options here
	    defaultBoxType: 'line',
	    minimumBoxWidth: 200,
	    minimumBoxHeight: 200,
	    maximumBoxHeight: 9999,
	    gutterWidth: 25,
	    // treat year values as continuous rather than discrete
	    // if small multiples type is 'bar' we set to false
	    yearsAsContinuous: true,
	    // make sure pie chart has no labels
	    disableGrid: true,
	    disablePieLabels: true,
	    pieOuterRadius: 120,
	    pieMinRadius: 20,
	    automaticRadius: false,
	    forceTickAtDomainTop: true,
	    // prevent overloading of force_vertical_bars
	    verticalBarsOnly: true,
	    // configuration options for layout manager
	    layoutManager: {
	      minHeight: 300
	    }
	  };

	  var opts = _merge(defaults, options);

	  var selections = [];
	  var env = {
	    x: null,
	    // simpleAxis({orientation: 'x'}),
	    y: null,
	    // simpleAxis({orientation: 'y'}),
	    r: null,
	    layout: null,
	    // simpleLayout(),
	    layers: [],
	    options: opts
	  };
	  var el = select(target).classed('toaster-chart-spread', true);
	  var chartType = chartData.config.multiples_type || env.options.defaultBoxType;
	  var multiplesLegend = chartData.config.multiplesLegend;

	  if (chartData.config.smallMultiplesGrouping) {
	    multiplesLegend = chartData.config.smallMultiplesGrouping.legendValues;
	  }

	  if (options.multiplesLegend) {
	    multiplesLegend = options.multiplesLegend;
	  } // only small multiples bar should treat years as categorical


	  if (chartType === 'bar') {
	    opts.yearsAsContinuous = false;
	  } // ensure we have a taxonomy specified on the data


	  buildTaxonomy(chartData, false, opts);
	  env.data = chartData;

	  if (chartType === 'area') {
	    el.classed('area-colors', true);
	  } // custom legend for pie multiples or when the splitMultiples option
	  // creates charts with more than one line/bar


	  if (chartType === 'pie') {
	    var legendVals = chartData.data.map(function (d) {
	      return {
	        name: d[0]
	      };
	    });
	    el.select('.legend').call(customLegend(legendVals));
	  } else if (multiplesLegend && multiplesLegend.length) {
	    var _legendVals = multiplesLegend.map(function (d) {
	      return {
	        name: d
	      };
	    });

	    el.select('.legend').call(customLegend(_legendVals, chartType === 'line'));
	  } else {
	    el.select('.legend').style('display', 'none');
	  }

	  el.classed('no-grid', !shouldDisplayGrid(env));
	  var chart = el.select('.chart');
	  var chartWidth = chart.node().offsetWidth;
	  var chartTypeClass = TYPE_MAP[chartType];
	  var spreadData = splitData$1(chartData, env.options);
	  var series = spreadData;
	  var boxWidth = Math.ceil(chart.node().offsetWidth / series.length) - 6;
	  var boxHeight = chart.node().offsetWidth / getAspectRatio(chartData); // when boxes are too small we start wrapping them

	  if (boxWidth < env.options.minimumBoxWidth) {
	    var numRows = Math.ceil(env.options.minimumBoxWidth * series.length / chart.node().offsetWidth);
	    boxWidth = chart.node().offsetWidth / Math.ceil(series.length / numRows) - 6;
	    boxHeight /= numRows;
	  }

	  boxHeight = Math.min(Math.max(boxHeight, env.options.minimumBoxHeight), env.options.maximumBoxHeight);
	  var numPerRow = Math.floor(chartWidth / boxWidth);
	  var gutterPadding = env.options.gutterWidth * (numPerRow - 1) / numPerRow;
	  env.options.pieOuterRadius = Math.max(env.options.pieMinRadius || 0, Math.min(env.options.pieMaxRadius || 1000, (boxWidth - 50) / 2 - 20));
	  env.options.layoutManager.minHeight = boxHeight; // el.selectAll('.spread-container').remove()
	  // cleanup after other chart forms

	  el.selectAll('.chart > svg').remove();
	  var spreads = chart.selectAll('.spread').data(spreadData);
	  spreads.exit().remove();
	  spreads.enter().append('div').attr('class', function (d, i) {
	    return 'spread spread-' + i;
	  }).merge(spreads).style('width', boxWidth - gutterPadding + 'px').style('padding-right', function (d, i) {
	    // last item on row has no padding-right
	    if (i % numPerRow === numPerRow - 1) {
	      return 0;
	    } else {
	      return env.options.gutterWidth + 'px';
	    }
	  }); // .style('height', boxHeight + 'px')

	  chart.selectAll('.spread').each(function (d, i) {
	    var container = select(this);

	    var options = _objectSpread2(_objectSpread2({}, env.options), {}, {
	      multiplesIndex: i
	    });

	    container.selectAppend('div.title').text(spreadData[i].fields[1].name);
	    var frame = container.selectAppend('div.toaster-chart');
	    var drawLayer = chartTypeClass(frame.node(), spreadData[i], options);
	    selections.push({
	      el: container,
	      env: drawLayer.getEnv()
	    });
	  });
	  debugEnv(env);
	  return makeLayerPrototype(spread$1, selections, _objectSpread2(_objectSpread2({}, opts), {}, {
	    // need customLayer props otherwise only the first small multiple
	    // is returned as the "target"
	    customLayerElement: el,
	    customLayerEnv: env
	  }));
	} // Validation is a static method to check if the class
	// supports the chartData before building the chart

	spread$1.validateData = function (chartData, options) {
	  var validate = validator(chartData);
	  validate('Line chart must have more than one value.', isMultipleValues);
	  validate('Line should be a time series', isTimeSeries);
	  return validate;
	};

	function customLegend(series, isLine) {
	  function customLegend(selection) {
	    selection.each(function (chartData) {
	      var items = select(this).selectAppend('ul.simple-legend').selectAll('li').data(series);
	      items.exit().remove();
	      items = items.merge(items.enter().append('li'));
	      items.selectAppend('span').attr('class', function (d, i) {
	        return "swatch bg series-".concat(i, " ").concat(isLine ? 'line' : '');
	      }).classed('highlight-legend', function (d) {
	        return d.isHighlight;
	      });
	      items.selectAppend('label').text(function (d) {
	        return d.name;
	      });

	      if (series.length === 0) {
	        select(this).classed('hidden', true);
	      }
	    });
	  }

	  return customLegend;
	}
	/**
	* The purpose of this function is to take any given chartData and
	* duplicate it on a per-field level so each small multiple chart
	* gets a one-series copy of the data (categorical field + numerical)

	* splitMultiples can be defined as config/options like: 1-2, 3-4 etc.
	*/


	function splitData$1(chartData, options) {
	  var indices = chartData.fields.slice(1).map(function (v, i) {
	    return [i + 1];
	  });

	  if (chartData.config.smallMultiplesGrouping) {
	    var groupBy = chartData.config.smallMultiplesGrouping.groupBy;
	    var count = Math.ceil((chartData.fields.length - 1) / groupBy);
	    indices = _range(count).map(function (row) {
	      var vals = _range(groupBy).map(function (col) {
	        return row * groupBy + col + 1;
	      }).filter(function (i) {
	        return i < chartData.fields.length;
	      });

	      return [vals[0], vals[vals.length - 1]];
	    });
	  }

	  if (chartData.config.splitMultiples || options.splitMultiples) {
	    var splitString = options.splitMultiples || chartData.config.splitMultiples;
	    indices = splitString.split(',').map(function (s) {
	      return s.trim().split('-').map(function (v) {
	        return Number(v);
	      });
	    });
	  }

	  return indices.map(function (group) {
	    var _group = _slicedToArray(group, 2),
	        start = _group[0],
	        end = _group[1];

	    end = end || start;

	    var clone = cloneDeep(chartData);

	    var field = chartData.fields[start]; // leftover remnant of editor

	    field.caption = null;
	    clone.fields = [chartData.fields[0]];

	    var _loop = function _loop(i) {
	      clone.fields.push(chartData.fields[i]);

	      if (chartData.annotations) {
	        clone.annotations = chartData.annotations.filter(function (annotation) {
	          return annotation.series === i + 1;
	        }).map(function (annotation) {
	          return _objectSpread2(_objectSpread2({}, annotation), {}, {
	            series: 1 + (i - start)
	          });
	        });
	      } // ALSO APPLY the split to the config based annotations


	      if (chartData.config.textAnnotations) {
	        clone.config.textAnnotations = chartData.config.textAnnotations.filter(function (annotation) {
	          return annotation.series === i;
	        }).map(function (annotation) {
	          return _objectSpread2(_objectSpread2({}, annotation), {}, {
	            series: 1 + (i - start)
	          });
	        });
	      }
	    };

	    for (var i = start; i <= end; i++) {
	      _loop(i);
	    } // pluck the data


	    clone.data = clone.data.map(function (row) {
	      var newRow = [row[0]];

	      for (var _i = start; _i <= end; _i++) {
	        newRow.push(row[_i]);
	      }

	      return newRow;
	    });
	    return clone;
	  }).map(function (clone, index) {
	    return applyMultiplesOptions(clone, options, index);
	  });
	}
	/**
	 * Allow custom properties to be set via options that override
	 * units etc. for each small multiple
	 * options.multiples = { 1: {}, 2: {}, 3: {}}
	 *
	 * Also now supporting the Small Multiples Axes editor in the
	 * Toaster V3 setup.
	 */

	function applyMultiplesOptions(chartData, options, index) {
	  var mergeOptions = null;

	  if (chartData.config.smallMultiplesAxis) {
	    mergeOptions = chartData.config.smallMultiplesAxis[index];
	  }

	  if (options.multiples && (options.multiples[index + 1] || options.multiples[index + 1 + ''])) {
	    var newOptions = options.multiples[index + 1] || options.multiples[index + 1 + ''];
	    mergeOptions = _objectSpread2(_objectSpread2({}, mergeOptions), {}, {
	      newOptions: newOptions
	    });
	  }

	  if (mergeOptions) {
	    var _newOptions = _merge(cloneDeep(options), mergeOptions);

	    return applyOptionsToData(chartData, _newOptions);
	  }

	  return chartData;
	}

	function spread(target, chartData, options) {
	  var defaults = {
	    // default options here
	    defaultBoxType: 'line',
	    minimumBoxWidth: 170,
	    minimumBoxHeight: 180,
	    disableGrid: true,
	    disableDomain: true,
	    // gutters between charts
	    gutterWidth: 25,
	    // breakpoint to split to "small" version of
	    // chart that uses circles instead of flats
	    renderStyleBreakpoint: 250,
	    // make sure pie chart has no labels
	    disablePieLabels: true,
	    pieOuterRadius: 120,
	    pieMinRadius: 20,
	    automaticRadius: false,
	    forceTickAtDomainTop: true,
	    minimumTicks: 2,
	    // prevent overloading of force_vertical_bars
	    verticalBarsOnly: true,
	    // colorSeries display options
	    colorSeriesOptions: [// TODO check colors
	    [cyan, gray1, orange], [redDown, gray1, greenUp]],
	    // configuration options for layout manager
	    layoutManager: {
	      minHeight: 300
	    }
	  };
	  options = _merge(defaults, options); // we need a way to store env, el for each selection and
	  // expose that out to any calling function

	  var selections = [];
	  var env = {
	    x: null,
	    // simpleAxis({orientation: 'x'}),
	    y: null,
	    // simpleAxis({orientation: 'y'}),
	    r: null,
	    options: _extends({}, options)
	  };
	  var el = select(target).classed('toaster-chart-spread', true); // ensure we have a taxonomy specified on the data

	  buildTaxonomy(chartData, false, options);
	  env.data = chartData; // allow editorHooks to set the colorSeries

	  var styleIndex = 0;
	  if (chartData.config.series_color_style) styleIndex = Number(chartData.config.series_color_style);
	  if (options.colorSeries != null) styleIndex = Number(options.colorSeries);

	  if (options.editorHooks && options.editorHooks.colorSeries) {
	    options.editorHooks.colorSeries(options.colorSeriesOptions, styleIndex);
	  }

	  var chart = el.select('.chart');
	  var chartWidth = chart.node().offsetWidth;
	  var chartTypeClass = line;
	  var series = chartData.fields.slice(1).filter(function (f, i) {
	    return i % 2 === 0;
	  });
	  if (env.options.widget) series = [series[0]];
	  var boxWidth = Math.ceil(chartWidth / series.length) - 6;
	  var boxHeight = chartWidth / getAspectRatio(chartData);
	  var numRows = 1; // when boxes are too small we start wrapping them

	  if (boxWidth < env.options.minimumBoxWidth) {
	    numRows = Math.ceil(env.options.minimumBoxWidth * series.length / chartWidth);
	    boxWidth = chartWidth / Math.ceil(series.length / numRows) - 6;
	    boxHeight /= numRows;
	  }

	  boxHeight = Math.max(boxHeight, env.options.minimumBoxHeight);
	  var numPerRow = Math.floor(chartWidth / boxWidth);
	  var gutterPadding = env.options.gutterWidth * (numPerRow - 1) / numPerRow;
	  env.options.pieOuterRadius = (boxWidth - 50) / 2 - 20;
	  if (env.options.widget) env.options.pieOuterRadius = 55;
	  env.options.layoutManager.minHeight = boxHeight; // no legend for these types

	  el.select('.legend').style('display', 'none');
	  el.classed('no-grid', !shouldDisplayGrid(env)).classed('no-domain', !shouldDisplayDomain(env)); // TWO types of renderers -- a single value render with dial or timeline style
	  // with axis / spread

	  if (chartData.fields.length === 2) {
	    chart.call(dial(env.options, styleIndex));
	    selections.push({
	      env: env,
	      el: el
	    });
	  } else {
	    // create postRender layer
	    var isSmallChart = boxWidth < env.options.renderStyleBreakpoint;
	    options.layers = [createRenderLayer(chartData, isSmallChart, styleIndex)]; // el.selectAll('.spread-container').remove()

	    var spreadData = splitData(chartData, env.options);
	    var spreads = chart.selectAll('.spread').data(spreadData);
	    var defaultOptions = {};

	    if (!isSmallChart) {
	      defaultOptions.curveType = 'stepAfter';
	      defaultOptions.layoutManager = {
	        yAxisInnerPadding: 22,
	        xAxisExtendRight: 50
	      };
	    } else {
	      defaultOptions.forceNoTicks = true;
	    }

	    var renderOptions = _merge(defaultOptions, env.options);

	    spreads.exit().remove();
	    spreads.enter().append('div').attr('class', function (d, i) {
	      return 'spread spread-' + i;
	    }).merge(spreads).style('width', boxWidth - gutterPadding + 'px').style('padding-right', function (d, i) {
	      // last item on row has no padding-right
	      if (i % numPerRow === numPerRow - 1) {
	        return 0;
	      } else {
	        return env.options.gutterWidth + 'px';
	      }
	    });
	    chart.selectAll('.spread').each(function (d, i) {
	      var container = select(this);

	      var layerOptions = _extends(renderOptions, {
	        tooltipPostRender: tooltipPostRender(chartData, i)
	      });

	      container.selectAppend('div.title').text(function (d) {
	        return spreadData[i] ? spreadData[i].fields[1].name : '';
	      });
	      container.selectAppend('div.score-title').html(function (d) {
	        var score = getScore(chartData, i);
	        return "<span>Score:</span> ".concat(score);
	      });
	      var frame = container.selectAppend('div.toaster-chart');
	      var drawLayer = chartTypeClass(frame.node(), spreadData[i], layerOptions);
	      selections.push({
	        el: container,
	        env: drawLayer.getEnv()
	      });
	    });
	  }

	  debugEnv(env);
	  return makeLayerPrototype(spread, selections, options);
	}

	function getScore(chartData, i) {
	  var colIndex = 2 * i + 2;
	  var rowIndex = chartData.data.length - 1;
	  return chartData.data[rowIndex][colIndex];
	}

	function createRenderLayer(chartData, isSmallChart, styleIndex) {
	  return function (renderTarget, el, env, opts) {
	    var container = el.select('.draw-container');
	    var lineDom = container.select('.line-group .line');
	    var oldSegments = lineDom.attr('d').split('L').map(function (v) {
	      return v.replace('M', '');
	    });
	    var selectIndex = opts.selectIndex; // now create the draw region

	    container.selectAll('.perf-group').remove();
	    container.insert('g', '.annotations') // insert before annotations
	    .classed('perf-group', true).classed('red-green', styleIndex === 1);
	    var renderGroup = container.select('g.perf-group');

	    if (isSmallChart) {
	      var circles = [];
	      var xData = getFieldIndexValueParser(chartData, true, env.options.forceCategorical);
	      chartData.data.forEach(function (row, i) {
	        circles.push({
	          line: "M".concat(oldSegments[2 * i], "L").concat(oldSegments[2 * i + 1]),
	          x: env.x.scale(xData(i)),
	          y: env.y.scale(row[1 + selectIndex * 2]),
	          value: chartData.data[i][1 + selectIndex * 2 + 1]
	        });
	      });
	      var points = renderGroup.selectAll('.circle').data(circles);
	      points.enter().append('circle').attr('cx', function (d) {
	        return d.x;
	      }).attr('cy', function (d) {
	        return d.y;
	      }).attr('r', 5).attr('class', function (d, i) {
	        return 'score-' + d.value;
	      });
	    } else {
	      var newSegments = [];

	      for (var i = 0; i < oldSegments.length / 2; i++) {
	        if (oldSegments[2 * i + 1] && chartData.data[i]) {
	          newSegments.push({
	            line: "M".concat(oldSegments[2 * i], "L").concat(oldSegments[2 * i + 1]),
	            value: chartData.data[i][1 + selectIndex * 2 + 1]
	          });
	        } else if (oldSegments[2 * i] && chartData.data[i]) {
	          var curSegment = oldSegments[2 * i];
	          var curPts = curSegment.split(',').map(function (v) {
	            return Number(v);
	          });
	          var lastSegment = newSegments[newSegments.length - 1];
	          var lastPts = lastSegment.line.replace('M', '').split('L').map(function (v) {
	            return v.split(',');
	          });
	          var segWidth = Number(lastPts[1][0]) - Number(lastPts[0][0]);
	          var finalSeg = "".concat(curPts[0] + segWidth, ",").concat(curPts[1]); // create the last segment as extended piece

	          newSegments.push({
	            line: "M".concat(oldSegments[2 * i], "L").concat(finalSeg),
	            value: chartData.data[i][1 + selectIndex * 2 + 1]
	          });
	        }
	      }

	      var lines = renderGroup.selectAll('.line').data(newSegments);
	      lines.enter().append('path').attr('stroke-width', '10').attr('class', function (d, i) {
	        return 'score-' + d.value;
	      }).merge(lines).attr('d', function (d) {
	        return d.line;
	      });
	    }
	  };
	} // Validation is a static method to check if the class
	// supports the chartData before building the chart


	spread.validateData = function (chartData, options) {
	  var validate = validator(chartData);
	  validate('Line chart must have more than one value.', isMultipleValues);
	  validate('Line should be a time series', isTimeSeries);
	  return validate;
	};

	function splitData(chartData, options) {
	  return chartData.fields.slice(1).filter(function (field, i) {
	    return i % 2 === 0;
	  }).map(function (field, i) {
	    var clone = cloneDeep(chartData);

	    var colIndex = 2 * i + 1; // leftover remnant of editor

	    field.caption = null;
	    clone.fields = [chartData.fields[0], clone.fields[colIndex]];
	    clone.data = clone.data.map(function (row) {
	      return [row[0], row[colIndex]];
	    });

	    if (clone.annotations) {
	      clone.annotations = clone.annotations.filter(function (annotation) {
	        return annotation.series === colIndex;
	      }).map(function (annotation) {
	        annotation.series = 1;
	        return annotation;
	      });
	    }

	    return clone;
	  }).map(function (clone, index) {
	    return applyMultiplesOptions(clone, options, index);
	  });
	}

	function tooltipPostRender(originalData, seriesIndex) {
	  return function (env, container, value, index) {
	    var scoreIndex = 1 + seriesIndex * 2 + 1;
	    var scoreVal = originalData.data[index][scoreIndex];
	    container.select('.tooltip-values').append('div').classed('tooltip-value', true).style('padding-top', '3px').style('line-height', '1').text("Score: ".concat(scoreVal));
	  };
	}

	function dumbbellColumn(opts) {
	  var options = _objectSpread2({
	    dumbbellRadius: 6,
	    barWidth: 2,
	    verticalColumnMinLength: 1,
	    horizontalColumnMinLength: 2,
	    preventDumbbellBars: false
	  }, opts);

	  var xScale = options.xScale,
	      yScale = options.yScale;
	  var seriesOffset = options.seriesOffset || 0;

	  function dumbbellColumn(selection) {
	    selection.each(function (chartData) {
	      var el = select(this).classed('dumbbell-column', true); // create a child element that encapsulates the entire range in order
	      // to force bounding box to match the "nice()" domain.

	      el.selectAll('.bounding-rect').remove();
	      el.append('rect').classed('bounding-rect', true).attr('x', xScale.range()[0]).attr('width', xScale.range()[1]).attr('y', yScale.range()[1]).attr('height', yScale.range()[0]).attr('fill', 'transparent'); // HORIZONTAL equals vertical bars

	      var verticalBars = options.orientation === HORIZONTAL;
	      var categoricalData = getFieldIndexValueParser(chartData, true, true);
	      var series = options.seriesData || getSeries(chartData);
	      var seriesScale = band().domain(range$2(1));
	      var isHighlighted = valueHighlighter(chartData);
	      var halfBar = options.barWidth / 2;
	      var halfWidth = verticalBars ? xScale.bandwidth() / 2 : yScale.bandwidth() / 2;

	      if (verticalBars) {
	        seriesScale.range([0, xScale.bandwidth()]);
	      } else {
	        seriesScale.range([0, yScale.bandwidth()]);
	      } // function to convert null to 0


	      var nullZero = function nullZero(values) {
	        return values.map(function (v) {
	          return v == null ? 0 : v;
	        });
	      };

	      if (seriesScale.bandwidth() < 1) {
	        console.warn(chartData.id, 'Column width is less than 1px', chartData.data.length + ' columns');
	      }

	      var barGroup = el.selectAppend('g.bar-group');
	      var cseries = el.selectAll('.series').data(series);
	      cseries.exit().remove();
	      cseries = cseries.enter().append('g').attr('class', function (d, i) {
	        return 'series f series-' + (i + seriesOffset);
	      }).merge(cseries);
	      var bars = barGroup.selectAll('.dumbbell-bar').data(function (d) {
	        return d.data;
	      });
	      var bells = cseries.selectAll('.dumbbell-value').data(function (d) {
	        return d.data;
	      });
	      bars.exit().remove();
	      bells.exit().remove();

	      if (verticalBars) {
	        if (!options.preventDumbbellBars) {
	          bars.enter().append('rect').merge(bars).attr('class', function (d, i) {
	            if (series.length > 2) return 'dumbbell-bar';
	            var vals = nullZero(d.slice(1));
	            var maxVal = max$2(vals);
	            var colorIndex = vals.indexOf(maxVal);
	            return "dumbbell-bar f series-".concat(colorIndex);
	          }).classed('highlight', isHighlighted).attr('x', function (d, i) {
	            return xScale(categoricalData(i)) + halfWidth - halfBar;
	          }).attr('y', function (d, i) {
	            // y value is 0 for single series, otherwise current
	            if (series.length === 1) {
	              return yScale(Math.max(0, numberOrNull(d[1])));
	            } else {
	              var vals = d.slice(1).filter(nullFilter);
	              var maxVal = max$2(vals);
	              return yScale(numberOrNull(maxVal));
	            }
	          }).attr('width', options.barWidth).attr('height', function (d, i) {
	            if (d == null) return 0;

	            if (series.length === 1) {
	              return Math.abs(yScale(numberOrNull(d[1])) - yScale(numberOrNull(0)));
	            } else {
	              var vals = d.slice(1).filter(nullFilter);
	              var maxVal = max$2(vals);
	              var minVal = min$2(vals);
	              if (maxVal == null) return 0;
	              return Math.abs(yScale(numberOrNull(maxVal)) - yScale(numberOrNull(minVal)));
	            }
	          });
	        }

	        bells.enter().append('circle').attr('class', 'dumbbell-value').merge(bells).classed('highlight', isHighlighted).attr('r', function (d, i) {
	          if (d == null) return 0;
	          return options.dumbbellRadius;
	        }).attr('cx', function (d, i) {
	          return xScale(categoricalData(i)) + halfWidth;
	        }).attr('cy', function (d) {
	          return yScale(numberOrNull(d));
	        });
	      } else {
	        // these are horizontal bars
	        if (!options.preventDumbbellBars) {
	          bars.enter().append('rect').merge(bars).attr('class', function (d, i) {
	            if (series.length > 2) return 'dumbbell-bar';
	            var vals = nullZero(d.slice(1));
	            var maxVal = max$2(vals);
	            var colorIndex = vals.indexOf(maxVal);
	            return "dumbbell-bar f series-".concat(colorIndex);
	          }).classed('highlight', isHighlighted).attr('y', function (d, i) {
	            return yScale(categoricalData(i)) + halfWidth - halfBar;
	          }).attr('x', function (d, i) {
	            // y value is 0 for single series, otherwise current
	            if (series.length === 1) {
	              return xScale(Math.min(0, numberOrNull(d[1])));
	            } else {
	              var vals = d.slice(1).filter(nullFilter);
	              var minVal = min$2(vals);
	              return xScale(numberOrNull(minVal));
	            }
	          }).attr('height', options.barWidth).attr('width', function (d, i) {
	            if (d == null) return 0;

	            if (series.length === 1) {
	              return Math.abs(xScale(numberOrNull(d[1])) - xScale(numberOrNull(0)));
	            } else {
	              var vals = d.slice(1).filter(nullFilter);
	              var maxVal = max$2(vals);
	              var minVal = min$2(vals);
	              if (maxVal == null || minVal == null) return 0;
	              return Math.abs(xScale(numberOrNull(maxVal)) - xScale(numberOrNull(minVal)));
	            }
	          });
	        }

	        bells.enter().append('circle').attr('class', 'dumbbell-value').merge(bells).classed('highlight', isHighlighted).attr('r', function (d, i) {
	          if (d == null) return 0;
	          return options.dumbbellRadius;
	        }).attr('cy', function (d, i) {
	          return yScale(categoricalData(i)) + halfWidth;
	        }).attr('cx', function (d) {
	          return xScale(numberOrNull(d));
	        });
	      }
	    });
	  }

	  dumbbellColumn.xScale = function (_) {
	    return arguments.length ? (xScale = _, dumbbellColumn) : xScale; // eslint-disable-line
	  };

	  dumbbellColumn.yScale = function (_) {
	    return arguments.length ? (yScale = _.copy(), dumbbellColumn) : yScale; // eslint-disable-line
	  };

	  return dumbbellColumn;
	}

	function dumbbellTransitions(target, chartData, options) {
	  var _options$transition = options.transition,
	      transition = _options$transition === void 0 ? {} : _options$transition;
	  var _transition$type = transition.type,
	      type = _transition$type === void 0 ? 'default' : _transition$type;

	  if (type === 'synced') {
	    return _objectSpread2(_objectSpread2({}, syncedTransition()), transition);
	  } else if (type === 'chained') {
	    return _objectSpread2(_objectSpread2({}, chainedTransition()), transition);
	  } else {
	    return _objectSpread2(_objectSpread2({}, staggeredTransition()), transition);
	  }
	}

	function makeStageHandler(staggered) {
	  return function (target, env, transitionOptions) {
	    var bars = target.selectAll('rect.dumbbell-bar').nodes();
	    var bells = target.selectAll('circle.dumbbell-value').nodes();
	    var horizontalBars = env.layout.orientation() === 'vertical';
	    var multiSeries = getSeries(env.data).length > 1;
	    var valProp = 'y',
	        lengthProp = 'height';

	    if (horizontalBars) {
	      valProp = 'x';
	      lengthProp = 'width';
	    }

	    bars.forEach(function (node, index) {
	      var bar = select(node);
	      var length = Number(bar.attr(lengthProp));
	      var val = Number(bar.attr(valProp));
	      var zeroVal = horizontalBars ? env.x.scale(0) : env.y.scale(0);
	      var initialVal = zeroVal;

	      if (multiSeries) {
	        initialVal = val > zeroVal ? val : val - length;
	      }

	      bar.attr(lengthProp, 0).attr(valProp, initialVal).attr("data-transition-".concat(valProp), val).attr("data-transition-".concat(lengthProp), length);
	    });
	    bells.forEach(function (node, index) {
	      var bell = select(node);
	      var yProp = horizontalBars ? 'cx' : 'cy';
	      var val = Number(bell.attr(yProp));
	      var zeroVal = horizontalBars ? env.x.scale(0) : env.y.scale(0);
	      var initialVal = zeroVal;
	      bell.attr(lengthProp, 0).attr(yProp, initialVal).attr("data-transition-".concat(yProp), val);
	    });
	    stageAnnotationTransition(target);
	    stageBarLabelTransition(target);
	  };
	} // TODO :: SUPPORT EASE OPTIONS


	function makePlayHandler(animType) {
	  return playInterface(function (target, env, transitionOptions) {
	    var data = env.data;
	    var delay = transitionOptions.delay,
	        duration = transitionOptions.duration,
	        normalizeSpeed = transitionOptions.normalizeSpeed,
	        _transitionOptions$ba = transitionOptions.barDuration,
	        barDuration = _transitionOptions$ba === void 0 ? 800 : _transitionOptions$ba;
	    var bars = target.selectAll('rect.dumbbell-bar').nodes();
	    var bells = target.selectAll('circle.dumbbell-value').nodes();
	    var durationOffset = duration - barDuration;
	    var barDelay = animType === 'staggered' ? durationOffset / (data.data.length * (data.fields.length - 1)) : durationOffset;
	    var rangeLength = env.y.rangeLength();
	    var transitions = [];
	    var valProp = 'y',
	        lengthProp = 'height';
	    var horizontalBars = env.layout.orientation() === 'vertical';

	    if (horizontalBars) {
	      valProp = 'x';
	      lengthProp = 'width';
	    }

	    bars.forEach(function (node, index) {
	      var bar = select(node);
	      var length = Number(bar.attr("data-transition-".concat(lengthProp)));
	      var val = Number(bar.attr("data-transition-".concat(valProp)));
	      var speedRatio = normalizeSpeed ? length / rangeLength : 1.0;
	      var t = bar.transition().ease(backOut).duration(barDelay + barDuration * speedRatio).delay(delay + index * barDelay).attr(lengthProp, length).attr(valProp, val);
	      transitions.push(t);
	    });
	    bells.forEach(function (node, index) {
	      var bell = select(node);
	      var yProp = horizontalBars ? 'cx' : 'cy';
	      var val = Number(bell.attr("data-transition-".concat(yProp)));
	      var length = Math.abs(Number(bell.attr(yProp)) - val);
	      var speedRatio = normalizeSpeed ? length / rangeLength : 1.0;
	      var t = bell.transition().ease(backOut).duration(barDelay + barDuration * speedRatio).delay(delay + index * barDelay).attr(yProp, val);
	      transitions.push(t);
	    });
	    transitions.concat(playAnnotationTransition(target, env, transitionOptions));
	    transitions.concat(playBarLabelTransition(target, env, transitionOptions));
	    return transitions;
	  });
	} // staggered transition will render one, then the other next


	function staggeredTransition(container, chartData, options) {
	  var stageHandler = makeStageHandler();
	  var playHandler = makePlayHandler('staggered');

	  var interruptHandler = function interruptHandler() {
	    return null;
	  };

	  return {
	    duration: 3000,
	    normalizeSpeed: false,
	    stageHandler: stageHandler,
	    playHandler: playHandler,
	    interruptHandler: interruptHandler
	  };
	}
	function chainedTransition(container, chartData, options) {
	  var stageHandler = makeStageHandler();
	  var playHandler = makePlayHandler('chained');

	  var interruptHandler = function interruptHandler() {
	    return null;
	  };

	  return {
	    duration: 2000,
	    normalizeSpeed: false,
	    stageHandler: stageHandler,
	    playHandler: playHandler,
	    interruptHandler: interruptHandler
	  };
	} // synced transition will render all lines at the same time

	function syncedTransition(target, options) {
	  var stageHandler = makeStageHandler();
	  var playHandler = makePlayHandler('synced');
	  return {
	    normalizeSpeed: false,
	    stageHandler: stageHandler,
	    playHandler: playHandler
	  };
	}

	function dumbbell(target, chartData, options) {
	  var defaults = {
	    // some settings for horizontal layout switching
	    // min width for column before horizontal layout
	    columnWidthBreakpointMin: 30,
	    // max width for column (disabled for now)
	    columnWidthBreakpointMax: 1250,
	    // how many characters triggers long text breakpoints
	    textLengthBreakpoint: 12,
	    // if long text min width of column
	    columnWidthLongTextBreakpoint: 110,
	    // everything under this width is horizontal
	    smallWidthBreakpoint: 500,
	    // everything under this width is horizontal table layout
	    mobileWidthBreakpoint: 380,
	    // distance tooltip box is away from point
	    tooltipOffsetX: 7,
	    // distance tooltip box is away from point
	    tooltipOffsetY: 7,
	    // tooltip box line for height estimation
	    tooltipLineHeight: 30,
	    // tooltip max width
	    tooltipMaxWidth: 160,
	    // radius of tooltip anchor
	    tooltipAnchorSize: 4,
	    // replaces axis inner padding for date axes
	    dateAxisInnerPadding: 15,
	    // 15,
	    // disable * condensed annotations
	    preventCondensedAnnotations: true,
	    isDumbbell: true,
	    stackedBand: false,
	    // becomes yAxisInnerPadding for horiz layout
	    horizontalLayoutPadding: 10,
	    // configuration options for layout manager
	    layoutManager: {
	      yAxisInnerPadding: 0,
	      xAxisExtendRight: 3,
	      minHeightHorizontal: 0,
	      margin: {
	        top: 10,
	        right: 0,
	        bottom: 0,
	        left: 8
	      }
	    },
	    // configuration for the chart axes
	    bandAxis: {
	      horizontalBarPadding: 0.2,
	      horizontalBarPaddingCondensed: 0.12,
	      horizontalBarHeight: 32,
	      horizontalBarHeightLarge: 50,
	      // custom value for HBar charts
	      horizontalBarHeightCondensed: 24,
	      // custom value for HBar charts
	      axisTextLineHeightHorizontal: 15,
	      axisTextLineHeight: 18,
	      verticalAxisWrapWidth: 300
	    },
	    linearAxis: {},
	    // configuration for animation
	    transition: _objectSpread2({}, dumbbellTransitions(target, chartData, options))
	  };

	  var opts = _merge(defaults, options);

	  var el = select(target).classed('toaster-chart-dumbbell', true).classed('transition-stage', stageForTransition(opts));
	  columnTaxonomy(chartData);
	  var env = makeEnv(el, chartData, opts); // horizontal bars is vertical orientation

	  var isHorizontal = isChartHorizontal(el, chartData, _objectSpread2(_objectSpread2({}, env.options), {}, {
	    stackedBand: true // for width calc

	  }));
	  var w = el.node().offsetWidth;
	  var orientation = HORIZONTAL;
	  var yAxisPosition = RIGHT$1;
	  var isDateAxis = false;
	  var isContinuousAxis = false;

	  if (!isHorizontal) {
	    isDateAxis = renderChartAsTimeSeries(el, chartData, env.options);
	    isContinuousAxis = renderAxisAsContinuous(el, chartData, env.options);
	  }

	  var minHeight = env.options.layoutManager.minHeight;
	  var minBarHeight = 0;

	  if (minHeight) {
	    minBarHeight = minHeight / getNumberOfColumns(env.data, true);
	  }

	  if (isHorizontal) {
	    // if horizontal sort descending
	    if (chartData.config && chartData.config.sort_by_value && !isTimeSeries(chartData)) {
	      if (isNegativeDomain(chartData)) {
	        sortAllFields(chartData, {
	          stacked: false,
	          direction: 'ascending'
	        });
	      } else {
	        sortAllFields(chartData, {
	          stacked: false
	        });
	      }
	    }

	    if (chartData.data.length <= 5) {
	      env.options.bandAxis.horizontalBarHeight = env.options.bandAxis.horizontalBarHeightLarge;
	    } else if (chartData.data.length > 15) {
	      env.options.bandAxis.horizontalBarHeight = env.options.bandAxis.horizontalBarHeightCondensed;
	    } // if screenshot mode calculate horizontalBarHeight


	    if (env.options.screenshotMode) {
	      env.options.bandAxis.horizontalBarHeight = Math.max(minBarHeight, env.options.bandAxis.horizontalBarHeight);
	    }

	    if (isMobileWidth(w, env.options)) {
	      env.options.bandAxis.axisTextLineHeightHorizontal = 12;
	      env.options.bandAxis.verticalAxisWrapWidth = 180;
	    }

	    orientation = VERTICAL;
	    yAxisPosition = LEFT$1;
	    env.options.disableGrid = false;
	    env.options.layoutManager.margin.top = 0;
	    env.options.layoutManager.margin.bottom = 20;
	    env.options.layoutManager.margin.right = 30;
	    env.options.layoutManager.margin.left = 0;
	    env.options.layoutManager.yAxisInnerPadding = env.options.horizontalLayoutPadding;
	    env.options.layoutManager.verticalAxisShift = -5;
	  }

	  el.classed('vertical-flow', isHorizontal);
	  var isMultiSeries = getSeries(chartData).length > 1; // for the dumbbell chart we use a stacked band axis for primary
	  // but a non stacked linear axis for secondary

	  var bandAxisConfig = _objectSpread2({
	    isPrimaryAxis: true,
	    stackedBand: true,
	    isDateAxis: isDateAxis,
	    isContinuousAxis: isContinuousAxis
	  }, env.options.bandAxis);

	  var linearAxisConfig = _objectSpread2({
	    isPrimaryAxis: false,
	    // domainFromZero only on single series charts
	    domainFromZero: !isMultiSeries,
	    stackedDomain: false
	  }, env.options.linearAxis);

	  var layoutConfig = _objectSpread2({
	    primaryAxis: bandAxisProvider(bandAxisConfig),
	    secondaryAxis: linearAxisProvider(linearAxisConfig),
	    orientation: orientation,
	    yAxisPosition: yAxisPosition,
	    yAxisInnerPadding: isDateAxis ? env.options.dateAxisInnerPadding : undefined
	  }, env.options.layoutManager);

	  var chartLayout = layoutManager(layoutConfig);
	  var chart = el.selectAppend('div.chart');
	  chart.selectAll('*').remove();
	  chart.call(chartLayout, env);
	  var drawArea = chartLayout.draw().classed('dumbbell', true);
	  var gridLength = env.x.rangeLength() + chartLayout.xAxisExtendRight() + 2 * chartLayout.yAxisInnerPadding(); // grid is now a render layer

	  var showGrid = isHorizontal && !env.options.disableGrid || shouldDisplayGrid(env);
	  el.classed('no-grid', !showGrid).classed('no-domain', !shouldDisplayDomain(env)).classed('no-axis', env.options.disableGrid); // draw grid

	  if (orientation === HORIZONTAL) {
	    drawArea.selectAppend('g.grid').call(gridlines({
	      length: gridLength
	    }), env);
	  } else {
	    gridLength = env.y.rangeLength() + 2 * chartLayout.xAxisInnerPadding();
	    drawArea.selectAppend('g.grid').call(gridlines({
	      length: gridLength,
	      orientation: Y,
	      hideBottomValueTick: false,
	      extendVerticalZeroTick: true,
	      gridTransform: [0, 0]
	    }), env);
	  }

	  if (!isHorizontal) {
	    // allow a layer for highlighting ranges below the chart
	    if (chartData.config.highlightRanges) {
	      var _chartData$config$hig = chartData.config.highlightRanges,
	          ranges = _chartData$config$hig.ranges,
	          rangeStyle = _chartData$config$hig.rangeStyle;
	      drawArea.selectAppend('g.highlight-ranges').call(highlightRanges({
	        ranges: ranges,
	        rangeStyle: rangeStyle,
	        isColumnType: true
	      }), env);
	    }
	  } // now finally call the dumbbellcolumn layer


	  drawArea.call(dumbbellColumn(_objectSpread2(_objectSpread2({}, env.options), {}, {
	    xScale: env.x.scale,
	    yScale: env.y.scale,
	    preventDumbbellBars: chartData.config.preventDumbbellBars,
	    orientation: orientation
	  })), env);
	  placeVerticalAxisLabel(env, isHorizontal); // draw annotation layer

	  columnAnnotations(drawArea, chartData.annotations, env);

	  if (!isHorizontal) {
	    // allow horizontal line thresholds
	    if (chartData.config.thresholds) {
	      drawArea.selectAppend('g.threshold-lines').call(thresholdLines(_objectSpread2(_objectSpread2({}, env.options), {}, {
	        thresholds: chartData.config.thresholds
	      })), env);
	    }
	  } // create bottom label if needed


	  chart.call(bottomLabel(), env, chartData); // overflow layout call

	  chartLayout.overflowScale();

	  if (!(env.options.disableTooltip || chartData.config.disableTooltip)) {
	    columnTooltip({
	      chart: chart,
	      area: drawArea,
	      env: env,
	      isDumbbell: true
	    });
	  }

	  debugEnv(env);
	  return makeLayerPrototype(drawArea, [{
	    env: env,
	    el: el
	  }], opts);
	}

	function add_css$r(target) {
	  append_styles(target, "svelte-19d7t0l", "table.container.svelte-19d7t0l.svelte-19d7t0l{border-spacing:0;border:none;color:inherit;font-size:14px}.box-outer.svelte-19d7t0l.svelte-19d7t0l{padding-right:4px}.box-inner.svelte-19d7t0l.svelte-19d7t0l{width:100%;bottom:0;height:1px}.value.svelte-19d7t0l.svelte-19d7t0l{font-size:32px;margin-top:7px;line-height:29px}.change.svelte-19d7t0l.svelte-19d7t0l{font-size:14px;margin-bottom:6px}.change.svelte-19d7t0l .num.svelte-19d7t0l{font-size:32px}td.box-cell.svelte-19d7t0l.svelte-19d7t0l{vertical-align:bottom}td.label-cell.svelte-19d7t0l.svelte-19d7t0l{vertical-align:top;padding-right:7px}td:last-child.label-cell.svelte-19d7t0l.svelte-19d7t0l{padding-right:0}@media(max-width: 480px){.value.svelte-19d7t0l.svelte-19d7t0l{font-size:22px;margin-top:9px;line-height:20px}}");
	}

	function get_each_context$b(ctx, list, i) {
	  var child_ctx = ctx.slice();
	  child_ctx[24] = list[i][0];
	  child_ctx[25] = list[i][1];
	  child_ctx[27] = i;
	  return child_ctx;
	}

	function get_each_context_1$4(ctx, list, i) {
	  var child_ctx = ctx.slice();
	  child_ctx[24] = list[i][0];
	  child_ctx[25] = list[i][1];
	  child_ctx[27] = i;
	  return child_ctx;
	} // (112:0) {#if showPercentChange}


	function create_if_block$n(ctx) {
	  var div;
	  var span;
	  var t0_value =
	  /*changeFormatter*/
	  ctx[3](
	  /*percentChange*/
	  ctx[1]) + "";
	  var t0;
	  var t1;
	  return {
	    c: function c() {
	      div = element("div");
	      span = element("span");
	      t0 = text(t0_value);
	      t1 = text(" change");
	      attr(span, "class", "num svelte-19d7t0l");
	      attr(div, "class", "change svelte-19d7t0l");
	    },
	    m: function m(target, anchor) {
	      insert(target, div, anchor);
	      append(div, span);
	      append(span, t0);
	      append(div, t1);
	    },
	    p: function p(ctx, dirty) {
	      if (dirty &
	      /*changeFormatter, percentChange*/
	      10 && t0_value !== (t0_value =
	      /*changeFormatter*/
	      ctx[3](
	      /*percentChange*/
	      ctx[1]) + "")) set_data(t0, t0_value);
	    },
	    d: function d(detaching) {
	      if (detaching) detach(div);
	    }
	  };
	} // (120:4) {#each boxes as [label, value], i}


	function create_each_block_1$4(ctx) {
	  var td;
	  var div1;
	  var div0;
	  var div0_style_value;
	  var t;
	  return {
	    c: function c() {
	      td = element("td");
	      div1 = element("div");
	      div0 = element("div");
	      t = space();
	      attr(div0, "class", "" + (null_to_empty("box-inner bg series-".concat(
	      /*i*/
	      ctx[27])) + " svelte-19d7t0l"));
	      attr(div0, "style", div0_style_value = "\n              height: ".concat(
	      /*classicMode*/
	      ctx[9] ?
	      /*classicScale*/
	      ctx[5](
	      /*value*/
	      ctx[25]) :
	      /*squareScale*/
	      ctx[7](Math.sqrt(
	      /*value*/
	      ctx[25])), "px;\n              width: ").concat(
	      /*classicMode*/
	      ctx[9] ?
	      /*columnWidth*/
	      ctx[6] :
	      /*squareScale*/
	      ctx[7](Math.sqrt(
	      /*value*/
	      ctx[25])), "px;\n            "));
	      attr(div1, "class", "box-outer svelte-19d7t0l");
	      attr(td, "class", "box-cell svelte-19d7t0l");
	    },
	    m: function m(target, anchor) {
	      insert(target, td, anchor);
	      append(td, div1);
	      append(div1, div0);
	      append(td, t);
	    },
	    p: function p(ctx, dirty) {
	      if (dirty &
	      /*classicMode, classicScale, boxes, squareScale, columnWidth*/
	      740 && div0_style_value !== (div0_style_value = "\n              height: ".concat(
	      /*classicMode*/
	      ctx[9] ?
	      /*classicScale*/
	      ctx[5](
	      /*value*/
	      ctx[25]) :
	      /*squareScale*/
	      ctx[7](Math.sqrt(
	      /*value*/
	      ctx[25])), "px;\n              width: ").concat(
	      /*classicMode*/
	      ctx[9] ?
	      /*columnWidth*/
	      ctx[6] :
	      /*squareScale*/
	      ctx[7](Math.sqrt(
	      /*value*/
	      ctx[25])), "px;\n            "))) {
	        attr(div0, "style", div0_style_value);
	      }
	    },
	    d: function d(detaching) {
	      if (detaching) detach(td);
	    }
	  };
	} // (135:4) {#each boxes as [label, value], i}


	function create_each_block$b(ctx) {
	  var td;
	  var div0;
	  var t0_value =
	  /*formatter*/
	  ctx[8](
	  /*value*/
	  ctx[25]) + "";
	  var t0;
	  var t1;
	  var div1;
	  var t2_value =
	  /*label*/
	  ctx[24] + "";
	  var t2;
	  var t3;
	  var td_style_value;
	  return {
	    c: function c() {
	      td = element("td");
	      div0 = element("div");
	      t0 = text(t0_value);
	      t1 = space();
	      div1 = element("div");
	      t2 = text(t2_value);
	      t3 = space();
	      attr(div0, "class", "value svelte-19d7t0l");
	      attr(div1, "class", "label");
	      attr(td, "class", "label-cell svelte-19d7t0l");
	      attr(td, "style", td_style_value = "\n          min-width: ".concat(
	      /*classicMode*/
	      ctx[9] ?
	      /*columnWidth*/
	      ctx[6] :
	      /*squareScale*/
	      ctx[7](Math.sqrt(
	      /*value*/
	      ctx[25])), "px;\n          max-width: ").concat((
	      /*classicMode*/
	      ctx[9] ?
	      /*columnWidth*/
	      ctx[6] :
	      /*squareScale*/
	      ctx[7](Math.sqrt(
	      /*value*/
	      ctx[25]))) + TEXT_PAD, "px;\n        "));
	    },
	    m: function m(target, anchor) {
	      insert(target, td, anchor);
	      append(td, div0);
	      append(div0, t0);
	      append(td, t1);
	      append(td, div1);
	      append(div1, t2);
	      append(td, t3);
	    },
	    p: function p(ctx, dirty) {
	      if (dirty &
	      /*formatter, boxes*/
	      260 && t0_value !== (t0_value =
	      /*formatter*/
	      ctx[8](
	      /*value*/
	      ctx[25]) + "")) set_data(t0, t0_value);
	      if (dirty &
	      /*boxes*/
	      4 && t2_value !== (t2_value =
	      /*label*/
	      ctx[24] + "")) set_data(t2, t2_value);

	      if (dirty &
	      /*classicMode, columnWidth, squareScale, boxes*/
	      708 && td_style_value !== (td_style_value = "\n          min-width: ".concat(
	      /*classicMode*/
	      ctx[9] ?
	      /*columnWidth*/
	      ctx[6] :
	      /*squareScale*/
	      ctx[7](Math.sqrt(
	      /*value*/
	      ctx[25])), "px;\n          max-width: ").concat((
	      /*classicMode*/
	      ctx[9] ?
	      /*columnWidth*/
	      ctx[6] :
	      /*squareScale*/
	      ctx[7](Math.sqrt(
	      /*value*/
	      ctx[25]))) + TEXT_PAD, "px;\n        "))) {
	        attr(td, "style", td_style_value);
	      }
	    },
	    d: function d(detaching) {
	      if (detaching) detach(td);
	    }
	  };
	}

	function create_fragment$A(ctx) {
	  var t0;
	  var table;
	  var tr0;
	  var t1;
	  var tr1;
	  var if_block =
	  /*showPercentChange*/
	  ctx[4] && create_if_block$n(ctx);
	  var each_value_1 =
	  /*boxes*/
	  ctx[2];
	  var each_blocks_1 = [];

	  for (var i = 0; i < each_value_1.length; i += 1) {
	    each_blocks_1[i] = create_each_block_1$4(get_each_context_1$4(ctx, each_value_1, i));
	  }

	  var each_value =
	  /*boxes*/
	  ctx[2];
	  var each_blocks = [];

	  for (var _i = 0; _i < each_value.length; _i += 1) {
	    each_blocks[_i] = create_each_block$b(get_each_context$b(ctx, each_value, _i));
	  }

	  return {
	    c: function c() {
	      if (if_block) if_block.c();
	      t0 = space();
	      table = element("table");
	      tr0 = element("tr");

	      for (var _i2 = 0; _i2 < each_blocks_1.length; _i2 += 1) {
	        each_blocks_1[_i2].c();
	      }

	      t1 = space();
	      tr1 = element("tr");

	      for (var _i3 = 0; _i3 < each_blocks.length; _i3 += 1) {
	        each_blocks[_i3].c();
	      }

	      attr(table, "class", "container svelte-19d7t0l");
	    },
	    m: function m(target, anchor) {
	      if (if_block) if_block.m(target, anchor);
	      insert(target, t0, anchor);
	      insert(target, table, anchor);
	      append(table, tr0);

	      for (var _i4 = 0; _i4 < each_blocks_1.length; _i4 += 1) {
	        each_blocks_1[_i4].m(tr0, null);
	      }

	      append(table, t1);
	      append(table, tr1);

	      for (var _i5 = 0; _i5 < each_blocks.length; _i5 += 1) {
	        each_blocks[_i5].m(tr1, null);
	      }
	      /*table_binding*/


	      ctx[23](table);
	    },
	    p: function p(ctx, _ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	          dirty = _ref2[0];

	      if (
	      /*showPercentChange*/
	      ctx[4]) {
	        if (if_block) {
	          if_block.p(ctx, dirty);
	        } else {
	          if_block = create_if_block$n(ctx);
	          if_block.c();
	          if_block.m(t0.parentNode, t0);
	        }
	      } else if (if_block) {
	        if_block.d(1);
	        if_block = null;
	      }

	      if (dirty &
	      /*classicMode, classicScale, boxes, squareScale, Math, columnWidth*/
	      740) {
	        each_value_1 =
	        /*boxes*/
	        ctx[2];

	        var _i6;

	        for (_i6 = 0; _i6 < each_value_1.length; _i6 += 1) {
	          var child_ctx = get_each_context_1$4(ctx, each_value_1, _i6);

	          if (each_blocks_1[_i6]) {
	            each_blocks_1[_i6].p(child_ctx, dirty);
	          } else {
	            each_blocks_1[_i6] = create_each_block_1$4(child_ctx);

	            each_blocks_1[_i6].c();

	            each_blocks_1[_i6].m(tr0, null);
	          }
	        }

	        for (; _i6 < each_blocks_1.length; _i6 += 1) {
	          each_blocks_1[_i6].d(1);
	        }

	        each_blocks_1.length = each_value_1.length;
	      }

	      if (dirty &
	      /*classicMode, columnWidth, squareScale, Math, boxes, TEXT_PAD, formatter*/
	      964) {
	        each_value =
	        /*boxes*/
	        ctx[2];

	        var _i7;

	        for (_i7 = 0; _i7 < each_value.length; _i7 += 1) {
	          var _child_ctx = get_each_context$b(ctx, each_value, _i7);

	          if (each_blocks[_i7]) {
	            each_blocks[_i7].p(_child_ctx, dirty);
	          } else {
	            each_blocks[_i7] = create_each_block$b(_child_ctx);

	            each_blocks[_i7].c();

	            each_blocks[_i7].m(tr1, null);
	          }
	        }

	        for (; _i7 < each_blocks.length; _i7 += 1) {
	          each_blocks[_i7].d(1);
	        }

	        each_blocks.length = each_value.length;
	      }
	    },
	    i: noop,
	    o: noop,
	    d: function d(detaching) {
	      if (if_block) if_block.d(detaching);
	      if (detaching) detach(t0);
	      if (detaching) detach(table);
	      destroy_each(each_blocks_1, detaching);
	      destroy_each(each_blocks, detaching);
	      /*table_binding*/

	      ctx[23](null);
	    }
	  };
	}

	var DEFAULT_WIDTH = 300;
	var MAX_HEIGHT = 400;
	var GAP_WIDTH = 12;
	var TEXT_PAD = 35;
	var MAX_COUNT = 5;

	function instance$A($$self, $$props, $$invalidate) {
	  var classicMode;
	  var boxes;
	  var containerWidth;
	  var columnWidth;
	  var formatter;
	  var rootValues;
	  var rootSum;
	  var largestRoot;
	  var gapWidth;
	  var rangeMax;
	  var squareScale;
	  var boxHeight;
	  var maxValue;
	  var classicScale;
	  var showPercentChange;
	  var firstValue;
	  var lastValue;
	  var percentChange;
	  var changeFormatter;
	  var env = $$props.env;
	  var _$$props$options = $$props.options,
	      options = _$$props$options === void 0 ? {} : _$$props$options;
	  var _$$props$chartData = $$props.chartData,
	      chartData = _$$props$chartData === void 0 ? {
	    fields: [],
	    data: [],
	    config: {},
	    chartOptions: {}
	  } : _$$props$chartData;
	  var containerNode;

	  function table_binding($$value) {
	    binding_callbacks[$$value ? 'unshift' : 'push'](function () {
	      containerNode = $$value;
	      $$invalidate(0, containerNode);
	    });
	  }

	  $$self.$$set = function ($$props) {
	    if ('env' in $$props) $$invalidate(10, env = $$props.env);
	    if ('options' in $$props) $$invalidate(11, options = $$props.options);
	    if ('chartData' in $$props) $$invalidate(12, chartData = $$props.chartData);
	  };

	  $$self.$$.update = function () {
	    if ($$self.$$.dirty &
	    /*options, chartData*/
	    6144) {
	      $$invalidate(9, classicMode = !(options.comparisonSquareMode || chartData.config.comparisonSquareMode));
	    }

	    if ($$self.$$.dirty &
	    /*chartData*/
	    4096) {
	      $$invalidate(2, boxes = chartData.data.slice(0, MAX_COUNT));
	    }

	    if ($$self.$$.dirty &
	    /*containerNode*/
	    1) {
	      $$invalidate(19, containerWidth = containerNode ? containerNode.parentNode.offsetWidth : DEFAULT_WIDTH);
	    }

	    if ($$self.$$.dirty &
	    /*containerWidth, boxes*/
	    524292) {
	      $$invalidate(6, columnWidth = containerWidth / boxes.length);
	    }

	    if ($$self.$$.dirty &
	    /*chartData, env*/
	    5120) {
	      $$invalidate(8, formatter = fieldFormatter$1(chartData.fields[1], env, {
	        decimalPlaces: chartData.chartOptions.decimalPlaces,
	        forceCommaDisplay: chartData.config.force_comma_display,
	        displayStringsInNumericFields: true
	      }));
	    }

	    if ($$self.$$.dirty &
	    /*boxes*/
	    4) {
	      // below is calculation for square rendering mode
	      $$invalidate(17, rootValues = boxes.map(function (row) {
	        return Math.sqrt(row[1]);
	      }));
	    }

	    if ($$self.$$.dirty &
	    /*rootValues*/
	    131072) {
	      $$invalidate(22, rootSum = rootValues.reduce(function (sum, a) {
	        return sum + a;
	      }, 0));
	    }

	    if ($$self.$$.dirty &
	    /*rootValues*/
	    131072) {
	      $$invalidate(21, largestRoot = Math.max.apply(Math, _toConsumableArray(rootValues)));
	    }

	    if ($$self.$$.dirty &
	    /*rootValues*/
	    131072) {
	      $$invalidate(18, gapWidth = (rootValues.length - 1) * GAP_WIDTH);
	    }

	    if ($$self.$$.dirty &
	    /*largestRoot, rootSum, containerWidth, gapWidth*/
	    7077888) {
	      $$invalidate(20, rangeMax = Math.min(largestRoot / rootSum * (containerWidth - gapWidth), (containerWidth - gapWidth) / 2));
	    }

	    if ($$self.$$.dirty &
	    /*largestRoot, rangeMax*/
	    3145728) {
	      $$invalidate(7, squareScale = linear().domain([0, largestRoot]).range([0, rangeMax]));
	    }

	    if ($$self.$$.dirty &
	    /*chartData*/
	    4096) {
	      // below is calculation for classic rendering mode
	      $$invalidate(15, boxHeight = 1 / getAspectRatio(chartData) * MAX_HEIGHT);
	    }

	    if ($$self.$$.dirty &
	    /*boxes*/
	    4) {
	      $$invalidate(16, maxValue = Math.max.apply(Math, _toConsumableArray(boxes.map(function (v) {
	        return v[1];
	      }))));
	    }

	    if ($$self.$$.dirty &
	    /*containerWidth, gapWidth, rootValues*/
	    917504) {
	      $$invalidate(6, columnWidth = (containerWidth - gapWidth) / rootValues.length);
	    }

	    if ($$self.$$.dirty &
	    /*maxValue, boxHeight*/
	    98304) {
	      $$invalidate(5, classicScale = linear().domain([0, maxValue]).range([0, boxHeight]));
	    }

	    if ($$self.$$.dirty &
	    /*chartData*/
	    4096) {
	      // these are used for a feature to show percentage change from one to the other (box office)
	      $$invalidate(4, showPercentChange = chartData.config.showPercentageChange || chartData.chartOptions.showPercentChange);
	    }

	    if ($$self.$$.dirty &
	    /*boxes*/
	    4) {
	      $$invalidate(13, firstValue = boxes[0][1]);
	    }

	    if ($$self.$$.dirty &
	    /*boxes*/
	    4) {
	      $$invalidate(14, lastValue = boxes[boxes.length - 1][1]);
	    }

	    if ($$self.$$.dirty &
	    /*lastValue, firstValue*/
	    24576) {
	      $$invalidate(1, percentChange = (lastValue - firstValue) / firstValue);
	    }

	    if ($$self.$$.dirty &
	    /*percentChange*/
	    2) {
	      $$invalidate(3, changeFormatter = Math.abs(percentChange) < 0.1 ? format('+,.1%') : format('+,.0%'));
	    }
	  };

	  return [containerNode, percentChange, boxes, changeFormatter, showPercentChange, classicScale, columnWidth, squareScale, formatter, classicMode, env, options, chartData, firstValue, lastValue, boxHeight, maxValue, rootValues, gapWidth, containerWidth, rangeMax, largestRoot, rootSum, table_binding];
	}

	var ComparisonChart = /*#__PURE__*/function (_SvelteComponent) {
	  _inherits(ComparisonChart, _SvelteComponent);

	  var _super = _createSuper(ComparisonChart);

	  function ComparisonChart(options) {
	    var _this;

	    _classCallCheck(this, ComparisonChart);

	    _this = _super.call(this);
	    init(_assertThisInitialized(_this), options, instance$A, create_fragment$A, safe_not_equal, {
	      env: 10,
	      options: 11,
	      chartData: 12
	    }, add_css$r);
	    return _this;
	  }

	  _createClass(ComparisonChart, [{
	    key: "env",
	    get: function get() {
	      return this.$$.ctx[10];
	    },
	    set: function set(env) {
	      this.$$set({
	        env: env
	      });
	      flush();
	    }
	  }, {
	    key: "options",
	    get: function get() {
	      return this.$$.ctx[11];
	    },
	    set: function set(options) {
	      this.$$set({
	        options: options
	      });
	      flush();
	    }
	  }, {
	    key: "chartData",
	    get: function get() {
	      return this.$$.ctx[12];
	    },
	    set: function set(chartData) {
	      this.$$set({
	        chartData: chartData
	      });
	      flush();
	    }
	  }]);

	  return ComparisonChart;
	}(SvelteComponent);

	function comparisonChart(container, data, options) {
	  options = options || {};
	  var target = container.querySelector('.chart');
	  var env = {
	    el: container,
	    data: data,
	    options: options
	  };
	  makeData(data, options);
	  buildTaxonomy(data, true, options); // TODO :: update data rather than re-render

	  target.innerHTML = '';
	  var component = new ComparisonChart({
	    target: target,
	    props: {
	      env: env,
	      chartData: data,
	      options: options
	    }
	  });
	  debugEnv(env);
	  return component;
	}

	var freezing = !fails(function () {
	  return Object.isExtensible(Object.preventExtensions({}));
	});

	var internalMetadata = createCommonjsModule(function (module) {
	var defineProperty = objectDefineProperty.f;



	var METADATA = uid('meta');
	var id = 0;

	var isExtensible = Object.isExtensible || function () {
	  return true;
	};

	var setMetadata = function (it) {
	  defineProperty(it, METADATA, { value: {
	    objectID: 'O' + ++id, // object ID
	    weakData: {}          // weak collections IDs
	  } });
	};

	var fastKey = function (it, create) {
	  // return a primitive with prefix
	  if (!isObject$3(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
	  if (!has$1(it, METADATA)) {
	    // can't set metadata to uncaught frozen object
	    if (!isExtensible(it)) return 'F';
	    // not necessary to add metadata
	    if (!create) return 'E';
	    // add missing metadata
	    setMetadata(it);
	  // return object ID
	  } return it[METADATA].objectID;
	};

	var getWeakData = function (it, create) {
	  if (!has$1(it, METADATA)) {
	    // can't set metadata to uncaught frozen object
	    if (!isExtensible(it)) return true;
	    // not necessary to add metadata
	    if (!create) return false;
	    // add missing metadata
	    setMetadata(it);
	  // return the store of weak collections IDs
	  } return it[METADATA].weakData;
	};

	// add metadata on freeze-family methods calling
	var onFreeze = function (it) {
	  if (freezing && meta.REQUIRED && isExtensible(it) && !has$1(it, METADATA)) setMetadata(it);
	  return it;
	};

	var meta = module.exports = {
	  REQUIRED: false,
	  fastKey: fastKey,
	  getWeakData: getWeakData,
	  onFreeze: onFreeze
	};

	hiddenKeys$1[METADATA] = true;
	});
	internalMetadata.REQUIRED;
	internalMetadata.fastKey;
	internalMetadata.getWeakData;
	internalMetadata.onFreeze;

	var collection = function (CONSTRUCTOR_NAME, wrapper, common) {
	  var IS_MAP = CONSTRUCTOR_NAME.indexOf('Map') !== -1;
	  var IS_WEAK = CONSTRUCTOR_NAME.indexOf('Weak') !== -1;
	  var ADDER = IS_MAP ? 'set' : 'add';
	  var NativeConstructor = global_1[CONSTRUCTOR_NAME];
	  var NativePrototype = NativeConstructor && NativeConstructor.prototype;
	  var Constructor = NativeConstructor;
	  var exported = {};

	  var fixMethod = function (KEY) {
	    var nativeMethod = NativePrototype[KEY];
	    redefine(NativePrototype, KEY,
	      KEY == 'add' ? function add(value) {
	        nativeMethod.call(this, value === 0 ? 0 : value);
	        return this;
	      } : KEY == 'delete' ? function (key) {
	        return IS_WEAK && !isObject$3(key) ? false : nativeMethod.call(this, key === 0 ? 0 : key);
	      } : KEY == 'get' ? function get(key) {
	        return IS_WEAK && !isObject$3(key) ? undefined : nativeMethod.call(this, key === 0 ? 0 : key);
	      } : KEY == 'has' ? function has(key) {
	        return IS_WEAK && !isObject$3(key) ? false : nativeMethod.call(this, key === 0 ? 0 : key);
	      } : function set(key, value) {
	        nativeMethod.call(this, key === 0 ? 0 : key, value);
	        return this;
	      }
	    );
	  };

	  // eslint-disable-next-line max-len
	  if (isForced_1(CONSTRUCTOR_NAME, typeof NativeConstructor != 'function' || !(IS_WEAK || NativePrototype.forEach && !fails(function () {
	    new NativeConstructor().entries().next();
	  })))) {
	    // create collection constructor
	    Constructor = common.getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER);
	    internalMetadata.REQUIRED = true;
	  } else if (isForced_1(CONSTRUCTOR_NAME, true)) {
	    var instance = new Constructor();
	    // early implementations not supports chaining
	    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;
	    // V8 ~ Chromium 40- weak-collections throws on primitives, but should return false
	    var THROWS_ON_PRIMITIVES = fails(function () { instance.has(1); });
	    // most early implementations doesn't supports iterables, most modern - not close it correctly
	    // eslint-disable-next-line no-new
	    var ACCEPT_ITERABLES = checkCorrectnessOfIteration(function (iterable) { new NativeConstructor(iterable); });
	    // for early implementations -0 and +0 not the same
	    var BUGGY_ZERO = !IS_WEAK && fails(function () {
	      // V8 ~ Chromium 42- fails only with 5+ elements
	      var $instance = new NativeConstructor();
	      var index = 5;
	      while (index--) $instance[ADDER](index, index);
	      return !$instance.has(-0);
	    });

	    if (!ACCEPT_ITERABLES) {
	      Constructor = wrapper(function (dummy, iterable) {
	        anInstance(dummy, Constructor, CONSTRUCTOR_NAME);
	        var that = inheritIfRequired(new NativeConstructor(), dummy, Constructor);
	        if (iterable != undefined) iterate(iterable, that[ADDER], { that: that, AS_ENTRIES: IS_MAP });
	        return that;
	      });
	      Constructor.prototype = NativePrototype;
	      NativePrototype.constructor = Constructor;
	    }

	    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
	      fixMethod('delete');
	      fixMethod('has');
	      IS_MAP && fixMethod('get');
	    }

	    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);

	    // weak collections should not contains .clear method
	    if (IS_WEAK && NativePrototype.clear) delete NativePrototype.clear;
	  }

	  exported[CONSTRUCTOR_NAME] = Constructor;
	  _export({ global: true, forced: Constructor != NativeConstructor }, exported);

	  setToStringTag(Constructor, CONSTRUCTOR_NAME);

	  if (!IS_WEAK) common.setStrong(Constructor, CONSTRUCTOR_NAME, IS_MAP);

	  return Constructor;
	};

	var defineProperty$2 = objectDefineProperty.f;








	var fastKey = internalMetadata.fastKey;


	var setInternalState$1 = internalState.set;
	var internalStateGetterFor = internalState.getterFor;

	var collectionStrong = {
	  getConstructor: function (wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
	    var C = wrapper(function (that, iterable) {
	      anInstance(that, C, CONSTRUCTOR_NAME);
	      setInternalState$1(that, {
	        type: CONSTRUCTOR_NAME,
	        index: objectCreate$1(null),
	        first: undefined,
	        last: undefined,
	        size: 0
	      });
	      if (!descriptors) that.size = 0;
	      if (iterable != undefined) iterate(iterable, that[ADDER], { that: that, AS_ENTRIES: IS_MAP });
	    });

	    var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);

	    var define = function (that, key, value) {
	      var state = getInternalState(that);
	      var entry = getEntry(that, key);
	      var previous, index;
	      // change existing entry
	      if (entry) {
	        entry.value = value;
	      // create new entry
	      } else {
	        state.last = entry = {
	          index: index = fastKey(key, true),
	          key: key,
	          value: value,
	          previous: previous = state.last,
	          next: undefined,
	          removed: false
	        };
	        if (!state.first) state.first = entry;
	        if (previous) previous.next = entry;
	        if (descriptors) state.size++;
	        else that.size++;
	        // add to index
	        if (index !== 'F') state.index[index] = entry;
	      } return that;
	    };

	    var getEntry = function (that, key) {
	      var state = getInternalState(that);
	      // fast case
	      var index = fastKey(key);
	      var entry;
	      if (index !== 'F') return state.index[index];
	      // frozen object case
	      for (entry = state.first; entry; entry = entry.next) {
	        if (entry.key == key) return entry;
	      }
	    };

	    redefineAll(C.prototype, {
	      // 23.1.3.1 Map.prototype.clear()
	      // 23.2.3.2 Set.prototype.clear()
	      clear: function clear() {
	        var that = this;
	        var state = getInternalState(that);
	        var data = state.index;
	        var entry = state.first;
	        while (entry) {
	          entry.removed = true;
	          if (entry.previous) entry.previous = entry.previous.next = undefined;
	          delete data[entry.index];
	          entry = entry.next;
	        }
	        state.first = state.last = undefined;
	        if (descriptors) state.size = 0;
	        else that.size = 0;
	      },
	      // 23.1.3.3 Map.prototype.delete(key)
	      // 23.2.3.4 Set.prototype.delete(value)
	      'delete': function (key) {
	        var that = this;
	        var state = getInternalState(that);
	        var entry = getEntry(that, key);
	        if (entry) {
	          var next = entry.next;
	          var prev = entry.previous;
	          delete state.index[entry.index];
	          entry.removed = true;
	          if (prev) prev.next = next;
	          if (next) next.previous = prev;
	          if (state.first == entry) state.first = next;
	          if (state.last == entry) state.last = prev;
	          if (descriptors) state.size--;
	          else that.size--;
	        } return !!entry;
	      },
	      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
	      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
	      forEach: function forEach(callbackfn /* , that = undefined */) {
	        var state = getInternalState(this);
	        var boundFunction = functionBindContext(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
	        var entry;
	        while (entry = entry ? entry.next : state.first) {
	          boundFunction(entry.value, entry.key, this);
	          // revert to the last existing entry
	          while (entry && entry.removed) entry = entry.previous;
	        }
	      },
	      // 23.1.3.7 Map.prototype.has(key)
	      // 23.2.3.7 Set.prototype.has(value)
	      has: function has(key) {
	        return !!getEntry(this, key);
	      }
	    });

	    redefineAll(C.prototype, IS_MAP ? {
	      // 23.1.3.6 Map.prototype.get(key)
	      get: function get(key) {
	        var entry = getEntry(this, key);
	        return entry && entry.value;
	      },
	      // 23.1.3.9 Map.prototype.set(key, value)
	      set: function set(key, value) {
	        return define(this, key === 0 ? 0 : key, value);
	      }
	    } : {
	      // 23.2.3.1 Set.prototype.add(value)
	      add: function add(value) {
	        return define(this, value = value === 0 ? 0 : value, value);
	      }
	    });
	    if (descriptors) defineProperty$2(C.prototype, 'size', {
	      get: function () {
	        return getInternalState(this).size;
	      }
	    });
	    return C;
	  },
	  setStrong: function (C, CONSTRUCTOR_NAME, IS_MAP) {
	    var ITERATOR_NAME = CONSTRUCTOR_NAME + ' Iterator';
	    var getInternalCollectionState = internalStateGetterFor(CONSTRUCTOR_NAME);
	    var getInternalIteratorState = internalStateGetterFor(ITERATOR_NAME);
	    // add .keys, .values, .entries, [@@iterator]
	    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
	    defineIterator(C, CONSTRUCTOR_NAME, function (iterated, kind) {
	      setInternalState$1(this, {
	        type: ITERATOR_NAME,
	        target: iterated,
	        state: getInternalCollectionState(iterated),
	        kind: kind,
	        last: undefined
	      });
	    }, function () {
	      var state = getInternalIteratorState(this);
	      var kind = state.kind;
	      var entry = state.last;
	      // revert to the last existing entry
	      while (entry && entry.removed) entry = entry.previous;
	      // get next entry
	      if (!state.target || !(state.last = entry = entry ? entry.next : state.state.first)) {
	        // or finish the iteration
	        state.target = undefined;
	        return { value: undefined, done: true };
	      }
	      // return step by kind
	      if (kind == 'keys') return { value: entry.key, done: false };
	      if (kind == 'values') return { value: entry.value, done: false };
	      return { value: [entry.key, entry.value], done: false };
	    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

	    // add [@@species], 23.1.2.2, 23.2.2.2
	    setSpecies(CONSTRUCTOR_NAME);
	  }
	};
	collectionStrong.getConstructor;
	collectionStrong.setStrong;

	// `Set` constructor
	// https://tc39.github.io/ecma262/#sec-set-objects
	collection('Set', function (init) {
	  return function Set() { return init(this, arguments.length ? arguments[0] : undefined); };
	}, collectionStrong);

	function add_css$q(target) {
	  append_styles(target, "svelte-ohsvll", ".standard-legend.svelte-ohsvll{list-style-type:none;padding:0;margin:2px 0}li.svelte-ohsvll{display:inline-block;padding-bottom:2px;margin-right:12px}li.svelte-ohsvll:last-child{margin-right:0}.swatch.svelte-ohsvll{position:relative;top:2px;display:inline-block;width:10px;height:10px;margin-right:5px;margin-bottom:2px;border:solid 1px transparent}.swatch.circle.svelte-ohsvll{border-radius:100%}.swatch.line.svelte-ohsvll{width:16px;height:2.5px;transform:rotate(-45deg) translate(8px, -1px);-webkit-transform:rotate(-45deg) translate(8px, -1px);margin-left:-8px;margin-right:9px;margin-bottom:0}.legend.hidden .standard-legend{display:none}");
	}

	function get_each_context$a(ctx, list, i) {
	  var child_ctx = ctx.slice();
	  child_ctx[2] = list[i].type;
	  child_ctx[3] = list[i].color;
	  child_ctx[4] = list[i].stroke;
	  child_ctx[5] = list[i].dashed;
	  child_ctx[6] = list[i].text;
	  return child_ctx;
	} // (66:4) {:else}


	function create_else_block$8(ctx) {
	  var li;
	  var span0;
	  var span0_class_value;
	  var t0;
	  var span1;
	  var t1_value =
	  /*text*/
	  ctx[6] + "";
	  var t1;
	  var t2;
	  return {
	    c: function c() {
	      li = element("li");
	      span0 = element("span");
	      t0 = space();
	      span1 = element("span");
	      t1 = text(t1_value);
	      t2 = space();
	      attr(span0, "class", span0_class_value = "swatch " +
	      /*type*/
	      ctx[2] + " svelte-ohsvll");
	      set_style(span0, "background-color",
	      /*color*/
	      ctx[3]);
	      set_style(span0, "border-color",
	      /*stroke*/
	      ctx[4]);
	      attr(span1, "class", "label");
	      attr(li, "class", "svelte-ohsvll");
	    },
	    m: function m(target, anchor) {
	      insert(target, li, anchor);
	      append(li, span0);
	      append(li, t0);
	      append(li, span1);
	      append(span1, t1);
	      append(li, t2);
	    },
	    p: function p(ctx, dirty) {
	      if (dirty &
	      /*items*/
	      1 && span0_class_value !== (span0_class_value = "swatch " +
	      /*type*/
	      ctx[2] + " svelte-ohsvll")) {
	        attr(span0, "class", span0_class_value);
	      }

	      if (dirty &
	      /*items*/
	      1) {
	        set_style(span0, "background-color",
	        /*color*/
	        ctx[3]);
	      }

	      if (dirty &
	      /*items*/
	      1) {
	        set_style(span0, "border-color",
	        /*stroke*/
	        ctx[4]);
	      }

	      if (dirty &
	      /*items*/
	      1 && t1_value !== (t1_value =
	      /*text*/
	      ctx[6] + "")) set_data(t1, t1_value);
	    },
	    d: function d(detaching) {
	      if (detaching) detach(li);
	    }
	  };
	} // (58:4) {#if type === 'line'}


	function create_if_block$m(ctx) {
	  var li;
	  var span0;
	  var span0_class_value;
	  var t0;
	  var span1;
	  var t1_value =
	  /*text*/
	  ctx[6] + "";
	  var t1;
	  var t2;
	  return {
	    c: function c() {
	      li = element("li");
	      span0 = element("span");
	      t0 = space();
	      span1 = element("span");
	      t1 = text(t1_value);
	      t2 = space();
	      attr(span0, "class", span0_class_value = "swatch " +
	      /*type*/
	      ctx[2] + " svelte-ohsvll");
	      set_style(span0, "border-color",
	      /*color*/
	      ctx[3]);
	      attr(span1, "class", "label");
	      attr(li, "class", "svelte-ohsvll");
	    },
	    m: function m(target, anchor) {
	      insert(target, li, anchor);
	      append(li, span0);
	      append(li, t0);
	      append(li, span1);
	      append(span1, t1);
	      append(li, t2);
	    },
	    p: function p(ctx, dirty) {
	      if (dirty &
	      /*items*/
	      1 && span0_class_value !== (span0_class_value = "swatch " +
	      /*type*/
	      ctx[2] + " svelte-ohsvll")) {
	        attr(span0, "class", span0_class_value);
	      }

	      if (dirty &
	      /*items*/
	      1) {
	        set_style(span0, "border-color",
	        /*color*/
	        ctx[3]);
	      }

	      if (dirty &
	      /*items*/
	      1 && t1_value !== (t1_value =
	      /*text*/
	      ctx[6] + "")) set_data(t1, t1_value);
	    },
	    d: function d(detaching) {
	      if (detaching) detach(li);
	    }
	  };
	} // (57:2) {#each items as {type, color, stroke, dashed, text}}


	function create_each_block$a(ctx) {
	  var if_block_anchor;

	  function select_block_type(ctx, dirty) {
	    if (
	    /*type*/
	    ctx[2] === 'line') return create_if_block$m;
	    return create_else_block$8;
	  }

	  var current_block_type = select_block_type(ctx);
	  var if_block = current_block_type(ctx);
	  return {
	    c: function c() {
	      if_block.c();
	      if_block_anchor = empty();
	    },
	    m: function m(target, anchor) {
	      if_block.m(target, anchor);
	      insert(target, if_block_anchor, anchor);
	    },
	    p: function p(ctx, dirty) {
	      if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
	        if_block.p(ctx, dirty);
	      } else {
	        if_block.d(1);
	        if_block = current_block_type(ctx);

	        if (if_block) {
	          if_block.c();
	          if_block.m(if_block_anchor.parentNode, if_block_anchor);
	        }
	      }
	    },
	    d: function d(detaching) {
	      if_block.d(detaching);
	      if (detaching) detach(if_block_anchor);
	    }
	  };
	}

	function create_fragment$z(ctx) {
	  var ul;
	  var each_value =
	  /*items*/
	  ctx[0];
	  var each_blocks = [];

	  for (var i = 0; i < each_value.length; i += 1) {
	    each_blocks[i] = create_each_block$a(get_each_context$a(ctx, each_value, i));
	  }

	  return {
	    c: function c() {
	      ul = element("ul");

	      for (var _i = 0; _i < each_blocks.length; _i += 1) {
	        each_blocks[_i].c();
	      }

	      attr(ul, "class", "standard-legend svelte-ohsvll");
	    },
	    m: function m(target, anchor) {
	      insert(target, ul, anchor);

	      for (var _i2 = 0; _i2 < each_blocks.length; _i2 += 1) {
	        each_blocks[_i2].m(ul, null);
	      }
	    },
	    p: function p(ctx, _ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	          dirty = _ref2[0];

	      if (dirty &
	      /*items*/
	      1) {
	        each_value =
	        /*items*/
	        ctx[0];

	        var _i3;

	        for (_i3 = 0; _i3 < each_value.length; _i3 += 1) {
	          var child_ctx = get_each_context$a(ctx, each_value, _i3);

	          if (each_blocks[_i3]) {
	            each_blocks[_i3].p(child_ctx, dirty);
	          } else {
	            each_blocks[_i3] = create_each_block$a(child_ctx);

	            each_blocks[_i3].c();

	            each_blocks[_i3].m(ul, null);
	          }
	        }

	        for (; _i3 < each_blocks.length; _i3 += 1) {
	          each_blocks[_i3].d(1);
	        }

	        each_blocks.length = each_value.length;
	      }
	    },
	    i: noop,
	    o: noop,
	    d: function d(detaching) {
	      if (detaching) detach(ul);
	      destroy_each(each_blocks, detaching);
	    }
	  };
	}

	function instance$z($$self, $$props, $$invalidate) {
	  var items;
	  var _$$props$config = $$props.config,
	      config = _$$props$config === void 0 ? {} : _$$props$config;

	  $$self.$$set = function ($$props) {
	    if ('config' in $$props) $$invalidate(1, config = $$props.config);
	  };

	  $$self.$$.update = function () {
	    if ($$self.$$.dirty &
	    /*config*/
	    2) {
	      $$invalidate(0, items = config.items || []);
	    }
	  };

	  return [items, config];
	}

	var StandardLegend = /*#__PURE__*/function (_SvelteComponent) {
	  _inherits(StandardLegend, _SvelteComponent);

	  var _super = _createSuper(StandardLegend);

	  function StandardLegend(options) {
	    var _this;

	    _classCallCheck(this, StandardLegend);

	    _this = _super.call(this);
	    init(_assertThisInitialized(_this), options, instance$z, create_fragment$z, safe_not_equal, {
	      config: 1
	    }, add_css$q);
	    return _this;
	  }

	  _createClass(StandardLegend, [{
	    key: "config",
	    get: function get() {
	      return this.$$.ctx[1];
	    },
	    set: function set(config) {
	      this.$$set({
	        config: config
	      });
	      flush();
	    }
	  }]);

	  return StandardLegend;
	}(SvelteComponent);

	function add_css$p(target) {
	  append_styles(target, "svelte-1yxz4q8", "ul.svelte-1yxz4q8.svelte-1yxz4q8{display:inline-block;list-style-type:none;padding:0;margin:0}ul.svelte-1yxz4q8 li.svelte-1yxz4q8{display:inline-block;position:relative;margin-right:0}ul.svelte-1yxz4q8 .swatch.svelte-1yxz4q8,.no-data-swatch.svelte-1yxz4q8.svelte-1yxz4q8{width:40px;height:10px;margin-right:0;display:block}ul.svelte-1yxz4q8 .label.svelte-1yxz4q8,.no-data-label.svelte-1yxz4q8.svelte-1yxz4q8{white-space:nowrap;position:absolute;left:100%;top:14px;transform:translateX(-50%);font-size:14px}ul.svelte-1yxz4q8 .label.center.svelte-1yxz4q8{left:50%}ul.svelte-1yxz4q8 .label.left.svelte-1yxz4q8{left:0%}li.last-label.svelte-1yxz4q8 .label.long.svelte-1yxz4q8{transform:translateX(-8px)}.gradient-group-nodata.svelte-1yxz4q8.svelte-1yxz4q8{position:relative;display:inline-block;margin-left:38px}.no-data-swatch.svelte-1yxz4q8.svelte-1yxz4q8{border:1px solid transparent;width:10px;height:8px}.no-data-label.svelte-1yxz4q8.svelte-1yxz4q8{left:50%}.mobile.svelte-1yxz4q8 ul .swatch.svelte-1yxz4q8{width:30px}.mobile.svelte-1yxz4q8 ul .label.svelte-1yxz4q8,.mobile.svelte-1yxz4q8 .no-data-label.svelte-1yxz4q8{top:12px;font-size:12px}.mobile.svelte-1yxz4q8 .gradient-group-nodata.svelte-1yxz4q8{margin-left:22px}");
	}

	function get_each_context$9(ctx, list, i) {
	  var child_ctx = ctx.slice();
	  child_ctx[10] = list[i].color;
	  child_ctx[11] = list[i].label;
	  child_ctx[12] = list[i].align;
	  child_ctx[14] = i;
	  return child_ctx;
	} // (104:10) {#if label !== undefined}


	function create_if_block_1$f(ctx) {
	  var div;
	  var t_value =
	  /*label*/
	  ctx[11] + "";
	  var t;
	  var div_class_value;
	  return {
	    c: function c() {
	      div = element("div");
	      t = text(t_value);
	      attr(div, "class", div_class_value = "label " + (
	      /*label*/
	      ctx[11].length > 3 ? 'long' : '') + " " + (
	      /*align*/
	      ctx[12] || '') + " svelte-1yxz4q8");
	    },
	    m: function m(target, anchor) {
	      insert(target, div, anchor);
	      append(div, t);
	    },
	    p: function p(ctx, dirty) {
	      if (dirty &
	      /*items*/
	      4 && t_value !== (t_value =
	      /*label*/
	      ctx[11] + "")) set_data(t, t_value);

	      if (dirty &
	      /*items*/
	      4 && div_class_value !== (div_class_value = "label " + (
	      /*label*/
	      ctx[11].length > 3 ? 'long' : '') + " " + (
	      /*align*/
	      ctx[12] || '') + " svelte-1yxz4q8")) {
	        attr(div, "class", div_class_value);
	      }
	    },
	    d: function d(detaching) {
	      if (detaching) detach(div);
	    }
	  };
	} // (98:6) {#each items as {color, label, align}


	function create_each_block$9(ctx) {
	  var li;
	  var span;
	  var t0;
	  var t1;
	  var li_class_value;
	  var if_block =
	  /*label*/
	  ctx[11] !== undefined && create_if_block_1$f(ctx);
	  return {
	    c: function c() {
	      li = element("li");
	      span = element("span");
	      t0 = space();
	      if (if_block) if_block.c();
	      t1 = space();
	      attr(span, "class", "swatch bg svelte-1yxz4q8");
	      set_style(span, "background-color",
	      /*color*/
	      ctx[10]);
	      attr(li, "class", li_class_value = "" + (null_to_empty(
	      /*i*/
	      ctx[14] ===
	      /*items*/
	      ctx[2].length - 2 ? 'last-label' : '') + " svelte-1yxz4q8"));
	    },
	    m: function m(target, anchor) {
	      insert(target, li, anchor);
	      append(li, span);
	      append(li, t0);
	      if (if_block) if_block.m(li, null);
	      append(li, t1);
	    },
	    p: function p(ctx, dirty) {
	      if (dirty &
	      /*items*/
	      4) {
	        set_style(span, "background-color",
	        /*color*/
	        ctx[10]);
	      }

	      if (
	      /*label*/
	      ctx[11] !== undefined) {
	        if (if_block) {
	          if_block.p(ctx, dirty);
	        } else {
	          if_block = create_if_block_1$f(ctx);
	          if_block.c();
	          if_block.m(li, t1);
	        }
	      } else if (if_block) {
	        if_block.d(1);
	        if_block = null;
	      }

	      if (dirty &
	      /*items*/
	      4 && li_class_value !== (li_class_value = "" + (null_to_empty(
	      /*i*/
	      ctx[14] ===
	      /*items*/
	      ctx[2].length - 2 ? 'last-label' : '') + " svelte-1yxz4q8"))) {
	        attr(li, "class", li_class_value);
	      }
	    },
	    d: function d(detaching) {
	      if (detaching) detach(li);
	      if (if_block) if_block.d();
	    }
	  };
	} // (112:4) {#if displayNoData}


	function create_if_block$l(ctx) {
	  var div2;
	  var div0;
	  var t0;
	  var div1;
	  return {
	    c: function c() {
	      div2 = element("div");
	      div0 = element("div");
	      t0 = space();
	      div1 = element("div");
	      div1.textContent = "".concat(
	      /*noDataText*/
	      ctx[6]);
	      attr(div0, "class", "no-data-swatch svelte-1yxz4q8");
	      set_style(div0, "background-color",
	      /*noDataColor*/
	      ctx[4]);
	      set_style(div0, "border-color",
	      /*noDataStroke*/
	      ctx[5]);
	      attr(div1, "class", "no-data-label svelte-1yxz4q8");
	      attr(div2, "class", "gradient-group-nodata svelte-1yxz4q8");
	    },
	    m: function m(target, anchor) {
	      insert(target, div2, anchor);
	      append(div2, div0);
	      append(div2, t0);
	      append(div2, div1);
	    },
	    p: noop,
	    d: function d(detaching) {
	      if (detaching) detach(div2);
	    }
	  };
	}

	function create_fragment$y(ctx) {
	  var div1;
	  var div0;
	  var ul;
	  var t;
	  var div1_class_value;
	  var each_value =
	  /*items*/
	  ctx[2];
	  var each_blocks = [];

	  for (var i = 0; i < each_value.length; i += 1) {
	    each_blocks[i] = create_each_block$9(get_each_context$9(ctx, each_value, i));
	  }

	  var if_block =
	  /*displayNoData*/
	  ctx[3] && create_if_block$l(ctx);
	  return {
	    c: function c() {
	      div1 = element("div");
	      div0 = element("div");
	      ul = element("ul");

	      for (var _i = 0; _i < each_blocks.length; _i += 1) {
	        each_blocks[_i].c();
	      }

	      t = space();
	      if (if_block) if_block.c();
	      attr(ul, "class", "svelte-1yxz4q8");
	      attr(div0, "class", "wrapper");
	      attr(div1, "class", div1_class_value = "gradient-legend " + (
	      /*darkTheme*/
	      ctx[7] ? 'dark' : '') + " " + (
	      /*isMobile*/
	      ctx[0] ? 'mobile' : '') + " svelte-1yxz4q8");
	    },
	    m: function m(target, anchor) {
	      insert(target, div1, anchor);
	      append(div1, div0);
	      append(div0, ul);

	      for (var _i2 = 0; _i2 < each_blocks.length; _i2 += 1) {
	        each_blocks[_i2].m(ul, null);
	      }

	      append(div0, t);
	      if (if_block) if_block.m(div0, null);
	      /*div1_binding*/

	      ctx[9](div1);
	    },
	    p: function p(ctx, _ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	          dirty = _ref2[0];

	      if (dirty &
	      /*items, undefined*/
	      4) {
	        each_value =
	        /*items*/
	        ctx[2];

	        var _i3;

	        for (_i3 = 0; _i3 < each_value.length; _i3 += 1) {
	          var child_ctx = get_each_context$9(ctx, each_value, _i3);

	          if (each_blocks[_i3]) {
	            each_blocks[_i3].p(child_ctx, dirty);
	          } else {
	            each_blocks[_i3] = create_each_block$9(child_ctx);

	            each_blocks[_i3].c();

	            each_blocks[_i3].m(ul, null);
	          }
	        }

	        for (; _i3 < each_blocks.length; _i3 += 1) {
	          each_blocks[_i3].d(1);
	        }

	        each_blocks.length = each_value.length;
	      }

	      if (
	      /*displayNoData*/
	      ctx[3]) if_block.p(ctx, dirty);

	      if (dirty &
	      /*isMobile*/
	      1 && div1_class_value !== (div1_class_value = "gradient-legend " + (
	      /*darkTheme*/
	      ctx[7] ? 'dark' : '') + " " + (
	      /*isMobile*/
	      ctx[0] ? 'mobile' : '') + " svelte-1yxz4q8")) {
	        attr(div1, "class", div1_class_value);
	      }
	    },
	    i: noop,
	    o: noop,
	    d: function d(detaching) {
	      if (detaching) detach(div1);
	      destroy_each(each_blocks, detaching);
	      if (if_block) if_block.d();
	      /*div1_binding*/

	      ctx[9](null);
	    }
	  };
	}

	function instance$y($$self, $$props, $$invalidate) {
	  var items;
	  var _$$props$config = $$props.config,
	      config = _$$props$config === void 0 ? {} : _$$props$config;
	  var _$$props$isMobile = $$props.isMobile,
	      isMobile = _$$props$isMobile === void 0 ? false : _$$props$isMobile;
	  var _config = config,
	      _config$displayNoData = _config.displayNoData,
	      displayNoData = _config$displayNoData === void 0 ? false : _config$displayNoData,
	      _config$noDataColor = _config.noDataColor,
	      noDataColor = _config$noDataColor === void 0 ? 'transparent' : _config$noDataColor,
	      _config$noDataStroke = _config.noDataStroke,
	      noDataStroke = _config$noDataStroke === void 0 ? 'black' : _config$noDataStroke,
	      _config$noDataText = _config.noDataText,
	      noDataText = _config$noDataText === void 0 ? 'No Data' : _config$noDataText,
	      _config$darkTheme = _config.darkTheme,
	      darkTheme = _config$darkTheme === void 0 ? false : _config$darkTheme;
	  var containerNode;

	  function div1_binding($$value) {
	    binding_callbacks[$$value ? 'unshift' : 'push'](function () {
	      containerNode = $$value;
	      $$invalidate(1, containerNode);
	    });
	  }

	  $$self.$$set = function ($$props) {
	    if ('config' in $$props) $$invalidate(8, config = $$props.config);
	    if ('isMobile' in $$props) $$invalidate(0, isMobile = $$props.isMobile);
	  };

	  $$self.$$.update = function () {
	    if ($$self.$$.dirty &
	    /*config*/
	    256) {
	      $$invalidate(2, items = config.items || []);
	    }
	  };

	  return [isMobile, containerNode, items, displayNoData, noDataColor, noDataStroke, noDataText, darkTheme, config, div1_binding];
	}

	var GradientLegend = /*#__PURE__*/function (_SvelteComponent) {
	  _inherits(GradientLegend, _SvelteComponent);

	  var _super = _createSuper(GradientLegend);

	  function GradientLegend(options) {
	    var _this;

	    _classCallCheck(this, GradientLegend);

	    _this = _super.call(this);
	    init(_assertThisInitialized(_this), options, instance$y, create_fragment$y, safe_not_equal, {
	      config: 8,
	      isMobile: 0
	    }, add_css$p);
	    return _this;
	  }

	  _createClass(GradientLegend, [{
	    key: "config",
	    get: function get() {
	      return this.$$.ctx[8];
	    },
	    set: function set(config) {
	      this.$$set({
	        config: config
	      });
	      flush();
	    }
	  }, {
	    key: "isMobile",
	    get: function get() {
	      return this.$$.ctx[0];
	    },
	    set: function set(isMobile) {
	      this.$$set({
	        isMobile: isMobile
	      });
	      flush();
	    }
	  }]);

	  return GradientLegend;
	}(SvelteComponent);

	function add_css$o(target) {
	  append_styles(target, "svelte-1jfzj1y", ".scale-legend.svelte-1jfzj1y.svelte-1jfzj1y{margin:0;margin-left:2px;position:relative;z-index:1;pointer-events:none;padding:0 6px 5px 6px;border-radius:2px}.scale-legend.dark.svelte-1jfzj1y.svelte-1jfzj1y{color:#ffffff}.scale-legend.bg.svelte-1jfzj1y.svelte-1jfzj1y{background:#ffffff}.scale-legend.bg.dark.svelte-1jfzj1y.svelte-1jfzj1y{background:#000000}.scale-legend.overlap.svelte-1jfzj1y.svelte-1jfzj1y{margin-bottom:-50px}.key.svelte-1jfzj1y.svelte-1jfzj1y{position:relative;padding-top:4px;z-index:3;display:block;margin-bottom:-6px;max-width:240px}.text-item.svelte-1jfzj1y.svelte-1jfzj1y{font-size:inherit;text-anchor:middle}.key.svelte-1jfzj1y.svelte-1jfzj1y,.text-item.svelte-1jfzj1y.svelte-1jfzj1y:not(.no-shadow){text-shadow:-1px -1px 1px #ffffff,-1px -0.5px 1px #ffffff,-1px 0px 1px #ffffff,-1px 0.5px 1px #ffffff,-1px 1px 1px #ffffff,-0.5px -1px 1px #ffffff,-0.5px -0.5px 1px #ffffff,-0.5px 0px 1px #ffffff,-0.5px 0.5px 1px #ffffff,-0.5px 1px 1px #ffffff,0px -0.5px 1px #ffffff,0px -0.5px 1px #ffffff,0px 1px 1px #ffffff,0px 1px 1px #ffffff,0.5px -1px 1px #ffffff,0.5px -0.5px 1px #ffffff,0.5px 0px 1px #ffffff,0.5px 0.5px 1px #ffffff,0.5px 1px 1px #ffffff,1px -1px 1px #ffffff,1px -0.5px 1px #ffffff,1px 0px 1px #ffffff,1px 0.5px 1px #ffffff,1px 1px 1px #ffffff}.wrapper.svelte-1jfzj1y>svg.svelte-1jfzj1y{position:relative;display:block}circle.svelte-1jfzj1y.svelte-1jfzj1y,path.svelte-1jfzj1y.svelte-1jfzj1y{fill:#ffffff;stroke:black}.dark.svelte-1jfzj1y circle.svelte-1jfzj1y,.dark.svelte-1jfzj1y path.svelte-1jfzj1y{fill:#000000;stroke:#ffffff}.dark.svelte-1jfzj1y .key.svelte-1jfzj1y,.dark.svelte-1jfzj1y .text-item.svelte-1jfzj1y:not(.no-shadow){text-shadow:-1px -1px 1px #000000,-1px -0.5px 1px #000000,-1px 0px 1px #000000,-1px 0.5px 1px #000000,-1px 1px 1px #000000,-0.5px -1px 1px #000000,-0.5px -0.5px 1px #000000,-0.5px 0px 1px #000000,-0.5px 0.5px 1px #000000,-0.5px 1px 1px #000000,0px -0.5px 1px #000000,0px -0.5px 1px #000000,0px 1px 1px #000000,0px 1px 1px #000000,0.5px -1px 1px #000000,0.5px -0.5px 1px #000000,0.5px 0px 1px #000000,0.5px 0.5px 1px #000000,0.5px 1px 1px #000000,1px -1px 1px #000000,1px -0.5px 1px #000000,1px 0px 1px #000000,1px 0.5px 1px #000000,1px 1px 1px #000000}.scale-legend.right.svelte-1jfzj1y.svelte-1jfzj1y{text-align:right}.scale-legend.right.svelte-1jfzj1y .key.svelte-1jfzj1y{margin-bottom:-5px}.scale-legend.right.svelte-1jfzj1y .wrapper.svelte-1jfzj1y{display:inline-block}.legend.hidden .scale-legend{display:none}");
	}

	function get_each_context$8(ctx, list, i) {
	  var child_ctx = ctx.slice();
	  child_ctx[22] = list[i].radius;
	  child_ctx[23] = list[i].label;
	  child_ctx[25] = i;
	  return child_ctx;
	} // (165:2) {#if key}


	function create_if_block_1$e(ctx) {
	  var div;
	  return {
	    c: function c() {
	      div = element("div");
	      div.textContent = "".concat(
	      /*key*/
	      ctx[12]);
	      attr(div, "class", "key svelte-1jfzj1y");
	    },
	    m: function m(target, anchor) {
	      insert(target, div, anchor);
	    },
	    p: noop,
	    d: function d(detaching) {
	      if (detaching) detach(div);
	    }
	  };
	} // (182:10) {:else}


	function create_else_block$7(ctx) {
	  var circle;
	  var circle_r_value;
	  var circle_cy_value;
	  return {
	    c: function c() {
	      circle = svg_element("circle");
	      attr(circle, "r", circle_r_value =
	      /*radius*/
	      ctx[22]);
	      attr(circle, "cy", circle_cy_value =
	      /*radius*/
	      ctx[22] * -1);
	      attr(circle, "class", "svelte-1jfzj1y");
	    },
	    m: function m(target, anchor) {
	      insert(target, circle, anchor);
	    },
	    p: function p(ctx, dirty) {
	      if (dirty &
	      /*items*/
	      8 && circle_r_value !== (circle_r_value =
	      /*radius*/
	      ctx[22])) {
	        attr(circle, "r", circle_r_value);
	      }

	      if (dirty &
	      /*items*/
	      8 && circle_cy_value !== (circle_cy_value =
	      /*radius*/
	      ctx[22] * -1)) {
	        attr(circle, "cy", circle_cy_value);
	      }
	    },
	    d: function d(detaching) {
	      if (detaching) detach(circle);
	    }
	  };
	} // (177:10) {#if asHalfArc}


	function create_if_block$k(ctx) {
	  var path;
	  var path_d_value;
	  return {
	    c: function c() {
	      path = svg_element("path");
	      attr(path, "d", path_d_value = "\n              M -" +
	      /*radius*/
	      ctx[22] + " 0\n              A -" +
	      /*radius*/
	      ctx[22] + " -" +
	      /*radius*/
	      ctx[22] + " 0 0 1 " +
	      /*radius*/
	      ctx[22] + " 0");
	      attr(path, "class", "svelte-1jfzj1y");
	    },
	    m: function m(target, anchor) {
	      insert(target, path, anchor);
	    },
	    p: function p(ctx, dirty) {
	      if (dirty &
	      /*items*/
	      8 && path_d_value !== (path_d_value = "\n              M -" +
	      /*radius*/
	      ctx[22] + " 0\n              A -" +
	      /*radius*/
	      ctx[22] + " -" +
	      /*radius*/
	      ctx[22] + " 0 0 1 " +
	      /*radius*/
	      ctx[22] + " 0")) {
	        attr(path, "d", path_d_value);
	      }
	    },
	    d: function d(detaching) {
	      if (detaching) detach(path);
	    }
	  };
	} // (175:6) {#each items as {radius, label}


	function create_each_block$8(ctx) {
	  var g;
	  var text_1;
	  var t_value =
	  /*label*/
	  ctx[23] + "";
	  var t;
	  var text_1_y_value;

	  function select_block_type(ctx, dirty) {
	    if (
	    /*asHalfArc*/
	    ctx[5]) return create_if_block$k;
	    return create_else_block$7;
	  }

	  var current_block_type = select_block_type(ctx);
	  var if_block = current_block_type(ctx);
	  return {
	    c: function c() {
	      g = svg_element("g");
	      if_block.c();
	      text_1 = svg_element("text");
	      t = text(t_value);
	      attr(text_1, "class", "text-item " + (
	      /*disableShadow*/
	      ctx[11] ? 'no-shadow' : '') + " svelte-1jfzj1y");
	      attr(text_1, "y", text_1_y_value = "" + ((
	      /*asHalfArc*/
	      ctx[5] ? 14 : 16) + "px"));
	      set_style(g, "transform", "translate(" +
	      /*leftVal*/
	      ctx[13](
	      /*i*/
	      ctx[25]) + "px, 5px)");
	    },
	    m: function m(target, anchor) {
	      insert(target, g, anchor);
	      if_block.m(g, null);
	      append(g, text_1);
	      append(text_1, t);
	    },
	    p: function p(ctx, dirty) {
	      if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
	        if_block.p(ctx, dirty);
	      } else {
	        if_block.d(1);
	        if_block = current_block_type(ctx);

	        if (if_block) {
	          if_block.c();
	          if_block.m(g, text_1);
	        }
	      }

	      if (dirty &
	      /*items*/
	      8 && t_value !== (t_value =
	      /*label*/
	      ctx[23] + "")) set_data(t, t_value);

	      if (dirty &
	      /*asHalfArc*/
	      32 && text_1_y_value !== (text_1_y_value = "" + ((
	      /*asHalfArc*/
	      ctx[5] ? 14 : 16) + "px"))) {
	        attr(text_1, "y", text_1_y_value);
	      }
	    },
	    d: function d(detaching) {
	      if (detaching) detach(g);
	      if_block.d();
	    }
	  };
	}

	function create_fragment$x(ctx) {
	  var div1;
	  var t;
	  var div0;
	  var svg;
	  var div1_class_value;
	  var if_block =
	  /*key*/
	  ctx[12] && create_if_block_1$e(ctx);
	  var each_value =
	  /*items*/
	  ctx[3];
	  var each_blocks = [];

	  for (var i = 0; i < each_value.length; i += 1) {
	    each_blocks[i] = create_each_block$8(get_each_context$8(ctx, each_value, i));
	  }

	  return {
	    c: function c() {
	      div1 = element("div");
	      if (if_block) if_block.c();
	      t = space();
	      div0 = element("div");
	      svg = svg_element("svg");

	      for (var _i = 0; _i < each_blocks.length; _i += 1) {
	        each_blocks[_i].c();
	      }

	      attr(svg, "style",
	      /*svgStyle*/
	      ctx[7]);
	      attr(svg, "width", "100");
	      attr(svg, "height",
	      /*svgHeight*/
	      ctx[4]);
	      attr(svg, "preserveAspectRatio", "none");
	      attr(svg, "class", "svelte-1jfzj1y");
	      attr(div0, "class", "wrapper svelte-1jfzj1y");
	      attr(div1, "class", div1_class_value = "scale-legend " + (
	      /*displayWithOverlap*/
	      ctx[8] ? 'overlap' : '') + " " + (
	      /*displayWithBackground*/
	      ctx[9] ? 'bg' : '') + " " + (
	      /*asHalfArc*/
	      ctx[5] ? 'arc' : '') + " " + (
	      /*darkTheme*/
	      ctx[10] ? 'dark' : '') + " " + (
	      /*isMobile*/
	      ctx[1] ? 'mobile' : '') + " " + (
	      /*fullWidth*/
	      ctx[2] ? 'wide' : '') + " " +
	      /*position*/
	      ctx[0] + "" + " svelte-1jfzj1y");
	    },
	    m: function m(target, anchor) {
	      insert(target, div1, anchor);
	      if (if_block) if_block.m(div1, null);
	      append(div1, t);
	      append(div1, div0);
	      append(div0, svg);

	      for (var _i2 = 0; _i2 < each_blocks.length; _i2 += 1) {
	        each_blocks[_i2].m(svg, null);
	      }
	      /*div1_binding*/


	      ctx[18](div1);
	    },
	    p: function p(ctx, _ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	          dirty = _ref2[0];

	      if (
	      /*key*/
	      ctx[12]) if_block.p(ctx, dirty);

	      if (dirty &
	      /*leftVal, disableShadow, asHalfArc, items*/
	      10280) {
	        each_value =
	        /*items*/
	        ctx[3];

	        var _i3;

	        for (_i3 = 0; _i3 < each_value.length; _i3 += 1) {
	          var child_ctx = get_each_context$8(ctx, each_value, _i3);

	          if (each_blocks[_i3]) {
	            each_blocks[_i3].p(child_ctx, dirty);
	          } else {
	            each_blocks[_i3] = create_each_block$8(child_ctx);

	            each_blocks[_i3].c();

	            each_blocks[_i3].m(svg, null);
	          }
	        }

	        for (; _i3 < each_blocks.length; _i3 += 1) {
	          each_blocks[_i3].d(1);
	        }

	        each_blocks.length = each_value.length;
	      }

	      if (dirty &
	      /*svgStyle*/
	      128) {
	        attr(svg, "style",
	        /*svgStyle*/
	        ctx[7]);
	      }

	      if (dirty &
	      /*svgHeight*/
	      16) {
	        attr(svg, "height",
	        /*svgHeight*/
	        ctx[4]);
	      }

	      if (dirty &
	      /*asHalfArc, isMobile, fullWidth, position*/
	      39 && div1_class_value !== (div1_class_value = "scale-legend " + (
	      /*displayWithOverlap*/
	      ctx[8] ? 'overlap' : '') + " " + (
	      /*displayWithBackground*/
	      ctx[9] ? 'bg' : '') + " " + (
	      /*asHalfArc*/
	      ctx[5] ? 'arc' : '') + " " + (
	      /*darkTheme*/
	      ctx[10] ? 'dark' : '') + " " + (
	      /*isMobile*/
	      ctx[1] ? 'mobile' : '') + " " + (
	      /*fullWidth*/
	      ctx[2] ? 'wide' : '') + " " +
	      /*position*/
	      ctx[0] + "" + " svelte-1jfzj1y")) {
	        attr(div1, "class", div1_class_value);
	      }
	    },
	    i: noop,
	    o: noop,
	    d: function d(detaching) {
	      if (detaching) detach(div1);
	      if (if_block) if_block.d();
	      destroy_each(each_blocks, detaching);
	      /*div1_binding*/

	      ctx[18](null);
	    }
	  };
	}

	var BUBBLE_LEGEND_PAD = 7;

	function instance$x($$self, $$props, $$invalidate) {
	  var asHalfArc;
	  var items;
	  var maxRadius;
	  var svgWidth;
	  var svgHeight;
	  var minLegendHeight;
	  var svgStyle;
	  var _$$props$config = $$props.config,
	      config = _$$props$config === void 0 ? {} : _$$props$config;
	  var _$$props$position = $$props.position,
	      position = _$$props$position === void 0 ? 'bottom' : _$$props$position;
	  var isMobile = $$props.isMobile;
	  var fullWidth = $$props.fullWidth;
	  var halfArc = $$props.halfArc;
	  var _config = config,
	      _config$displayWithOv = _config.displayWithOverlap,
	      displayWithOverlap = _config$displayWithOv === void 0 ? true : _config$displayWithOv,
	      _config$displayAsHalf = _config.displayAsHalfArc,
	      displayAsHalfArc = _config$displayAsHalf === void 0 ? false : _config$displayAsHalf,
	      _config$displayWithBa = _config.displayWithBackground,
	      displayWithBackground = _config$displayWithBa === void 0 ? true : _config$displayWithBa,
	      _config$darkTheme = _config.darkTheme,
	      darkTheme = _config$darkTheme === void 0 ? false : _config$darkTheme,
	      _config$disableShadow = _config.disableShadow,
	      disableShadow = _config$disableShadow === void 0 ? false : _config$disableShadow,
	      key = _config.key;
	  var containerNode;

	  var leftVal = function leftVal(index) {
	    var leftPx = 0;
	    items.slice(0, index).forEach(function (_ref3) {
	      var radius = _ref3.radius;
	      leftPx += radius;
	    });
	    return leftPx;
	  };

	  afterUpdate(function () {
	    if (containerNode) {
	      var cumulativeLeft = 0;

	      var gNodes = _toConsumableArray(containerNode.querySelectorAll('g'));

	      var gNodeBounds = gNodes.map(function (node) {
	        return node.getBoundingClientRect();
	      });
	      gNodes.forEach(function (node, index) {
	        var boundWidth = gNodeBounds[index].width;
	        var minWidth = Math.max(leftVal(index) * 2, cumulativeLeft + boundWidth / 2);
	        node.style.transform = "translate(".concat(minWidth, "px, 5px)");
	        cumulativeLeft += boundWidth + BUBBLE_LEGEND_PAD;
	      });
	      containerNode.querySelector('svg').setAttribute('width', Math.max(svgWidth, cumulativeLeft - BUBBLE_LEGEND_PAD));
	    }
	  });

	  function div1_binding($$value) {
	    binding_callbacks[$$value ? 'unshift' : 'push'](function () {
	      containerNode = $$value;
	      $$invalidate(6, containerNode);
	    });
	  }

	  $$self.$$set = function ($$props) {
	    if ('config' in $$props) $$invalidate(14, config = $$props.config);
	    if ('position' in $$props) $$invalidate(0, position = $$props.position);
	    if ('isMobile' in $$props) $$invalidate(1, isMobile = $$props.isMobile);
	    if ('fullWidth' in $$props) $$invalidate(2, fullWidth = $$props.fullWidth);
	    if ('halfArc' in $$props) $$invalidate(15, halfArc = $$props.halfArc);
	  };

	  $$self.$$.update = function () {
	    if ($$self.$$.dirty &
	    /*halfArc*/
	    32768) {
	      $$invalidate(5, asHalfArc = halfArc || displayAsHalfArc);
	    }

	    if ($$self.$$.dirty &
	    /*config*/
	    16384) {
	      $$invalidate(3, items = config.items || []);
	    }

	    if ($$self.$$.dirty &
	    /*items*/
	    8) {
	      var _items$;

	      $$invalidate(16, maxRadius = ((_items$ = items[2]) === null || _items$ === void 0 ? void 0 : _items$.radius) || 50);
	    }

	    if ($$self.$$.dirty &
	    /*maxRadius*/
	    65536) {
	      svgWidth = maxRadius * 2.6; // TODO

	    }

	    if ($$self.$$.dirty &
	    /*asHalfArc, maxRadius*/
	    65568) {
	      $$invalidate(4, svgHeight = asHalfArc ? Math.max(maxRadius, 20) + 20 : Math.max(maxRadius, 20) * 2 + 30);
	    }

	    if ($$self.$$.dirty &
	    /*isMobile*/
	    2) {
	      $$invalidate(17, minLegendHeight = isMobile ? 16 : 25);
	    }

	    if ($$self.$$.dirty &
	    /*asHalfArc, minLegendHeight, maxRadius*/
	    196640) {
	      $$invalidate(7, svgStyle = "\n    top: ".concat(asHalfArc ? Math.max(minLegendHeight, maxRadius) : Math.max(minLegendHeight, maxRadius * 2), "px;\n  "));
	    }

	    if ($$self.$$.dirty &
	    /*svgHeight*/
	    16) ;
	  };

	  return [position, isMobile, fullWidth, items, svgHeight, asHalfArc, containerNode, svgStyle, displayWithOverlap, displayWithBackground, darkTheme, disableShadow, key, leftVal, config, halfArc, maxRadius, minLegendHeight, div1_binding];
	}

	var ScaleLegend = /*#__PURE__*/function (_SvelteComponent) {
	  _inherits(ScaleLegend, _SvelteComponent);

	  var _super = _createSuper(ScaleLegend);

	  function ScaleLegend(options) {
	    var _this;

	    _classCallCheck(this, ScaleLegend);

	    _this = _super.call(this);
	    init(_assertThisInitialized(_this), options, instance$x, create_fragment$x, safe_not_equal, {
	      config: 14,
	      position: 0,
	      isMobile: 1,
	      fullWidth: 2,
	      halfArc: 15
	    }, add_css$o);
	    return _this;
	  }

	  _createClass(ScaleLegend, [{
	    key: "config",
	    get: function get() {
	      return this.$$.ctx[14];
	    },
	    set: function set(config) {
	      this.$$set({
	        config: config
	      });
	      flush();
	    }
	  }, {
	    key: "position",
	    get: function get() {
	      return this.$$.ctx[0];
	    },
	    set: function set(position) {
	      this.$$set({
	        position: position
	      });
	      flush();
	    }
	  }, {
	    key: "isMobile",
	    get: function get() {
	      return this.$$.ctx[1];
	    },
	    set: function set(isMobile) {
	      this.$$set({
	        isMobile: isMobile
	      });
	      flush();
	    }
	  }, {
	    key: "fullWidth",
	    get: function get() {
	      return this.$$.ctx[2];
	    },
	    set: function set(fullWidth) {
	      this.$$set({
	        fullWidth: fullWidth
	      });
	      flush();
	    }
	  }, {
	    key: "halfArc",
	    get: function get() {
	      return this.$$.ctx[15];
	    },
	    set: function set(halfArc) {
	      this.$$set({
	        halfArc: halfArc
	      });
	      flush();
	    }
	  }]);

	  return ScaleLegend;
	}(SvelteComponent);

	function add_css$n(target) {
	  append_styles(target, "svelte-yaxqtr", ".split-legend.svelte-yaxqtr.svelte-yaxqtr{display:flex;flex-direction:row;justify-content:space-between;align-items:flex-start;padding-bottom:6px}.split-legend.top-bottom.svelte-yaxqtr.svelte-yaxqtr{flex-direction:column}.top-bottom.svelte-yaxqtr .legend-left.svelte-yaxqtr{padding:6px 0 9px;min-height:22px}.left-right.svelte-yaxqtr .legend-right.svelte-yaxqtr{padding-bottom:8px}.single-legend.svelte-yaxqtr.svelte-yaxqtr{display:flex;flex-direction:row;padding-top:6px}");
	} // (85:0) {:else}


	function create_else_block$6(ctx) {
	  var div;
	  var switch_instance;
	  var div_resize_listener;
	  var current;
	  var switch_value =
	  /*LegendComponent*/
	  ctx[6];

	  function switch_props(ctx) {
	    return {
	      props: {
	        config:
	        /*primaryLegend*/
	        ctx[1],
	        fullWidth:
	        /*fullWidth*/
	        ctx[7],
	        isMobile:
	        /*isMobile*/
	        ctx[8]
	      }
	    };
	  }

	  if (switch_value) {
	    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
	  }

	  return {
	    c: function c() {
	      div = element("div");
	      if (switch_instance) create_component(switch_instance.$$.fragment);
	      attr(div, "class", "single-legend svelte-yaxqtr");
	      add_render_callback(function () {
	        return (
	          /*div_elementresize_handler*/
	          ctx[12].call(div)
	        );
	      });
	    },
	    m: function m(target, anchor) {
	      insert(target, div, anchor);
	      if (switch_instance) mount_component(switch_instance, div, null);
	      div_resize_listener = add_resize_listener(div,
	      /*div_elementresize_handler*/
	      ctx[12].bind(div));
	      current = true;
	    },
	    p: function p(ctx, dirty) {
	      var switch_instance_changes = {};
	      if (dirty &
	      /*primaryLegend*/
	      2) switch_instance_changes.config =
	      /*primaryLegend*/
	      ctx[1];
	      if (dirty &
	      /*fullWidth*/
	      128) switch_instance_changes.fullWidth =
	      /*fullWidth*/
	      ctx[7];
	      if (dirty &
	      /*isMobile*/
	      256) switch_instance_changes.isMobile =
	      /*isMobile*/
	      ctx[8];

	      if (switch_value !== (switch_value =
	      /*LegendComponent*/
	      ctx[6])) {
	        if (switch_instance) {
	          group_outros();
	          var old_component = switch_instance;
	          transition_out(old_component.$$.fragment, 1, 0, function () {
	            destroy_component(old_component, 1);
	          });
	          check_outros();
	        }

	        if (switch_value) {
	          switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
	          create_component(switch_instance.$$.fragment);
	          transition_in(switch_instance.$$.fragment, 1);
	          mount_component(switch_instance, div, null);
	        } else {
	          switch_instance = null;
	        }
	      } else if (switch_value) {
	        switch_instance.$set(switch_instance_changes);
	      }
	    },
	    i: function i(local) {
	      if (current) return;
	      if (switch_instance) transition_in(switch_instance.$$.fragment, local);
	      current = true;
	    },
	    o: function o(local) {
	      if (switch_instance) transition_out(switch_instance.$$.fragment, local);
	      current = false;
	    },
	    d: function d(detaching) {
	      if (detaching) detach(div);
	      if (switch_instance) destroy_component(switch_instance);
	      div_resize_listener();
	    }
	  };
	} // (64:0) {#if isSplitLegend}


	function create_if_block$j(ctx) {
	  var div2;
	  var div0;
	  var switch_instance0;
	  var t;
	  var div1;
	  var switch_instance1;
	  var div2_class_value;
	  var div2_resize_listener;
	  var current;
	  var switch_value =
	  /*LegendComponent*/
	  ctx[6];

	  function switch_props(ctx) {
	    return {
	      props: {
	        config:
	        /*primaryLegend*/
	        ctx[1],
	        position:
	        /*layout*/
	        ctx[0] === 'left-right' ? 'left' : 'top',
	        fullWidth:
	        /*fullWidth*/
	        ctx[7],
	        isMobile:
	        /*isMobile*/
	        ctx[8]
	      }
	    };
	  }

	  if (switch_value) {
	    switch_instance0 = construct_svelte_component(switch_value, switch_props(ctx));
	  }

	  var switch_value_1 =
	  /*SecondaryLegendComponent*/
	  ctx[5];

	  function switch_props_1(ctx) {
	    return {
	      props: {
	        config:
	        /*secondaryLegend*/
	        ctx[2],
	        position:
	        /*layout*/
	        ctx[0] === 'left-right' ? 'right' : 'bottom',
	        fullWidth:
	        /*fullWidth*/
	        ctx[7],
	        isMobile:
	        /*isMobile*/
	        ctx[8]
	      }
	    };
	  }

	  if (switch_value_1) {
	    switch_instance1 = construct_svelte_component(switch_value_1, switch_props_1(ctx));
	  }

	  return {
	    c: function c() {
	      div2 = element("div");
	      div0 = element("div");
	      if (switch_instance0) create_component(switch_instance0.$$.fragment);
	      t = space();
	      div1 = element("div");
	      if (switch_instance1) create_component(switch_instance1.$$.fragment);
	      attr(div0, "class", "legend-left svelte-yaxqtr");
	      attr(div1, "class", "legend-right svelte-yaxqtr");
	      attr(div2, "class", div2_class_value = "split-legend " +
	      /*layout*/
	      ctx[0] + " svelte-yaxqtr");
	      add_render_callback(function () {
	        return (
	          /*div2_elementresize_handler*/
	          ctx[11].call(div2)
	        );
	      });
	    },
	    m: function m(target, anchor) {
	      insert(target, div2, anchor);
	      append(div2, div0);
	      if (switch_instance0) mount_component(switch_instance0, div0, null);
	      append(div2, t);
	      append(div2, div1);
	      if (switch_instance1) mount_component(switch_instance1, div1, null);
	      div2_resize_listener = add_resize_listener(div2,
	      /*div2_elementresize_handler*/
	      ctx[11].bind(div2));
	      current = true;
	    },
	    p: function p(ctx, dirty) {
	      var switch_instance0_changes = {};
	      if (dirty &
	      /*primaryLegend*/
	      2) switch_instance0_changes.config =
	      /*primaryLegend*/
	      ctx[1];
	      if (dirty &
	      /*layout*/
	      1) switch_instance0_changes.position =
	      /*layout*/
	      ctx[0] === 'left-right' ? 'left' : 'top';
	      if (dirty &
	      /*fullWidth*/
	      128) switch_instance0_changes.fullWidth =
	      /*fullWidth*/
	      ctx[7];
	      if (dirty &
	      /*isMobile*/
	      256) switch_instance0_changes.isMobile =
	      /*isMobile*/
	      ctx[8];

	      if (switch_value !== (switch_value =
	      /*LegendComponent*/
	      ctx[6])) {
	        if (switch_instance0) {
	          group_outros();
	          var old_component = switch_instance0;
	          transition_out(old_component.$$.fragment, 1, 0, function () {
	            destroy_component(old_component, 1);
	          });
	          check_outros();
	        }

	        if (switch_value) {
	          switch_instance0 = construct_svelte_component(switch_value, switch_props(ctx));
	          create_component(switch_instance0.$$.fragment);
	          transition_in(switch_instance0.$$.fragment, 1);
	          mount_component(switch_instance0, div0, null);
	        } else {
	          switch_instance0 = null;
	        }
	      } else if (switch_value) {
	        switch_instance0.$set(switch_instance0_changes);
	      }

	      var switch_instance1_changes = {};
	      if (dirty &
	      /*secondaryLegend*/
	      4) switch_instance1_changes.config =
	      /*secondaryLegend*/
	      ctx[2];
	      if (dirty &
	      /*layout*/
	      1) switch_instance1_changes.position =
	      /*layout*/
	      ctx[0] === 'left-right' ? 'right' : 'bottom';
	      if (dirty &
	      /*fullWidth*/
	      128) switch_instance1_changes.fullWidth =
	      /*fullWidth*/
	      ctx[7];
	      if (dirty &
	      /*isMobile*/
	      256) switch_instance1_changes.isMobile =
	      /*isMobile*/
	      ctx[8];

	      if (switch_value_1 !== (switch_value_1 =
	      /*SecondaryLegendComponent*/
	      ctx[5])) {
	        if (switch_instance1) {
	          group_outros();
	          var _old_component = switch_instance1;
	          transition_out(_old_component.$$.fragment, 1, 0, function () {
	            destroy_component(_old_component, 1);
	          });
	          check_outros();
	        }

	        if (switch_value_1) {
	          switch_instance1 = construct_svelte_component(switch_value_1, switch_props_1(ctx));
	          create_component(switch_instance1.$$.fragment);
	          transition_in(switch_instance1.$$.fragment, 1);
	          mount_component(switch_instance1, div1, null);
	        } else {
	          switch_instance1 = null;
	        }
	      } else if (switch_value_1) {
	        switch_instance1.$set(switch_instance1_changes);
	      }

	      if (!current || dirty &
	      /*layout*/
	      1 && div2_class_value !== (div2_class_value = "split-legend " +
	      /*layout*/
	      ctx[0] + " svelte-yaxqtr")) {
	        attr(div2, "class", div2_class_value);
	      }
	    },
	    i: function i(local) {
	      if (current) return;
	      if (switch_instance0) transition_in(switch_instance0.$$.fragment, local);
	      if (switch_instance1) transition_in(switch_instance1.$$.fragment, local);
	      current = true;
	    },
	    o: function o(local) {
	      if (switch_instance0) transition_out(switch_instance0.$$.fragment, local);
	      if (switch_instance1) transition_out(switch_instance1.$$.fragment, local);
	      current = false;
	    },
	    d: function d(detaching) {
	      if (detaching) detach(div2);
	      if (switch_instance0) destroy_component(switch_instance0);
	      if (switch_instance1) destroy_component(switch_instance1);
	      div2_resize_listener();
	    }
	  };
	}

	function create_fragment$w(ctx) {
	  var current_block_type_index;
	  var if_block;
	  var if_block_anchor;
	  var current;
	  var if_block_creators = [create_if_block$j, create_else_block$6];
	  var if_blocks = [];

	  function select_block_type(ctx, dirty) {
	    if (
	    /*isSplitLegend*/
	    ctx[4]) return 0;
	    return 1;
	  }

	  current_block_type_index = select_block_type(ctx);
	  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	  return {
	    c: function c() {
	      if_block.c();
	      if_block_anchor = empty();
	    },
	    m: function m(target, anchor) {
	      if_blocks[current_block_type_index].m(target, anchor);
	      insert(target, if_block_anchor, anchor);
	      current = true;
	    },
	    p: function p(ctx, _ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	          dirty = _ref2[0];

	      var previous_block_index = current_block_type_index;
	      current_block_type_index = select_block_type(ctx);

	      if (current_block_type_index === previous_block_index) {
	        if_blocks[current_block_type_index].p(ctx, dirty);
	      } else {
	        group_outros();
	        transition_out(if_blocks[previous_block_index], 1, 1, function () {
	          if_blocks[previous_block_index] = null;
	        });
	        check_outros();
	        if_block = if_blocks[current_block_type_index];

	        if (!if_block) {
	          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	          if_block.c();
	        } else {
	          if_block.p(ctx, dirty);
	        }

	        transition_in(if_block, 1);
	        if_block.m(if_block_anchor.parentNode, if_block_anchor);
	      }
	    },
	    i: function i(local) {
	      if (current) return;
	      transition_in(if_block);
	      current = true;
	    },
	    o: function o(local) {
	      transition_out(if_block);
	      current = false;
	    },
	    d: function d(detaching) {
	      if_blocks[current_block_type_index].d(detaching);
	      if (detaching) detach(if_block_anchor);
	    }
	  };
	}

	function instance$w($$self, $$props, $$invalidate) {
	  var isMobile;
	  var legendType;
	  var secondaryLegendType;
	  var isSplitLegend;
	  var fullWidth;
	  var LegendComponent;
	  var SecondaryLegendComponent;
	  var _$$props$layout = $$props.layout,
	      layout = _$$props$layout === void 0 ? 'left-right' : _$$props$layout; // or top-bottom

	  var primaryLegend = $$props.primaryLegend;
	  var secondaryLegend = $$props.secondaryLegend;
	  var width = 620;

	  var getComponent = function getComponent(type) {
	    return {
	      standard: StandardLegend,
	      gradient: GradientLegend,
	      scale: ScaleLegend
	    }[type];
	  };

	  function div2_elementresize_handler() {
	    width = this.clientWidth;
	    $$invalidate(3, width);
	  }

	  function div_elementresize_handler() {
	    width = this.clientWidth;
	    $$invalidate(3, width);
	  }

	  $$self.$$set = function ($$props) {
	    if ('layout' in $$props) $$invalidate(0, layout = $$props.layout);
	    if ('primaryLegend' in $$props) $$invalidate(1, primaryLegend = $$props.primaryLegend);
	    if ('secondaryLegend' in $$props) $$invalidate(2, secondaryLegend = $$props.secondaryLegend);
	  };

	  $$self.$$.update = function () {
	    if ($$self.$$.dirty &
	    /*width*/
	    8) {
	      $$invalidate(8, isMobile = isMobileWidth(width));
	    }

	    if ($$self.$$.dirty &
	    /*primaryLegend*/
	    2) {
	      var _primaryLegend;

	      $$invalidate(10, legendType = (_primaryLegend = primaryLegend) === null || _primaryLegend === void 0 ? void 0 : _primaryLegend.type);
	    }

	    if ($$self.$$.dirty &
	    /*secondaryLegend*/
	    4) {
	      var _secondaryLegend;

	      $$invalidate(9, secondaryLegendType = (_secondaryLegend = secondaryLegend) === null || _secondaryLegend === void 0 ? void 0 : _secondaryLegend.type);
	    }

	    if ($$self.$$.dirty &
	    /*secondaryLegend*/
	    4) {
	      $$invalidate(4, isSplitLegend = secondaryLegend != null);
	    }

	    if ($$self.$$.dirty &
	    /*isSplitLegend, layout*/
	    17) {
	      $$invalidate(7, fullWidth = !(isSplitLegend && layout === 'left-right'));
	    }

	    if ($$self.$$.dirty &
	    /*legendType*/
	    1024) {
	      $$invalidate(6, LegendComponent = getComponent(legendType) || StandardLegend);
	    }

	    if ($$self.$$.dirty &
	    /*secondaryLegendType*/
	    512) {
	      $$invalidate(5, SecondaryLegendComponent = getComponent(secondaryLegendType) || StandardLegend);
	    }
	  };

	  return [layout, primaryLegend, secondaryLegend, width, isSplitLegend, SecondaryLegendComponent, LegendComponent, fullWidth, isMobile, secondaryLegendType, legendType, div2_elementresize_handler, div_elementresize_handler];
	}

	var LegendContainer = /*#__PURE__*/function (_SvelteComponent) {
	  _inherits(LegendContainer, _SvelteComponent);

	  var _super = _createSuper(LegendContainer);

	  function LegendContainer(options) {
	    var _this;

	    _classCallCheck(this, LegendContainer);

	    _this = _super.call(this);
	    init(_assertThisInitialized(_this), options, instance$w, create_fragment$w, safe_not_equal, {
	      layout: 0,
	      primaryLegend: 1,
	      secondaryLegend: 2
	    }, add_css$n);
	    return _this;
	  }

	  _createClass(LegendContainer, [{
	    key: "layout",
	    get: function get() {
	      return this.$$.ctx[0];
	    },
	    set: function set(layout) {
	      this.$$set({
	        layout: layout
	      });
	      flush();
	    }
	  }, {
	    key: "primaryLegend",
	    get: function get() {
	      return this.$$.ctx[1];
	    },
	    set: function set(primaryLegend) {
	      this.$$set({
	        primaryLegend: primaryLegend
	      });
	      flush();
	    }
	  }, {
	    key: "secondaryLegend",
	    get: function get() {
	      return this.$$.ctx[2];
	    },
	    set: function set(secondaryLegend) {
	      this.$$set({
	        secondaryLegend: secondaryLegend
	      });
	      flush();
	    }
	  }]);

	  return LegendContainer;
	}(SvelteComponent);

	// constructor for Svelte legend
	// tie the presentation logic too closely to the configuration

	function configBasedLegend(target) {
	  var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	  var primaryLegend = config.primaryLegend,
	      secondaryLegend = config.secondaryLegend,
	      options = config.options;
	  return new LegendContainer({
	    target: target,
	    props: {
	      layout: 'top-bottom',
	      primaryLegend: primaryLegend,
	      secondaryLegend: secondaryLegend,
	      options: options
	    }
	  });
	}

	var $every = arrayIteration.every;



	var STRICT_METHOD = arrayMethodIsStrict('every');
	var USES_TO_LENGTH = arrayMethodUsesToLength('every');

	// `Array.prototype.every` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.every
	_export({ target: 'Array', proto: true, forced: !STRICT_METHOD || !USES_TO_LENGTH }, {
	  every: function every(callbackfn /* , thisArg */) {
	    return $every(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	// as prepareTickFormatOptions (Y-axis) in that only the last
	// item will contain all of the unit displays while the rest
	// will have a bareFormatter -- but we want to avoid different
	// units like 1M and 300K within the same set
	//
	// ideally the field you pass in has numericProperties set

	function legendValueFormatters(field, legendValues, env) {
	  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

	  var _field$options = _objectSpread2(_objectSpread2(_objectSpread2({}, field), field.numericProperties || {}), options),
	      decimals = _field$options.decimals,
	      unitBefore = _field$options.unitBefore,
	      unitAfter = _field$options.unitAfter;

	  var decimalsSpecified = decimals != null && decimals !== '';
	  var axis = mockAxis(field);
	  var formatOptions = prepareTickFormatOptions(legendValues, _objectSpread2({
	    unitBefore: unitBefore,
	    unitAfter: unitAfter,
	    forAxis: true,
	    decimalPlaces: decimalsSpecified ? decimals : undefined,
	    defaultDecimals: decimals,
	    preventCommaDisplay: true,
	    ignoreChartOptions: true,
	    // make sure old chartOptions don't override
	    voidDecimals: decimalsSpecified,
	    reductionLooseFit: true
	  }, options), axis, env); // the prepareTickFormatOptions passes back
	  // the reduced divisors used for the legend

	  var reduced = formatOptions.reduced; // now run through and apply the values back
	  // to return actual numbers for gradient etc.

	  var unitFormatter = valueFormatter(axis, env, _objectSpread2(_objectSpread2({}, formatOptions), {}, {
	    bareValue: true
	  }));
	  var numFormat = format(".".concat(unitFormatter.decimals || 1, "f"));
	  var roundedValues = legendValues.map(function (v) {
	    return v / (reduced ? reduced.divisor : 1);
	  }).map(function (v) {
	    return Number(numFormat(v));
	  }).map(function (v) {
	    return v * (reduced ? reduced.divisor : 1);
	  });
	  var units = legendValues.filter(function (v) {
	    return v !== 0;
	  }) // strip out zero
	  .map(function (v) {
	    return unitFormatter(v);
	  }).map(function (v) {
	    return String(v).replace(/[\d.-]/g, '');
	  });
	  var sameUnits = units.every(function (v) {
	    return v === units[0];
	  });
	  return {
	    roundedValues: roundedValues,
	    fullValueFormatter: valueFormatter(axis, env, formatOptions),
	    bareValueFormatter: valueFormatter(axis, env, _objectSpread2(_objectSpread2({}, formatOptions), {}, {
	      bareValue: true,
	      // all the magic is here, if all units are not the same
	      // then we show 100K 1M etc.  otherwise we strip out everything
	      // but the last value
	      preventUnitDisplay: sameUnits
	    }))
	  };
	} // Splice in Neutral zero value into gradient items

	var NUM_SCALE_TICKS = 5;
	var HALF_ARC_MIN_SIZE = 7;
	/**
	 * Generate a radius scale such that the area of the circle is proportional to "sizeField"
	 * and the radius of the circle is proportional to it's square root
	 *
	 * @param {{min: number, max: number}} sizeField Size fields with taxonomy
	 * @param {{minValue: number, maxValue: number, minRadius: number, maxRadius: number, hasMinLimit: boolean, minLimitValue: number, hasMaxLimit: boolean, maxLimitValue: number}} options Function overrides
	 * @returns Scale
	 */

	function makeRadiusScale(sizeField) {
	  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	  var customMinVal = options.minValue,
	      customMaxVal = options.maxValue,
	      customMinRadius = options.minRadius,
	      customMaxRadius = options.maxRadius,
	      hasMaxLimit = options.hasMaxLimit,
	      maxLimitValue = options.maxLimitValue;
	  var min = sizeField.min,
	      max = sizeField.max;
	  var maxRadius = customMaxRadius;
	  var minRadius = customMinRadius; // scale the min/max if it's < 0

	  var minVal = customMinVal || (min < 0 || max < 0 ? min * 100 : min);
	  var maxVal = customMaxVal || (max < 0 ? max * 100 : max); // if necessary, interpolate the minimum or maximum radius
	  // https://en.wikipedia.org/wiki/Proportional_symbol_map#Scaling_techniques

	  if (maxRadius && !minRadius) {
	    // the minimum radius is never less than 2px
	    minRadius = Math.max(maxRadius * Math.sqrt(Math.abs(minVal / maxVal)), 2);
	  } else if (minRadius && !maxRadius) {
	    // minimum value is never less than 1
	    maxRadius = minRadius * Math.sqrt(Math.abs(maxVal / Math.max(minVal, 1)));
	  } // instead of setting domain and clamping, always use 0
	  // as min, and full max and provide a custom clamping function on the
	  // output, otherwise you get a scale that is mapped to the min-max range
	  // vs 0-max range


	  var rScale = sqrt$1().domain([0, // always zero at the min
	  hasMaxLimit && +maxLimitValue || maxVal]).range([0, maxRadius]).clamp(true);

	  var customClamp = function customClamp(val) {
	    var radius = rScale(val);
	    return Math.min(maxRadius, Math.max(minRadius, radius));
	  };

	  var scaleWrapper = _extends(customClamp, rScale);

	  return scaleWrapper;
	} // this creates a list of items for the scaleLegend to render
	// this is only used the bubble map, other types will prepare their own config

	function prepareScaleLegendConfig(scaleField, chartData, radiusScale) {
	  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
	  if (!scaleField) return;
	  var _chartData$config = chartData.config,
	      bubbleLegend = _chartData$config.bubbleLegend,
	      bubbleLimits = _chartData$config.bubbleLimits,
	      radiusLegendCircleStyle = _chartData$config.radiusLegendCircleStyle,
	      scaleRadiusLimits = _chartData$config.scaleRadiusLimits,
	      scalePrecision = _chartData$config.scalePrecision,
	      scaleLegendLabel = _chartData$config.scaleLegendLabel,
	      scalePreventLegendOverlap = _chartData$config.scalePreventLegendOverlap,
	      scaleEnableLegendOverlap = _chartData$config.scaleEnableLegendOverlap;
	  var _options$displayWithB = options.displayWithBackground,
	      displayWithBackground = _options$displayWithB === void 0 ? true : _options$displayWithB,
	      _options$disableShado = options.disableShadow,
	      disableShadow = _options$disableShado === void 0 ? false : _options$disableShado,
	      displayAsHalfArc = options.displayAsHalfArc,
	      overlapByDefault = options.overlapByDefault,
	      isMobile = options.isMobile;
	  var env = {
	    data: chartData
	  };
	  var displayWithOverlap = overlapByDefault ? !scalePreventLegendOverlap : Boolean(scaleEnableLegendOverlap);
	  var key = bubbleLegend ? bubbleLegend.text : scaleLegendLabel;
	  var ticks = radiusScale.copy().nice().ticks(NUM_SCALE_TICKS); // we are not always guaranteed 5 ticks, sometimes its six

	  var radii = ticks.length === 6 ? [ticks[1], ticks[2], ticks[4]] : [ticks[1], ticks[2], ticks[3]];
	  var radiiScale = isMobile ? 0.6 : 1;
	  var circleSizes = radii.map(function (val, i) {
	    var radius = val > 0 ? radiusScale(val) * radiiScale : 0;
	    return {
	      val: val,
	      radius: radius
	    };
	  }); // transform bubble prefix / decimal / etc. properties
	  // into the field for the sizeField

	  if (bubbleLegend) {
	    var prefix = bubbleLegend.prefix,
	        postfix = bubbleLegend.postfix,
	        precision = bubbleLegend.precision,
	        isPercent = bubbleLegend.isPercent;

	    _extends(scaleField, {
	      unitBefore: prefix,
	      unitAfter: postfix,
	      precision: precision !== undefined && precision !== null ? Number(precision) : undefined,
	      displayAs: isPercent ? '%' : ''
	    });
	  } else if (scalePrecision != null) {
	    scaleField.precision = Number(scalePrecision);
	  } // we only want the units to display on the last label
	  // legend formatters returns a bare value formatter and a full formatter


	  var _legendValueFormatter = legendValueFormatters(scaleField, radii, env, {
	    decimals: scaleField.precision
	  }),
	      fullValueFormatter = _legendValueFormatter.fullValueFormatter,
	      bareValueFormatter = _legendValueFormatter.bareValueFormatter; // reserved for greater than or less than prefixes


	  var labelPrefix = ['', '', ''];
	  var labelPostfix = ['', '', '']; // if the bubble sizes are constrained, adjust the legend

	  if (bubbleLimits || scaleRadiusLimits) {
	    var limits = bubbleLimits || scaleRadiusLimits;
	    var hasMinLimit = limits.hasMinLimit,
	        hasMaxLimit = limits.hasMaxLimit,
	        minLimitValue = limits.minLimitValue,
	        maxLimitValue = limits.maxLimitValue;

	    if (hasMinLimit) {
	      circleSizes[0] = {
	        val: minLimitValue,
	        radius: radiusScale(minLimitValue) * radiiScale
	      };
	      labelPrefix[0] = 'â¤';
	    }

	    if (hasMaxLimit) {
	      circleSizes[2] = {
	        val: maxLimitValue,
	        radius: radiusScale(maxLimitValue) * radiiScale
	      };
	      labelPostfix[2] = '+';
	    }
	  } // half arc by default is only for large circles
	  // but can be set through UI or options


	  var useHalfArc = circleSizes[0].radius > HALF_ARC_MIN_SIZE;
	  if (radiusLegendCircleStyle) useHalfArc = radiusLegendCircleStyle === 'arc';
	  if (displayAsHalfArc != null) useHalfArc = displayAsHalfArc;
	  return {
	    type: 'scale',
	    displayWithOverlap: displayWithOverlap,
	    displayWithBackground: displayWithBackground,
	    disableShadow: disableShadow,
	    displayAsHalfArc: useHalfArc,
	    key: key,
	    darkTheme: isDarkTheme(chartData, options),
	    items: circleSizes.map(function (_ref, i) {
	      var val = _ref.val,
	          radius = _ref.radius;
	      var formatter = i === 2 ? fullValueFormatter : bareValueFormatter;
	      return {
	        label: "".concat(labelPrefix[i]).concat(formatter(val)).concat(labelPostfix[i]),
	        radius: radius
	      };
	    })
	  };
	}

	var log = Math.log;
	var LOG10E = Math.LOG10E;

	// `Math.log10` method
	// https://tc39.github.io/ecma262/#sec-math.log10
	_export({ target: 'Math', stat: true }, {
	  log10: function log10(x) {
	    return log(x) * LOG10E;
	  }
	});

	/**
	 * Rounds n to the nearest p
	 * @param {number} n number to round
	 * @param {number} p target number
	 * @returns {number} n rounded to the nearest p
	 */
	function roundNearest(n, p) {
	  return Math.round(n / p) * p;
	}
	/**
	 * Rounds n up to the nearest p
	 * @param {number} n number to round
	 * @param {number} p target number
	 * @returns {number} n rounded up to the nearest p
	 */

	function roundUp(n, p) {
	  return Math.ceil(n / p) * p;
	}
	/**
	 * Rounds n down to the nearest p
	 * @param {number} n number to round
	 * @param {number} p target number
	 * @returns {number} n rounded down to the nearest p
	 */

	function roundDown(n, p) {
	  return Math.floor(n / p) * p;
	}
	/**
	 * Calculates a nice round interval for a number
	 * @param {number} n number to produce a nice interval
	 * @returns {number} an interval that is a factor of 5 or 10
	 */

	function roundInterval(n) {
	  var coefficients = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [5, 10];
	  // calculate the power. not the true power but one significant digit less, e.g., for 1300 we look at 1.3 instead of 1
	  var power = Math.max(Math.floor(Math.log10(n) - 1), 0);
	  var coefficient = Math.floor(n / Math.pow(10, power)); // round the coefficient by 5, and 10

	  var rounded = coefficients.map(function (r) {
	    return roundNearest(coefficient, r) || roundUp(coefficient, r);
	  }); // choose the round number closest to the original coefficient

	  var interval = rounded.reduce(function (p, rr) {
	    return Math.abs(coefficient - p) > Math.abs(coefficient - rr) ? rr : p;
	  }, 0); // convert the interval back to n's range

	  return Math.max(interval * Math.pow(10, power), 1);
	}
	/**
	 * Used by discrete gradients, sorts a comma separate string for the legend
	 * @param {string} vals
	 * @param {string} sortString
	 */

	function sortCommaSeparatedString(vals, sortString) {
	  var order = sortString.split(',').map(function (t) {
	    return t.toUpperCase().trim();
	  });

	  var getIndex = function getIndex(v) {
	    if (!v.toUpperCase) v = v.toString();
	    var i = order.indexOf(v.toUpperCase().trim());
	    return i === -1 ? 9999 : i;
	  };

	  return vals.sort(function (a, b) {
	    return getIndex(a) - getIndex(b);
	  });
	}

	/**
	 * [Jenks natural breaks optimization](http://en.wikipedia.org/wiki/Jenks_natural_breaks_optimization)
	 *
	 * Implementations: [1](http://danieljlewis.org/files/2010/06/Jenks.pdf) (python),
	 * [2](https://github.com/vvoovv/djeo-jenks/blob/master/main.js) (buggy),
	 * [3](https://github.com/simogeo/geostats/blob/master/lib/geostats.js#L407) (works)
	 *
	 * @param {Array<number>} data values
	 * @param {number} nClasses number of breaks
	 * @returns Array<number> array of breaks
	 */
	function jenks(data, nClasses) {
	  // Compute the matrices required for Jenks breaks. These matrices
	  // can be used for any classing of data with `classes <= nClasses`
	  function getMatrices(data, nClasses) {
	    // in the original implementation, these matrices are referred to
	    // as `LC` and `OP`
	    //
	    // * lowerClassLimits (LC): optimal lower class limits
	    // * varianceCombinations (OP): optimal variance combinations for all classes
	    var lowerClassLimits = [];
	    var varianceCombinations = []; // loop counters

	    var i;
	    var j; // the variance, as computed at each step in the calculation

	    var variance = 0; // Initialize and fill each matrix with zeroes

	    for (i = 0; i < data.length + 1; i++) {
	      var tmp1 = [];
	      var tmp2 = [];

	      for (j = 0; j < nClasses + 1; j++) {
	        tmp1.push(0);
	        tmp2.push(0);
	      }

	      lowerClassLimits.push(tmp1);
	      varianceCombinations.push(tmp2);
	    }

	    for (i = 1; i < nClasses + 1; i++) {
	      lowerClassLimits[1][i] = 1;
	      varianceCombinations[1][i] = 0; // in the original implementation, 9999999 is used but
	      // since Javascript has `Infinity`, we use that.

	      for (j = 2; j < data.length + 1; j++) {
	        varianceCombinations[j][i] = Infinity;
	      }
	    }

	    for (var l = 2; l < data.length + 1; l++) {
	      // `SZ` originally. this is the sum of the values seen thus
	      // far when calculating variance.
	      var sum = 0; // `ZSQ` originally. the sum of squares of values seen
	      // thus far

	      var sumSquares = 0; // `WT` originally. This is the number of

	      var w = 0; // `IV` originally

	      var i4 = 0; // in several instances, you could say `Math.pow(x, 2)`
	      // instead of `x * x`, but this is slower in some browsers
	      // introduces an unnecessary concept.

	      for (var m = 1; m < l + 1; m++) {
	        // `III` originally
	        var lowerClassLimit = l - m + 1;
	        var val = data[lowerClassLimit - 1]; // here we're estimating variance for each potential classing
	        // of the data, for each potential number of classes. `w`
	        // is the number of data points considered so far.

	        w++; // increase the current sum and sum-of-squares

	        sum += val;
	        sumSquares += val * val; // the variance at this point in the sequence is the difference
	        // between the sum of squares and the total x 2, over the number
	        // of samples.

	        variance = sumSquares - sum * sum / w;
	        i4 = lowerClassLimit - 1;

	        if (i4 !== 0) {
	          for (j = 2; j < nClasses + 1; j++) {
	            // if adding this element to an existing class
	            // will increase its variance beyond the limit, break
	            // the class at this point, setting the lowerClassLimit
	            // at this point.
	            if (varianceCombinations[l][j] >= variance + varianceCombinations[i4][j - 1]) {
	              lowerClassLimits[l][j] = lowerClassLimit;
	              varianceCombinations[l][j] = variance + varianceCombinations[i4][j - 1];
	            }
	          }
	        }
	      }

	      lowerClassLimits[l][1] = 1;
	      varianceCombinations[l][1] = variance;
	    } // return the two matrices. for just providing breaks, only
	    // `lowerClassLimits` is needed, but variances can be useful to
	    // evaluage goodness of fit.


	    return {
	      lowerClassLimits: lowerClassLimits,
	      varianceCombinations: varianceCombinations
	    };
	  } // the second part of the jenks recipe: take the calculated matrices
	  // and derive an array of n breaks.


	  function breaks(data, lowerClassLimits, nClasses) {
	    var k = data.length - 1;
	    var kclass = [];
	    var countNum = nClasses; // the calculation of classes will never include the upper and
	    // lower bounds, so we need to explicitly set them

	    kclass[nClasses] = data[data.length - 1];
	    kclass[0] = data[0]; // the lowerClassLimits matrix is used as indexes into itself
	    // here: the `k` variable is reused in each iteration.

	    while (countNum > 1) {
	      kclass[countNum - 1] = data[lowerClassLimits[k][countNum] - 2];
	      k = lowerClassLimits[k][countNum] - 1;
	      countNum--;
	    }

	    return kclass;
	  }

	  if (nClasses > data.length) return null; // sort data in numerical order, since this is expected
	  // by the matrices function

	  data = data.slice().sort(function (a, b) {
	    return a - b;
	  }); // get our basic matrices

	  var matrices = getMatrices(data, nClasses); // we only need lower class limits here

	  var lowerClassLimits = matrices.lowerClassLimits; // extract nClasses out of the computed matrices

	  return breaks(data, lowerClassLimits, nClasses);
	}

	var QUANTILE_INDICES$1 = {
	  minmax: [0, 1],
	  median: [0, 0.5, 1],
	  quartiles: [0, 0.25, 0.5, 0.75, 1],
	  quintiles: [0, 0.2, 0.4, 0.6, 0.8, 1],
	  log: [0, 1],
	  linear: [0, 1]
	};

	function getNiceInterval(gradientStops, min, max) {
	  var interval = (max - min) / gradientStops;
	  var niceInterval = roundInterval(interval);
	  var newMin = roundDown(min, niceInterval);
	  var newMax = roundUp(max, niceInterval);
	  return {
	    interval: niceInterval,
	    min: newMin,
	    max: newMax
	  };
	}

	function intervalCount(intervalObj) {
	  var min = intervalObj.min,
	      max = intervalObj.max,
	      interval = intervalObj.interval;
	  return (max - min) / interval;
	} // crop the longer side of diverging buckets
	// by a single interval
	// count should only be 1, 2, or 3 in the worst case and if it
	// is 3 then we crop by 2 on one side and 1 on the other
	// this ensures that our color stops always matches the requested amount
	// even with nice intervals


	function cropMinMaxByInterval(intervalObj) {
	  var count = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

	  if (count > 1) {
	    if (Math.abs(intervalObj.min) >= Math.abs(intervalObj.max)) {
	      intervalObj.min += intervalObj.interval * (count - 1);
	      intervalObj.max -= intervalObj.interval;
	    } else {
	      intervalObj.max -= intervalObj.interval * (count - 1);
	      intervalObj.min += intervalObj.interval;
	    }
	  } else {
	    if (Math.abs(intervalObj.min) >= Math.abs(intervalObj.max)) {
	      intervalObj.min += intervalObj.interval * count;
	    } else {
	      intervalObj.max -= intervalObj.interval * count;
	    }
	  }
	}

	function makeStats(valFieldIndex, data, chartConfig, noScale) {
	  var inputGradientType = chartConfig.gradientType,
	      inputGradientScale = chartConfig.gradientScale,
	      inputGradientStops = chartConfig.gradientStops;
	  var _chartConfig$gradient = chartConfig.gradientPositions,
	      gradientPositions = _chartConfig$gradient === void 0 ? QUANTILE_INDICES$1.quartiles : _chartConfig$gradient; // making sure a default is set if null

	  var gradientType = inputGradientType == null ? 'continuous' : inputGradientType;
	  var gradientScale = inputGradientScale == null ? 'minmax' : inputGradientScale;
	  var gradientStops = inputGradientStops == null ? 5 : inputGradientStops; // test for multi-dimensional array

	  var sortedValues = (valFieldIndex != null && valFieldIndex < data.length && Array.isArray(data[valFieldIndex]) ? data.map(function (d) {
	    return +d[valFieldIndex];
	  }) : data).filter(function (d) {
	    return !isNaN(d);
	  }).sort(function (a, b) {
	    return a - b;
	  });
	  var isCustom = gradientScale === 'custom';
	  var colorStops = [];
	  var min = sortedValues[0] !== undefined && sortedValues[0] !== null ? sortedValues[0] : Infinity;
	  var max = sortedValues[sortedValues.length - 1];
	  var isDiverging = min < 0 && max > 0;

	  if (gradientType === 'discrete') {
	    colorStops = QUANTILE_INDICES$1.minmax.map(function (q) {
	      return d3quantile(sortedValues, q);
	    });
	  } else if (gradientScale === 'jenks') {
	    colorStops = jenks(sortedValues, gradientStops);
	  } else if (!isCustom) {
	    colorStops = QUANTILE_INDICES$1[gradientScale].map(function (q) {
	      return d3quantile(sortedValues, q);
	    });
	  }

	  var diverging = gradientScale !== 'log' && isDiverging;

	  if (isCustom) {
	    if (!gradientPositions) {
	      gradientPositions = _toConsumableArray(Array(gradientStops).keys()).map(function (n) {
	        return n / gradientStops;
	      });
	    }

	    var newGradientPositions = Array.isArray(gradientPositions) ? gradientPositions : gradientPositions.split(',');
	    colorStops = noScale ? newGradientPositions : newGradientPositions.map(function (p) {
	      return p * (max - min) + min;
	    });
	  }

	  var results = {
	    min: min,
	    max: max,
	    sortedValues: sortedValues,
	    diverging: diverging,
	    colorStops: colorStops
	  };

	  if (diverging && gradientScale !== 'jenks') {
	    var intervalObj = getNiceInterval(gradientStops, min, max); // adjust if count is over or under number of requested stops

	    if (intervalCount(intervalObj) > gradientStops) {
	      cropMinMaxByInterval(intervalObj, intervalCount(intervalObj) - gradientStops);
	    } else if (intervalCount(intervalObj) < gradientStops) {
	      // if it's under the number of stops we can't just add to max/min
	      // because there will be an unused bucket so we try the calculation
	      // again with one more stop and adjust down if needed
	      intervalObj = getNiceInterval(gradientStops + 1, min, max);

	      if (intervalCount(intervalObj) > gradientStops) {
	        cropMinMaxByInterval(intervalObj, intervalCount(intervalObj) - gradientStops);
	      }
	    }

	    var _intervalObj = intervalObj,
	        niceInterval = _intervalObj.interval,
	        newMin = _intervalObj.min,
	        newMax = _intervalObj.max; // calculate the number of left and right colors

	    var lcount = 0;
	    var rcount = 0;

	    for (var i = newMin; i < 0; i += niceInterval, lcount++) {
	    }

	    for (var _i = 0; _i < newMax; _i += niceInterval, rcount++) {
	    }

	    var divergingStops = isCustom ? colorStops : [newMin, newMax];
	    return _objectSpread2(_objectSpread2({}, results), {}, {
	      min: newMin,
	      max: newMax,
	      interval: niceInterval,
	      colorStops: divergingStops,
	      colorCount: [lcount, rcount]
	    });
	  }

	  return results;
	}

	// `Number.EPSILON` constant
	// https://tc39.github.io/ecma262/#sec-number.epsilon
	_export({ target: 'Number', stat: true }, {
	  EPSILON: Math.pow(2, -52)
	});

	var QUANTILE_INDICES = {
	  minmax: [0, 1],
	  median: [0, 0.5, 1],
	  quartiles: [0, 0.25, 0.5, 0.75, 1],
	  quintiles: [0, 0.2, 0.4, 0.6, 0.8, 1],
	  log: [0, 1],
	  linear: [0, 1]
	};
	/**
	 * Generates a d3-scale that maps a value to colors
	 * @param {{colorStops: [number], min: number, max: number}} chartStats statistics object generated by makeStats()
	 * @param {{colors: [string], neutral: string}} chartColors the mapped colors and an additional neutral colors
	 * @param {Object} chartConfig chartData object
	 * @returns {Object} a d3 scale
	 */

	function makeScale(field, chartStats, chartColors, chartData, options) {
	  var colors = chartColors.colors,
	      neutral = chartColors.neutral;
	  var colorStops = chartStats.colorStops,
	      min = chartStats.min,
	      max = chartStats.max,
	      diverging = chartStats.diverging;
	  var config = chartData.config;
	  var gradientIncludeNeutral = config.gradientIncludeNeutral,
	      gradientShowZeroAsNeutral = config.gradientShowZeroAsNeutral,
	      inputGradientScale = config.gradientScale;
	  var colorCount = colors.length;
	  var gradientScale = inputGradientScale || 'minmax'; // if it's null

	  var stops;

	  if (gradientScale === 'log') {
	    var step = log$1().domain(colorStops).range(QUANTILE_INDICES.log.map(function (q) {
	      return colorCount * q;
	    }));
	    stops = colors.map(function (c, i) {
	      return step.invert(i);
	    });
	  } else if (gradientScale === 'jenks') {
	    stops = colorStops;
	  } else if (gradientScale === 'linear') {
	    var interval = (max - min) / colorCount;
	    stops = [];

	    for (var i = 0; i <= colorCount; i++) {
	      stops.push(min + i * interval);
	    }
	  } else if (gradientScale === 'custom') {
	    // just linear interpolate the custom stops
	    stops = colorStops;
	  } else {
	    var _step = linear().range(colorStops).domain(QUANTILE_INDICES[gradientScale].map(function (q) {
	      return colorCount * q;
	    }));

	    stops = colors.map(function (_, i) {
	      return _step(i);
	    });
	  } // correct for 3 decimal places from the steps


	  stops = stops.map(function (v) {
	    return Math.round((v + Number.EPSILON) * 1000) / 1000;
	  }); // handle cases for diverging where the last tick value doesn't show
	  // we append one more value at the end which will yield 3 color values
	  // and 3 legend ticks (usually 3 colors 2 ticks)

	  if (diverging && stops[stops.length - 1] <= 0) {
	    stops.push(Math.abs(stops[stops.length - 1] - stops[stops.length - 2]));
	  } // For gradients especially we need to use the user defined
	  // rounding information to determine the actual stops used
	  // for the gradient


	  var env = {
	    data: chartData,
	    options: options
	  };

	  var _ref = field ? legendValueFormatters(field, stops.slice(1), env) : {},
	      bareValueFormatter = _ref.bareValueFormatter,
	      fullValueFormatter = _ref.fullValueFormatter,
	      roundedValues = _ref.roundedValues;

	  if (!options.preventRounding) {
	    stops = stops.slice(0, 1).concat(roundedValues);
	  }

	  var interpolateFloor = function interpolateFloor(color) {
	    var lastColor = colors[colors.length - 1];
	    var thresholdColor = colors[colors.length - 2];
	    return function (d) {
	      if (color === thresholdColor && d >= 1.0) return lastColor;
	      return color;
	    };
	  };

	  var linearScale = linear().domain(stops).range(colors).interpolate(interpolateFloor); // TODO: Cleanup, there's probably an ES6 way of doing this

	  var func = function func(x) {
	    if (+x === 0) return neutral;
	    return linearScale(x);
	  };

	  var scale = gradientShowZeroAsNeutral || gradientIncludeNeutral && gradientScale === 'discrete' ? _extends(func, linearScale) : linearScale;
	  scale.stats = chartStats;
	  return {
	    scale: scale,
	    values: stops,
	    neutral: neutral,
	    colors: colors,
	    fullValueFormatter: fullValueFormatter,
	    bareValueFormatter: bareValueFormatter
	  };
	}

	var index = function index(n) {
	  return [n];
	};

	var sequence = function sequence(n) {
	  return Array.from({
	    length: n
	  }, function (v, i) {
	    return i;
	  });
	}; // generally grey has less colors than other palettes, so to normalize the count (for offsets) we strip the extraneous colors


	var divergingColors = function divergingColors(a, b) {
	  return {
	    colors: a.slice(0, 25).concat(b),
	    neutral: a[0],
	    lhs: a,
	    rhs: b
	  };
	};

	var orderedColors = function orderedColors(colorSet) {
	  var colorOrder = ['l3', 'l2', 'l1', 'base', 'd1', 'd2', 'd3'];
	  return colorOrder.map(function (cKey) {
	    return colorSet[cKey];
	  });
	};

	var reverseOrderedColors = function reverseOrderedColors(colorSet) {
	  var colorOrder = ['d3', 'd2', 'd1', 'base', 'l1', 'l2', 'l3'];
	  return colorOrder.map(function (cKey) {
	    return colorSet[cKey];
	  });
	};

	var orderedColorsXL = function orderedColorsXL(colorSet) {
	  var colorOrder = ['l6', 'l5', 'l4', 'l3', 'l2', 'l1', 'base', 'd1', 'd2', 'd3', 'd4', 'd5', 'd6'];
	  return colorOrder.map(function (cKey) {
	    return colorSet[cKey];
	  });
	};

	var SINGLE_HUE_INDICES = {
	  1: index(3),
	  2: [1, 3],
	  3: [1, 2, 3],
	  4: [1, 2, 3, 4],
	  5: [1, 2, 3, 4, 6],
	  6: [1, 2, 3, 4, 5, 6],
	  7: [0, 1, 2, 3, 4, 5, 6]
	};
	var DARK_SINGLE_HUE_INDICES = {
	  1: index(4),
	  2: [2, 4],
	  3: [1, 4, 6],
	  4: [1, 3, 4, 6],
	  5: [1, 2, 3, 4, 6],
	  6: [0, 1, 2, 3, 4, 5],
	  7: [0, 1, 2, 3, 4, 5, 6]
	};
	var DIVERGING_INDICES = {
	  1: [6],
	  2: [1, 5],
	  3: [1, 3, 5],
	  4: [1, 2, 4, 5],
	  5: [1, 2, 3, 4, 5],
	  6: [0, 1, 2, 4, 5, 6],
	  7: [0, 1, 2, 3, 4, 5, 6]
	};
	var DIVERGING_INDICES_ALTERNATE = {
	  1: [0],
	  2: [1, 5],
	  3: [1, 3, 5],
	  4: [1, 2, 4, 5],
	  5: [1, 2, 3, 4, 5],
	  6: [0, 1, 2, 4, 5, 6],
	  7: [0, 1, 2, 3, 4, 5, 6]
	};
	var BBG_SINGLE_HUE_INDICES = {
	  1: [1],
	  2: [1, 2],
	  3: [0, 1, 2],
	  4: [3, 4, 5, 6],
	  5: [7, 8, 9, 10, 11],
	  6: [12, 13, 14, 15, 16, 17],
	  7: [18, 19, 20, 21, 22, 23, 24]
	};
	var BBG_DIVGERGING_INDICES = {
	  1: [2],
	  2: [2, 27],
	  3: [2, 0, 27],
	  4: [2, 1, 26, 27],
	  5: [2, 1, 7, 26, 27],
	  6: [6, 5, 4, 29, 30, 31],
	  7: [6, 5, 4, 7, 29, 30, 31]
	};
	var BBG_DIVGERGING_INDICES_DARK = {
	  1: [2],
	  2: [2, 27],
	  3: [2, 0, 27],
	  4: [2, 1, 26, 27],
	  5: [2, 1, 7, 26, 27],
	  6: [6, 5, 4, 29, 30, 31],
	  7: [6, 5, 4, 7, 29, 30, 31]
	};
	var BBG_DIVERGING_DYNAMIC = {
	  1: [1],
	  2: [1, 2],
	  3: [4, 5, 6],
	  4: [8, 9, 10, 11],
	  5: [13, 14, 15, 16, 17],
	  6: [19, 20, 21, 22, 23, 24],
	  7: [26, 27, 28, 29, 30, 31, 32],
	  8: [34, 35, 36, 37, 38, 39, 40, 41]
	};
	var CATEGORICAL_INDICES = {
	  1: sequence(1),
	  2: sequence(2),
	  3: sequence(3),
	  4: sequence(4),
	  5: sequence(5),
	  6: sequence(6),
	  7: sequence(7)
	};
	var POLITICS_INDICES = {
	  1: sequence(1),
	  2: sequence(2),
	  3: sequence(3),
	  4: sequence(4),
	  5: sequence(4),
	  6: sequence(4),
	  7: sequence(4)
	};
	var POLITICS_INDICES_ALT = {
	  1: index(2),
	  2: sequence(2),
	  3: sequence(3),
	  4: sequence(4),
	  5: sequence(4),
	  6: sequence(4),
	  7: sequence(4)
	}; // Storing the colors directly from the color style guide

	var baseColors = {
	  cyan: {
	    d3: '#00577f',
	    d2: '#0079b2',
	    d1: '#0094d9',
	    base: '#00aeff',
	    l1: '#44c4ff',
	    l2: '#89d9fe',
	    l3: '#cdeffe'
	  },
	  honey: {
	    d3: '#7f6200',
	    d2: '#b28900',
	    d1: '#d9a700',
	    base: '#ffc400',
	    l1: '#ffd345',
	    l2: '#ffe389',
	    l3: '#fff2ce'
	  },
	  orange: {
	    d3: '#7f3101',
	    d2: '#b24400',
	    d1: '#d95300',
	    base: '#ff6200',
	    l1: '#ff8d46',
	    l2: '#feb98d',
	    l3: '#ffe5d3'
	  },
	  black: {
	    d3: '#000000',
	    d2: '#333333',
	    d1: '#666666',
	    base: '#999999',
	    l1: '#cccccc',
	    l2: '#efefef',
	    l3: '#ffffff'
	  },
	  magenta: {
	    base: '#ff008c',
	    d2: '#b20062'
	  },
	  mint: {
	    base: '#3ef794',
	    d2: '#25a463'
	  },
	  teal: {
	    d3: '#007972',
	    d2: '#00aaa0',
	    d1: '#00cfc3',
	    base: '#00f3e5',
	    l1: '#7bf7f0',
	    l2: '#9ff9f4',
	    l3: '#cffdf9'
	  },
	  yellow: {
	    base: '#fff200'
	  },
	  white: {
	    base: '#ffffff'
	  },
	  blue: {
	    base: '#004bf8'
	  },
	  neutral: '#cecece'
	}; // dark themed colors for terminal

	var baseColorsDark = {
	  cyan: {
	    d3: '#003f5d',
	    d2: '#00577f',
	    d1: '#0079b2',
	    base: '#0094d9',
	    l1: '#00aeff',
	    l2: '#2fbdff',
	    l3: '#5fccff'
	  },
	  honey: {
	    d3: '#544100',
	    d2: '#7f6200',
	    d1: '#b28900',
	    base: '#d9a700',
	    l1: '#ffc400',
	    l2: '#ffcd2e',
	    l3: '#ffd961'
	  },
	  orange: {
	    d3: '#7f3101',
	    d2: '#b24400',
	    d1: '#d95300',
	    base: '#ff6200',
	    l1: '#ff8d46',
	    l2: '#feb98d',
	    l3: '#ffe5d3'
	  },
	  black: {
	    d3: '#000000',
	    d2: '#333333',
	    d1: '#666666',
	    base: '#999999',
	    l1: '#cccccc',
	    l2: '#efefef',
	    l3: '#ffffff'
	  },
	  neutral: '#333333'
	};
	var baseColorsBW = {
	  blue: {
	    d3: '#002a7f',
	    d2: '#003eb2',
	    d1: '#0052d9',
	    base: '#0078ff',
	    l1: '#4499ff',
	    l2: '#89baff',
	    l3: '#cddcff'
	  },
	  red: {
	    d3: '#7f0000',
	    d2: '#b20000',
	    d1: '#d90000',
	    base: '#ff0000',
	    l1: '#ff4141',
	    l2: '#ff8282',
	    l3: '#ffc3c3'
	  },
	  black: {
	    d3: '#000000',
	    d2: '#333333',
	    d1: '#666666',
	    base: '#999999',
	    l1: '#cccccc',
	    l2: '#efefef',
	    l3: '#ffffff'
	  },
	  green: {
	    base: '#008800'
	  },
	  lilac: {
	    base: '#dca0ff'
	  },
	  yellow: {
	    base: '#ffff00'
	  },
	  white: {
	    base: '#ffffff'
	  }
	};
	var baseColorsGreen = {
	  // actually green
	  green: {
	    d3: '#148714',
	    d2: '#14A014',
	    d1: '#14D21E',
	    base: '#14eb1e',
	    l1: '#48fb51',
	    l2: '#81ff87',
	    l3: '#bfffc2'
	  },
	  // actually cyan
	  cyan: {
	    d3: '#00788c',
	    d2: '#00889e',
	    d1: '#00a2bd',
	    base: '#00b4d2',
	    l1: '#00c2e2',
	    l2: '#10ccea',
	    l3: '#62dbef'
	  },
	  black: {
	    d3: '#000000',
	    d2: '#333333',
	    d1: '#666666',
	    base: '#999999',
	    l1: '#cccccc',
	    l2: '#efefef',
	    l3: '#ffffff'
	  },
	  discrete: ['#14eb1e', '#00B3D2', '#FFBB1C', '#9F502A', '#505050', '#ffbe1e', '#ffeb50', '#9b5028', '#e1a05a']
	};
	var baseColorsBNEF = {
	  blue: {
	    d3: '#005174',
	    d2: '#046A96',
	    d1: '#0984B9',
	    base: '#0D9DDB',
	    l1: '#41B5E7',
	    l2: '#76CDF3',
	    l3: '#AAE5FF'
	  },
	  purple: {
	    d3: '#3C294E',
	    d2: '#563A70',
	    d1: '#704C93',
	    base: '#8A5DB5',
	    l1: '#A67CCE',
	    l2: '#C19BE6',
	    l3: '#DDBAFF'
	  },
	  green: {
	    d3: '#037D6B',
	    d2: '#029983',
	    d1: '#01B69B',
	    base: '#00D2B3',
	    l1: '#31E1C7',
	    l2: '#62F0DB',
	    l3: '#93FFEF'
	  },
	  discrete: ['#0D9DDB', '#8A5DB5', '#00D2B3', '#ED4436', '#FFCC1D', '#EA60A7', '#4DAA50', '#aaa', '#666']
	};
	var baseColorsOP = {
	  blue: {
	    d6: '#031023',
	    d5: '#072145',
	    d4: '#0D3169',
	    d3: '#15438C',
	    d2: '#1B53AF',
	    d1: '#2264D2',
	    base: '#0072ff',
	    l1: '#2486ff',
	    l2: '#489aff',
	    l3: '#6daeff',
	    l4: '#91c2ff',
	    l5: '#b6d6ff',
	    l6: '#daeaff'
	  }
	};
	var baseColorsBBG = {
	  'bbg-mint': ['#efefef', '#a2e1b5', '#33cc7a', '#efefef', '#bde7c9', '#84daa1', '#33cc7a', '#efefef', '#cbead3', '#a2e1b5', '#70cd91', '#2db96e', '#efefef', '#d3ecd9', '#b3e5c1', '#8fd9a6', '#65c98a', '#2db96e', '#efefef', '#d1ebd7', '#afe3bd', '#8bdaa3', '#6ec88d', '#4fb677', '#28a462', '#efefef', '#d3ecd8', '#b2e5be', '#90dda5', '#71ce8e', '#59b97b', '#40a468', '#239056', '#efefef', '#d1ebd6', '#afe3ba', '#8bda9e', '#61d183', '#50bb74', '#3fa566', '#2f9057', '#1e7b49'],
	  'bbg-red': ['#efefef', '#ff999a', '#f91f4e', '#efefef', '#feb7b6', '#ff7a80', '#f91f4e', '#efefef', '#fcc5c4', '#ff999a', '#ff6973', '#f91f4e', '#efefef', '#f9cccb', '#ffaaaa', '#ff868a', '#ff5d6b', '#f91f4e', '#efefef', '#f6d0cd', '#fcb3af', '#fd9591', '#fc7574', '#f85058', '#f20d3e', '#efefef', '#f8dbda', '#fec6c4', '#ffa6a4', '#ff807f', '#f75b60', '#e93d4c', '#da0b38', '#efefef', '#f9dbda', '#fdc5c2', '#ffa7a6', '#fd7a80', '#f7425d', '#e71f4a', '#d5153e', '#c20a32'],
	  'bbg-orange': ['#efefef', '#ffac81', '#ff6200', '#efefef', '#ffc2a5', '#ff945d', '#ff6200', '#efefef', '#ffcdb7', '#ffac81', '#ff884b', '#ff6200', '#efefef', '#fcd4c2', '#ffb996', '#ff9e6b', '#ff813f', '#ff6200', '#efefef', '#fbd9c9', '#ffc2a5', '#ffac81', '#ff945d', '#ff7c38', '#ff6200', '#efefef', '#f6ded2', '#fdceb8', '#ffb58d', '#ff9658', '#fb7b2d', '#f16a1a', '#e65800', '#efefef', '#f6ddd3', '#fccdb9', '#ffba9a', '#ffa170', '#ff8944', '#f57528', '#e56417', '#d65200'],
	  'bopinion-blue': ['#efefef', '#97bcf2', '#3e87f4', '#efefef', '#b5cdf1', '#7aaaf2', '#3e87f4', '#efefef', '#c3d5f0', '#97bcf2', '#6ba1f3', '#3e87f4', '#efefef', '#c8d8f0', '#9fc0f1', '#77a8f1', '#4f90f2', '#2678f2', '#efefef', '#d0ddf2', '#aec8f2', '#8bb4f1', '#6aa0f1', '#488cf2', '#2678f2', '#efefef', '#d1dff2', '#b1cbf2', '#90b7f2', '#70a4f2', '#4f90f1', '#2e7df1', '#0e69f1', '#efefef', '#d7e3f5', '#bcd3f7', '#a0c3fa', '#83b3fc', '#629cf4', '#4386eb', '#2671e3', '#0b5eda'],
	  'bbg-cyan': ['#efefef', '#a1ccf1', '#0daaf2', '#efefef', '#bdd8f1', '#82c1f2', '#0daaf2', '#efefef', '#c9e1f5', '#9ed2fa', '#69b7f0', '#009de6', '#efefef', '#c5ddf1', '#94cbf2', '#50b8f4', '#19a2e4', '#008bcc', '#efefef', '#cce0f1', '#a6d1f2', '#76c1f3', '#23a8e6', '#1699d8', '#0081bd', '#efefef', '#d2e2f1', '#b1d5f2', '#8cc8f3', '#5cbbf4', '#21aaeb', '#1391cf', '#007ab3', '#efefef', '#dee9f1', '#cbe2f3', '#afd7f4', '#80c4f3', '#3fb0f2', '#0999db', '#0481b9', '#006999'],
	  'bbg-honey': ['#efefef', '#fce679', '#ffc400', '#efefef', '#f8e59b', '#f9d754', '#ffc400', '#efefef', '#f7e8b0', '#f7e06e', '#facf44', '#ffbb00', '#efefef', '#f6e9bd', '#f8e389', '#f8d860', '#fbc843', '#ffb624', '#efefef', '#f3e9c6', '#f4e39d', '#f2dd73', '#f5cb52', '#f9b830', '#ffa200', '#efefef', '#f3eacc', '#f4e4a9', '#f3df86', '#f3d665', '#f6c649', '#fab52b', '#ffa200', '#efefef', '#f4ebd1', '#f5e6b1', '#f5e192', '#f4dc71', '#f6cf59', '#f8c141', '#fbb227', '#ffa200'],
	  'bbg-teal': ['#efefef', '#9ee1d9', '#00cfc3', '#efefef', '#bbe6e1', '#7fdbd2', '#00cfc3', '#efefef', '#c5e8e3', '#96dfd6', '#66d3c9', '#00c7bd', '#efefef', '#cce9e5', '#a6e1da', '#7fd6cd', '#55c7bd', '#00aaa0', '#efefef', '#d1ebe8', '#afe4de', '#89dcd4', '#69cbc1', '#45b9af', '#00a89d'],
	  'bbg-grey': ['#efefef', '#c4c4c4', '#999999', '#efefef', '#d3d3d3', '#b6b6b6', '#999999', '#efefef', '#cbcbcb', '#a8a8a8', '#868686', '#666666', '#efefef', '#d3d3d3', '#b6b6b6', '#9b9b9b', '#808080', '#666666', '#efefef', '#d7d7d7', '#c0c0c0', '#a8a8a8', '#919191', '#7b7b7b', '#666666'],
	  'bbg-mint-dark': ['#333333', '#379663', '#3ef794', '#333333', '#3b7054', '#2ec273', '#3ef794', '#333333', '#3b5f4c', '#379663', '#29d87a', '#3ef794', '#333333', '#3b5547', '#3a7e5a', '#33b06d', '#2ddf80', '#3ef794', '#333333', '#3a4f44', '#3b7054', '#379663', '#2ec273', '#2fe483', '#3ef794'],
	  'bbg-red-dark': ['#333333', '#993349', '#ff335f', '#333333', '#713945', '#c6284a', '#ff335f', '#333333', '#603942', '#993349', '#df2049', '#ff335f', '#333333', '#56393f', '#813747', '#b42d4a', '#e7234d', '#ff335f', '#333333', '#4f393e', '#713945', '#993349', '#c6284a', '#eb2550', '#ff335f'],
	  'bbg-orange-dark': ['#333333', '#86592d', '#ff8000', '#333333', '#664d33', '#aa6622', '#ff8000', '#333333', '#584635', '#86592d', '#be6d1b', '#ff8000', '#333333', '#504235', '#725231', '#9b6127', '#ca7116', '#ff8000', '#333333', '#4a4035', '#664d33', '#86592d', '#aa6622', '#d27313', '#ff8000'],
	  'bopinion-blue-dark': ['#333333', '#3669a3', '#4da0ff', '#333333', '#3c5777', '#2b7ad5', '#4da0ff', '#333333', '#3c4e64', '#3669a3', '#3183e2', '#4da0ff', '#333333', '#3b4959', '#3a5e88', '#3073c0', '#3589e9', '#4da0ff', '#333333', '#3a4552', '#3c5777', '#3669a3', '#2b7ad5', '#398ded', '#4da0ff'],
	  'bbg-cyan-dark': ['#333333', '#337999', '#33beff', '#333333', '#395f71', '#2894c6', '#33beff', '#333333', '#395360', '#337999', '#20a2df', '#33beff', '#333333', '#394d56', '#376981', '#2d89b4', '#23a8e7', '#33beff', '#333333', '#39484f', '#395f71', '#337999', '#2894c6', '#25aceb', '#33beff'],
	  'bbg-honey-dark': ['#333333', '#907930', '#ffc91a', '#333333', '#6c5f36', '#b89625', '#ffc91a', '#333333', '#5c5337', '#907930', '#cfa51e', '#ffc91a', '#333333', '#534c37', '#7a6934', '#a88a2a', '#ddae19', '#ffc91a', '#333333', '#4d4837', '#6c5f36', '#907930', '#b89625', '#e6b515', '#ffc91a'],
	  'bbg-teal-dark': ['#333333', '#2b817c', '#00F3E5', '#333333', '#326360', '#21a39c', '#00F3E5', '#333333', '#335654', '#2b817c', '#1ab6ad', '#00F3E5', '#333333', '#344e4d', '#306f6b', '#25958f', '#15c1b7', '#00F3E5', '#333333', '#344948', '#326360', '#2b817c', '#21a39c', '#12c9bf', '#00F3E5'],
	  'bbg-grey-dark': ['#333333', '#919191', '#cccccc', '#333333', '#7d7d7d', '#a5a5a5', '#cccccc', '#333333', '#747474', '#919191', '#afafaf', '#cccccc', '#333333', '#868686', '#8f8f8f', '#9d9d9d', '#b4b4b4', '#cccccc', '#333333', '#6b6b6b', '#7e7e7e', '#969696', '#a6a6a6', '#b8b8b8', '#cccccc']
	};
	var baseColorBGreen = {
	  bgreen: ['#efefef', '#a1e491', '#17cf20', '#efefef', '#bde7b1', '#80d970', '#16ca1f', '#efefef', '#c4ecba', '#90e481', '#60ce54', '#14b81d', '#efefef', '#ceedc5', '#a6e798', '#7edb6f', '#55ca4a', '#14b81d', '#efefef', '#d1eec8', '#ade89f', '#85e274', '#66cb57', '#45b539', '#149f14', '#efefef', '#d0edc7', '#ace69b', '#83df6f', '#60ce4e', '#49b63b', '#319e28', '#138613', '#efefef', '#d5edcc', '#b5e8a6', '#93e280', '#6bdb57', '#57c547', '#43b036', '#2e9b25', '#138613'],
	  'bgreen-dark': ['#333333', '#347f37', '#14eb1e', '#333333', '#376239', '#2d9f32', '#14eb1e', '#333333', '#375539', '#347f37', '#28b12e', '#14eb1e', '#333333', '#374d38', '#366d39', '#309234', '#25bc2c', '#14eb1e', '#333333', '#374938', '#376239', '#347f37', '#2d9f32', '#22c32a', '#14eb1e']
	};
	var baseColorPolitics = {
	  'bbg-red': ['#efefef', '#ffa5a7', '#ff4d64', '#efefef', '#febebe', '#ff8b90', '#ff4d64', '#efefef', '#fbcbca', '#ffa5a7', '#ff7d85', '#ff4d64', '#efefef', '#fcd0cd', '#ffafab', '#ff8d8b', '#ff676c', '#ff4d64', '#efefef', '#fad5d3', '#ffbab6', '#ff9e9b', '#ff8180', '#ff5f67', '#ff334e'],
	  'bbg-blue': ['#efefef', '#aed8f8', '#4dc1ff', '#efefef', '#c5e0f5', '#94d0fa', '#4dc1ff', '#efefef', '#d0e4f4', '#aed8f8', '#85cdfc', '#4dc1ff', '#efefef', '#d5e4f3', '#b8d9f6', '#97cef9', '#71c3fc', '#4dc1ff', '#efefef', '#d9e6f3', '#c2ddf5', '#a8d3f8', '#8bcafa', '#69c1fd', '#4dc1ff'],
	  'bbg-red-dark': ['#333333', '#96464b', '#ff4d64', '#333333', '#754143', '#b84a53', '#ff4d64', '#333333', '#653e3f', '#96464b', '#ca4b57', '#ff4d64', '#333333', '#5b3c3c', '#824346', '#ab4950', '#d44c5a', '#ff4d64', '#333333', '#543b3b', '#754143', '#96464b', '#b84a53', '#db4c5b', '#ff4d64'],
	  'bbg-blue-dark': ['#333333', '#4b7692', '#4dc1ff', '#333333', '#455f71', '#4f8eb5', '#4dc1ff', '#333333', '#415361', '#4b7692', '#509bc7', '#4dc1ff', '#333333', '#3f4d57', '#48687e', '#4e84a7', '#50a2d2', '#4dc1ff', '#333333', '#3d4851', '#455f71', '#4b7692', '#4f8eb5', '#50a7da', '#4dc1ff']
	};
	var colorPalettes = {
	  singlehue: {
	    cyan: {
	      colors: orderedColors(baseColors.cyan),
	      indices: _extends({}, SINGLE_HUE_INDICES),
	      neutral: baseColors.neutral
	    },
	    honey: {
	      colors: orderedColors(baseColors.honey),
	      indices: {
	        1: [3],
	        2: [1, 3],
	        3: [1, 2, 3],
	        4: [1, 2, 3, 4],
	        5: [0, 1, 2, 3, 4],
	        6: [0, 1, 2, 3, 4, 5],
	        7: [0, 1, 2, 3, 4, 5, 6]
	      },
	      neutral: baseColors.neutral
	    },
	    teal: {
	      colors: orderedColors(baseColors.teal),
	      indices: _extends({}, SINGLE_HUE_INDICES),
	      neutral: baseColors.neutral
	    },
	    orange: {
	      colors: orderedColors(baseColors.orange),
	      indices: _extends({}, SINGLE_HUE_INDICES),
	      neutral: baseColors.neutral
	    },
	    blueBW: {
	      colors: orderedColors(baseColorsBW.blue),
	      indices: _extends({}, SINGLE_HUE_INDICES),
	      neutral: baseColors.neutral
	    },
	    red: {
	      colors: orderedColors(baseColorsBW.red),
	      indices: _extends({}, SINGLE_HUE_INDICES),
	      neutral: baseColors.neutral
	    },
	    greyscale: {
	      colors: orderedColors(baseColorsBW.black),
	      indices: _extends({}, SINGLE_HUE_INDICES),
	      neutral: baseColors.neutral
	    },
	    greenBGreen: {
	      colors: orderedColors(baseColorsGreen.green),
	      indices: _extends({}, SINGLE_HUE_INDICES),
	      neutral: baseColors.neutral
	    },
	    cyanBGreen: {
	      colors: orderedColors(baseColorsGreen.cyan),
	      indices: _extends({}, SINGLE_HUE_INDICES),
	      neutral: baseColors.neutral
	    },
	    blueBNEF: {
	      colors: orderedColors(baseColorsBNEF.blue),
	      indices: _extends({}, SINGLE_HUE_INDICES),
	      neutral: baseColors.neutral
	    },
	    purpleBNEF: {
	      colors: orderedColors(baseColorsBNEF.purple),
	      indices: _extends({}, SINGLE_HUE_INDICES),
	      neutral: baseColors.neutral
	    },
	    greenBNEF: {
	      colors: orderedColors(baseColorsBNEF.green),
	      indices: _extends({}, SINGLE_HUE_INDICES),
	      neutral: baseColors.neutral
	    },
	    blueOP: {
	      colors: orderedColorsXL(baseColorsOP.blue),
	      indices: {
	        1: [6],
	        2: [2, 6],
	        3: [2, 6, 8],
	        4: [2, 4, 6, 8],
	        5: [2, 4, 6, 8, 9],
	        6: [1, 2, 4, 6, 8, 9],
	        7: [1, 2, 4, 6, 8, 9, 10, 11]
	      },
	      neutral: baseColors.neutral
	    },
	    'bbg-cyan': {
	      colors: baseColorsBBG['bbg-cyan'],
	      indices: _extends({}, BBG_SINGLE_HUE_INDICES),
	      neutral: baseColors.neutral
	    },
	    'bbg-honey': {
	      colors: baseColorsBBG['bbg-honey'],
	      indices: _extends({}, BBG_SINGLE_HUE_INDICES),
	      neutral: baseColors.neutral
	    },
	    'bbg-orange': {
	      colors: baseColorsBBG['bbg-orange'],
	      indices: _extends({}, BBG_SINGLE_HUE_INDICES),
	      neutral: baseColors.neutral
	    },
	    'bbg-mint': {
	      colors: baseColorsBBG['bbg-mint'],
	      indices: _extends({}, BBG_SINGLE_HUE_INDICES),
	      neutral: baseColors.neutral
	    },
	    'bbg-grey': {
	      colors: baseColorsBBG['bbg-grey'],
	      indices: _extends({}, BBG_SINGLE_HUE_INDICES),
	      neutral: baseColors.neutral
	    },
	    'bbg-teal': {
	      colors: baseColorsBBG['bbg-teal'],
	      indices: _extends({}, BBG_SINGLE_HUE_INDICES),
	      neutral: baseColors.neutral
	    },
	    'bopinion-blue': {
	      colors: baseColorsBBG['bopinion-blue'],
	      indices: _extends({}, BBG_SINGLE_HUE_INDICES),
	      neutral: baseColors.neutral
	    },
	    bgreen: {
	      colors: baseColorBGreen.bgreen,
	      indices: _extends({}, BBG_SINGLE_HUE_INDICES),
	      neutral: baseColors.neutral
	    }
	  },
	  singlehueDark: {
	    cyan: {
	      colors: reverseOrderedColors(baseColorsDark.cyan),
	      indices: _extends({}, DARK_SINGLE_HUE_INDICES),
	      neutral: baseColorsDark.neutral
	    },
	    honey: {
	      colors: reverseOrderedColors(baseColorsDark.honey),
	      indices: _extends({}, DARK_SINGLE_HUE_INDICES),
	      neutral: baseColorsDark.neutral
	    },
	    greyscale: {
	      colors: reverseOrderedColors(baseColorsDark.black),
	      indices: _extends({}, DARK_SINGLE_HUE_INDICES),
	      neutral: baseColorsDark.neutral
	    },
	    orange: {
	      colors: reverseOrderedColors(baseColors.orange),
	      indices: _extends({}, DARK_SINGLE_HUE_INDICES),
	      neutral: baseColorsDark.neutral
	    },
	    teal: {
	      colors: reverseOrderedColors(baseColors.teal),
	      indices: _extends({}, DARK_SINGLE_HUE_INDICES),
	      neutral: baseColorsDark.neutral
	    },
	    citylabCyan: {
	      colors: reverseOrderedColors(baseColors.cyan),
	      indices: _extends({}, DARK_SINGLE_HUE_INDICES),
	      neutral: baseColorsDark.neutral
	    },
	    blueBNEF: {
	      colors: reverseOrderedColors(baseColorsBNEF.blue),
	      indices: _extends({}, DARK_SINGLE_HUE_INDICES),
	      neutral: baseColors.neutral
	    },
	    purpleBNEF: {
	      colors: reverseOrderedColors(baseColorsBNEF.purple),
	      indices: _extends({}, DARK_SINGLE_HUE_INDICES),
	      neutral: baseColors.neutral
	    },
	    greenBNEF: {
	      colors: reverseOrderedColors(baseColorsBNEF.green),
	      indices: _extends({}, DARK_SINGLE_HUE_INDICES),
	      neutral: baseColors.neutral
	    },
	    'bbg-cyan-dark': {
	      colors: baseColorsBBG['bbg-cyan-dark'],
	      indices: _extends({}, BBG_SINGLE_HUE_INDICES),
	      neutral: baseColorsDark.neutral
	    },
	    'bbg-honey-dark': {
	      colors: baseColorsBBG['bbg-honey-dark'],
	      indices: _extends({}, BBG_SINGLE_HUE_INDICES),
	      neutral: baseColorsDark.neutral
	    },
	    'bbg-grey-dark': {
	      colors: baseColorsBBG['bbg-grey-dark'],
	      indices: _extends({}, BBG_SINGLE_HUE_INDICES),
	      neutral: baseColorsDark.neutral
	    },
	    'bbg-orange-dark': {
	      colors: baseColorsBBG['bbg-orange-dark'],
	      indices: _extends({}, BBG_SINGLE_HUE_INDICES),
	      neutral: baseColorsDark.neutral
	    },
	    'bbg-mint-dark': {
	      colors: baseColorsBBG['bbg-mint-dark'],
	      indices: _extends({}, BBG_SINGLE_HUE_INDICES),
	      neutral: baseColorsDark.neutral
	    },
	    'bgreen-dark': {
	      colors: baseColorBGreen['bgreen-dark'],
	      indices: _extends({}, BBG_SINGLE_HUE_INDICES),
	      neutral: baseColorsDark.neutral
	    },
	    'bopinion-blue-dark': {
	      colors: baseColorsBBG['bopinion-blue-dark'],
	      indices: _extends({}, BBG_SINGLE_HUE_INDICES),
	      neutral: baseColorsDark.neutral
	    },
	    'bbg-teal-dark': {
	      colors: baseColorsBBG['bbg-teal-dark'],
	      indices: _extends({}, BBG_SINGLE_HUE_INDICES),
	      neutral: baseColorsDark.neutral
	    }
	  },
	  categorical: {
	    cyanmint: {
	      colors: [baseColors.cyan.base, baseColors.mint.base],
	      indices: {
	        1: [1],
	        2: [0, 1]
	      },
	      neutral: baseColors.neutral
	    },
	    honeymagenta: {
	      colors: [baseColors.honey.base, baseColors.magenta.base, baseColors.cyan.base, baseColors.cyan.d3, baseColors.mint.base, baseColors.mint.d2, baseColors.magenta.d2],
	      indices: _extends({}, CATEGORICAL_INDICES),
	      neutral: baseColors.neutral
	    },
	    bluegrey: {
	      colors: [baseColorsBW.blue.base, baseColorsBW.red.base, baseColorsBW.green.base, baseColorsBW.lilac.base, baseColorsBW.yellow.base, baseColorsBW.white.base, baseColorsBW.black.l1],
	      indices: _extends({}, CATEGORICAL_INDICES),
	      neutral: baseColors.neutral
	    },
	    bluehoney: {
	      colors: [baseColorsOP.blue.base, baseColors.orange.base, baseColors.honey.base, baseColorsOP.blue.d2, baseColors.mint.base, baseColors.mint.d2, baseColors.honey.d1],
	      indices: _extends({}, CATEGORICAL_INDICES),
	      neutral: baseColors.neutral
	    },
	    cyangrey: {
	      colors: ['#65c9ff', '#fe8090', '#feedb8', '#e5e5e5'],
	      indices: _extends({}, POLITICS_INDICES),
	      neutral: baseColors.neutral
	    },
	    blueredyellow: {
	      colors: [baseColorsBW.blue.base, baseColorsBW.red.base, baseColorsBW.yellow.base],
	      indices: _extends({}, POLITICS_INDICES_ALT),
	      neutral: baseColors.neutral
	    },
	    BGreen: {
	      colors: baseColorsGreen.discrete,
	      indices: _extends({}, CATEGORICAL_INDICES),
	      neutral: baseColors.neutral
	    },
	    BNEF: {
	      colors: baseColorsBNEF.discrete,
	      indices: _extends({}, CATEGORICAL_INDICES),
	      neutral: baseColors.neutral
	    },
	    citylab: {
	      colors: [baseColors.black.l1, baseColors.orange.base, baseColors.cyan.base, baseColors.orange.l1, baseColors.teal.base, baseColors.orange.l2, baseColors.cyan.l2],
	      indices: _extends({}, CATEGORICAL_INDICES),
	      neutral: baseColors.neutral
	    }
	  },
	  categoricalDark: {
	    cyanmint: {
	      colors: [baseColors.cyan.base, baseColors.mint.base],
	      indices: {
	        1: [1],
	        2: [0, 1]
	      },
	      neutral: baseColorsDark.neutral
	    },
	    honeymagenta: {
	      colors: [baseColors.honey.base, baseColors.magenta.base, baseColors.cyan.base, baseColors.cyan.d3, baseColors.mint.base, baseColors.mint.d2, baseColors.magenta.d2],
	      indices: _extends({}, CATEGORICAL_INDICES),
	      neutral: baseColorsDark.neutral
	    },
	    bluegrey: {
	      colors: [baseColorsBW.blue.base, baseColorsBW.red.base, baseColorsBW.green.base, baseColorsBW.lilac.base, baseColorsBW.yellow.base, baseColorsBW.white.base, baseColorsBW.black.l1],
	      indices: _extends({}, CATEGORICAL_INDICES),
	      neutral: baseColorsDark.neutral
	    },
	    bluehoney: {
	      colors: [baseColorsOP.blue.base, baseColors.orange.base, baseColors.honey.base, baseColorsOP.blue.d2, baseColors.mint.base, baseColors.mint.d2, baseColors.honey.d1],
	      indices: _extends({}, CATEGORICAL_INDICES),
	      neutral: baseColorsDark.neutral
	    },
	    cyangrey: {
	      colors: ['#65c9ff', '#fe8090', '#feedb8', '#e5e5e5'],
	      indices: _extends({}, POLITICS_INDICES),
	      neutral: baseColorsDark.neutral
	    },
	    blueredyellow: {
	      colors: [baseColorsBW.blue.base, baseColorsBW.red.base, baseColorsBW.yellow.base],
	      indices: _extends({}, POLITICS_INDICES_ALT),
	      neutral: baseColorsDark.neutral
	    },
	    BGreen: {
	      colors: baseColorsGreen.discrete,
	      indices: _extends({}, CATEGORICAL_INDICES),
	      neutral: baseColorsDark.neutral
	    },
	    BNEF: {
	      colors: baseColorsBNEF.discrete,
	      indices: _extends({}, CATEGORICAL_INDICES),
	      neutral: baseColorsDark.neutral
	    }
	  },
	  diverging: {
	    cyanorange: _objectSpread2(_objectSpread2({}, divergingColors(baseColorsBBG['bbg-cyan'], baseColorsBBG['bbg-orange'])), {}, {
	      indices: _extends({}, BBG_DIVGERGING_INDICES)
	    }),
	    tealorange: {
	      colors: [baseColors.teal.base, baseColors.teal.l1, baseColors.teal.l2, baseColors.neutral, baseColors.orange.l2, baseColors.orange.l1, baseColors.orange.base],
	      indices: _extends({}, DIVERGING_INDICES),
	      neutral: baseColors.neutral
	    },
	    blackorange: {
	      colors: [baseColors.black.d2, baseColors.black.d1, baseColors.black.base, baseColors.neutral, baseColors.orange.l2, baseColors.orange.l1, baseColors.orange.base],
	      indices: _extends({}, DIVERGING_INDICES_ALTERNATE),
	      neutral: baseColors.neutral
	    },
	    blackcyan: {
	      colors: [baseColors.black.d2, baseColors.black.d1, baseColors.black.base, baseColors.neutral, baseColors.cyan.l2, baseColors.cyan.l1, baseColors.cyan.base],
	      indices: _extends({}, DIVERGING_INDICES),
	      neutral: baseColors.neutral
	    },
	    blackteal: {
	      colors: [baseColors.black.d2, baseColors.black.d1, baseColors.black.base, baseColors.neutral, baseColors.teal.l2, baseColors.teal.l1, baseColors.teal.base],
	      indices: _extends({}, DIVERGING_INDICES),
	      neutral: baseColors.neutral
	    },
	    cyanred: {
	      colors: ['#65c9ff', '#ccedff', '#e5e5e5', '#ffe0e4', '#fe8090'],
	      indices: {
	        1: index(4),
	        2: sequence(2),
	        3: sequence(3),
	        4: sequence(4),
	        5: sequence(5),
	        6: sequence(6),
	        7: sequence(7)
	      },
	      neutral: baseColors.neutral
	    },
	    bluered: {
	      colors: [baseColorsBW.blue.base, baseColorsBW.blue.l1, baseColorsBW.blue.l2, baseColors.neutral, baseColorsBW.red.l2, baseColorsBW.red.l1, baseColorsBW.red.base],
	      indices: _extends({}, DIVERGING_INDICES),
	      neutral: baseColors.neutral
	    },
	    blackred: {
	      colors: [baseColorsBW.black.d2, baseColorsBW.black.d1, baseColorsBW.black.base, baseColors.neutral, baseColorsBW.red.l2, baseColorsBW.red.l1, baseColorsBW.red.base],
	      indices: _extends({}, DIVERGING_INDICES_ALTERNATE),
	      neutral: baseColors.neutral
	    },
	    blackblue: {
	      colors: [baseColorsBW.black.d2, baseColorsBW.black.d1, baseColorsBW.black.base, baseColors.neutral, baseColorsBW.blue.base, baseColorsBW.blue.l1, baseColorsBW.blue.l2],
	      indices: _extends({}, DIVERGING_INDICES),
	      neutral: baseColors.neutral
	    },
	    blueorange: _objectSpread2(_objectSpread2({}, divergingColors(baseColorsBBG['bopinion-blue'], baseColorsBBG['bbg-orange'])), {}, {
	      indices: _extends({}, BBG_DIVGERGING_INDICES_DARK)
	    }),
	    bluehoney: {
	      colors: [baseColorsOP.blue.base, baseColorsOP.blue.l2, baseColorsOP.blue.l4, baseColors.neutral, baseColors.honey.l2, baseColors.honey.l1, baseColors.honey.base],
	      indices: _extends({}, DIVERGING_INDICES),
	      neutral: baseColors.neutral
	    },
	    greenblueBGreen: {
	      colors: [baseColorsOP.blue.base, baseColorsOP.blue.l2, baseColorsOP.blue.l4, baseColors.neutral, baseColors.honey.l2, baseColors.honey.l1, baseColors.honey.base],
	      indices: _extends({}, DIVERGING_INDICES),
	      neutral: baseColors.neutral
	    },
	    greengoldBGreen: {
	      colors: [baseColorsOP.blue.base, baseColorsOP.blue.l2, baseColorsOP.blue.l4, baseColors.neutral, baseColors.honey.l2, baseColors.honey.l1, baseColors.honey.base],
	      indices: _extends({}, DIVERGING_INDICES),
	      neutral: baseColors.neutral
	    },
	    bluegreenBNEF: {
	      colors: ['#0D9DDB', '#1DB8FB', '#62D0FF', '#E5E5E5', '#93FFEF', '#62F0DB', '#00D2B3'],
	      indices: _extends({}, DIVERGING_INDICES),
	      neutral: baseColors.neutral
	    },
	    cyanhoney: _objectSpread2(_objectSpread2({}, divergingColors(baseColorsBBG['bbg-cyan'], baseColorsBBG['bbg-honey'])), {}, {
	      indices: _extends({}, BBG_DIVGERGING_INDICES)
	    }),
	    greyblue: _objectSpread2(_objectSpread2({}, divergingColors(baseColorsBBG['bbg-grey'], baseColorsBBG['bopinion-blue'])), {}, {
	      indices: _extends({}, BBG_DIVGERGING_INDICES)
	    }),
	    honeyBGreen: _objectSpread2(_objectSpread2({}, divergingColors(baseColorsBBG['bbg-honey'], baseColorBGreen.bgreen)), {}, {
	      indices: _extends({}, BBG_DIVGERGING_INDICES)
	    }),
	    cyanBGreen: _objectSpread2(_objectSpread2({}, divergingColors(baseColorsBBG['bbg-cyan'], baseColorBGreen.bgreen)), {}, {
	      indices: _extends({}, BBG_DIVGERGING_INDICES)
	    }),
	    greyBGreen: _objectSpread2(_objectSpread2({}, divergingColors(baseColorsBBG['bbg-grey'], baseColorBGreen.bgreen)), {}, {
	      indices: _extends({}, BBG_DIVGERGING_INDICES)
	    }),
	    orangeteal: _objectSpread2(_objectSpread2({}, divergingColors(baseColorsBBG['bbg-orange'], baseColorsBBG['bbg-teal'])), {}, {
	      indices: _extends({}, BBG_DIVGERGING_INDICES)
	    }),
	    cyanorangeCity: _objectSpread2(_objectSpread2({}, divergingColors(baseColorsBBG['bbg-cyan'], baseColorsBBG['bbg-orange'])), {}, {
	      indices: _extends({}, BBG_DIVGERGING_INDICES)
	    }),
	    redblue: _objectSpread2(_objectSpread2({}, divergingColors(baseColorPolitics['bbg-red'], baseColorPolitics['bbg-blue'])), {}, {
	      indices: _extends({}, BBG_DIVGERGING_INDICES)
	    })
	  },
	  divergingDark: {
	    cyanorange: _objectSpread2(_objectSpread2({}, divergingColors(baseColorsBBG['bbg-cyan-dark'], baseColorsBBG['bbg-orange-dark'])), {}, {
	      indices: _extends({}, BBG_DIVGERGING_INDICES)
	    }),
	    // duplicate of "cyanorange" but we need the consistent naming so darkThemedGradient() can find it
	    cyanorangeCity: _objectSpread2(_objectSpread2({}, divergingColors(baseColorsBBG['bbg-cyan-dark'], baseColorsBBG['bbg-orange-dark'])), {}, {
	      indices: _extends({}, BBG_DIVGERGING_INDICES)
	    }),
	    citylabCyanOrange: {
	      colors: [baseColors.cyan.base, baseColors.cyan.d1, baseColors.cyan.d2, baseColors.neutral, baseColors.orange.d2, baseColors.orange.d1, baseColors.orange.base],
	      indices: _extends({}, DIVERGING_INDICES),
	      neutral: baseColorsDark.neutral
	    },
	    tealorange: {
	      colors: [baseColors.teal.base, baseColors.teal.d1, baseColors.teal.d2, baseColors.neutral, baseColors.orange.d2, baseColors.orange.d1, baseColors.orange.base],
	      indices: _extends({}, DIVERGING_INDICES),
	      neutral: baseColorsDark.neutral
	    },
	    blackorange: {
	      colors: [baseColorsDark.black.l2, baseColorsDark.black.l1, baseColorsDark.black.base, baseColorsDark.neutral, baseColorsDark.orange.d2, baseColorsDark.orange.d1, baseColorsDark.orange.base],
	      indices: _extends({}, DIVERGING_INDICES_ALTERNATE),
	      neutral: baseColorsDark.neutral
	    },
	    blackcyan: {
	      colors: [baseColorsDark.black.l2, baseColorsDark.black.l1, baseColorsDark.black.base, baseColorsDark.neutral, baseColorsDark.cyan.d2, baseColorsDark.cyan.d1, baseColorsDark.cyan.base],
	      indices: _extends({}, DIVERGING_INDICES),
	      neutral: baseColorsDark.neutral
	    },
	    cyanred: {
	      colors: ['#2eaaec', '#327294', '#4c4c4c', '#bb4c5a', '#ff5167'],
	      indices: {
	        1: index(4),
	        2: sequence(2),
	        3: sequence(3),
	        4: sequence(4),
	        5: sequence(5),
	        6: sequence(6),
	        7: sequence(7)
	      },
	      neutral: baseColorsDark.neutral
	    },
	    cyanhoneyDark: _objectSpread2(_objectSpread2({}, divergingColors(baseColorsBBG['bbg-cyan-dark'], baseColorsBBG['bbg-honey-dark'])), {}, {
	      indices: _extends({}, BBG_DIVGERGING_INDICES_DARK)
	    }),
	    greyblueDark: _objectSpread2(_objectSpread2({}, divergingColors(baseColorsBBG['bbg-grey-dark'], baseColorsBBG['bopinion-blue-dark'])), {}, {
	      indices: _extends({}, BBG_DIVGERGING_INDICES_DARK)
	    }),
	    honeyBGreenDark: _objectSpread2(_objectSpread2({}, divergingColors(baseColorsBBG['bbg-honey-dark'], baseColorBGreen['bgreen-dark'])), {}, {
	      indices: _extends({}, BBG_DIVGERGING_INDICES_DARK)
	    }),
	    cyanBGreenDark: _objectSpread2(_objectSpread2({}, divergingColors(baseColorsBBG['bbg-cyan-dark'], baseColorBGreen['bgreen-dark'])), {}, {
	      indices: _extends({}, BBG_DIVGERGING_INDICES_DARK)
	    }),
	    greyBGreenDark: _objectSpread2(_objectSpread2({}, divergingColors(baseColorsBBG['bbg-grey-dark'], baseColorBGreen['bgreen-dark'])), {}, {
	      indices: _extends({}, BBG_DIVGERGING_INDICES_DARK)
	    }),
	    bluegreenBNEF: {
	      colors: ['#0D9DDB', '#0984B9', '#046A96', '#3B3B3B', '#029983', '#01B69B', '#00D2B3'],
	      indices: _extends({}, DIVERGING_INDICES),
	      neutral: baseColors.neutral
	    },
	    orangecyanDark: _objectSpread2(_objectSpread2({}, divergingColors(baseColorsBBG['bbg-orange-dark'], baseColorsBBG['bbg-cyan-dark'])), {}, {
	      indices: _extends({}, BBG_DIVGERGING_INDICES_DARK)
	    }),
	    orangetealDark: _objectSpread2(_objectSpread2({}, divergingColors(baseColorsBBG['bbg-orange-dark'], baseColorsBBG['bbg-teal-dark'])), {}, {
	      indices: _extends({}, BBG_DIVGERGING_INDICES_DARK)
	    }),
	    redblue: _objectSpread2(_objectSpread2({}, divergingColors(baseColorPolitics['bbg-red-dark'], baseColorPolitics['bbg-blue-dark'])), {}, {
	      indices: _extends({}, BBG_DIVGERGING_INDICES_DARK)
	    }),
	    blueorange: _objectSpread2(_objectSpread2({}, divergingColors(baseColorsBBG['bopinion-blue-dark'], baseColorsBBG['bbg-orange-dark'])), {}, {
	      indices: _extends({}, BBG_DIVGERGING_INDICES_DARK)
	    })
	  }
	};
	function findColorPalette(palette) {
	  var colorPalette = colorPalettes;
	  var frags = palette.split('.');

	  while (frags.length) {
	    var frag = frags.shift();
	    colorPalette = colorPalette[frag];
	  }

	  return colorPalette;
	}
	/**
	 * Given a palette and number of stops, returns the colors
	 * @param {string} palette palette name, .e.g, singlehue.cyan
	 * @param {number} stops number of color stops to produce
	 * @param {boolean} reverse reverse the colors
	 * @param {{diverging: boolean, colorCount: [rcount: number, lcount: number]}} stats an stats array necessary to generate diverging colors
	 * @returns {{colors: [string], neutral: string}} an array of hex colors + the neutral color
	 */

	function reduceColors(palette, stops) {
	  var includeNeutral = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
	  var reverse = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
	  var stats = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};
	  var paletteStops = stops || 5;
	  var diverging = stats.diverging,
	      colorCount = stats.colorCount,
	      colorStops = stats.colorStops;

	  var _findColorPalette = findColorPalette(palette),
	      colors = _findColorPalette.colors,
	      indices = _findColorPalette.indices,
	      neutral = _findColorPalette.neutral,
	      rhs = _findColorPalette.rhs,
	      lhs = _findColorPalette.lhs;

	  var colorIndices = indices[Number(paletteStops)] || indices[7];
	  if (!colorIndices) return null;

	  function mapNormal() {
	    if (includeNeutral) {
	      return [neutral].concat(colorIndices.map(function (i) {
	        return colors[i];
	      }).slice(0, colorIndices.length - 1));
	    }

	    return colorIndices.map(function (i) {
	      return colors[i];
	    });
	  }

	  function mapDiverging() {
	    // get the number of colors left of 0 (lcount) and to the right of it (rcount)
	    var lcount;
	    var rcount;

	    if (colorCount) {

	      var _colorCount = _slicedToArray(colorCount, 2);

	      lcount = _colorCount[0];
	      rcount = _colorCount[1];
	    } else {
	      lcount = colorStops.filter(function (v) {
	        return v < 0;
	      }).length;
	      rcount = colorStops.filter(function (v) {
	        return v >= 0;
	      }).length - 1;
	    } // choose the max count so the hue matches on both the left and right side


	    var maxCount = Math.max(lcount, rcount); // generate palette indices for the left and right side, taking reverse into account

	    var lindices = Array.from({
	      length: lcount
	    }, function (_, i) {
	      return BBG_DIVERGING_DYNAMIC[maxCount][i];
	    });
	    var rindices = Array.from({
	      length: rcount
	    }, function (_, i) {
	      return BBG_DIVERGING_DYNAMIC[maxCount][i];
	    });
	    var lpal = reverse ? rhs : lhs;
	    var rpal = reverse ? lhs : rhs; // concatenate the palettes

	    if (includeNeutral) {
	      return [].concat(_toConsumableArray(lindices.map(function (_, i) {
	        return lpal[lindices[i]];
	      }).reverse()), [neutral], _toConsumableArray(rindices.map(function (_, i) {
	        return rpal[rindices[i]];
	      }).slice(0, rindices.length - 1)));
	    } else {
	      return [].concat(_toConsumableArray(lindices.map(function (_, i) {
	        return lpal[lindices[i]];
	      }).reverse()), _toConsumableArray(rindices.map(function (_, i) {
	        return rpal[rindices[i]];
	      })));
	    }
	  }

	  var isDiverging = diverging && rhs && lhs && stats;
	  var mappedColors = isDiverging ? mapDiverging() : mapNormal();
	  var outColors = reverse && !isDiverging ? _toConsumableArray(mappedColors).reverse() : mappedColors;
	  return {
	    colors: outColors,
	    neutral: neutral
	  };
	}

	/**
	 * Ensure the right palette is setup for the dark theme
	 * @param {*} chartData chart data object
	 * @param {*} options factory options
	 * @returns the chart config (copy)
	 */

	function themedGradient(chartData) {
	  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	  var chartConfig = chartData.config;
	  var gradient = chartConfig.gradient;
	  var isDiverging = options.isDiverging;
	  var defaultTheme = isDiverging ? 'diverging.cyanhoney' : 'singlehue.cyan';
	  return getThemedGradient(gradient || defaultTheme, chartData.theme, options);
	} // pulled into a single param function

	function getThemedGradient(gradient, theme, options) {
	  var _gradient$split = gradient.split('.'),
	      _gradient$split2 = _slicedToArray(_gradient$split, 2),
	      hue = _gradient$split2[0],
	      palette = _gradient$split2[1]; // do we have a dark theme? the palette should be dark as well,
	  // e.g., it's "singlehue" we'll swap it to it's "singlehueDark"


	  if (isDarkTheme({
	    theme: theme
	  }, options)) {
	    // the hue should have Dark in it's name, .e.g, singlehue, diverging, etc.
	    if (!hue.includes('Dark')) {
	      // due to inconsistent naming conventions, try all
	      var foundPalette = ["".concat(hue, "Dark.").concat(palette), "".concat(hue, "Dark.").concat(palette, "-dark"), "".concat(hue, "Dark.").concat(palette, "Dark")].find(function (colorPalette) {
	        // confirm it exists, some palettes don't have dark versions (like bizweek)
	        if (findColorPalette(colorPalette)) return colorPalette;else return null;
	      });
	      if (foundPalette) return foundPalette;
	    } // conversely, for non-dark themes we should have the non-dark palette

	  } else if (hue.includes('Dark') || palette.includes('dark')) {
	    var lightPalette = gradient.replace(/-dark|Dark/g, ''); // confirm it exists

	    if (findColorPalette(lightPalette)) return lightPalette;
	  }

	  return gradient;
	}

	var COLOR_KEYS = ['color0', 'color1', 'color2', 'color3', 'color4', 'color5', 'color6', 'color7', 'color8', 'color9'];
	/**
	 * Generates a d3 color scale
	 * This version can use either custom colors or color stops from options
	 * @param {Object} chartData chart data
	 * @param {Object} options chart options taken from query parameters or override_options
	 * @returns {Object} a d3-scale useful for mapping value to colors
	 */

	function customColorScale(chartData) {
	  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	  var data = chartData.data,
	      config = chartData.config,
	      fields = chartData.fields;
	  var gradientStops = config.gradientStops,
	      gradientReverse = config.gradientReverse,
	      gradientType = config.gradientType,
	      gradientDiscreteOrder = config.gradientDiscreteOrder,
	      valField = config.valField;
	  var customColors = options.colors,
	      customStops = options.stops,
	      gradientTypeOverride = options.gradientTypeOverride;
	  var _options$neutral = options.neutral,
	      neutral = _options$neutral === void 0 ? baseColors.black.base : _options$neutral; // early out, no custom scale

	  if (!fields) return null;

	  if ((!customColors || !Array.isArray(customColors) || customColors.length < 2) && (!customStops || !Array.isArray(customStops) || customStops.length < 2)) {
	    // support the "color0, color1, ... color9" interface
	    customColors = COLOR_KEYS.reduce(function (p, key, i) {
	      var colorOption = options[key];

	      if (colorOption) {
	        if (!p) p = [];
	        p.push(colorOption);
	      }

	      return p;
	    }, null); // still no colors? continue exiting

	    if (!customColors) return null;
	  } // dark supported mode gradients


	  var gradient = themedGradient(chartData, options);
	  var appliedGradientType = gradientTypeOverride || gradientType; // discrete gradient follow a different logic

	  if (appliedGradientType === 'discrete') {
	    // get unique values via filter
	    var vals = chartData.data // grab all dataset values
	    .map(function (d) {
	      return d[valField];
	    }) // filter the unique values
	    .filter(function (x, i, a) {
	      return a.indexOf(x) === i;
	    }) // and remove null strings
	    .filter(function (s) {
	      return s && s !== '';
	    }); // apply the custom discrete order if one exists

	    if (gradientDiscreteOrder) {
	      vals = sortCommaSeparatedString(vals, gradientDiscreteOrder);
	    }

	    return {
	      scale: stringScale(customColors, vals)
	    };
	  } // for our purposes, create a custom chart config


	  var customConfig = {
	    gradientType: appliedGradientType,
	    gradientScale: 'custom',
	    gradientStops: customColors ? customColors.length : customColors,
	    gradientPositions: customStops && customStops.join(',')
	  }; // use stats to create a custom linear scale

	  var stats = makeStats(valField, data, customConfig, !!customStops);
	  var field = fields[valField]; // no custom colors? just use the gradient palette

	  var colors = customColors;

	  if (!colors) {
	    // https://stackoverflow.com/questions/27386234/object-destructuring-without-var-let-or-const
	    var _reduceColors = reduceColors(gradient, gradientStops, gradientReverse, stats);

	    colors = _reduceColors.colors;
	    neutral = _reduceColors.neutral;
	  } // make the color scale available to the editor
	  // const scale = makeScale(stats, { colors, neutral }, customConfig)


	  var scaleConfig = makeScale(field, stats, {
	    colors: colors,
	    neutral: neutral
	  }, chartData, _objectSpread2(_objectSpread2({}, options), {}, {
	    preventRounding: true
	  }));
	  window.colorScale = scaleConfig.scale; // for form validation

	  return scaleConfig;
	}
	/**
	 * Generates a d3 color scale for color interpolation
	 * @param {Object} chartData chart data
	 * @param {Object} options chart options taken from query parameters or override_options
	 * @returns {Object} a d3-scale useful for mapping value to colors
	 */


	function makeGradientColorScale(chartData) {
	  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	  var data = chartData.data,
	      config = chartData.config,
	      _chartData$fields = chartData.fields,
	      fields = _chartData$fields === void 0 ? [{
	    decimals: 2
	  }] : _chartData$fields,
	      _chartData$chartOptio = chartData.chartOptions,
	      chartOptions = _chartData$chartOptio === void 0 ? {} : _chartData$chartOptio;
	  var gradientType = config.gradientType;
	      config.gradientScale;
	      var gradientStops = config.gradientStops,
	      gradientReverse = config.gradientReverse,
	      gradientIncludeNeutral = config.gradientIncludeNeutral,
	      gradientDiscreteOrder = config.gradientDiscreteOrder,
	      includeZeroValues = config.includeZeroValues,
	      valField = config.valField;
	  var fieldIndex = options.fieldIndex,
	      gradientTypeOverride = options.gradientTypeOverride,
	      gradientStopsOverride = options.gradientStopsOverride; // dark supported mode gradients

	  var appliedGradientType = gradientTypeOverride || gradientType;
	  var appliedGradientStops = gradientStopsOverride || gradientStops; // detect custom scaling

	  var customScale = customColorScale(chartData, options);
	  if (customScale) return customScale;
	  var valueFieldIndex = fieldIndex == null ? valField : fieldIndex;

	  var field = _objectSpread2({}, fields[valueFieldIndex]); // because the field could be non-extensible
	  // carry over from bubblemap/choropleth which doesn't copy
	  // precision/decimals into field


	  if (valField != null && chartOptions.decimalPlaces != null && chartOptions.decimalPlaces !== '') {
	    field.decimals = chartOptions.decimalPlaces;
	  } // if not follow thru with generating normal scale


	  var stats = makeStats(valueFieldIndex, data, config);
	  var isDiverging = stats.diverging;
	  var gradient = themedGradient(chartData, _objectSpread2(_objectSpread2({}, options), {}, {
	    isDiverging: isDiverging
	  }));

	  var _reduceColors2 = reduceColors(gradient, appliedGradientStops, gradientIncludeNeutral, gradientReverse, stats),
	      colors = _reduceColors2.colors,
	      neutral = _reduceColors2.neutral; // append the neutral colors


	  if (gradientIncludeNeutral) {
	    if (appliedGradientType === 'discrete') {
	      colors = colors.slice(0, -1);
	      colors.push(neutral);
	    }
	  } // if discrete values, we can skip all the scale calculation


	  if (appliedGradientType === 'discrete') {
	    // get unique values via filter
	    var vals = chartData.data // grab all dataset values
	    .map(function (d) {
	      return d[valueFieldIndex];
	    }) // filter the unique values
	    .filter(function (x, i, a) {
	      return a.indexOf(x) === i;
	    }) // and remove null strings
	    .filter(function (s) {
	      return s && s !== '';
	    }) // exclude 0
	    // eslint-disable-next-line eqeqeq
	    .filter(function (n) {
	      return includeZeroValues ? true : n != 0;
	    }); // apply the custom discrete order if one exists

	    if (gradientDiscreteOrder) {
	      vals = sortCommaSeparatedString(vals, gradientDiscreteOrder);
	    }

	    return {
	      scale: stringScale(colors, vals)
	    };
	  } // make the color scale available to the editor


	  var scaleConfig = makeScale(field, stats, {
	    colors: colors,
	    neutral: neutral
	  }, chartData, options);
	  window.colorScale = scaleConfig.scale; // for form validation

	  return scaleConfig;
	}
	/**
	 * Generate an ordinal mapping between string values and colors
	 * @param {Array<string>} gradientColors the array of rgb or css colors
	 * @param {Array<string>} vals the array of values
	 * @returns d3 ordinal scale
	 */

	function stringScale(gradientColors, vals) {
	  // if the length of vals is greater than gradientColors we crop
	  // vals to be the same as gradientColors
	  if (vals.length > gradientColors.length) {
	    vals = vals.slice(0, gradientColors.length);
	  }

	  return ordinal().domain(vals).range(gradientColors);
	} // DH::
	// gradient where the last value will need a tick
	// mark otherwise you don't know the domain. for example
	// if 0 is the last tick and there are positive we need to show it

	function requiresLegendEndTick(colors, values) {
	  if (values.length < 3) return true;
	  if (values.length > colors.length) return true; // keeping around this case of last two as 0
	  // {
	  //   const vals = values.slice(values.length - 2, values.length)
	  //   return vals[0] === 0
	  // }

	  return false;
	} // good defaults for the color scale

	// similar to accessors.js but acting as custom transforms
	// of specific properties. For example scatterplot is a dual numeric
	// axis type so the unit_after unit_before is in the wrong field
	function transformMultiNumericAxisFields(chartData) {
	  var taxonomy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	  if (!chartData.config) return chartData;
	  if (!chartData.chartOptions) return chartData;
	  if (!(chartData.fields && chartData.fields[1] && chartData.fields[2])) return chartData;
	  var primaryField = taxonomy.primaryField,
	      secondaryField = taxonomy.secondaryField,
	      gradientField = taxonomy.gradientField,
	      scaleField = taxonomy.scaleField;
	  primaryField = primaryField || chartData.fields[1];
	  secondaryField = secondaryField || chartData.fields[2]; // keeping underscore variations for backwards compat

	  primaryField.unitBefore = chartData.config.prefixPrimary;
	  primaryField.unit_before = chartData.config.prefixPrimary;
	  primaryField.unitAfter = chartData.config.postfixPrimary;
	  primaryField.unit_after = chartData.config.postfixPrimary;
	  secondaryField.unitBefore = chartData.config.prefixSecondary;
	  secondaryField.unit_before = chartData.config.prefixSecondary;
	  secondaryField.unitAfter = chartData.config.postfixSecondary;
	  secondaryField.unit_after = chartData.config.postfixSecondary; // primary numeric axis properties are newer and come from
	  // different fields on the form

	  primaryField.numericProperties = {
	    decimals: chartData.config.decimalsPrimary,
	    tooltipDecimals: chartData.config.tooltipDecimalsPrimary,
	    scaleStart: chartData.config.scaleStartPrimary,
	    scaleEnd: chartData.config.scaleEndPrimary,
	    scaleStep: chartData.config.scaleStepPrimary
	  }; // default Y-axis properties should go to field[2]

	  secondaryField.numericProperties = {
	    decimals: chartData.chartOptions.decimalPlaces,
	    tooltipDecimals: chartData.chartOptions.tooltipDecimals,
	    scaleStart: chartData.chartOptions.scaleStart,
	    scaleEnd: chartData.chartOptions.scaleEnd,
	    scaleStep: chartData.chartOptions.scaleStep
	  };

	  if (gradientField) {
	    gradientField.numericProperties = _objectSpread2(_objectSpread2({}, gradientField.numericProperties), {}, {
	      decimals: chartData.config.gradientDecimals,
	      tooltipDecimals: chartData.config.gradientTooltipDecimals
	    });
	    gradientField.unitBefore = chartData.config.gradientPrefix;
	    gradientField.unitAfter = chartData.config.gradientPostfix;
	  }

	  if (scaleField) {
	    scaleField.numericProperties = _objectSpread2(_objectSpread2({}, scaleField.numericProperties), {}, {
	      decimals: chartData.config.scalePrecision,
	      tooltipDecimals: chartData.config.scaleTooltipPrecision
	    });
	    scaleField.unitBefore = chartData.config.scalePrefix;
	    scaleField.unitAfter = chartData.config.scalePostfix;
	  }

	  return chartData;
	}

	// the input data

	function scatterPlotTaxonomy(chartData) {
	  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	  if (!chartData || !chartData.fields) return null;
	  makeData(chartData, options); // ensure min/max/type is set

	  buildTaxonomy(chartData, false, {
	    preventAxisPropertyOverrides: true
	  });
	  var primaryField;
	  var secondaryField;
	  var groupField;
	  var scaleField;
	  var gradientField;
	  var numericField;
	  var numericField2; // chartData options are gradient + scale

	  var _chartData$config = chartData.config,
	      scatterPlotType = _chartData$config.scatterPlotType,
	      scatterPlotPrimaryField = _chartData$config.scatterPlotPrimaryField,
	      scatterPlotSecondaryField = _chartData$config.scatterPlotSecondaryField,
	      scatterPlotScaleField = _chartData$config.scatterPlotScaleField,
	      scatterPlotColorField = _chartData$config.scatterPlotColorField,
	      scatterPlotColorType = _chartData$config.scatterPlotColorType;
	  var hasExtraField = chartData.fields[3] != null;
	  var hasTwoExtraFields = hasExtraField && chartData.fields[4] != null;
	  primaryField = chartData.fields[1];
	  secondaryField = chartData.fields[2]; // right now we only allow a scale field
	  // and a group field, so we determine which

	  if (hasTwoExtraFields) {
	    if (chartData.fields[3].type === 'numeric' && chartData.fields[4].type === 'numeric') {
	      numericField = chartData.fields[3];
	      numericField2 = chartData.fields[4];
	    } else if (chartData.fields[3].type === 'string') {
	      groupField = chartData.fields[3];
	      numericField = chartData.fields[4];
	    } else {
	      numericField = chartData.fields[3];
	      groupField = chartData.fields[4];
	    }
	  } else if (hasExtraField) {
	    if (chartData.fields[3].type === 'string') {
	      groupField = chartData.fields[3];
	    } else {
	      numericField = chartData.fields[3];
	    }
	  }

	  if (scatterPlotType == null || scatterPlotType === 'scale-only' || scatterPlotType === 'grouped-scale') {
	    scaleField = numericField;
	  } else if (scatterPlotType === 'gradient-only') {
	    gradientField = numericField;
	  } else if (scatterPlotType === 'gradient-scale') {
	    gradientField = numericField;
	    scaleField = numericField2;
	  } else if (scatterPlotType === 'scale-gradient') {
	    scaleField = numericField;
	    gradientField = numericField2;
	  } // ALL of the above is the automatic taxonomy, but now we use the hand
	  // selected fields if the user overrides them


	  if (scatterPlotPrimaryField != null && scatterPlotPrimaryField !== '') {
	    primaryField = scatterPlotPrimaryField === 'none' ? undefined : chartData.fields[Number(scatterPlotPrimaryField)];
	  }

	  if (scatterPlotSecondaryField != null && scatterPlotSecondaryField !== '') {
	    secondaryField = scatterPlotSecondaryField === 'none' ? undefined : chartData.fields[Number(scatterPlotSecondaryField)];
	  }

	  if (scatterPlotScaleField != null && scatterPlotScaleField !== '') {
	    scaleField = scatterPlotScaleField === 'none' ? undefined : chartData.fields[Number(scatterPlotScaleField)];
	  }

	  if (scatterPlotColorField != null && scatterPlotColorField !== '') {
	    if (scatterPlotColorField === 'none') {
	      gradientField = undefined;
	      groupField = undefined;
	    } else {
	      var colorField = chartData.fields[Number(scatterPlotColorField)];

	      if (scatterPlotColorType == null) {
	        if (colorField.type === 'numeric') {
	          gradientField = colorField;
	          groupField = undefined;
	        } else {
	          groupField = colorField;
	          gradientField = undefined;
	        }
	      } else {
	        if (scatterPlotColorType === 'gradient') {
	          gradientField = colorField;
	          groupField = undefined;
	        } else if (scatterPlotColorType === 'categorical') {
	          groupField = colorField;
	          gradientField = undefined;
	        }
	      }
	    }
	  }

	  return {
	    primaryField: primaryField,
	    secondaryField: secondaryField,
	    groupField: groupField,
	    scaleField: scaleField,
	    gradientField: gradientField
	  };
	} // setup called during the factory operation, to set the taxonomy
	// to the config

	function scatterPlotSetup(env, chartData) {
	  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
	  var taxonomy = scatterPlotTaxonomy(chartData, options);
	  var primaryField = taxonomy.primaryField,
	      secondaryField = taxonomy.secondaryField,
	      groupField = taxonomy.groupField,
	      scaleField = taxonomy.scaleField,
	      gradientField = taxonomy.gradientField;
	  var _chartData$config2 = chartData.config,
	      config = _chartData$config2 === void 0 ? {} : _chartData$config2;
	  var overrides = {};

	  if (config.scatterPlotPrimaryField == null && primaryField) {
	    overrides.scatterPlotPrimaryField = primaryField.index;
	  }

	  if (config.scatterPlotSecondaryField == null && secondaryField) {
	    overrides.scatterPlotSecondaryField = secondaryField.index;
	  }

	  if (config.scatterPlotScaleField == null && scaleField) {
	    overrides.scatterPlotScaleField = scaleField.index;
	  }

	  if (config.scatterPlotColorField == null && groupField) {
	    overrides.scatterPlotColorField = groupField.index;
	    overrides.scatterPlotUseCategorical = true;
	  }

	  if (config.scatterPlotColorField == null && gradientField) {
	    overrides.scatterPlotColorField = gradientField.index;
	    overrides.scatterPlotUseGradient = true;
	  }

	  if (Object.keys(overrides).length) {
	    chartData.config = _objectSpread2(_objectSpread2({}, config), overrides);
	  }

	  chartData.chartOptions = chartData.chartOptions || {};
	  transformMultiNumericAxisFields(chartData, taxonomy);
	}

	var MAX_CATEGORICAL = 7;
	var STANDARD_RAD = 10;
	var MIN_STANDARD_RAD = 3; // smallest a non scaled item can go

	var MIN_RAD = 2;
	var MAX_RAD = 30;
	var SCATTER_PLOT_DEFAULTS = {
	  // radius of scatterplot dot
	  dotRadius: 5,
	  // display value tag at end of line
	  displayValueTags: false,
	  // treat year values as continuous rather than discrete
	  yearsAsContinuous: true
	};
	function getScatterPlotConfig(env, chartData) {
	  var _options$afterRenderC;

	  var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

	  var options = _objectSpread2(_objectSpread2(_objectSpread2({}, SCATTER_PLOT_DEFAULTS), opts), {}, {
	    // build out our legend config
	    customLegend: configBasedLegend,
	    legendConfig: legendConfig(env, chartData, opts)
	  });

	  options.afterRenderCallbacks = (_options$afterRenderC = options.afterRenderCallbacks) !== null && _options$afterRenderC !== void 0 ? _options$afterRenderC : [];

	  options.addAfterRenderCallback = function (cb) {
	    options.afterRenderCallbacks.push(cb);
	  };

	  return options;
	}
	// by default only 1 series, but if a groupField exists it is
	// the number of group values

	function scatterPlotGroupColors(chartData, groupField) {
	  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

	  if (!groupField) {
	    // no group field if single value
	    var colorOptions = _objectSpread2(_objectSpread2({}, options), {}, {
	      colorSeriesKey: 1
	    }); // terminal theme has no seriesColors applied so we just
	    // return defaults there


	    var colorVals = createColorScheme(null, chartData, colorOptions) || defaultThemeColors(chartData.theme); // filter out { color: stroke: objects }

	    var _customColors = applyCustomColorsToArray(chartData, colorVals, options);

	    return _customColors;
	  }

	  var groups = _toConsumableArray(new Set(groupField.data)).slice(0, MAX_CATEGORICAL);

	  var count = groups.length;

	  var _makeGradientColorSca = makeGradientColorScale(chartData, {
	    fieldIndex: groupField.index,
	    gradientTypeOverride: 'discrete',
	    gradientStopsOverride: count
	  }),
	      scale = _makeGradientColorSca.scale;

	  var customColors = applyCustomColorsToArray(chartData, scale.range(), options);
	  return customColors;
	} // return a configuration for the legend based on all of the
	// possible data

	function legendConfig(env, chartData) {
	  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
	  var fields = scatterPlotTaxonomy(chartData, options);
	  var groupField = fields.groupField,
	      scaleField = fields.scaleField,
	      gradientField = fields.gradientField;
	  var darkTheme = isDarkTheme(chartData, options);
	  var showScaleLegend = !chartData.config.hideScaleLegend;
	  var scaleLegend;
	  var gradientLegend;
	  var categoricalLegend;

	  if (scaleField && showScaleLegend) {
	    var radiusRange = getRadiusSize(env, fields);
	    var radiusScale = makeRadiusScale(scaleField, _objectSpread2(_objectSpread2(_objectSpread2({}, options), chartData.config.scaleRadiusLimits), {}, {
	      minRadius: radiusRange[0],
	      maxRadius: radiusRange[1]
	    }));
	    scaleLegend = prepareScaleLegendConfig(scaleField, chartData, radiusScale, _objectSpread2(_objectSpread2({}, options), {}, {
	      overlapByDefault: true
	    }));
	  }

	  if (gradientField) {
	    var _makeGradientColorSca2 = makeGradientColorScale(chartData, {
	      fieldIndex: gradientField.index
	    }),
	        scale = _makeGradientColorSca2.scale,
	        bareValueFormatter = _makeGradientColorSca2.bareValueFormatter,
	        fullValueFormatter = _makeGradientColorSca2.fullValueFormatter;

	    var colorValues = applyCustomColorsToArray(chartData, scale.range(), options);
	    var fillColors = onlyFillColors(colorValues);
	    var strokeColors = onlyStrokeColors(colorValues);
	    var values = scale.domain();
	    var formatterOffset = requiresLegendEndTick(colorValues, values) ? 1 : 2;
	    gradientLegend = {
	      type: 'gradient',
	      items: fillColors.map(function (color, i) {
	        return {
	          color: color,
	          stroke: strokeColors[i],
	          label: i < fillColors.length - formatterOffset ? bareValueFormatter(values[i + 1]) : fullValueFormatter(values[i + 1])
	        };
	      })
	    };
	  }

	  if (groupField) {
	    var groups = _toConsumableArray(new Set(groupField.data)).slice(0, MAX_CATEGORICAL);

	    var _colorValues = scatterPlotGroupColors(chartData, groupField, options);

	    var _fillColors = onlyFillColors(_colorValues);

	    var _strokeColors = onlyStrokeColors(_colorValues);

	    categoricalLegend = {
	      type: 'standard',
	      darkTheme: darkTheme,
	      items: groups.map(function (v, i) {
	        return {
	          type: 'circle',
	          text: v,
	          color: _fillColors[i],
	          stroke: _strokeColors[i]
	        };
	      })
	    };
	  }

	  if (groupField && scaleField && showScaleLegend) {
	    return {
	      primaryLegend: categoricalLegend,
	      secondaryLegend: scaleLegend
	    };
	  } else if (gradientField && scaleField && showScaleLegend) {
	    return {
	      primaryLegend: gradientLegend,
	      secondaryLegend: scaleLegend
	    };
	  } else if (groupField) {
	    return {
	      primaryLegend: categoricalLegend
	    };
	  } else if (gradientField) {
	    return {
	      primaryLegend: gradientLegend
	    };
	  } else if (scaleField && showScaleLegend) {
	    return {
	      primaryLegend: scaleLegend
	    };
	  } // no legend


	  return {};
	} // scatter plot supports the gradient scale
	function getRadiusSize(env, fields) {
	  var scaleField = fields.scaleField;
	  var scaleRadiusMax = env.data.config.scaleRadiusMax;
	  var defaultRadius = scaleField ? MAX_RAD : STANDARD_RAD;
	  var maxRadius = scaleRadiusMax || defaultRadius; // smaller circles on mobile phones

	  var rangeMultiplier = isMobileWidth(env.el.offsetWidth, env.options) ? 0.6 : 1.0;

	  if (scaleField) {
	    return [MIN_RAD * rangeMultiplier, // MAX_RAD * rangeMultiplier * userMultiplier
	    maxRadius * rangeMultiplier];
	  } else {
	    return [Math.max(MIN_STANDARD_RAD, maxRadius) * rangeMultiplier, Math.max(MIN_STANDARD_RAD, maxRadius) * rangeMultiplier];
	  }
	} // given a scatterplot fieldTaxonomy
	// provide scale functions for color, opacity, and radius

	function propertyScales(env, fields) {
	  var groupField = fields.groupField,
	      scaleField = fields.scaleField,
	      gradientField = fields.gradientField;
	  var groupColors = scatterPlotGroupColors(env.data, groupField, env.options);
	  var fillColors = onlyFillColors(groupColors);
	  var strokeColors = onlyStrokeColors(groupColors);
	  var groups;
	  var radiusInterpolate;
	  var gradientColorScale;

	  if (groupField) {
	    groups = _toConsumableArray(new Set(groupField.data));
	  }

	  if (scaleField) {
	    var radiusRange = getRadiusSize(env, fields);
	    radiusInterpolate = makeRadiusScale(scaleField, _objectSpread2(_objectSpread2({}, env.data.config.scaleRadiusLimits), {}, {
	      minRadius: radiusRange[0],
	      maxRadius: radiusRange[1]
	    }));
	  }

	  if (gradientField) {
	    var gradientScaleConfig = makeGradientColorScale(env.data, {
	      fieldIndex: gradientField.index
	    });
	    gradientColorScale = gradientScaleConfig.scale;
	  }

	  var colorScale = function colorScale(index) {
	    if (groupField && groups) {
	      var groupIndex = groups.indexOf(groupField.data[index]);
	      return fillColors[groupIndex];
	    } else if (gradientField) {
	      return gradientColorScale(gradientField.data[index]);
	    } else {
	      return fillColors[0];
	    }
	  };

	  var radiusScale = function radiusScale(index) {
	    if (radiusInterpolate) {
	      return radiusInterpolate(scaleField.data[index]);
	    }

	    return getRadiusSize(env, fields)[0];
	  };

	  var opacityScale = function opacityScale() {
	    var scatterPlotOpacity = env.data.config.scatterPlotOpacity;

	    if (scatterPlotOpacity != null && scatterPlotOpacity >= 0 && scatterPlotOpacity <= 100) {
	      return Number(scatterPlotOpacity) / 100;
	    }

	    return 1.0;
	  };

	  var strokeScale = function strokeScale(index) {
	    var _env$data$config = env.data.config,
	        scatterPlotBorder = _env$data$config.scatterPlotBorder,
	        highlightValues = _env$data$config.highlight_values;
	    var darkMode = isDarkTheme(env.data, env.options);
	    var highlights = highlightValues ? highlightValues.split(',').map(Number) : [];
	    var groupIndex = 0;

	    if (groupField && groups) {
	      groupIndex = groups.indexOf(groupField.data[index]);
	    }

	    if (highlights.includes(index + 1)) {
	      if (env.options.scatterPlotStrokeHighlightColor) {
	        return env.options.scatterPlotStrokeHighlightColor;
	      }

	      return darkMode ? '#FFFFFF' : '#000000';
	    }

	    if (strokeColors[groupIndex] != null) return strokeColors[groupIndex];

	    if (env.options.scatterPlotStrokeColor) {
	      return env.options.scatterPlotStrokeColor;
	    }

	    if (scatterPlotBorder === 'no-border') {
	      return 'transparent';
	    }

	    if (scatterPlotBorder === 'contrast') {
	      return darkMode ? '#FFFFFF' : '#000000';
	    }

	    return darkMode ? '#000000' : '#FFFFFF';
	  };

	  return {
	    colorScale: colorScale,
	    radiusScale: radiusScale,
	    opacityScale: opacityScale,
	    strokeScale: strokeScale
	  };
	}

	function add_css$m(target) {
	  append_styles(target, "svelte-1q8rl2h", "path.svelte-1q8rl2h{fill:none;stroke-width:1px}");
	}

	function create_fragment$v(ctx) {
	  var g;
	  var path;
	  var path_class_value;
	  return {
	    c: function c() {
	      g = svg_element("g");
	      path = svg_element("path");
	      attr(path, "class", path_class_value = "line s series-" +
	      /*series*/
	      ctx[0] + " svelte-1q8rl2h");
	      attr(path, "d",
	      /*pathData*/
	      ctx[1]);
	      attr(g, "class", "line-graph");
	    },
	    m: function m(target, anchor) {
	      insert(target, g, anchor);
	      append(g, path);
	    },
	    p: function p(ctx, _ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	          dirty = _ref2[0];

	      if (dirty &
	      /*series*/
	      1 && path_class_value !== (path_class_value = "line s series-" +
	      /*series*/
	      ctx[0] + " svelte-1q8rl2h")) {
	        attr(path, "class", path_class_value);
	      }

	      if (dirty &
	      /*pathData*/
	      2) {
	        attr(path, "d",
	        /*pathData*/
	        ctx[1]);
	      }
	    },
	    i: noop,
	    o: noop,
	    d: function d(detaching) {
	      if (detaching) detach(g);
	    }
	  };
	}

	function instance$v($$self, $$props, $$invalidate) {
	  var env = $$props.env;
	  var fields = $$props.fields;
	  var _$$props$series = $$props.series,
	      series = _$$props$series === void 0 ? 0 : _$$props$series;
	  var _$$props$xScale = $$props.xScale,
	      xScale = _$$props$xScale === void 0 ? function () {
	    return null;
	  } : _$$props$xScale;
	  var _$$props$yScale = $$props.yScale,
	      yScale = _$$props$yScale === void 0 ? function () {
	    return null;
	  } : _$$props$yScale;
	  var pathData;
	  var chartData = env.data;
	  var curveType = chartData.config.curve_type;
	  var _fields = fields,
	      primaryField = _fields.primaryField,
	      secondaryField = _fields.secondaryField;
	  var curveTypes = {
	    step: curveStep,
	    stepAfter: stepAfter,
	    stepBefore: stepBefore,
	    smooth: curveBasis
	  };

	  $$self.$$set = function ($$props) {
	    if ('env' in $$props) $$invalidate(2, env = $$props.env);
	    if ('fields' in $$props) $$invalidate(3, fields = $$props.fields);
	    if ('series' in $$props) $$invalidate(0, series = $$props.series);
	    if ('xScale' in $$props) $$invalidate(4, xScale = $$props.xScale);
	    if ('yScale' in $$props) $$invalidate(5, yScale = $$props.yScale);
	  };

	  $$self.$$.update = function () {
	    if ($$self.$$.dirty &
	    /*xScale, yScale*/
	    48) {
	      {
	        var line = d3line().x(function (d, i) {
	          return xScale(chartData.data[i][primaryField.index]);
	        }).y(function (d, i) {
	          return yScale(chartData.data[i][secondaryField.index]);
	        }); // .defined(isDefined)

	        if (curveType) {
	          line.curve(curveTypes[curveType]);
	        }

	        $$invalidate(1, pathData = line(chartData.data));
	      }
	    }
	  };

	  return [series, pathData, env, fields, xScale, yScale];
	}

	var LineGraph = /*#__PURE__*/function (_SvelteComponent) {
	  _inherits(LineGraph, _SvelteComponent);

	  var _super = _createSuper(LineGraph);

	  function LineGraph(options) {
	    var _this;

	    _classCallCheck(this, LineGraph);

	    _this = _super.call(this);
	    init(_assertThisInitialized(_this), options, instance$v, create_fragment$v, safe_not_equal, {
	      env: 2,
	      fields: 3,
	      series: 0,
	      xScale: 4,
	      yScale: 5
	    }, add_css$m);
	    return _this;
	  }

	  _createClass(LineGraph, [{
	    key: "env",
	    get: function get() {
	      return this.$$.ctx[2];
	    },
	    set: function set(env) {
	      this.$$set({
	        env: env
	      });
	      flush();
	    }
	  }, {
	    key: "fields",
	    get: function get() {
	      return this.$$.ctx[3];
	    },
	    set: function set(fields) {
	      this.$$set({
	        fields: fields
	      });
	      flush();
	    }
	  }, {
	    key: "series",
	    get: function get() {
	      return this.$$.ctx[0];
	    },
	    set: function set(series) {
	      this.$$set({
	        series: series
	      });
	      flush();
	    }
	  }, {
	    key: "xScale",
	    get: function get() {
	      return this.$$.ctx[4];
	    },
	    set: function set(xScale) {
	      this.$$set({
	        xScale: xScale
	      });
	      flush();
	    }
	  }, {
	    key: "yScale",
	    get: function get() {
	      return this.$$.ctx[5];
	    },
	    set: function set(yScale) {
	      this.$$set({
	        yScale: yScale
	      });
	      flush();
	    }
	  }]);

	  return LineGraph;
	}(SvelteComponent);

	function get_each_context$7(ctx, list, i) {
	  var child_ctx = ctx.slice();
	  child_ctx[18] = list[i];
	  return child_ctx;
	} // (70:4) {:else}


	function create_else_block$5(ctx) {
	  var circle;
	  var circle_r_value;
	  var circle_cx_value;
	  var circle_cy_value;
	  return {
	    c: function c() {
	      circle = svg_element("circle");
	      attr(circle, "r", circle_r_value =
	      /*radiusScale*/
	      ctx[8](
	      /*i*/
	      ctx[18]));
	      attr(circle, "cx", circle_cx_value =
	      /*xScale*/
	      ctx[1](
	      /*chartData*/
	      ctx[4].data[
	      /*i*/
	      ctx[18]][
	      /*primaryField*/
	      ctx[10].index]));
	      attr(circle, "cy", circle_cy_value =
	      /*yScale*/
	      ctx[2](
	      /*chartData*/
	      ctx[4].data[
	      /*i*/
	      ctx[18]][
	      /*secondaryField*/
	      ctx[11].index]));
	      set_style(circle, "fill",
	      /*colorScale*/
	      ctx[6](
	      /*i*/
	      ctx[18]));
	      set_style(circle, "stroke",
	      /*activeTooltipIndex*/
	      ctx[0] ===
	      /*i*/
	      ctx[18] ?
	      /*tooltipStrokeColor*/
	      ctx[12]() :
	      /*strokeScale*/
	      ctx[7](
	      /*i*/
	      ctx[18]));
	      set_style(circle, "opacity",
	      /*opacityScale*/
	      ctx[9](
	      /*i*/
	      ctx[18]));
	    },
	    m: function m(target, anchor) {
	      insert(target, circle, anchor);
	    },
	    p: function p(ctx, dirty) {
	      if (dirty &
	      /*sortedIndices*/
	      8 && circle_r_value !== (circle_r_value =
	      /*radiusScale*/
	      ctx[8](
	      /*i*/
	      ctx[18]))) {
	        attr(circle, "r", circle_r_value);
	      }

	      if (dirty &
	      /*xScale, sortedIndices*/
	      10 && circle_cx_value !== (circle_cx_value =
	      /*xScale*/
	      ctx[1](
	      /*chartData*/
	      ctx[4].data[
	      /*i*/
	      ctx[18]][
	      /*primaryField*/
	      ctx[10].index]))) {
	        attr(circle, "cx", circle_cx_value);
	      }

	      if (dirty &
	      /*yScale, sortedIndices*/
	      12 && circle_cy_value !== (circle_cy_value =
	      /*yScale*/
	      ctx[2](
	      /*chartData*/
	      ctx[4].data[
	      /*i*/
	      ctx[18]][
	      /*secondaryField*/
	      ctx[11].index]))) {
	        attr(circle, "cy", circle_cy_value);
	      }

	      if (dirty &
	      /*sortedIndices*/
	      8) {
	        set_style(circle, "fill",
	        /*colorScale*/
	        ctx[6](
	        /*i*/
	        ctx[18]));
	      }

	      if (dirty &
	      /*activeTooltipIndex, sortedIndices*/
	      9) {
	        set_style(circle, "stroke",
	        /*activeTooltipIndex*/
	        ctx[0] ===
	        /*i*/
	        ctx[18] ?
	        /*tooltipStrokeColor*/
	        ctx[12]() :
	        /*strokeScale*/
	        ctx[7](
	        /*i*/
	        ctx[18]));
	      }

	      if (dirty &
	      /*sortedIndices*/
	      8) {
	        set_style(circle, "opacity",
	        /*opacityScale*/
	        ctx[9](
	        /*i*/
	        ctx[18]));
	      }
	    },
	    d: function d(detaching) {
	      if (detaching) detach(circle);
	    }
	  };
	} // (56:4) {#if scatterPlotRenderIcon === 'square'}


	function create_if_block$i(ctx) {
	  var rect;
	  var rect_x_value;
	  var rect_y_value;
	  var rect_width_value;
	  var rect_height_value;
	  return {
	    c: function c() {
	      rect = svg_element("rect");
	      attr(rect, "x", rect_x_value =
	      /*xScale*/
	      ctx[1](
	      /*chartData*/
	      ctx[4].data[
	      /*i*/
	      ctx[18]][
	      /*primaryField*/
	      ctx[10].index]) +
	      /*radiusScale*/
	      ctx[8](
	      /*i*/
	      ctx[18]));
	      attr(rect, "y", rect_y_value =
	      /*yScale*/
	      ctx[2](
	      /*chartData*/
	      ctx[4].data[
	      /*i*/
	      ctx[18]][
	      /*secondaryField*/
	      ctx[11].index]) -
	      /*radiusScale*/
	      ctx[8](
	      /*i*/
	      ctx[18]));
	      attr(rect, "width", rect_width_value =
	      /*radiusScale*/
	      ctx[8](
	      /*i*/
	      ctx[18]) * 2);
	      attr(rect, "height", rect_height_value =
	      /*radiusScale*/
	      ctx[8](
	      /*i*/
	      ctx[18]) * 2);
	      set_style(rect, "fill",
	      /*colorScale*/
	      ctx[6](
	      /*i*/
	      ctx[18]));
	      set_style(rect, "stroke",
	      /*activeTooltipIndex*/
	      ctx[0] ===
	      /*i*/
	      ctx[18] ?
	      /*tooltipStrokeColor*/
	      ctx[12]() :
	      /*strokeScale*/
	      ctx[7](
	      /*i*/
	      ctx[18]));
	      set_style(rect, "opacity",
	      /*opacityScale*/
	      ctx[9](
	      /*i*/
	      ctx[18]));
	    },
	    m: function m(target, anchor) {
	      insert(target, rect, anchor);
	    },
	    p: function p(ctx, dirty) {
	      if (dirty &
	      /*xScale, sortedIndices*/
	      10 && rect_x_value !== (rect_x_value =
	      /*xScale*/
	      ctx[1](
	      /*chartData*/
	      ctx[4].data[
	      /*i*/
	      ctx[18]][
	      /*primaryField*/
	      ctx[10].index]) +
	      /*radiusScale*/
	      ctx[8](
	      /*i*/
	      ctx[18]))) {
	        attr(rect, "x", rect_x_value);
	      }

	      if (dirty &
	      /*yScale, sortedIndices*/
	      12 && rect_y_value !== (rect_y_value =
	      /*yScale*/
	      ctx[2](
	      /*chartData*/
	      ctx[4].data[
	      /*i*/
	      ctx[18]][
	      /*secondaryField*/
	      ctx[11].index]) -
	      /*radiusScale*/
	      ctx[8](
	      /*i*/
	      ctx[18]))) {
	        attr(rect, "y", rect_y_value);
	      }

	      if (dirty &
	      /*sortedIndices*/
	      8 && rect_width_value !== (rect_width_value =
	      /*radiusScale*/
	      ctx[8](
	      /*i*/
	      ctx[18]) * 2)) {
	        attr(rect, "width", rect_width_value);
	      }

	      if (dirty &
	      /*sortedIndices*/
	      8 && rect_height_value !== (rect_height_value =
	      /*radiusScale*/
	      ctx[8](
	      /*i*/
	      ctx[18]) * 2)) {
	        attr(rect, "height", rect_height_value);
	      }

	      if (dirty &
	      /*sortedIndices*/
	      8) {
	        set_style(rect, "fill",
	        /*colorScale*/
	        ctx[6](
	        /*i*/
	        ctx[18]));
	      }

	      if (dirty &
	      /*activeTooltipIndex, sortedIndices*/
	      9) {
	        set_style(rect, "stroke",
	        /*activeTooltipIndex*/
	        ctx[0] ===
	        /*i*/
	        ctx[18] ?
	        /*tooltipStrokeColor*/
	        ctx[12]() :
	        /*strokeScale*/
	        ctx[7](
	        /*i*/
	        ctx[18]));
	      }

	      if (dirty &
	      /*sortedIndices*/
	      8) {
	        set_style(rect, "opacity",
	        /*opacityScale*/
	        ctx[9](
	        /*i*/
	        ctx[18]));
	      }
	    },
	    d: function d(detaching) {
	      if (detaching) detach(rect);
	    }
	  };
	} // (55:2) {#each sortedIndices as i}


	function create_each_block$7(ctx) {
	  var if_block_anchor;

	  function select_block_type(ctx, dirty) {
	    if (
	    /*scatterPlotRenderIcon*/
	    ctx[5] === 'square') return create_if_block$i;
	    return create_else_block$5;
	  }

	  var current_block_type = select_block_type(ctx);
	  var if_block = current_block_type(ctx);
	  return {
	    c: function c() {
	      if_block.c();
	      if_block_anchor = empty();
	    },
	    m: function m(target, anchor) {
	      if_block.m(target, anchor);
	      insert(target, if_block_anchor, anchor);
	    },
	    p: function p(ctx, dirty) {
	      if_block.p(ctx, dirty);
	    },
	    d: function d(detaching) {
	      if_block.d(detaching);
	      if (detaching) detach(if_block_anchor);
	    }
	  };
	}

	function create_fragment$u(ctx) {
	  var g;
	  var each_value =
	  /*sortedIndices*/
	  ctx[3];
	  var each_blocks = [];

	  for (var i = 0; i < each_value.length; i += 1) {
	    each_blocks[i] = create_each_block$7(get_each_context$7(ctx, each_value, i));
	  }

	  return {
	    c: function c() {
	      g = svg_element("g");

	      for (var _i = 0; _i < each_blocks.length; _i += 1) {
	        each_blocks[_i].c();
	      }

	      attr(g, "class", "scatter-plot");
	    },
	    m: function m(target, anchor) {
	      insert(target, g, anchor);

	      for (var _i2 = 0; _i2 < each_blocks.length; _i2 += 1) {
	        each_blocks[_i2].m(g, null);
	      }
	    },
	    p: function p(ctx, _ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	          dirty = _ref2[0];

	      if (dirty &
	      /*xScale, chartData, sortedIndices, primaryField, radiusScale, yScale, secondaryField, colorScale, activeTooltipIndex, tooltipStrokeColor, strokeScale, opacityScale, scatterPlotRenderIcon*/
	      8191) {
	        each_value =
	        /*sortedIndices*/
	        ctx[3];

	        var _i3;

	        for (_i3 = 0; _i3 < each_value.length; _i3 += 1) {
	          var child_ctx = get_each_context$7(ctx, each_value, _i3);

	          if (each_blocks[_i3]) {
	            each_blocks[_i3].p(child_ctx, dirty);
	          } else {
	            each_blocks[_i3] = create_each_block$7(child_ctx);

	            each_blocks[_i3].c();

	            each_blocks[_i3].m(g, null);
	          }
	        }

	        for (; _i3 < each_blocks.length; _i3 += 1) {
	          each_blocks[_i3].d(1);
	        }

	        each_blocks.length = each_value.length;
	      }
	    },
	    i: noop,
	    o: noop,
	    d: function d(detaching) {
	      if (detaching) detach(g);
	      destroy_each(each_blocks, detaching);
	    }
	  };
	}

	function instance$u($$self, $$props, $$invalidate) {
	  var sortedIndices;
	  var env = $$props.env;
	  var fields = $$props.fields;
	  var activeTooltipIndex = $$props.activeTooltipIndex;
	  var _$$props$xScale = $$props.xScale,
	      xScale = _$$props$xScale === void 0 ? function () {
	    return null;
	  } : _$$props$xScale;
	  var _$$props$yScale = $$props.yScale,
	      yScale = _$$props$yScale === void 0 ? function () {
	    return null;
	  } : _$$props$yScale;
	  var chartData = env.data;
	  var _chartData$config$sca = chartData.config.scatterPlotRenderIcon,
	      scatterPlotRenderIcon = _chartData$config$sca === void 0 ? 'circle' : _chartData$config$sca;

	  var _propertyScales = propertyScales(env, fields),
	      colorScale = _propertyScales.colorScale,
	      strokeScale = _propertyScales.strokeScale,
	      radiusScale = _propertyScales.radiusScale,
	      opacityScale = _propertyScales.opacityScale;

	  var _fields = fields,
	      _fields$primaryField = _fields.primaryField,
	      primaryField = _fields$primaryField === void 0 ? {
	    index: 1
	  } : _fields$primaryField,
	      _fields$secondaryFiel = _fields.secondaryField,
	      secondaryField = _fields$secondaryFiel === void 0 ? {
	    index: 2
	  } : _fields$secondaryFiel,
	      scaleField = _fields.scaleField,
	      groupField = _fields.groupField;
	  var groups;

	  if (groupField) {
	    groups = _toConsumableArray(new Set(groupField.data)).slice(0, MAX_CATEGORICAL);
	  }

	  var tooltipStrokeColor = function tooltipStrokeColor() {
	    return isDarkTheme(env.data, env.options) ? '#FFFFFF' : '#000000';
	  };

	  $$self.$$set = function ($$props) {
	    if ('env' in $$props) $$invalidate(13, env = $$props.env);
	    if ('fields' in $$props) $$invalidate(14, fields = $$props.fields);
	    if ('activeTooltipIndex' in $$props) $$invalidate(0, activeTooltipIndex = $$props.activeTooltipIndex);
	    if ('xScale' in $$props) $$invalidate(1, xScale = $$props.xScale);
	    if ('yScale' in $$props) $$invalidate(2, yScale = $$props.yScale);
	  };

	  $$self.$$.update = function () {
	    if ($$self.$$.dirty &
	    /*groups*/
	    32768) {
	      // we need to sort so that the largest is at the bottom
	      // otherwise it will obscure smaller items
	      $$invalidate(3, sortedIndices = chartData.data.map(function (row, i) {
	        return i;
	      }).sort(function (a, b) {
	        if (scaleField) return radiusScale(b) - radiusScale(a);

	        if (groups) {
	          // order so first group is on top
	          var valA = chartData.data[a][groupField.index];
	          var valB = chartData.data[b][groupField.index];
	          return groups.indexOf(valB) - groups.indexOf(valA);
	        }

	        return 0;
	      }));
	    }
	  };

	  return [activeTooltipIndex, xScale, yScale, sortedIndices, chartData, scatterPlotRenderIcon, colorScale, strokeScale, radiusScale, opacityScale, primaryField, secondaryField, tooltipStrokeColor, env, fields, groups];
	}

	var RenderMarkers = /*#__PURE__*/function (_SvelteComponent) {
	  _inherits(RenderMarkers, _SvelteComponent);

	  var _super = _createSuper(RenderMarkers);

	  function RenderMarkers(options) {
	    var _this;

	    _classCallCheck(this, RenderMarkers);

	    _this = _super.call(this);
	    init(_assertThisInitialized(_this), options, instance$u, create_fragment$u, safe_not_equal, {
	      env: 13,
	      fields: 14,
	      activeTooltipIndex: 0,
	      xScale: 1,
	      yScale: 2
	    });
	    return _this;
	  }

	  _createClass(RenderMarkers, [{
	    key: "env",
	    get: function get() {
	      return this.$$.ctx[13];
	    },
	    set: function set(env) {
	      this.$$set({
	        env: env
	      });
	      flush();
	    }
	  }, {
	    key: "fields",
	    get: function get() {
	      return this.$$.ctx[14];
	    },
	    set: function set(fields) {
	      this.$$set({
	        fields: fields
	      });
	      flush();
	    }
	  }, {
	    key: "activeTooltipIndex",
	    get: function get() {
	      return this.$$.ctx[0];
	    },
	    set: function set(activeTooltipIndex) {
	      this.$$set({
	        activeTooltipIndex: activeTooltipIndex
	      });
	      flush();
	    }
	  }, {
	    key: "xScale",
	    get: function get() {
	      return this.$$.ctx[1];
	    },
	    set: function set(xScale) {
	      this.$$set({
	        xScale: xScale
	      });
	      flush();
	    }
	  }, {
	    key: "yScale",
	    get: function get() {
	      return this.$$.ctx[2];
	    },
	    set: function set(yScale) {
	      this.$$set({
	        yScale: yScale
	      });
	      flush();
	    }
	  }]);

	  return RenderMarkers;
	}(SvelteComponent);

	function layoutInterface (env) {
	  var postLayoutHandlers = [];
	  var layout = {};

	  layout.addPostLayoutHandler = function (name, callback) {
	    postLayoutHandlers.push([name, callback]);
	  };

	  layout.removePostLayoutHandler = function (name) {
	    var i = postLayoutHandlers.indexOf(function (_ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	          n = _ref2[0];

	      return n === name;
	    });
	    postLayoutHandlers.splice(i, 1);
	  };

	  layout.emitPostLayout = function (el, env) {
	    postLayoutHandlers.forEach(function (_ref3) {
	      var _ref4 = _slicedToArray(_ref3, 2),
	          cb = _ref4[1];

	      cb(el, env, layout);
	    });
	  }; // TODO :: eventually get rid of these


	  layout.g = function () {
	    return select(env.el.querySelector('g.margin'));
	  };

	  layout.draw = function () {
	    return select(env.el.querySelector('g.draw-container'));
	  };

	  layout.extents = function () {
	    return select(env.el.querySelector('.extents'));
	  };

	  layout.container = function () {
	    return select(env.el.querySelector('.chart'));
	  };

	  layout.xAxis = function () {
	    return select(env.el.querySelector('.axis.axis-x'));
	  };

	  layout.yAxis = function () {
	    return select(env.el.querySelector('.axis.axis-y'));
	  };

	  layout.svg = function () {
	    return select(env.el.querySelector('svg.svg-wrapper'));
	  };

	  layout.margin = function () {
	    return select(env.el.querySelector('g.margin'));
	  };

	  return layout;
	}

	function mouseEvents() {
	  var store = writable();

	  function action(node) {
	    function update(event) {
	      store.set(event);
	    }

	    function touchmove(event) {
	      event.preventDefault();
	      store.set(event);
	    }

	    function clear() {
	      store.set(null);
	    }

	    var startEvents = ['mouseover', 'mousemove', 'touchstart'];
	    var endEvents = ['mouseout', 'touchend'];
	    startEvents.forEach(function (eventName) {
	      node.addEventListener(eventName, update, {
	        passive: true
	      });
	    });
	    endEvents.forEach(function (eventName) {
	      node.addEventListener(eventName, clear, {
	        passive: true
	      });
	    });
	    node.addEventListener('touchmove', touchmove, {
	      passive: false
	    });
	    return {
	      destroy: function destroy() {
	        startEvents.forEach(function (eventName) {
	          node.removeEventListener(eventName, update);
	        });
	        endEvents.forEach(function (eventName) {
	          node.removeEventListener(eventName, clear);
	        });
	        node.removeEventListener('touchmove', touchmove);
	      }
	    };
	  }

	  return {
	    store: store,
	    action: action
	  };
	}
	function equalBounds(boundsA, boundsB) {
	  var props = ['bottom', 'height', 'left', 'right', 'top', 'width', 'x', 'y'];
	  var matches = true;

	  for (var _i = 0, _props = props; _i < _props.length; _i++) {
	    var prop = _props[_i];

	    if (boundsA[prop] !== boundsB[prop]) {
	      matches = false;
	      break;
	    }
	  }

	  return matches;
	}
	function dimensionsChanged(cur, last) {
	  if (!last) return true;
	  if (cur.height !== last.height) return true;
	  if (cur.width !== last.width) return true;
	  return false;
	}

	function add_css$l(target) {
	  append_styles(target, "svelte-1rulc65", ".dual-axis-container.svelte-1rulc65.svelte-1rulc65{position:relative}.y-axis-label.svelte-1rulc65.svelte-1rulc65{text-align:right}.y-axis-label.svelte-1rulc65 span.svelte-1rulc65{max-width:115px;display:inline-block}.y-axis-label.svelte-1rulc65.svelte-1rulc65::after{content:'â²';vertical-align:top;margin-left:4px;font-size:12px}.x-axis-label.svelte-1rulc65.svelte-1rulc65{margin-top:10px;text-align:left;max-width:140px}.label-bottom.svelte-1rulc65.svelte-1rulc65::after{content:'âº';margin-left:4px;font-size:12px}");
	}

	var get_renderer_slot_changes = function get_renderer_slot_changes(dirty) {
	  return {
	    width: dirty[0] &
	    /*width*/
	    128,
	    height: dirty[0] &
	    /*height*/
	    256
	  };
	};

	var get_renderer_slot_context = function get_renderer_slot_context(ctx) {
	  return {
	    width:
	    /*width*/
	    ctx[7],
	    height:
	    /*height*/
	    ctx[8],
	    afterRenderDraw:
	    /*afterDrawRender*/
	    ctx[25]
	  };
	};

	var get_x_axis_slot_changes = function get_x_axis_slot_changes(dirty) {
	  return {
	    xRange: dirty[0] &
	    /*xRange*/
	    512
	  };
	};

	var get_x_axis_slot_context = function get_x_axis_slot_context(ctx) {
	  return {
	    xRange:
	    /*xRange*/
	    ctx[9],
	    afterRenderX:
	    /*afterXAxisRender*/
	    ctx[24]
	  };
	};

	var get_y_axis_slot_changes = function get_y_axis_slot_changes(dirty) {
	  return {
	    yRange: dirty[0] &
	    /*yRange*/
	    1024
	  };
	};

	var get_y_axis_slot_context = function get_y_axis_slot_context(ctx) {
	  return {
	    yRange:
	    /*yRange*/
	    ctx[10],
	    afterRenderY:
	    /*afterYAxisRender*/
	    ctx[23]
	  };
	}; // (227:2) {#if yAxisLabel}


	function create_if_block_4$4(ctx) {
	  var div;
	  var span;
	  var t;
	  return {
	    c: function c() {
	      div = element("div");
	      span = element("span");
	      t = text(
	      /*yAxisLabel*/
	      ctx[2]);
	      attr(span, "class", "svelte-1rulc65");
	      attr(div, "class", "label-top y-axis-label svelte-1rulc65");
	      set_style(div, "margin-right",
	      /*margin*/
	      ctx[3].right + "px");
	    },
	    m: function m(target, anchor) {
	      insert(target, div, anchor);
	      append(div, span);
	      append(span, t);
	    },
	    p: function p(ctx, dirty) {
	      if (dirty[0] &
	      /*yAxisLabel*/
	      4) set_data(t,
	      /*yAxisLabel*/
	      ctx[2]);

	      if (dirty[0] &
	      /*margin*/
	      8) {
	        set_style(div, "margin-right",
	        /*margin*/
	        ctx[3].right + "px");
	      }
	    },
	    d: function d(detaching) {
	      if (detaching) detach(div);
	    }
	  };
	} // (248:6) {#if readyToRenderYAxis}


	function create_if_block_3$5(ctx) {
	  var g;
	  var current;
	  var y_axis_slot_template =
	  /*#slots*/
	  ctx[40]["y-axis"];
	  var y_axis_slot = create_slot(y_axis_slot_template, ctx,
	  /*$$scope*/
	  ctx[39], get_y_axis_slot_context);
	  return {
	    c: function c() {
	      g = svg_element("g");
	      if (y_axis_slot) y_axis_slot.c();
	      attr(g, "class", "y-axis-outer");
	      attr(g, "style",
	      /*yAxisStyle*/
	      ctx[17]);
	    },
	    m: function m(target, anchor) {
	      insert(target, g, anchor);

	      if (y_axis_slot) {
	        y_axis_slot.m(g, null);
	      }
	      /*g_binding*/


	      ctx[41](g);
	      current = true;
	    },
	    p: function p(ctx, dirty) {
	      if (y_axis_slot) {
	        if (y_axis_slot.p && (!current || dirty[0] &
	        /*yRange*/
	        1024 | dirty[1] &
	        /*$$scope*/
	        256)) {
	          update_slot_base(y_axis_slot, y_axis_slot_template, ctx,
	          /*$$scope*/
	          ctx[39], !current ? get_all_dirty_from_scope(
	          /*$$scope*/
	          ctx[39]) : get_slot_changes(y_axis_slot_template,
	          /*$$scope*/
	          ctx[39], dirty, get_y_axis_slot_changes), get_y_axis_slot_context);
	        }
	      }

	      if (!current || dirty[0] &
	      /*yAxisStyle*/
	      131072) {
	        attr(g, "style",
	        /*yAxisStyle*/
	        ctx[17]);
	      }
	    },
	    i: function i(local) {
	      if (current) return;
	      transition_in(y_axis_slot, local);
	      current = true;
	    },
	    o: function o(local) {
	      transition_out(y_axis_slot, local);
	      current = false;
	    },
	    d: function d(detaching) {
	      if (detaching) detach(g);
	      if (y_axis_slot) y_axis_slot.d(detaching);
	      /*g_binding*/

	      ctx[41](null);
	    }
	  };
	} // (261:6) {#if readyToRenderXAxis}


	function create_if_block_2$7(ctx) {
	  var g;
	  var current;
	  var x_axis_slot_template =
	  /*#slots*/
	  ctx[40]["x-axis"];
	  var x_axis_slot = create_slot(x_axis_slot_template, ctx,
	  /*$$scope*/
	  ctx[39], get_x_axis_slot_context);
	  return {
	    c: function c() {
	      g = svg_element("g");
	      if (x_axis_slot) x_axis_slot.c();
	      attr(g, "class", "x-axis-outer");
	      attr(g, "style",
	      /*xAxisStyle*/
	      ctx[16]);
	    },
	    m: function m(target, anchor) {
	      insert(target, g, anchor);

	      if (x_axis_slot) {
	        x_axis_slot.m(g, null);
	      }
	      /*g_binding_1*/


	      ctx[42](g);
	      current = true;
	    },
	    p: function p(ctx, dirty) {
	      if (x_axis_slot) {
	        if (x_axis_slot.p && (!current || dirty[0] &
	        /*xRange*/
	        512 | dirty[1] &
	        /*$$scope*/
	        256)) {
	          update_slot_base(x_axis_slot, x_axis_slot_template, ctx,
	          /*$$scope*/
	          ctx[39], !current ? get_all_dirty_from_scope(
	          /*$$scope*/
	          ctx[39]) : get_slot_changes(x_axis_slot_template,
	          /*$$scope*/
	          ctx[39], dirty, get_x_axis_slot_changes), get_x_axis_slot_context);
	        }
	      }

	      if (!current || dirty[0] &
	      /*xAxisStyle*/
	      65536) {
	        attr(g, "style",
	        /*xAxisStyle*/
	        ctx[16]);
	      }
	    },
	    i: function i(local) {
	      if (current) return;
	      transition_in(x_axis_slot, local);
	      current = true;
	    },
	    o: function o(local) {
	      transition_out(x_axis_slot, local);
	      current = false;
	    },
	    d: function d(detaching) {
	      if (detaching) detach(g);
	      if (x_axis_slot) x_axis_slot.d(detaching);
	      /*g_binding_1*/

	      ctx[42](null);
	    }
	  };
	} // (281:8) {#if readyToRender}


	function create_if_block_1$d(ctx) {
	  var rect;
	  var current;
	  var renderer_slot_template =
	  /*#slots*/
	  ctx[40].renderer;
	  var renderer_slot = create_slot(renderer_slot_template, ctx,
	  /*$$scope*/
	  ctx[39], get_renderer_slot_context);
	  return {
	    c: function c() {
	      rect = svg_element("rect");
	      if (renderer_slot) renderer_slot.c();
	      attr(rect, "class", "extents");
	      attr(rect, "x", "0");
	      attr(rect, "y", "0");
	      attr(rect, "width",
	      /*width*/
	      ctx[7]);
	      attr(rect, "height",
	      /*height*/
	      ctx[8]);
	    },
	    m: function m(target, anchor) {
	      insert(target, rect, anchor);

	      if (renderer_slot) {
	        renderer_slot.m(target, anchor);
	      }

	      current = true;
	    },
	    p: function p(ctx, dirty) {
	      if (!current || dirty[0] &
	      /*width*/
	      128) {
	        attr(rect, "width",
	        /*width*/
	        ctx[7]);
	      }

	      if (!current || dirty[0] &
	      /*height*/
	      256) {
	        attr(rect, "height",
	        /*height*/
	        ctx[8]);
	      }

	      if (renderer_slot) {
	        if (renderer_slot.p && (!current || dirty[0] &
	        /*width, height*/
	        384 | dirty[1] &
	        /*$$scope*/
	        256)) {
	          update_slot_base(renderer_slot, renderer_slot_template, ctx,
	          /*$$scope*/
	          ctx[39], !current ? get_all_dirty_from_scope(
	          /*$$scope*/
	          ctx[39]) : get_slot_changes(renderer_slot_template,
	          /*$$scope*/
	          ctx[39], dirty, get_renderer_slot_changes), get_renderer_slot_context);
	        }
	      }
	    },
	    i: function i(local) {
	      if (current) return;
	      transition_in(renderer_slot, local);
	      current = true;
	    },
	    o: function o(local) {
	      transition_out(renderer_slot, local);
	      current = false;
	    },
	    d: function d(detaching) {
	      if (detaching) detach(rect);
	      if (renderer_slot) renderer_slot.d(detaching);
	    }
	  };
	} // (294:2) {#if xAxisLabel}


	function create_if_block$h(ctx) {
	  var div1;
	  var div0;
	  var span;
	  var t;
	  return {
	    c: function c() {
	      div1 = element("div");
	      div0 = element("div");
	      span = element("span");
	      t = text(
	      /*xAxisLabel*/
	      ctx[1]);
	      attr(div0, "class", "label-bottom x-axis-label svelte-1rulc65");
	      set_style(div0, "margin-left",
	      /*yAxisInnerPaddingLeft*/
	      ctx[0] +
	      /*margin*/
	      ctx[3].left - 4 + "px");
	      attr(div1, "class", "chart-footer");
	    },
	    m: function m(target, anchor) {
	      insert(target, div1, anchor);
	      append(div1, div0);
	      append(div0, span);
	      append(span, t);
	    },
	    p: function p(ctx, dirty) {
	      if (dirty[0] &
	      /*xAxisLabel*/
	      2) set_data(t,
	      /*xAxisLabel*/
	      ctx[1]);

	      if (dirty[0] &
	      /*yAxisInnerPaddingLeft, margin*/
	      9) {
	        set_style(div0, "margin-left",
	        /*yAxisInnerPaddingLeft*/
	        ctx[0] +
	        /*margin*/
	        ctx[3].left - 4 + "px");
	      }
	    },
	    d: function d(detaching) {
	      if (detaching) detach(div1);
	    }
	  };
	}

	function create_fragment$t(ctx) {
	  var div;
	  var t0;
	  var svg;
	  var g1;
	  var if_block1_anchor;
	  var g0;
	  var t1;
	  var div_class_value;
	  var div_resize_listener;
	  var current;
	  var if_block0 =
	  /*yAxisLabel*/
	  ctx[2] && create_if_block_4$4(ctx);
	  var if_block1 =
	  /*readyToRenderYAxis*/
	  ctx[22] && create_if_block_3$5(ctx);
	  var if_block2 =
	  /*readyToRenderXAxis*/
	  ctx[21] && create_if_block_2$7(ctx);
	  var if_block3 =
	  /*readyToRender*/
	  ctx[20] && create_if_block_1$d(ctx);
	  var if_block4 =
	  /*xAxisLabel*/
	  ctx[1] && create_if_block$h(ctx);
	  return {
	    c: function c() {
	      div = element("div");
	      if (if_block0) if_block0.c();
	      t0 = space();
	      svg = svg_element("svg");
	      g1 = svg_element("g");
	      if (if_block1) if_block1.c();
	      if_block1_anchor = empty();
	      if (if_block2) if_block2.c();
	      g0 = svg_element("g");
	      if (if_block3) if_block3.c();
	      t1 = space();
	      if (if_block4) if_block4.c();
	      attr(g0, "class", "draw-container");
	      attr(g0, "style",
	      /*drawRegionStyle*/
	      ctx[15]);
	      attr(g0, "data-width",
	      /*width*/
	      ctx[7]);
	      attr(g0, "data-height",
	      /*height*/
	      ctx[8]);
	      attr(g1, "class", "margin");
	      set_style(g1, "transform", "translate(" +
	      /*margin*/
	      ctx[3].left + "px, " +
	      /*margin*/
	      ctx[3].top + "px)");
	      attr(svg, "class", "svg-wrapper");
	      set_style(svg, "width", (
	      /*readyWithBounds*/
	      ctx[19] ?
	      /*marginBounds*/
	      ctx[6].width : 100) + "px");
	      set_style(svg, "height", (
	      /*readyWithBounds*/
	      ctx[19] ?
	      /*marginBounds*/
	      ctx[6].height : 100) + "px");
	      attr(div, "class", div_class_value = "dual-axis-container " + (
	      /*isMobile*/
	      ctx[18] ? 'mobile' : '') + " svelte-1rulc65");
	      add_render_callback(function () {
	        return (
	          /*div_elementresize_handler*/
	          ctx[46].call(div)
	        );
	      });
	    },
	    m: function m(target, anchor) {
	      insert(target, div, anchor);
	      if (if_block0) if_block0.m(div, null);
	      append(div, t0);
	      append(div, svg);
	      append(svg, g1);
	      if (if_block1) if_block1.m(g1, null);
	      append(g1, if_block1_anchor);
	      if (if_block2) if_block2.m(g1, null);
	      append(g1, g0);
	      if (if_block3) if_block3.m(g0, null);
	      /*g0_binding*/

	      ctx[43](g0);
	      /*g1_binding*/

	      ctx[44](g1);
	      append(div, t1);
	      if (if_block4) if_block4.m(div, null);
	      /*div_binding*/

	      ctx[45](div);
	      div_resize_listener = add_resize_listener(div,
	      /*div_elementresize_handler*/
	      ctx[46].bind(div));
	      current = true;
	    },
	    p: function p(ctx, dirty) {
	      if (
	      /*yAxisLabel*/
	      ctx[2]) {
	        if (if_block0) {
	          if_block0.p(ctx, dirty);
	        } else {
	          if_block0 = create_if_block_4$4(ctx);
	          if_block0.c();
	          if_block0.m(div, t0);
	        }
	      } else if (if_block0) {
	        if_block0.d(1);
	        if_block0 = null;
	      }

	      if (
	      /*readyToRenderYAxis*/
	      ctx[22]) {
	        if (if_block1) {
	          if_block1.p(ctx, dirty);

	          if (dirty[0] &
	          /*readyToRenderYAxis*/
	          4194304) {
	            transition_in(if_block1, 1);
	          }
	        } else {
	          if_block1 = create_if_block_3$5(ctx);
	          if_block1.c();
	          transition_in(if_block1, 1);
	          if_block1.m(g1, if_block1_anchor);
	        }
	      } else if (if_block1) {
	        group_outros();
	        transition_out(if_block1, 1, 1, function () {
	          if_block1 = null;
	        });
	        check_outros();
	      }

	      if (
	      /*readyToRenderXAxis*/
	      ctx[21]) {
	        if (if_block2) {
	          if_block2.p(ctx, dirty);

	          if (dirty[0] &
	          /*readyToRenderXAxis*/
	          2097152) {
	            transition_in(if_block2, 1);
	          }
	        } else {
	          if_block2 = create_if_block_2$7(ctx);
	          if_block2.c();
	          transition_in(if_block2, 1);
	          if_block2.m(g1, g0);
	        }
	      } else if (if_block2) {
	        group_outros();
	        transition_out(if_block2, 1, 1, function () {
	          if_block2 = null;
	        });
	        check_outros();
	      }

	      if (
	      /*readyToRender*/
	      ctx[20]) {
	        if (if_block3) {
	          if_block3.p(ctx, dirty);

	          if (dirty[0] &
	          /*readyToRender*/
	          1048576) {
	            transition_in(if_block3, 1);
	          }
	        } else {
	          if_block3 = create_if_block_1$d(ctx);
	          if_block3.c();
	          transition_in(if_block3, 1);
	          if_block3.m(g0, null);
	        }
	      } else if (if_block3) {
	        group_outros();
	        transition_out(if_block3, 1, 1, function () {
	          if_block3 = null;
	        });
	        check_outros();
	      }

	      if (!current || dirty[0] &
	      /*drawRegionStyle*/
	      32768) {
	        attr(g0, "style",
	        /*drawRegionStyle*/
	        ctx[15]);
	      }

	      if (!current || dirty[0] &
	      /*width*/
	      128) {
	        attr(g0, "data-width",
	        /*width*/
	        ctx[7]);
	      }

	      if (!current || dirty[0] &
	      /*height*/
	      256) {
	        attr(g0, "data-height",
	        /*height*/
	        ctx[8]);
	      }

	      if (!current || dirty[0] &
	      /*margin*/
	      8) {
	        set_style(g1, "transform", "translate(" +
	        /*margin*/
	        ctx[3].left + "px, " +
	        /*margin*/
	        ctx[3].top + "px)");
	      }

	      if (!current || dirty[0] &
	      /*readyWithBounds, marginBounds*/
	      524352) {
	        set_style(svg, "width", (
	        /*readyWithBounds*/
	        ctx[19] ?
	        /*marginBounds*/
	        ctx[6].width : 100) + "px");
	      }

	      if (!current || dirty[0] &
	      /*readyWithBounds, marginBounds*/
	      524352) {
	        set_style(svg, "height", (
	        /*readyWithBounds*/
	        ctx[19] ?
	        /*marginBounds*/
	        ctx[6].height : 100) + "px");
	      }

	      if (
	      /*xAxisLabel*/
	      ctx[1]) {
	        if (if_block4) {
	          if_block4.p(ctx, dirty);
	        } else {
	          if_block4 = create_if_block$h(ctx);
	          if_block4.c();
	          if_block4.m(div, null);
	        }
	      } else if (if_block4) {
	        if_block4.d(1);
	        if_block4 = null;
	      }

	      if (!current || dirty[0] &
	      /*isMobile*/
	      262144 && div_class_value !== (div_class_value = "dual-axis-container " + (
	      /*isMobile*/
	      ctx[18] ? 'mobile' : '') + " svelte-1rulc65")) {
	        attr(div, "class", div_class_value);
	      }
	    },
	    i: function i(local) {
	      if (current) return;
	      transition_in(if_block1);
	      transition_in(if_block2);
	      transition_in(if_block3);
	      current = true;
	    },
	    o: function o(local) {
	      transition_out(if_block1);
	      transition_out(if_block2);
	      transition_out(if_block3);
	      current = false;
	    },
	    d: function d(detaching) {
	      if (detaching) detach(div);
	      if (if_block0) if_block0.d();
	      if (if_block1) if_block1.d();
	      if (if_block2) if_block2.d();
	      if (if_block3) if_block3.d();
	      /*g0_binding*/

	      ctx[43](null);
	      /*g1_binding*/

	      ctx[44](null);
	      if (if_block4) if_block4.d();
	      /*div_binding*/

	      ctx[45](null);
	      div_resize_listener();
	    }
	  };
	}

	function instance$t($$self, $$props, $$invalidate) {
	  var readyToRenderYAxis;
	  var readyToRenderXAxis;
	  var readyToRender;
	  var readyWithBounds;
	  var isMobile;
	  var minHeightOption;
	  var _$$props$$$slots = $$props.$$slots,
	      slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots,
	      $$scope = $$props.$$scope;
	  var env = $$props.env;
	  var _$$props$aspectRatio = $$props.aspectRatio,
	      aspectRatio = _$$props$aspectRatio === void 0 ? 2.5 : _$$props$aspectRatio; // '5:2'

	  var _$$props$yAxisInnerPa = $$props.yAxisInnerPadding,
	      yAxisInnerPadding = _$$props$yAxisInnerPa === void 0 ? 0 : _$$props$yAxisInnerPa;
	  var _$$props$yAxisInnerPa2 = $$props.yAxisInnerPaddingLeft,
	      yAxisInnerPaddingLeft = _$$props$yAxisInnerPa2 === void 0 ? 0 : _$$props$yAxisInnerPa2;
	  var _$$props$yAxisInnerPa3 = $$props.yAxisInnerPaddingRight,
	      yAxisInnerPaddingRight = _$$props$yAxisInnerPa3 === void 0 ? 25 : _$$props$yAxisInnerPa3;
	  var _$$props$xAxisInnerPa = $$props.xAxisInnerPadding,
	      xAxisInnerPadding = _$$props$xAxisInnerPa === void 0 ? 0 : _$$props$xAxisInnerPa;
	  var _$$props$yAxisPadding = $$props.yAxisPadding,
	      yAxisPadding = _$$props$yAxisPadding === void 0 ? 8 : _$$props$yAxisPadding;
	  var _$$props$xAxisPadding = $$props.xAxisPadding,
	      xAxisPadding = _$$props$xAxisPadding === void 0 ? 0 : _$$props$xAxisPadding;
	  var _$$props$yAxisPositio = $$props.yAxisPosition,
	      yAxisPosition = _$$props$yAxisPositio === void 0 ? 'right' : _$$props$yAxisPositio;
	  var _$$props$xAxisPositio = $$props.xAxisPosition,
	      xAxisPosition = _$$props$xAxisPositio === void 0 ? 'bottom' : _$$props$xAxisPositio;
	  var xAxisLabel = $$props.xAxisLabel;
	  var yAxisLabel = $$props.yAxisLabel;
	  var _$$props$minHeight = $$props.minHeight,
	      minHeight = _$$props$minHeight === void 0 ? 160 : _$$props$minHeight;
	  var _$$props$margin = $$props.margin,
	      margin = _$$props$margin === void 0 ? {
	    top: 24,
	    left: 8,
	    right: 8,
	    bottom: 0
	  } : _$$props$margin;
	  var totalYAxisInnerPadding = yAxisInnerPadding * 2 + yAxisInnerPaddingLeft + yAxisInnerPaddingRight;
	  var clientWidth;
	  var drawRegionNode;
	  var containerNode;
	  var marginNode;
	  var xAxisNode;
	  var yAxisNode;
	  var containerBounds = {};
	  var marginBounds = {};
	  var drawRegionBounds = {};
	  var xAxisBounds = {};
	  var yAxisBounds = {};
	  var width;
	  var height;
	  var xRange;
	  var yRange;
	  var drawRegionStyle;
	  var xAxisStyle;
	  var yAxisStyle;
	  var yAxisWidth = 20;
	  var xAxisHeight = 22; // just some things needed to be compatible
	  // with existing layout system

	  var layoutObj = layoutInterface(env);

	  layoutObj.yAxisInnerPadding = function () {
	    return yAxisInnerPadding;
	  };

	  layoutObj.yAxisPadding = function () {
	    return yAxisPadding;
	  };

	  layoutObj.yAxisInnerPaddingRight = function () {
	    return yAxisInnerPaddingRight;
	  };

	  layoutObj.yAxisInnerPaddingLeft = function () {
	    return yAxisInnerPaddingLeft;
	  };

	  layoutObj.xAxisInnerPadding = function () {
	    return xAxisInnerPadding;
	  };

	  layoutObj.updateBounds = function () {
	    return updateBounds();
	  };

	  layoutObj.width = function () {
	    return width;
	  };

	  layoutObj.outerWidth = function () {
	    return width + yAxisInnerPadding * 2 + yAxisInnerPaddingLeft + yAxisInnerPaddingRight;
	  };

	  layoutObj.height = function () {
	    return height;
	  };

	  layoutObj.outerHeight = function () {
	    return height + xAxisInnerPadding * 2;
	  };

	  layout.set(layoutObj);

	  var boundsReady = function boundsReady(obj) {
	    return obj.top != null;
	  }; // switching from reactive $ to specific variables


	  var afterYAxisRender = function afterYAxisRender() {
	    if (!yAxisNode) return;
	    var newYAxisBounds = yAxisNode.getBoundingClientRect();
	    yAxisWidth = newYAxisBounds.width + yAxisPadding;
	    $$invalidate(7, width = containerNode.offsetWidth - yAxisWidth - margin.left - margin.right - totalYAxisInnerPadding);
	    $$invalidate(9, xRange = [0, width]);

	    if (!equalBounds(yAxisBounds, newYAxisBounds)) {
	      $$invalidate(37, yAxisBounds = yAxisNode.getBoundingClientRect());
	    }
	  };

	  var afterXAxisRender = function afterXAxisRender() {
	    if (!xAxisNode) return;
	    var newXAxisBounds = xAxisNode.getBoundingClientRect();

	    if (!equalBounds(xAxisBounds, newXAxisBounds)) {
	      $$invalidate(36, xAxisBounds = xAxisNode.getBoundingClientRect());
	    }

	    xAxisHeight = xAxisBounds.height + xAxisPadding;

	    if (yAxisPosition === 'right') {
	      $$invalidate(17, yAxisStyle = "transform: translate(".concat(width + totalYAxisInnerPadding, "px, 0)"));
	    } else {
	      $$invalidate(17, yAxisStyle = 'transform: translate(0, 0)');
	    }

	    if (xAxisPosition === 'bottom') {
	      $$invalidate(16, xAxisStyle = "transform: translate(".concat(yAxisInnerPadding, "px, ").concat(height, "px)"));
	    } else {
	      $$invalidate(16, xAxisStyle = "transform: translate(".concat(yAxisInnerPadding, "px, 0)"));
	    }

	    var leftPos = yAxisPosition === 'right' ? yAxisInnerPadding + yAxisInnerPaddingLeft : yAxisInnerPadding + yAxisInnerPaddingLeft + yAxisWidth;
	    var topPos = xAxisPosition === 'bottom' ? xAxisInnerPadding : xAxisInnerPadding + xAxisHeight;
	    $$invalidate(15, drawRegionStyle = "transform: translate(".concat(leftPos, "px, ").concat(topPos, "px)"));
	    range$1.set(width, height); // allow other components to read dimensions

	    updateBounds();
	    dimensions.set({
	      width: width,
	      height: height,
	      outerWidth: width + totalYAxisInnerPadding,
	      outerHeight: height + 2 * xAxisInnerPadding,
	      marginTop: margin.top,
	      top: drawRegionBounds.top - containerBounds.top,
	      left: leftPos + margin.left
	    }); // render the rest and then call afterDraw

	    setTimeout(afterDrawRender, 10);
	  };

	  var afterDrawRender = function afterDrawRender() {
	    // some axes have hooks on postLayout (from old system)
	    env.layout.emitPostLayout(env.el, env);
	  };

	  var updateBounds = function updateBounds() {
	    if (!(containerNode && containerNode.parentElement)) return;
	    var newContainerBounds = containerNode.parentElement.getBoundingClientRect();
	    var newDrawRegionBounds = drawRegionNode.getBoundingClientRect();
	    var newMarginBounds = marginNode.getBoundingClientRect();

	    if (!equalBounds(containerBounds, newContainerBounds)) {
	      containerBounds = newContainerBounds;
	    }

	    if (!equalBounds(drawRegionBounds, newDrawRegionBounds)) {
	      drawRegionBounds = drawRegionNode.getBoundingClientRect();
	    }

	    if (!equalBounds(marginBounds, newMarginBounds)) {
	      $$invalidate(6, marginBounds = marginNode.getBoundingClientRect());
	    }
	  }; // provide a mechanism to update all bounds after an exernal
	  // change -- like the label placement operation


	  layoutObj.updateAllBounds = function () {
	    afterYAxisRender(); // because this gets called after placeVerticalAxisLabel

	    updateBounds();
	  };

	  function g_binding($$value) {
	    binding_callbacks[$$value ? 'unshift' : 'push'](function () {
	      yAxisNode = $$value;
	      $$invalidate(14, yAxisNode);
	    });
	  }

	  function g_binding_1($$value) {
	    binding_callbacks[$$value ? 'unshift' : 'push'](function () {
	      xAxisNode = $$value;
	      $$invalidate(13, xAxisNode);
	    });
	  }

	  function g0_binding($$value) {
	    binding_callbacks[$$value ? 'unshift' : 'push'](function () {
	      drawRegionNode = $$value;
	      $$invalidate(11, drawRegionNode);
	    });
	  }

	  function g1_binding($$value) {
	    binding_callbacks[$$value ? 'unshift' : 'push'](function () {
	      marginNode = $$value;
	      $$invalidate(12, marginNode);
	    });
	  }

	  function div_binding($$value) {
	    binding_callbacks[$$value ? 'unshift' : 'push'](function () {
	      containerNode = $$value;
	      $$invalidate(5, containerNode);
	    });
	  }

	  function div_elementresize_handler() {
	    clientWidth = this.clientWidth;
	    $$invalidate(4, clientWidth);
	  }

	  $$self.$$set = function ($$props) {
	    if ('env' in $$props) $$invalidate(26, env = $$props.env);
	    if ('aspectRatio' in $$props) $$invalidate(27, aspectRatio = $$props.aspectRatio);
	    if ('yAxisInnerPadding' in $$props) $$invalidate(28, yAxisInnerPadding = $$props.yAxisInnerPadding);
	    if ('yAxisInnerPaddingLeft' in $$props) $$invalidate(0, yAxisInnerPaddingLeft = $$props.yAxisInnerPaddingLeft);
	    if ('yAxisInnerPaddingRight' in $$props) $$invalidate(29, yAxisInnerPaddingRight = $$props.yAxisInnerPaddingRight);
	    if ('xAxisInnerPadding' in $$props) $$invalidate(30, xAxisInnerPadding = $$props.xAxisInnerPadding);
	    if ('yAxisPadding' in $$props) $$invalidate(31, yAxisPadding = $$props.yAxisPadding);
	    if ('xAxisPadding' in $$props) $$invalidate(32, xAxisPadding = $$props.xAxisPadding);
	    if ('yAxisPosition' in $$props) $$invalidate(33, yAxisPosition = $$props.yAxisPosition);
	    if ('xAxisPosition' in $$props) $$invalidate(34, xAxisPosition = $$props.xAxisPosition);
	    if ('xAxisLabel' in $$props) $$invalidate(1, xAxisLabel = $$props.xAxisLabel);
	    if ('yAxisLabel' in $$props) $$invalidate(2, yAxisLabel = $$props.yAxisLabel);
	    if ('minHeight' in $$props) $$invalidate(35, minHeight = $$props.minHeight);
	    if ('margin' in $$props) $$invalidate(3, margin = $$props.margin);
	    if ('$$scope' in $$props) $$invalidate(39, $$scope = $$props.$$scope);
	  };

	  $$self.$$.update = function () {
	    if ($$self.$$.dirty[0] &
	    /*env*/
	    67108864 | $$self.$$.dirty[1] &
	    /*minHeight*/
	    16) {
	      $$invalidate(38, minHeightOption = env.options.minHeight || minHeight);
	    }

	    if ($$self.$$.dirty[0] &
	    /*containerNode, clientWidth, margin, aspectRatio, height*/
	    134218040 | $$self.$$.dirty[1] &
	    /*minHeightOption*/
	    128) {
	      {
	        if (containerNode != null && clientWidth) {
	          $$invalidate(8, height = Math.max(minHeightOption, (containerNode.parentElement.offsetWidth - margin.left - margin.right) / aspectRatio));
	          $$invalidate(10, yRange = [height, 0]);
	        }
	      }
	    }

	    if ($$self.$$.dirty[0] &
	    /*containerNode, height, yRange*/
	    1312) {
	      // The Render order that takes place is:
	      // first the y axis is rendered, then width calculation takes place
	      // then the x axis is rendered
	      // then we can finally know the full bounds so readyToRender triggers
	      // the rest
	      $$invalidate(22, readyToRenderYAxis = containerNode != null && height != null && yRange != null);
	    }

	    if ($$self.$$.dirty[0] &
	    /*xRange*/
	    512 | $$self.$$.dirty[1] &
	    /*yAxisBounds*/
	    64) {
	      $$invalidate(21, readyToRenderXAxis = boundsReady(yAxisBounds) && xRange != null);
	    }

	    if ($$self.$$.dirty[1] &
	    /*yAxisBounds, xAxisBounds*/
	    96) {
	      $$invalidate(20, readyToRender = boundsReady(yAxisBounds) && boundsReady(xAxisBounds));
	    }

	    if ($$self.$$.dirty[0] &
	    /*marginBounds*/
	    64) {
	      $$invalidate(19, readyWithBounds = boundsReady(marginBounds));
	    }

	    if ($$self.$$.dirty[0] &
	    /*width*/
	    128) {
	      $$invalidate(18, isMobile = isMobileWidth(width));
	    }
	  };

	  return [yAxisInnerPaddingLeft, xAxisLabel, yAxisLabel, margin, clientWidth, containerNode, marginBounds, width, height, xRange, yRange, drawRegionNode, marginNode, xAxisNode, yAxisNode, drawRegionStyle, xAxisStyle, yAxisStyle, isMobile, readyWithBounds, readyToRender, readyToRenderXAxis, readyToRenderYAxis, afterYAxisRender, afterXAxisRender, afterDrawRender, env, aspectRatio, yAxisInnerPadding, yAxisInnerPaddingRight, xAxisInnerPadding, yAxisPadding, xAxisPadding, yAxisPosition, xAxisPosition, minHeight, xAxisBounds, yAxisBounds, minHeightOption, $$scope, slots, g_binding, g_binding_1, g0_binding, g1_binding, div_binding, div_elementresize_handler];
	}

	var DualAxisLayout = /*#__PURE__*/function (_SvelteComponent) {
	  _inherits(DualAxisLayout, _SvelteComponent);

	  var _super = _createSuper(DualAxisLayout);

	  function DualAxisLayout(options) {
	    var _this;

	    _classCallCheck(this, DualAxisLayout);

	    _this = _super.call(this);
	    init(_assertThisInitialized(_this), options, instance$t, create_fragment$t, safe_not_equal, {
	      env: 26,
	      aspectRatio: 27,
	      yAxisInnerPadding: 28,
	      yAxisInnerPaddingLeft: 0,
	      yAxisInnerPaddingRight: 29,
	      xAxisInnerPadding: 30,
	      yAxisPadding: 31,
	      xAxisPadding: 32,
	      yAxisPosition: 33,
	      xAxisPosition: 34,
	      xAxisLabel: 1,
	      yAxisLabel: 2,
	      minHeight: 35,
	      margin: 3
	    }, add_css$l, [-1, -1]);
	    return _this;
	  }

	  _createClass(DualAxisLayout, [{
	    key: "env",
	    get: function get() {
	      return this.$$.ctx[26];
	    },
	    set: function set(env) {
	      this.$$set({
	        env: env
	      });
	      flush();
	    }
	  }, {
	    key: "aspectRatio",
	    get: function get() {
	      return this.$$.ctx[27];
	    },
	    set: function set(aspectRatio) {
	      this.$$set({
	        aspectRatio: aspectRatio
	      });
	      flush();
	    }
	  }, {
	    key: "yAxisInnerPadding",
	    get: function get() {
	      return this.$$.ctx[28];
	    },
	    set: function set(yAxisInnerPadding) {
	      this.$$set({
	        yAxisInnerPadding: yAxisInnerPadding
	      });
	      flush();
	    }
	  }, {
	    key: "yAxisInnerPaddingLeft",
	    get: function get() {
	      return this.$$.ctx[0];
	    },
	    set: function set(yAxisInnerPaddingLeft) {
	      this.$$set({
	        yAxisInnerPaddingLeft: yAxisInnerPaddingLeft
	      });
	      flush();
	    }
	  }, {
	    key: "yAxisInnerPaddingRight",
	    get: function get() {
	      return this.$$.ctx[29];
	    },
	    set: function set(yAxisInnerPaddingRight) {
	      this.$$set({
	        yAxisInnerPaddingRight: yAxisInnerPaddingRight
	      });
	      flush();
	    }
	  }, {
	    key: "xAxisInnerPadding",
	    get: function get() {
	      return this.$$.ctx[30];
	    },
	    set: function set(xAxisInnerPadding) {
	      this.$$set({
	        xAxisInnerPadding: xAxisInnerPadding
	      });
	      flush();
	    }
	  }, {
	    key: "yAxisPadding",
	    get: function get() {
	      return this.$$.ctx[31];
	    },
	    set: function set(yAxisPadding) {
	      this.$$set({
	        yAxisPadding: yAxisPadding
	      });
	      flush();
	    }
	  }, {
	    key: "xAxisPadding",
	    get: function get() {
	      return this.$$.ctx[32];
	    },
	    set: function set(xAxisPadding) {
	      this.$$set({
	        xAxisPadding: xAxisPadding
	      });
	      flush();
	    }
	  }, {
	    key: "yAxisPosition",
	    get: function get() {
	      return this.$$.ctx[33];
	    },
	    set: function set(yAxisPosition) {
	      this.$$set({
	        yAxisPosition: yAxisPosition
	      });
	      flush();
	    }
	  }, {
	    key: "xAxisPosition",
	    get: function get() {
	      return this.$$.ctx[34];
	    },
	    set: function set(xAxisPosition) {
	      this.$$set({
	        xAxisPosition: xAxisPosition
	      });
	      flush();
	    }
	  }, {
	    key: "xAxisLabel",
	    get: function get() {
	      return this.$$.ctx[1];
	    },
	    set: function set(xAxisLabel) {
	      this.$$set({
	        xAxisLabel: xAxisLabel
	      });
	      flush();
	    }
	  }, {
	    key: "yAxisLabel",
	    get: function get() {
	      return this.$$.ctx[2];
	    },
	    set: function set(yAxisLabel) {
	      this.$$set({
	        yAxisLabel: yAxisLabel
	      });
	      flush();
	    }
	  }, {
	    key: "minHeight",
	    get: function get() {
	      return this.$$.ctx[35];
	    },
	    set: function set(minHeight) {
	      this.$$set({
	        minHeight: minHeight
	      });
	      flush();
	    }
	  }, {
	    key: "margin",
	    get: function get() {
	      return this.$$.ctx[3];
	    },
	    set: function set(margin) {
	      this.$$set({
	        margin: margin
	      });
	      flush();
	    }
	  }]);

	  return DualAxisLayout;
	}(SvelteComponent);

	function create_fragment$s(ctx) {
	  var g;
	  var g_class_value;
	  return {
	    c: function c() {
	      g = svg_element("g");
	      attr(g, "class", g_class_value = "axis-wrapper axis axis-" +
	      /*id*/
	      ctx[0]);
	    },
	    m: function m(target, anchor) {
	      insert(target, g, anchor);
	      /*g_binding*/

	      ctx[12](g);
	    },
	    p: function p(ctx, _ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	          dirty = _ref2[0];

	      if (dirty &
	      /*id*/
	      1 && g_class_value !== (g_class_value = "axis-wrapper axis axis-" +
	      /*id*/
	      ctx[0])) {
	        attr(g, "class", g_class_value);
	      }
	    },
	    i: noop,
	    o: noop,
	    d: function d(detaching) {
	      if (detaching) detach(g);
	      /*g_binding*/

	      ctx[12](null);
	    }
	  };
	}

	function instance$s($$self, $$props, $$invalidate) {
	  var env = $$props.env;
	  var field = $$props.field; // pass through if it is a single field

	  var series = $$props.series; // pass through an array of fields if series data

	  var _$$props$id = $$props.id,
	      id = _$$props$id === void 0 ? 'x' : _$$props$id;
	  var _$$props$type = $$props.type,
	      type = _$$props$type === void 0 ? 'linear' : _$$props$type;
	  var _$$props$orientation = $$props.orientation,
	      orientation = _$$props$orientation === void 0 ? 'vertical' : _$$props$orientation;
	  var _$$props$position = $$props.position,
	      position = _$$props$position === void 0 ? 'right' : _$$props$position;
	  var _$$props$range = $$props.range,
	      range = _$$props$range === void 0 ? [0, 100] : _$$props$range;
	  var props = $$props.props;
	  var afterRender = $$props.afterRender;
	  var targetEl;
	  var axisRenderer;
	  var lastRange = [-1, -1];

	  var isSameRange = function isSameRange() {
	    return range[0] === lastRange[0] && range[1] === lastRange[1];
	  };

	  function g_binding($$value) {
	    binding_callbacks[$$value ? 'unshift' : 'push'](function () {
	      targetEl = $$value;
	      $$invalidate(1, targetEl);
	    });
	  }

	  $$self.$$set = function ($$props) {
	    if ('env' in $$props) $$invalidate(2, env = $$props.env);
	    if ('field' in $$props) $$invalidate(3, field = $$props.field);
	    if ('series' in $$props) $$invalidate(4, series = $$props.series);
	    if ('id' in $$props) $$invalidate(0, id = $$props.id);
	    if ('type' in $$props) $$invalidate(5, type = $$props.type);
	    if ('orientation' in $$props) $$invalidate(6, orientation = $$props.orientation);
	    if ('position' in $$props) $$invalidate(7, position = $$props.position);
	    if ('range' in $$props) $$invalidate(8, range = $$props.range);
	    if ('props' in $$props) $$invalidate(9, props = $$props.props);
	    if ('afterRender' in $$props) $$invalidate(10, afterRender = $$props.afterRender);
	  };

	  $$self.$$.update = function () {
	    if ($$self.$$.dirty &
	    /*series, range, orientation, position, field, props, type, axisRenderer, env, targetEl, afterRender, id*/
	    4095) {
	      {
	        var activeProps = _objectSpread2({
	          series: series,
	          range: range,
	          orientation: orientation,
	          position: position,
	          customField: field,
	          skipYAxisExtend: true,
	          isDualAxisLayout: true
	        }, props);

	        if (type === 'linear') {
	          $$invalidate(11, axisRenderer = linearAxisProvider(activeProps));
	        } else if (type === 'band') {
	          $$invalidate(11, axisRenderer = bandAxisProvider(activeProps));
	        } else if (type === 'date') {
	          $$invalidate(11, axisRenderer = dateAxisProvider(activeProps));
	        }

	        axisRenderer.orientation(orientation).position(position).range(range).data(env.data);

	        if (targetEl && !isSameRange()) {
	          lastRange = [range[0], range[1]];
	          axisRenderer(select(targetEl), env);
	          if (afterRender) afterRender(); // set to stores

	          if (id === 'x') {
	            xAxis.set(axisRenderer);
	            $$invalidate(2, env.x = axisRenderer, env); // fallback
	          } else {
	            yAxis.set(axisRenderer);
	            $$invalidate(2, env.y = axisRenderer, env);
	          }
	        }
	      }
	    }
	  };

	  return [id, targetEl, env, field, series, type, orientation, position, range, props, afterRender, axisRenderer, g_binding];
	}

	var AxisWrapper = /*#__PURE__*/function (_SvelteComponent) {
	  _inherits(AxisWrapper, _SvelteComponent);

	  var _super = _createSuper(AxisWrapper);

	  function AxisWrapper(options) {
	    var _this;

	    _classCallCheck(this, AxisWrapper);

	    _this = _super.call(this);
	    init(_assertThisInitialized(_this), options, instance$s, create_fragment$s, safe_not_equal, {
	      env: 2,
	      field: 3,
	      series: 4,
	      id: 0,
	      type: 5,
	      orientation: 6,
	      position: 7,
	      range: 8,
	      props: 9,
	      afterRender: 10
	    });
	    return _this;
	  }

	  _createClass(AxisWrapper, [{
	    key: "env",
	    get: function get() {
	      return this.$$.ctx[2];
	    },
	    set: function set(env) {
	      this.$$set({
	        env: env
	      });
	      flush();
	    }
	  }, {
	    key: "field",
	    get: function get() {
	      return this.$$.ctx[3];
	    },
	    set: function set(field) {
	      this.$$set({
	        field: field
	      });
	      flush();
	    }
	  }, {
	    key: "series",
	    get: function get() {
	      return this.$$.ctx[4];
	    },
	    set: function set(series) {
	      this.$$set({
	        series: series
	      });
	      flush();
	    }
	  }, {
	    key: "id",
	    get: function get() {
	      return this.$$.ctx[0];
	    },
	    set: function set(id) {
	      this.$$set({
	        id: id
	      });
	      flush();
	    }
	  }, {
	    key: "type",
	    get: function get() {
	      return this.$$.ctx[5];
	    },
	    set: function set(type) {
	      this.$$set({
	        type: type
	      });
	      flush();
	    }
	  }, {
	    key: "orientation",
	    get: function get() {
	      return this.$$.ctx[6];
	    },
	    set: function set(orientation) {
	      this.$$set({
	        orientation: orientation
	      });
	      flush();
	    }
	  }, {
	    key: "position",
	    get: function get() {
	      return this.$$.ctx[7];
	    },
	    set: function set(position) {
	      this.$$set({
	        position: position
	      });
	      flush();
	    }
	  }, {
	    key: "range",
	    get: function get() {
	      return this.$$.ctx[8];
	    },
	    set: function set(range) {
	      this.$$set({
	        range: range
	      });
	      flush();
	    }
	  }, {
	    key: "props",
	    get: function get() {
	      return this.$$.ctx[9];
	    },
	    set: function set(props) {
	      this.$$set({
	        props: props
	      });
	      flush();
	    }
	  }, {
	    key: "afterRender",
	    get: function get() {
	      return this.$$.ctx[10];
	    },
	    set: function set(afterRender) {
	      this.$$set({
	        afterRender: afterRender
	      });
	      flush();
	    }
	  }]);

	  return AxisWrapper;
	}(SvelteComponent);

	function create_fragment$r(ctx) {
	  var g;
	  return {
	    c: function c() {
	      g = svg_element("g");
	      attr(g, "class",
	      /*classes*/
	      ctx[2]);
	      attr(g, "data-dimensions",
	      /*dimensions*/
	      ctx[0]);
	    },
	    m: function m(target, anchor) {
	      insert(target, g, anchor);
	      /*g_binding*/

	      ctx[7](g);
	    },
	    p: function p(ctx, _ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	          dirty = _ref2[0];

	      if (dirty &
	      /*classes*/
	      4) {
	        attr(g, "class",
	        /*classes*/
	        ctx[2]);
	      }

	      if (dirty &
	      /*dimensions*/
	      1) {
	        attr(g, "data-dimensions",
	        /*dimensions*/
	        ctx[0]);
	      }
	    },
	    i: noop,
	    o: noop,
	    d: function d(detaching) {
	      if (detaching) detach(g);
	      /*g_binding*/

	      ctx[7](null);
	    }
	  };
	}

	function instance$r($$self, $$props, $$invalidate) {
	  var classes;
	  var env = $$props.env;
	  var dimensions = $$props.dimensions;
	  var _$$props$orientation = $$props.orientation,
	      orientation = _$$props$orientation === void 0 ? 'horizontal' : _$$props$orientation;
	  var _$$props$options = $$props.options,
	      options = _$$props$options === void 0 ? {} : _$$props$options;
	  var DEFAULTS = {
	    verticalGridLength: 8,
	    extendAllVerticalTicks: true,
	    extendVerticalZeroTick: false,
	    gridTransform: null,
	    hideBottomValueTick: orientation === 'horizontal',
	    useInnerPadding: false,
	    fromDualAxisLayout: true,
	    hideAllLinesButZero: false,
	    hideAllGridlines: false
	  };
	  var lastDimensions;
	  var targetNode;
	  var xy = orientation === 'horizontal' ? 'x' : 'y';

	  function g_binding($$value) {
	    binding_callbacks[$$value ? 'unshift' : 'push'](function () {
	      targetNode = $$value;
	      $$invalidate(1, targetNode);
	    });
	  }

	  $$self.$$set = function ($$props) {
	    if ('env' in $$props) $$invalidate(3, env = $$props.env);
	    if ('dimensions' in $$props) $$invalidate(0, dimensions = $$props.dimensions);
	    if ('orientation' in $$props) $$invalidate(4, orientation = $$props.orientation);
	    if ('options' in $$props) $$invalidate(5, options = $$props.options);
	  };

	  $$self.$$.update = function () {
	    if ($$self.$$.dirty &
	    /*dimensions, options, targetNode, lastDimensions, env*/
	    107) {
	      {
	        var gridRenderer = gridlines(_objectSpread2(_objectSpread2({
	          orientation: xy,
	          length: xy === 'x' ? dimensions.outerWidth : dimensions.outerHeight
	        }, DEFAULTS), options));

	        if (targetNode && dimensionsChanged(dimensions, lastDimensions)) {
	          gridRenderer(select(targetNode), env);
	          $$invalidate(6, lastDimensions = dimensions);
	        }
	      }
	    }

	    if ($$self.$$.dirty &
	    /*options*/
	    32) {
	      $$invalidate(2, classes = "\n    grid\n    grid-".concat(xy, "\n    ").concat(options.hideAllLinesButZero ? 'hide-gridlines' : '', "\n    ").concat(options.hideAllGridlines ? 'hide-all-gridlines' : '', "\n  "));
	    }
	  };

	  return [dimensions, targetNode, classes, env, orientation, options, lastDimensions, g_binding];
	}

	var GridLines = /*#__PURE__*/function (_SvelteComponent) {
	  _inherits(GridLines, _SvelteComponent);

	  var _super = _createSuper(GridLines);

	  function GridLines(options) {
	    var _this;

	    _classCallCheck(this, GridLines);

	    _this = _super.call(this);
	    init(_assertThisInitialized(_this), options, instance$r, create_fragment$r, safe_not_equal, {
	      env: 3,
	      dimensions: 0,
	      orientation: 4,
	      options: 5
	    });
	    return _this;
	  }

	  _createClass(GridLines, [{
	    key: "env",
	    get: function get() {
	      return this.$$.ctx[3];
	    },
	    set: function set(env) {
	      this.$$set({
	        env: env
	      });
	      flush();
	    }
	  }, {
	    key: "dimensions",
	    get: function get() {
	      return this.$$.ctx[0];
	    },
	    set: function set(dimensions) {
	      this.$$set({
	        dimensions: dimensions
	      });
	      flush();
	    }
	  }, {
	    key: "orientation",
	    get: function get() {
	      return this.$$.ctx[4];
	    },
	    set: function set(orientation) {
	      this.$$set({
	        orientation: orientation
	      });
	      flush();
	    }
	  }, {
	    key: "options",
	    get: function get() {
	      return this.$$.ctx[5];
	    },
	    set: function set(options) {
	      this.$$set({
	        options: options
	      });
	      flush();
	    }
	  }]);

	  return GridLines;
	}(SvelteComponent);

	function add_css$k(target) {
	  append_styles(target, "svelte-4qjlyl", ".tooltip-hidden-point.svelte-4qjlyl.svelte-4qjlyl{visibility:hidden;position:absolute;pointer-events:none;top:var(--top);left:var(--left);width:10px;height:10px;background-color:rgba(0, 0, 0, 0)}.dvz-tooltip.svelte-4qjlyl.svelte-4qjlyl{position:absolute;z-index:21;top:-1000px;width:auto;min-width:var(--min-width);max-width:400px;padding:7px;border:1px solid #000000;box-shadow:0 0 10px rgba(140,140,140,0.2);background:#ffffff;pointer-events:none;font-size:10px;line-height:12px;position:absolute;left:var(--left);top:var(--top);transform:var(--transform)}.dvz-tooltip.dark.svelte-4qjlyl.svelte-4qjlyl{border-color:#ffffff;color:#ffffff;background-color:#000000;box-shadow:0 0 10px rgba(20,20,20,0.2)}svg.arrow.svelte-4qjlyl.svelte-4qjlyl{position:absolute;overflow:visible;top:var(--top);left:var(--left);width:var(--width);height:var(--height)}path.svelte-4qjlyl.svelte-4qjlyl{fill:#ffffff;stroke:#000000}.dark.svelte-4qjlyl path.svelte-4qjlyl{fill:#000000;stroke:#ffffff}");
	}

	function create_fragment$q(ctx) {
	  var div0;
	  var div0_style_value;
	  var t0;
	  var div1;
	  var t1;
	  var svg;
	  var path;
	  var div1_class_value;
	  var current;
	  var default_slot_template =
	  /*#slots*/
	  ctx[29].default;
	  var default_slot = create_slot(default_slot_template, ctx,
	  /*$$scope*/
	  ctx[28], null);
	  return {
	    c: function c() {
	      div0 = element("div");
	      t0 = space();
	      div1 = element("div");
	      if (default_slot) default_slot.c();
	      t1 = space();
	      svg = svg_element("svg");
	      path = svg_element("path");
	      attr(div0, "class", "tooltip-hidden-point svelte-4qjlyl");
	      attr(div0, "style", div0_style_value = "--left: ".concat(
	      /*left*/
	      ctx[1], "; --top: ").concat(
	      /*top*/
	      ctx[2], ";"));
	      attr(path, "d",
	      /*arrowPathDefinition*/
	      ctx[7]);
	      attr(path, "fill", "white");
	      attr(path, "stroke", "black");
	      attr(path, "class", "svelte-4qjlyl");
	      attr(svg, "class", "arrow svelte-4qjlyl");
	      attr(svg, "style",
	      /*arrowStyle*/
	      ctx[5]);
	      attr(div1, "class", div1_class_value = "dvz-tooltip tt-svelte " + (
	      /*darkTheme*/
	      ctx[0] ? 'dark' : '') + " svelte-4qjlyl");
	      attr(div1, "style",
	      /*style*/
	      ctx[6]);
	    },
	    m: function m(target, anchor) {
	      insert(target, div0, anchor);
	      /*div0_binding*/

	      ctx[30](div0);
	      insert(target, t0, anchor);
	      insert(target, div1, anchor);

	      if (default_slot) {
	        default_slot.m(div1, null);
	      }

	      append(div1, t1);
	      append(div1, svg);
	      append(svg, path);
	      /*div1_binding*/

	      ctx[31](div1);
	      current = true;
	    },
	    p: function p(ctx, dirty) {
	      if (!current || dirty[0] &
	      /*left, top*/
	      6 && div0_style_value !== (div0_style_value = "--left: ".concat(
	      /*left*/
	      ctx[1], "; --top: ").concat(
	      /*top*/
	      ctx[2], ";"))) {
	        attr(div0, "style", div0_style_value);
	      }

	      if (default_slot) {
	        if (default_slot.p && (!current || dirty[0] &
	        /*$$scope*/
	        268435456)) {
	          update_slot_base(default_slot, default_slot_template, ctx,
	          /*$$scope*/
	          ctx[28], !current ? get_all_dirty_from_scope(
	          /*$$scope*/
	          ctx[28]) : get_slot_changes(default_slot_template,
	          /*$$scope*/
	          ctx[28], dirty, null), null);
	        }
	      }

	      if (!current || dirty[0] &
	      /*arrowPathDefinition*/
	      128) {
	        attr(path, "d",
	        /*arrowPathDefinition*/
	        ctx[7]);
	      }

	      if (!current || dirty[0] &
	      /*arrowStyle*/
	      32) {
	        attr(svg, "style",
	        /*arrowStyle*/
	        ctx[5]);
	      }

	      if (!current || dirty[0] &
	      /*darkTheme*/
	      1 && div1_class_value !== (div1_class_value = "dvz-tooltip tt-svelte " + (
	      /*darkTheme*/
	      ctx[0] ? 'dark' : '') + " svelte-4qjlyl")) {
	        attr(div1, "class", div1_class_value);
	      }

	      if (!current || dirty[0] &
	      /*style*/
	      64) {
	        attr(div1, "style",
	        /*style*/
	        ctx[6]);
	      }
	    },
	    i: function i(local) {
	      if (current) return;
	      transition_in(default_slot, local);
	      current = true;
	    },
	    o: function o(local) {
	      transition_out(default_slot, local);
	      current = false;
	    },
	    d: function d(detaching) {
	      if (detaching) detach(div0);
	      /*div0_binding*/

	      ctx[30](null);
	      if (detaching) detach(t0);
	      if (detaching) detach(div1);
	      if (default_slot) default_slot.d(detaching);
	      /*div1_binding*/

	      ctx[31](null);
	    }
	  };
	}

	var TOP = 'TOP';
	var MIDDLE = 'MIDDLE';
	var BOTTOM = 'BOTTOM';
	var LEFT = 'LEFT';
	var RIGHT = 'RIGHT';
	var CENTER = 'CENTER';

	function instance$q($$self, $$props, $$invalidate) {
	  var circleRadius;
	  var circleBuffer;
	  var arrowPoints;
	  var arrowPathDefinition;
	  var translateX;
	  var translateY;
	  var transform;
	  var arrowLeft;
	  var arrowTop;
	  var style;
	  var arrowStyle;
	  var _$$props = $$props,
	      _$$props$$$slots = _$$props.$$slots,
	      slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots,
	      $$scope = _$$props.$$scope;
	  var _$$props2 = $$props,
	      _$$props2$darkTheme = _$$props2.darkTheme,
	      darkTheme = _$$props2$darkTheme === void 0 ? false : _$$props2$darkTheme;
	  var _$$props3 = $$props,
	      left = _$$props3.left;
	  var _$$props4 = $$props,
	      top = _$$props4.top;
	  var _$$props5 = $$props,
	      _$$props5$arrowWidth = _$$props5.arrowWidth,
	      arrowWidth = _$$props5$arrowWidth === void 0 ? 10 : _$$props5$arrowWidth;
	  var _$$props6 = $$props,
	      _$$props6$arrowHeight = _$$props6.arrowHeight,
	      arrowHeight = _$$props6$arrowHeight === void 0 ? 10 : _$$props6$arrowHeight;
	  var _$$props7 = $$props,
	      _$$props7$minWidth = _$$props7.minWidth,
	      minWidth = _$$props7$minWidth === void 0 ? 50 : _$$props7$minWidth;
	  var _$$props8 = $$props,
	      containerEl = _$$props8.containerEl;
	  var orientVertical = TOP;
	  var orientHorizontal = CENTER;
	  var tooltipRef;
	  var pointRef;
	  var pointRect;
	  var containerRect;
	  var rect;
	  var needsPositioning = true;
	  var lastTop;
	  var lastLeft;
	  afterUpdate(function () {
	    var _pointRef, _tooltipRef, _containerEl;

	    // reset orientVertical to top
	    // wait fraction of second so that rect is most up to date
	    $$invalidate(14, pointRect = (_pointRef = pointRef) === null || _pointRef === void 0 ? void 0 : _pointRef.getBoundingClientRect());
	    $$invalidate(16, rect = (_tooltipRef = tooltipRef) === null || _tooltipRef === void 0 ? void 0 : _tooltipRef.getBoundingClientRect());
	    $$invalidate(15, containerRect = (_containerEl = containerEl) === null || _containerEl === void 0 ? void 0 : _containerEl.getBoundingClientRect());
	  });

	  function getArrowPoints(orientH, orientV) {
	    var _LEFT$RIGHT$CENTER$or;

	    var w = arrowWidth;
	    var h = arrowHeight * (orientV === BOTTOM ? -1 : 1);
	    var z = 0.5;
	    return (_LEFT$RIGHT$CENTER$or = {}, _defineProperty(_LEFT$RIGHT$CENTER$or, LEFT, [[z, 0], [z, h], [-w, 0]]), _defineProperty(_LEFT$RIGHT$CENTER$or, RIGHT, [[-z, 0], [-z, h], [w, 0]]), _defineProperty(_LEFT$RIGHT$CENTER$or, CENTER, [[-w, 0], [0, h], [w, 0]]), _LEFT$RIGHT$CENTER$or)[orientH];
	  }

	  function div0_binding($$value) {
	    binding_callbacks[$$value ? 'unshift' : 'push'](function () {
	      pointRef = $$value;
	      $$invalidate(4, pointRef);
	    });
	  }

	  function div1_binding($$value) {
	    binding_callbacks[$$value ? 'unshift' : 'push'](function () {
	      tooltipRef = $$value;
	      $$invalidate(3, tooltipRef);
	    });
	  }

	  $$self.$$set = function ($$new_props) {
	    $$invalidate(33, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
	    if ('darkTheme' in $$new_props) $$invalidate(0, darkTheme = $$new_props.darkTheme);
	    if ('left' in $$new_props) $$invalidate(1, left = $$new_props.left);
	    if ('top' in $$new_props) $$invalidate(2, top = $$new_props.top);
	    if ('arrowWidth' in $$new_props) $$invalidate(8, arrowWidth = $$new_props.arrowWidth);
	    if ('arrowHeight' in $$new_props) $$invalidate(9, arrowHeight = $$new_props.arrowHeight);
	    if ('minWidth' in $$new_props) $$invalidate(10, minWidth = $$new_props.minWidth);
	    if ('containerEl' in $$new_props) $$invalidate(11, containerEl = $$new_props.containerEl);
	    if ('$$scope' in $$new_props) $$invalidate(28, $$scope = $$new_props.$$scope);
	  };

	  $$self.$$.update = function () {
	    var _$$props9, _$$props9$circleRadiu, _$$props9$circleBuffe;

	    if ($$self.$$.dirty[0] &
	    /*needsPositioning, rect, pointRect, containerRect, left, top*/
	    245766) {
	      {
	        if (needsPositioning && rect && pointRect) {
	          var topBoundary = containerRect ? containerRect.top : 0;
	          var leftBoundary = containerRect ? containerRect.left : 0;
	          var rightBoundary = containerRect ? containerRect.right : window.innerWidth;
	          var _pointRect = pointRect,
	              x = _pointRect.left;
	          var _rect = rect,
	              width = _rect.width,
	              y = _rect.top;
	          var rightX = x + width / 2;
	          var leftX = x - width / 2;

	          if (y < topBoundary) {
	            $$invalidate(12, orientVertical = BOTTOM);
	          }

	          if (rightX > rightBoundary) {
	            $$invalidate(13, orientHorizontal = LEFT);
	          } else if (leftX < leftBoundary) {
	            $$invalidate(13, orientHorizontal = RIGHT);
	          } else {
	            $$invalidate(13, orientHorizontal = CENTER);
	          }

	          $$invalidate(19, lastLeft = left);
	          $$invalidate(18, lastTop = top);
	          $$invalidate(17, needsPositioning = false);
	        }
	      }
	    }

	    if ($$self.$$.dirty[0] &
	    /*top, lastTop, left, lastLeft, needsPositioning*/
	    917510) {
	      {
	        $$invalidate(17, needsPositioning = !(top === lastTop && left === lastLeft));

	        if (needsPositioning) {
	          // reset to top
	          $$invalidate(12, orientVertical = TOP);
	        }
	      }
	    }

	    $$invalidate(26, (_$$props9 = $$props, _$$props9$circleRadiu = _$$props9.circleRadius, circleRadius = _$$props9$circleRadiu === void 0 ? 4 : _$$props9$circleRadiu, _$$props9$circleBuffe = _$$props9.circleBuffer, circleBuffer = _$$props9$circleBuffe === void 0 ? 3 : _$$props9$circleBuffe, _$$props9), circleRadius, ($$invalidate(25, circleBuffer), $$invalidate(33, $$props)));

	    if ($$self.$$.dirty[0] &
	    /*orientHorizontal, orientVertical*/
	    12288) {
	      $$invalidate(27, arrowPoints = getArrowPoints(orientHorizontal, orientVertical));
	    }

	    if ($$self.$$.dirty[0] &
	    /*arrowPoints*/
	    134217728) {
	      // we don't need d3-line just to do M0,0L1,0
	      $$invalidate(7, arrowPathDefinition = arrowPoints.map(function (pt, i) {
	        return "".concat(i === 0 ? 'M' : 'L').concat(pt[0], ",").concat(pt[1]);
	      }).join(''));
	    }

	    if ($$self.$$.dirty[0] &
	    /*orientHorizontal*/
	    8192) {
	      var _LEFT$CENTER$RIGHT$or;

	      $$invalidate(24, translateX = (_LEFT$CENTER$RIGHT$or = {}, _defineProperty(_LEFT$CENTER$RIGHT$or, LEFT, '-100%'), _defineProperty(_LEFT$CENTER$RIGHT$or, CENTER, '-50%'), _defineProperty(_LEFT$CENTER$RIGHT$or, RIGHT, '0'), _LEFT$CENTER$RIGHT$or)[orientHorizontal]);
	    }

	    if ($$self.$$.dirty[0] &
	    /*arrowHeight, circleRadius, circleBuffer, orientVertical*/
	    100667904) {
	      var _TOP$BOTTOM$orientVer;

	      $$invalidate(23, translateY = (_TOP$BOTTOM$orientVer = {}, _defineProperty(_TOP$BOTTOM$orientVer, TOP, "calc(-100% - ".concat(arrowHeight + circleRadius + circleBuffer + 1, "px)")), _defineProperty(_TOP$BOTTOM$orientVer, BOTTOM, "".concat(arrowHeight + circleRadius + circleBuffer + 1, "px")), _TOP$BOTTOM$orientVer)[orientVertical]);
	    }

	    if ($$self.$$.dirty[0] &
	    /*translateX, translateY*/
	    25165824) {
	      $$invalidate(22, transform = "translate(".concat(translateX, ", ").concat(translateY, ")"));
	    }

	    if ($$self.$$.dirty[0] &
	    /*orientHorizontal*/
	    8192) {
	      var _LEFT$CENTER$RIGHT$or2;

	      $$invalidate(21, arrowLeft = (_LEFT$CENTER$RIGHT$or2 = {}, _defineProperty(_LEFT$CENTER$RIGHT$or2, LEFT, '100%'), _defineProperty(_LEFT$CENTER$RIGHT$or2, CENTER, '50%'), _defineProperty(_LEFT$CENTER$RIGHT$or2, RIGHT, 0), _LEFT$CENTER$RIGHT$or2)[orientHorizontal]);
	    }

	    if ($$self.$$.dirty[0] &
	    /*orientVertical*/
	    4096) {
	      var _TOP$MIDDLE$BOTTOM$or;

	      $$invalidate(20, arrowTop = (_TOP$MIDDLE$BOTTOM$or = {}, _defineProperty(_TOP$MIDDLE$BOTTOM$or, TOP, '100%'), _defineProperty(_TOP$MIDDLE$BOTTOM$or, MIDDLE, '50%'), _defineProperty(_TOP$MIDDLE$BOTTOM$or, BOTTOM, 0), _TOP$MIDDLE$BOTTOM$or)[orientVertical]);
	    }

	    if ($$self.$$.dirty[0] &
	    /*left, top, minWidth, transform*/
	    4195334) {
	      $$invalidate(6, style = "\n    --left: ".concat(left, ";\n    --top: ").concat(top, ";\n    --min-width: ").concat(minWidth, ";\n    --transform: ").concat(transform, ";\n  "));
	    }

	    if ($$self.$$.dirty[0] &
	    /*arrowWidth, arrowHeight, arrowLeft, arrowTop*/
	    3146496) {
	      $$invalidate(5, arrowStyle = "\n    --width: ".concat(arrowWidth, "px;\n    --height: ").concat(arrowHeight, "px;\n    --left: ").concat(arrowLeft, ";\n    --top: ").concat(arrowTop, ";\n  "));
	    }
	  };

	  $$props = exclude_internal_props($$props);
	  return [darkTheme, left, top, tooltipRef, pointRef, arrowStyle, style, arrowPathDefinition, arrowWidth, arrowHeight, minWidth, containerEl, orientVertical, orientHorizontal, pointRect, containerRect, rect, needsPositioning, lastTop, lastLeft, arrowTop, arrowLeft, transform, translateY, translateX, circleBuffer, circleRadius, arrowPoints, $$scope, slots, div0_binding, div1_binding];
	}

	var Tooltip = /*#__PURE__*/function (_SvelteComponent) {
	  _inherits(Tooltip, _SvelteComponent);

	  var _super = _createSuper(Tooltip);

	  function Tooltip(options) {
	    var _this;

	    _classCallCheck(this, Tooltip);

	    _this = _super.call(this);
	    init(_assertThisInitialized(_this), options, instance$q, create_fragment$q, safe_not_equal, {
	      darkTheme: 0,
	      left: 1,
	      top: 2,
	      arrowWidth: 8,
	      arrowHeight: 9,
	      minWidth: 10,
	      containerEl: 11
	    }, add_css$k, [-1, -1]);
	    return _this;
	  }

	  _createClass(Tooltip, [{
	    key: "darkTheme",
	    get: function get() {
	      return this.$$.ctx[0];
	    },
	    set: function set(darkTheme) {
	      this.$$set({
	        darkTheme: darkTheme
	      });
	      flush();
	    }
	  }, {
	    key: "left",
	    get: function get() {
	      return this.$$.ctx[1];
	    },
	    set: function set(left) {
	      this.$$set({
	        left: left
	      });
	      flush();
	    }
	  }, {
	    key: "top",
	    get: function get() {
	      return this.$$.ctx[2];
	    },
	    set: function set(top) {
	      this.$$set({
	        top: top
	      });
	      flush();
	    }
	  }, {
	    key: "arrowWidth",
	    get: function get() {
	      return this.$$.ctx[8];
	    },
	    set: function set(arrowWidth) {
	      this.$$set({
	        arrowWidth: arrowWidth
	      });
	      flush();
	    }
	  }, {
	    key: "arrowHeight",
	    get: function get() {
	      return this.$$.ctx[9];
	    },
	    set: function set(arrowHeight) {
	      this.$$set({
	        arrowHeight: arrowHeight
	      });
	      flush();
	    }
	  }, {
	    key: "minWidth",
	    get: function get() {
	      return this.$$.ctx[10];
	    },
	    set: function set(minWidth) {
	      this.$$set({
	        minWidth: minWidth
	      });
	      flush();
	    }
	  }, {
	    key: "containerEl",
	    get: function get() {
	      return this.$$.ctx[11];
	    },
	    set: function set(containerEl) {
	      this.$$set({
	        containerEl: containerEl
	      });
	      flush();
	    }
	  }]);

	  return Tooltip;
	}(SvelteComponent);

	// `Map` constructor
	// https://tc39.github.io/ecma262/#sec-map-objects
	collection('Map', function (init) {
	  return function Map() { return init(this, arguments.length ? arguments[0] : undefined); };
	}, collectionStrong);

	/**
	 * lodash (Custom Build) <https://lodash.com/>
	 * Build: `lodash modularize exports="npm" -o ./`
	 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
	 * Released under MIT license <https://lodash.com/license>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 */

	/** Used as the `TypeError` message for "Functions" methods. */
	var FUNC_ERROR_TEXT$2 = 'Expected a function';

	/** Used as references for various `Number` constants. */
	var NAN = 0 / 0;

	/** `Object#toString` result references. */
	var symbolTag$1 = '[object Symbol]';

	/** Used to match leading and trailing whitespace. */
	var reTrim = /^\s+|\s+$/g;

	/** Used to detect bad signed hexadecimal string values. */
	var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

	/** Used to detect binary string values. */
	var reIsBinary = /^0b[01]+$/i;

	/** Used to detect octal string values. */
	var reIsOctal = /^0o[0-7]+$/i;

	/** Built-in method references without a dependency on `root`. */
	var freeParseInt = parseInt;

	/** Detect free variable `global` from Node.js. */
	var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

	/** Detect free variable `self`. */
	var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

	/** Used as a reference to the global object. */
	var root = freeGlobal || freeSelf || Function('return this')();

	/** Used for built-in method references. */
	var objectProto$2 = Object.prototype;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objectToString = objectProto$2.toString;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMax$1 = Math.max,
	    nativeMin$1 = Math.min;

	/**
	 * Gets the timestamp of the number of milliseconds that have elapsed since
	 * the Unix epoch (1 January 1970 00:00:00 UTC).
	 *
	 * @static
	 * @memberOf _
	 * @since 2.4.0
	 * @category Date
	 * @returns {number} Returns the timestamp.
	 * @example
	 *
	 * _.defer(function(stamp) {
	 *   console.log(_.now() - stamp);
	 * }, _.now());
	 * // => Logs the number of milliseconds it took for the deferred invocation.
	 */
	var now$3 = function() {
	  return root.Date.now();
	};

	/**
	 * Creates a debounced function that delays invoking `func` until after `wait`
	 * milliseconds have elapsed since the last time the debounced function was
	 * invoked. The debounced function comes with a `cancel` method to cancel
	 * delayed `func` invocations and a `flush` method to immediately invoke them.
	 * Provide `options` to indicate whether `func` should be invoked on the
	 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
	 * with the last arguments provided to the debounced function. Subsequent
	 * calls to the debounced function return the result of the last `func`
	 * invocation.
	 *
	 * **Note:** If `leading` and `trailing` options are `true`, `func` is
	 * invoked on the trailing edge of the timeout only if the debounced function
	 * is invoked more than once during the `wait` timeout.
	 *
	 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
	 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
	 *
	 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
	 * for details over the differences between `_.debounce` and `_.throttle`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Function
	 * @param {Function} func The function to debounce.
	 * @param {number} [wait=0] The number of milliseconds to delay.
	 * @param {Object} [options={}] The options object.
	 * @param {boolean} [options.leading=false]
	 *  Specify invoking on the leading edge of the timeout.
	 * @param {number} [options.maxWait]
	 *  The maximum time `func` is allowed to be delayed before it's invoked.
	 * @param {boolean} [options.trailing=true]
	 *  Specify invoking on the trailing edge of the timeout.
	 * @returns {Function} Returns the new debounced function.
	 * @example
	 *
	 * // Avoid costly calculations while the window size is in flux.
	 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
	 *
	 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
	 * jQuery(element).on('click', _.debounce(sendMail, 300, {
	 *   'leading': true,
	 *   'trailing': false
	 * }));
	 *
	 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
	 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
	 * var source = new EventSource('/stream');
	 * jQuery(source).on('message', debounced);
	 *
	 * // Cancel the trailing debounced invocation.
	 * jQuery(window).on('popstate', debounced.cancel);
	 */
	function debounce$1(func, wait, options) {
	  var lastArgs,
	      lastThis,
	      maxWait,
	      result,
	      timerId,
	      lastCallTime,
	      lastInvokeTime = 0,
	      leading = false,
	      maxing = false,
	      trailing = true;

	  if (typeof func != 'function') {
	    throw new TypeError(FUNC_ERROR_TEXT$2);
	  }
	  wait = toNumber(wait) || 0;
	  if (isObject(options)) {
	    leading = !!options.leading;
	    maxing = 'maxWait' in options;
	    maxWait = maxing ? nativeMax$1(toNumber(options.maxWait) || 0, wait) : maxWait;
	    trailing = 'trailing' in options ? !!options.trailing : trailing;
	  }

	  function invokeFunc(time) {
	    var args = lastArgs,
	        thisArg = lastThis;

	    lastArgs = lastThis = undefined;
	    lastInvokeTime = time;
	    result = func.apply(thisArg, args);
	    return result;
	  }

	  function leadingEdge(time) {
	    // Reset any `maxWait` timer.
	    lastInvokeTime = time;
	    // Start the timer for the trailing edge.
	    timerId = setTimeout(timerExpired, wait);
	    // Invoke the leading edge.
	    return leading ? invokeFunc(time) : result;
	  }

	  function remainingWait(time) {
	    var timeSinceLastCall = time - lastCallTime,
	        timeSinceLastInvoke = time - lastInvokeTime,
	        result = wait - timeSinceLastCall;

	    return maxing ? nativeMin$1(result, maxWait - timeSinceLastInvoke) : result;
	  }

	  function shouldInvoke(time) {
	    var timeSinceLastCall = time - lastCallTime,
	        timeSinceLastInvoke = time - lastInvokeTime;

	    // Either this is the first call, activity has stopped and we're at the
	    // trailing edge, the system time has gone backwards and we're treating
	    // it as the trailing edge, or we've hit the `maxWait` limit.
	    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
	      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
	  }

	  function timerExpired() {
	    var time = now$3();
	    if (shouldInvoke(time)) {
	      return trailingEdge(time);
	    }
	    // Restart the timer.
	    timerId = setTimeout(timerExpired, remainingWait(time));
	  }

	  function trailingEdge(time) {
	    timerId = undefined;

	    // Only invoke if we have `lastArgs` which means `func` has been
	    // debounced at least once.
	    if (trailing && lastArgs) {
	      return invokeFunc(time);
	    }
	    lastArgs = lastThis = undefined;
	    return result;
	  }

	  function cancel() {
	    if (timerId !== undefined) {
	      clearTimeout(timerId);
	    }
	    lastInvokeTime = 0;
	    lastArgs = lastCallTime = lastThis = timerId = undefined;
	  }

	  function flush() {
	    return timerId === undefined ? result : trailingEdge(now$3());
	  }

	  function debounced() {
	    var time = now$3(),
	        isInvoking = shouldInvoke(time);

	    lastArgs = arguments;
	    lastThis = this;
	    lastCallTime = time;

	    if (isInvoking) {
	      if (timerId === undefined) {
	        return leadingEdge(lastCallTime);
	      }
	      if (maxing) {
	        // Handle invocations in a tight loop.
	        timerId = setTimeout(timerExpired, wait);
	        return invokeFunc(lastCallTime);
	      }
	    }
	    if (timerId === undefined) {
	      timerId = setTimeout(timerExpired, wait);
	    }
	    return result;
	  }
	  debounced.cancel = cancel;
	  debounced.flush = flush;
	  return debounced;
	}

	/**
	 * Checks if `value` is the
	 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(_.noop);
	 * // => true
	 *
	 * _.isObject(null);
	 * // => false
	 */
	function isObject(value) {
	  var type = typeof value;
	  return !!value && (type == 'object' || type == 'function');
	}

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return !!value && typeof value == 'object';
	}

	/**
	 * Checks if `value` is classified as a `Symbol` primitive or object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
	 * @example
	 *
	 * _.isSymbol(Symbol.iterator);
	 * // => true
	 *
	 * _.isSymbol('abc');
	 * // => false
	 */
	function isSymbol$1(value) {
	  return typeof value == 'symbol' ||
	    (isObjectLike(value) && objectToString.call(value) == symbolTag$1);
	}

	/**
	 * Converts `value` to a number.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to process.
	 * @returns {number} Returns the number.
	 * @example
	 *
	 * _.toNumber(3.2);
	 * // => 3.2
	 *
	 * _.toNumber(Number.MIN_VALUE);
	 * // => 5e-324
	 *
	 * _.toNumber(Infinity);
	 * // => Infinity
	 *
	 * _.toNumber('3.2');
	 * // => 3.2
	 */
	function toNumber(value) {
	  if (typeof value == 'number') {
	    return value;
	  }
	  if (isSymbol$1(value)) {
	    return NAN;
	  }
	  if (isObject(value)) {
	    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
	    value = isObject(other) ? (other + '') : other;
	  }
	  if (typeof value != 'string') {
	    return value === 0 ? value : +value;
	  }
	  value = value.replace(reTrim, '');
	  var isBinary = reIsBinary.test(value);
	  return (isBinary || reIsOctal.test(value))
	    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
	    : (reIsBadHex.test(value) ? NAN : +value);
	}

	var lodash_debounce = debounce$1;

	function generateHtml(text) {
	  return text; // return text.replace(/\n/g, '<br>')
	}

	function dist$1(a, b) {
	  return Math.sqrt(Math.pow(a[0] - b[0], 2) + Math.pow(a[1] - b[1], 2));
	} // used in the arrow function, pass in three points and it will return an
	// arc path going through all three


	function calcCirclePath(a, b, c) {
	  var A = dist$1(b, c);
	  var B = dist$1(c, a);
	  var C = dist$1(a, b);
	  var angle = Math.acos((A * A + B * B - C * C) / (2 * A * B)); // calc radius of circle

	  var K = 0.5 * A * B * Math.sin(angle);
	  var r = A * B * C / 4 / K;
	  r = Math.round(r * 1000) / 1000; // large arc flag

	  var laf = +(Math.PI / 2 > angle); // sweep flag

	  var saf = +((b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]) < 0);
	  return ['M', a, 'A', r, r, 0, laf, saf, b].join(' ');
	} // Return function that uses the containerWidth
	// read breakpoints for implementation
	// for now always use largest as "Default"
	//
	// use options.maxWidthMode to have the rangeWidth operate
	// as the maximum width - for containers larger than the range
	// the range can either stop or keep scaling up

	function scaleLinear() {
	  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	  var maxWidthMode = options.maxWidthMode || false;
	  var rangeWidth = 1;

	  var scaleFunction = function scaleFunction(width, pos) {
	    var maxRatio = maxWidthMode ? 1.0 : Infinity;
	    var ratio = Math.min(maxRatio, width / rangeWidth);
	    return pos.map(function (v) {
	      return v * ratio;
	    });
	  }; // provide an `invert` function for converting
	  // screen coordinates to x, y


	  scaleFunction.invert = function (width, pos) {
	    var maxRatio = maxWidthMode ? 1.0 : 0;
	    var ratio = Math.max(maxRatio, rangeWidth / width);
	    return pos.map(function (v) {
	      return v * ratio;
	    });
	  };

	  return scaleFunction;
	}
	/**
	 *
	 * @param {object} options
	 * @param {boolean} options.maxWidthMode - maxWidthMode
	 * @param {function} scale - a d3-geo projection or d3-scale
	 */

	function getScale(options, customScale) {
	  // if user has passed in customScale function
	  if (customScale && typeof customScale === 'function') {
	    // return screenX/screenY
	    var scaleFunction = function scaleFunction(_, pos) {
	      return customScale(pos);
	    }; // return custom format (lon/lat)


	    scaleFunction.invert = function (_, pos) {
	      return customScale.invert(pos);
	    }; // return custom scaleFunction


	    return scaleFunction;
	  } // othwerise return linear scale


	  return scaleLinear(options);
	}
	function defaultResizeFrame(target) {
	  var _initialSize = null;
	  return function (width) {
	    if (_initialSize == null) {
	      _initialSize = target.parentElement.style.width;
	    }

	    if (width == null) {
	      target.parentElement.style.width = _initialSize;
	    } else {
	      target.parentElement.style.width = "".concat(width, "px");
	    }

	    window.dispatchEvent(new Event('resize'));
	  };
	}
	function getBoundsAtWidth(containerWidth, options) {
	  var breakpoint = getBreakpoint(containerWidth, options.breakpoints, false);

	  if (breakpoint && breakpoint.bounds) {
	    return breakpoint.bounds;
	  }

	  return {
	    top: 0,
	    left: 0,
	    right: 0,
	    bottom: 0
	  };
	}
	function getBreakpoint(containerWidth) {
	  var breakpoints = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
	  var noDefault = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
	  var sortedBreakpoints = breakpoints.sort(function (a, b) {
	    return b.size - a.size;
	  });
	  var breakpoint = null; // sortedBreakpoints[sortedBreakpoints.length]

	  sortedBreakpoints.forEach(function (b) {
	    if (containerWidth <= b.size) {
	      breakpoint = b;
	    }
	  });
	  if (noDefault && isDefaultBreakpoint(breakpoint, breakpoints)) return null;
	  return breakpoint;
	} // the default breakpoint is the largest one

	function isDefaultBreakpoint(breakpoint) {
	  var breakpoints = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
	  var largest = Math.max.apply(null, breakpoints.map(function (b) {
	    return b.size;
	  }));
	  return breakpoint && breakpoint.size === largest;
	} // 4 digit rando string

	function shortyId() {
	  return Math.random().toString(36).substring(2, 6);
	} // return an alignment option for vertical and horizontal lines
	// there are tricky rules so better to load all the ugly logic into
	// one ugly place

	function alignOffset(hAlign, vAlign, lineStyle) {
	  var alignOffsetX = 0;
	  var alignOffsetY = 0;

	  if (lineStyle === 'horizontal') {
	    if (hAlign === 'left') alignOffsetX = 5;
	    if (hAlign === 'right') alignOffsetX = -5;
	    if (hAlign === 'center') alignOffsetX = 0;
	    if (vAlign === 'top') alignOffsetY = -10;
	    if (vAlign === 'center') alignOffsetY = 0;
	    if (vAlign === 'bottom') alignOffsetY = 10;
	  } else if (lineStyle === 'vertical') {
	    if (vAlign === 'top') alignOffsetY = 5;
	    if (vAlign === 'bottom') alignOffsetY = -5;
	    if (vAlign === 'center') alignOffsetY = 0;
	    if (hAlign === 'left') alignOffsetX = -5;
	    if (hAlign === 'right') alignOffsetX = 5;
	    if (hAlign === 'center') alignOffsetX = 0;
	  }

	  return {
	    alignOffsetX: alignOffsetX,
	    alignOffsetY: alignOffsetY
	  };
	} // alignment specific to icons to get proper text align

	function iconAlignOffset(hAlign, vAlign, iconSize, fontSize) {
	  var alignOffsetX = 0;
	  var alignOffsetY = 0;
	  if (hAlign === 'left') alignOffsetX = iconSize / 2 + 3;
	  if (hAlign === 'right') alignOffsetX = -1 * (iconSize / 2 + 3);
	  if (vAlign === 'top') alignOffsetY = -1;
	  if (vAlign === 'bottom') alignOffsetY = 2; // horizontal center will appear above / below the icon

	  if (hAlign === 'center') {
	    if (vAlign === 'top') alignOffsetY = iconSize / 2 + 5;
	    if (vAlign === 'bottom') alignOffsetY = -1 * (iconSize / 2 + 5);
	  }

	  return {
	    alignOffsetX: alignOffsetX,
	    alignOffsetY: alignOffsetY
	  };
	} // alignment specific to icons to get proper text align

	function circleAlignOffset(hAlign, vAlign, radius) {
	  var alignOffsetX = 0;
	  var alignOffsetY = 0;
	  var textPadding = 5;
	  if (hAlign === 'left') alignOffsetX = 2 * radius + textPadding;
	  if (hAlign === 'right') alignOffsetX = -1 * textPadding;
	  alignOffsetY = radius; // horizontal center will appear above / below the icon

	  if (hAlign === 'center') {
	    alignOffsetX = radius;
	    if (vAlign === 'top') alignOffsetY = 2 * radius + textPadding;
	    if (vAlign === 'bottom') alignOffsetY = -1 * textPadding;
	  }

	  return {
	    alignOffsetX: alignOffsetX,
	    alignOffsetY: alignOffsetY
	  };
	} // provide standard offsets depending on the direction of the arrow

	function arrowMidpointOffset(lineStyle, x3, y3) {
	  var x = 0;
	  var y = 0;

	  if (lineStyle === 'vertical') {
	    y = y3 > 0 ? -10 : 10;
	    x = x3 > 0 ? -2 : 2;
	  } else if (lineStyle === 'horizontal') {
	    x = x3 > 0 ? -10 : 10;
	    y = y3 > 0 ? -2 : 2;
	  }

	  return [x, y];
	} // simple utility for preview alignment

	function previewAlignX(align) {
	  if (align === 'right') return 0.9;
	  if (align === 'center') return 0.5;
	  return 0.1;
	}
	function previewAlignY(align) {
	  if (align === 'bottom') return 0.6;
	  if (align === 'center') return 0.5;
	  return 0.4;
	}
	function defaultProperties() {
	  return {
	    visible: true,
	    text: '',
	    align: 'left',
	    valign: 'top',
	    lineStyle: 'horizontal',
	    x: 0,
	    y: 0,
	    x2: 50,
	    y2: 0,
	    offsetX: 0,
	    offsetY: 0,
	    strokeWidth: 1
	  };
	} // helper utility to insert at cursor
	// https://stackoverflow.com/questions/4714192/insert-text-before-and-after-selection-in-textarea-with-javascript

	function insertAtCursor(myField, myValueBefore, myValueAfter) {
	  if (document.selection) {
	    myField.focus();
	    document.selection.createRange().text = myValueBefore + document.selection.createRange().text + myValueAfter;
	  } else if (myField.selectionStart !== undefined && myField.selectionEnd !== undefined) {
	    var startPos = myField.selectionStart;
	    var endPos = myField.selectionEnd;
	    myField.value = myField.value.substring(0, startPos) + myValueBefore + myField.value.substring(startPos, endPos) + myValueAfter + myField.value.substring(endPos, myField.value.length);
	  } // Create a new 'change' event


	  myField.dispatchEvent(new Event('change'));
	  myField.dispatchEvent(new Event('keyup'));
	}
	function makeDraggable(getState, onChange, onChangeComplete) {
	  var maxDrag = 50;

	  var _isDragging;

	  var lastX;
	  var lastY;
	  var grabOffsetX;
	  var grabOffsetY; // set the position directly to the component

	  var updatePosition = function updatePosition(final) {
	    var _getState = getState(),
	        x = _getState.x,
	        y = _getState.y;

	    var props = {
	      x: Number(x) + lastX - grabOffsetX,
	      y: Number(y) + lastY - grabOffsetY
	    };

	    if (!isNaN(props.x) && !isNaN(props.y)) {
	      if (final) {
	        onChangeComplete(props);
	      } else {
	        onChange(props);
	      }
	    }
	  };

	  var drag = function drag(e) {
	    if (!_isDragging) return;
	    if (!(e && e.target)) return;
	    var screenX = e.screenX,
	        screenY = e.screenY,
	        offsetX = e.offsetX,
	        offsetY = e.offsetY;

	    if (screenX === 0 && screenY === 0) {
	      return;
	    }

	    if (lastX != null && lastY != null && (offsetX - lastX > maxDrag || offsetY - lastY > maxDrag)) {
	      return;
	    } // record offset of position from target


	    if (grabOffsetX == null) {
	      var targetBounds = e.target.getBoundingClientRect();
	      grabOffsetX = e.x - targetBounds.x;
	      grabOffsetY = e.y - targetBounds.y;
	    }

	    lastX = offsetX;
	    lastY = offsetY;
	    updatePosition();
	  };

	  var resetDrag = function resetDrag() {
	    _isDragging = false;
	    lastX = null;
	    lastY = null;
	    grabOffsetX = null;
	    grabOffsetY = null;
	  };

	  var dragStart = function dragStart(e) {
	    resetDrag(); // prevent default ghost image -- which has imprecise position value!

	    var ghostImage = new Image();
	    ghostImage.src = 'data:image/gif;base64,R0lGODlhAQABAIAAAAUEBAAAACwAAAAAAQABAAACAkQBADs=';
	    event.dataTransfer.setDragImage(ghostImage, 0, 0); // don't allow dragging while editor is open

	    var _getState2 = getState(),
	        isEditorActive = _getState2.isEditorActive;

	    if (isEditorActive) return;
	    _isDragging = true;
	  };

	  var dragEnd = function dragEnd(e) {
	    // only during dragging do we need onChangeComplete called
	    if (_isDragging) updatePosition(true);
	    resetDrag();
	    return true;
	  };

	  return {
	    drag: drag,
	    dragStart: dragStart,
	    dragEnd: dragEnd,
	    isDragging: function isDragging() {
	      return _isDragging;
	    }
	  };
	}
	// so we create a generator for it

	function positionChangeHandler(id, x, y, scale, containerWidth, updateDraggable, isEditor, editor) {
	  return function (props) {
	    var scaled = scale.invert(containerWidth, [props.x + x, props.y + y]);
	    updateDraggable(id, {
	      x: scaled[0],
	      y: scaled[1]
	    });

	    if (isEditor) {
	      editor.calculateBounds();
	    }
	  };
	}
	var defaultOptions = {
	  breakpoints: [{
	    name: 'Default',
	    size: 620
	  }, {
	    name: 'Mobile',
	    size: 400
	  }]
	};
	function nullHandler() {
	  return null;
	}
	function boundsHandler(draggablesState) {
	  return function (width) {
	    return getBoundsAtWidth(width, draggablesState.options);
	  };
	} // recursively walk the element parent tree until we get a height
	// that actually represents a container height by avoiding 0 height items

	function getNonZeroContainerHeight(el) {
	  var bounds = el.getBoundingClientRect();

	  if (bounds.height === 0) {
	    return getNonZeroContainerHeight(el.parentElement);
	  }

	  return bounds.height;
	} // read either draggables or annotations from passed in
	// object and return all of the items with a guaranteed id

	function readDraggablesWithIds(draggablesState) {
	  // build in support for either annotations or draggables
	  var items = draggablesState.draggables ? draggablesState.draggables : draggablesState.annotations;
	  return items.map(function (item) {
	    item.id = item.id || Math.round(Math.random() * 999999);
	    return _objectSpread2(_objectSpread2({}, defaultProperties()), item);
	  });
	} // bind resize and allow a cleanup to be passed back

	function bindResizeEvents(component, target) {
	  var onResize = function onResize() {
	    component.containerWidth = target.offsetWidth;
	  };

	  window.addEventListener('resize', onResize); // return to be called to clean up event listeners

	  return function () {
	    window.removeEventListener('resize', onResize);
	  };
	} // another jest pain -- would be great if this were
	// something that was taken care of at the library level

	function debouncer(fn) {
	  if (typeof process !== 'undefined' && process && process.env && process.env.NODE_ENV === 'test') {
	    return fn;
	  }

	  return lodash_debounce(fn);
	}

	var gripIcon = "<svg xmlns=\"http://www.w3.org/2000/svg\" class=\"icon icon-tabler icon-tabler-grip-horizontal\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" stroke-width=\"2\" stroke=\"currentColor\" fill=\"none\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n  <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\"/>\n  <circle cx=\"5\" cy=\"9\" r=\"1\" />\n  <circle cx=\"5\" cy=\"15\" r=\"1\" />\n  <circle cx=\"12\" cy=\"9\" r=\"1\" />\n  <circle cx=\"12\" cy=\"15\" r=\"1\" />\n  <circle cx=\"19\" cy=\"9\" r=\"1\" />\n  <circle cx=\"19\" cy=\"15\" r=\"1\" />\n</svg>";

	var moveIcon = "<svg xmlns=\"http://www.w3.org/2000/svg\" class=\"icon icon-tabler icon-tabler-arrows-maximize\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" stroke-width=\"2\" stroke=\"currentColor\" fill=\"none\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n  <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\"/>\n  <polyline points=\"16 4 20 4 20 8\" />\n  <line x1=\"14\" y1=\"10\" x2=\"20\" y2=\"4\" />\n  <polyline points=\"8 20 4 20 4 16\" />\n  <line x1=\"4\" y1=\"20\" x2=\"10\" y2=\"14\" />\n  <polyline points=\"16 20 20 20 20 16\" />\n  <line x1=\"14\" y1=\"14\" x2=\"20\" y2=\"20\" />\n  <polyline points=\"8 4 4 4 4 8\" />\n  <line x1=\"4\" y1=\"4\" x2=\"10\" y2=\"10\" />\n</svg>";

	function add_css$j(target) {
	  append_styles(target, "svelte-j8nqk", ".handle.svelte-j8nqk{z-index:1;cursor:move;position:absolute;display:none;border-radius:20px;border:solid 1px #3a73ff;box-shadow:2px 1px 2px rgba(0,0,0,0.2)}.handle.svelte-j8nqk:hover{box-shadow:2px 1px 2px rgba(0,0,0,0.4);border-color:#ffb702}.handle.active.svelte-j8nqk{display:block}.handle.offset.svelte-j8nqk,.handle.textWidth.svelte-j8nqk{border-radius:0px;border:solid 1px #3a73ff;background:rgb(255 255 255 / 86%);box-shadow:none}.handle.textWidth.svelte-j8nqk{cursor:ew-resize}.handle.offset.svelte-j8nqk:hover,.handle.textWidth.svelte-j8nqk:hover{border-color:#ffb702}.handle.dialog.svelte-j8nqk{box-shadow:none;line-height:10px;font-size:18px;padding:0;background:transparent;text-align:center;border:none}.handle.move.svelte-j8nqk{border-radius:0;border:none;background:#3a73ff;box-shadow:none}.handle.move.svelte-j8nqk:hover{background:#ffb702}.draggable .handle.move > svg{display:block;height:8px;width:8px;color:#ffffff;padding:0}.draggable.dark .handle.move > svg{color:#000000}");
	} // (148:36) 


	function create_if_block_2$6(ctx) {
	  var svg;
	  return {
	    c: function c() {
	      svg = svg_element("svg");
	    },
	    m: function m(target, anchor) {
	      insert(target, svg, anchor);
	    },
	    p: noop,
	    d: function d(detaching) {
	      if (detaching) detach(svg);
	    }
	  };
	} // (146:35) 


	function create_if_block_1$c(ctx) {
	  var html_tag;
	  var html_anchor;
	  return {
	    c: function c() {
	      html_tag = new HtmlTag(false);
	      html_anchor = empty();
	      html_tag.a = html_anchor;
	    },
	    m: function m(target, anchor) {
	      html_tag.m(moveIcon, target, anchor);
	      insert(target, html_anchor, anchor);
	    },
	    p: noop,
	    d: function d(detaching) {
	      if (detaching) detach(html_anchor);
	      if (detaching) html_tag.d();
	    }
	  };
	} // (143:2) {#if handleClass === 'dialog'}


	function create_if_block$g(ctx) {
	  var html_tag;
	  var t;
	  var html_tag_1;
	  var html_anchor;
	  return {
	    c: function c() {
	      html_tag = new HtmlTag(false);
	      t = space();
	      html_tag_1 = new HtmlTag(false);
	      html_anchor = empty();
	      html_tag.a = t;
	      html_tag_1.a = html_anchor;
	    },
	    m: function m(target, anchor) {
	      html_tag.m(gripIcon, target, anchor);
	      insert(target, t, anchor);
	      html_tag_1.m(gripIcon, target, anchor);
	      insert(target, html_anchor, anchor);
	    },
	    p: noop,
	    d: function d(detaching) {
	      if (detaching) html_tag.d();
	      if (detaching) detach(t);
	      if (detaching) detach(html_anchor);
	      if (detaching) html_tag_1.d();
	    }
	  };
	}

	function create_fragment$p(ctx) {
	  var div;
	  var div_class_value;
	  var mounted;
	  var dispose;

	  function select_block_type(ctx, dirty) {
	    if (
	    /*handleClass*/
	    ctx[1] === 'dialog') return create_if_block$g;
	    if (
	    /*handleClass*/
	    ctx[1] === 'move') return create_if_block_1$c;
	    if (
	    /*handleClass*/
	    ctx[1] === 'dummy') return create_if_block_2$6;
	  }

	  var current_block_type = select_block_type(ctx);
	  var if_block = current_block_type && current_block_type(ctx);
	  return {
	    c: function c() {
	      div = element("div");
	      if (if_block) if_block.c();
	      attr(div, "style",
	      /*style*/
	      ctx[2]);
	      attr(div, "draggable", "true");
	      attr(div, "class", div_class_value = "handle " + (
	      /*active*/
	      ctx[0] ||
	      /*isDragging*/
	      ctx[3] ? 'active' : '') + " " +
	      /*handleClass*/
	      ctx[1] + " svelte-j8nqk");
	    },
	    m: function m(target, anchor) {
	      insert(target, div, anchor);
	      if (if_block) if_block.m(div, null);

	      if (!mounted) {
	        dispose = [listen(div, "dragstart",
	        /*resetDrag*/
	        ctx[5]), listen(div, "dragend",
	        /*dragEnd*/
	        ctx[6]), listen(div, "drag",
	        /*handleDrag*/
	        ctx[4])];
	        mounted = true;
	      }
	    },
	    p: function p(ctx, _ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	          dirty = _ref2[0];

	      if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
	        if_block.p(ctx, dirty);
	      } else {
	        if (if_block) if_block.d(1);
	        if_block = current_block_type && current_block_type(ctx);

	        if (if_block) {
	          if_block.c();
	          if_block.m(div, null);
	        }
	      }

	      if (dirty &
	      /*style*/
	      4) {
	        attr(div, "style",
	        /*style*/
	        ctx[2]);
	      }

	      if (dirty &
	      /*active, isDragging, handleClass*/
	      11 && div_class_value !== (div_class_value = "handle " + (
	      /*active*/
	      ctx[0] ||
	      /*isDragging*/
	      ctx[3] ? 'active' : '') + " " +
	      /*handleClass*/
	      ctx[1] + " svelte-j8nqk")) {
	        attr(div, "class", div_class_value);
	      }
	    },
	    i: noop,
	    o: noop,
	    d: function d(detaching) {
	      if (detaching) detach(div);

	      if (if_block) {
	        if_block.d();
	      }

	      mounted = false;
	      run_all(dispose);
	    }
	  };
	}

	function instance$p($$self, $$props, $$invalidate) {
	  var _$$props$active = $$props.active,
	      active = _$$props$active === void 0 ? false : _$$props$active;
	  var onChange = $$props.onChange;
	  var onComplete = $$props.onComplete;
	  var color = $$props.color;
	  var _$$props$x = $$props.x,
	      x = _$$props$x === void 0 ? 0 : _$$props$x;
	  var _$$props$y = $$props.y,
	      y = _$$props$y === void 0 ? 0 : _$$props$y;
	  var _$$props$handleWidth = $$props.handleWidth,
	      handleWidth = _$$props$handleWidth === void 0 ? 8 : _$$props$handleWidth;
	  var _$$props$handleHeight = $$props.handleHeight,
	      handleHeight = _$$props$handleHeight === void 0 ? 8 : _$$props$handleHeight;
	  var _$$props$handleClass = $$props.handleClass,
	      handleClass = _$$props$handleClass === void 0 ? 'drag' : _$$props$handleClass;
	  var _$$props$maxDrag = $$props.maxDrag,
	      maxDrag = _$$props$maxDrag === void 0 ? 50 : _$$props$maxDrag;
	  var style = '';
	  var isDragging = false;
	  var lastX;
	  var lastY;

	  function handleDrag(e) {
	    var screenX = e.screenX,
	        screenY = e.screenY,
	        offsetX = e.offsetX,
	        offsetY = e.offsetY;
	    $$invalidate(3, isDragging = true);

	    if (lastX != null && lastY != null && (offsetX - lastX > maxDrag || offsetY - lastY > maxDrag)) {
	      return;
	    }

	    if (screenX && screenY) {
	      var props = {
	        x: Number(x) + offsetX - 5,
	        y: Number(y) + offsetY - 5
	      };

	      if (!isNaN(props.x) && !isNaN(props.y)) {
	        onChange(props);
	      }
	    }

	    lastX = offsetX;
	    lastY = offsetY;
	  }

	  function resetDrag() {
	    $$invalidate(3, isDragging = false);
	    lastX = null;
	    lastY = null;
	  }

	  function dragEnd() {
	    resetDrag();
	    if (onComplete) onComplete();
	  }

	  $$self.$$set = function ($$props) {
	    if ('active' in $$props) $$invalidate(0, active = $$props.active);
	    if ('onChange' in $$props) $$invalidate(7, onChange = $$props.onChange);
	    if ('onComplete' in $$props) $$invalidate(8, onComplete = $$props.onComplete);
	    if ('color' in $$props) $$invalidate(9, color = $$props.color);
	    if ('x' in $$props) $$invalidate(10, x = $$props.x);
	    if ('y' in $$props) $$invalidate(11, y = $$props.y);
	    if ('handleWidth' in $$props) $$invalidate(12, handleWidth = $$props.handleWidth);
	    if ('handleHeight' in $$props) $$invalidate(13, handleHeight = $$props.handleHeight);
	    if ('handleClass' in $$props) $$invalidate(1, handleClass = $$props.handleClass);
	    if ('maxDrag' in $$props) $$invalidate(14, maxDrag = $$props.maxDrag);
	  };

	  $$self.$$.update = function () {
	    if ($$self.$$.dirty &
	    /*x, handleWidth, y, handleHeight, color, style*/
	    15876) {
	      {
	        $$invalidate(2, style = "\n      left: ".concat(x - handleWidth / 2, "px;\n      top: ").concat(y - handleHeight / 2, "px;\n      width: ").concat(handleWidth, "px;\n      height: ").concat(handleHeight, "px;\n    "));

	        if (color) {
	          $$invalidate(2, style += "background: ".concat(color, ";"));
	        }
	      }
	    }
	  };

	  return [active, handleClass, style, isDragging, handleDrag, resetDrag, dragEnd, onChange, onComplete, color, x, y, handleWidth, handleHeight, maxDrag];
	}

	var DragHandle = /*#__PURE__*/function (_SvelteComponent) {
	  _inherits(DragHandle, _SvelteComponent);

	  var _super = _createSuper(DragHandle);

	  function DragHandle(options) {
	    var _this;

	    _classCallCheck(this, DragHandle);

	    _this = _super.call(this);
	    init(_assertThisInitialized(_this), options, instance$p, create_fragment$p, safe_not_equal, {
	      active: 0,
	      onChange: 7,
	      onComplete: 8,
	      color: 9,
	      x: 10,
	      y: 11,
	      handleWidth: 12,
	      handleHeight: 13,
	      handleClass: 1,
	      maxDrag: 14
	    }, add_css$j);
	    return _this;
	  }

	  _createClass(DragHandle, [{
	    key: "active",
	    get: function get() {
	      return this.$$.ctx[0];
	    },
	    set: function set(active) {
	      this.$$set({
	        active: active
	      });
	      flush();
	    }
	  }, {
	    key: "onChange",
	    get: function get() {
	      return this.$$.ctx[7];
	    },
	    set: function set(onChange) {
	      this.$$set({
	        onChange: onChange
	      });
	      flush();
	    }
	  }, {
	    key: "onComplete",
	    get: function get() {
	      return this.$$.ctx[8];
	    },
	    set: function set(onComplete) {
	      this.$$set({
	        onComplete: onComplete
	      });
	      flush();
	    }
	  }, {
	    key: "color",
	    get: function get() {
	      return this.$$.ctx[9];
	    },
	    set: function set(color) {
	      this.$$set({
	        color: color
	      });
	      flush();
	    }
	  }, {
	    key: "x",
	    get: function get() {
	      return this.$$.ctx[10];
	    },
	    set: function set(x) {
	      this.$$set({
	        x: x
	      });
	      flush();
	    }
	  }, {
	    key: "y",
	    get: function get() {
	      return this.$$.ctx[11];
	    },
	    set: function set(y) {
	      this.$$set({
	        y: y
	      });
	      flush();
	    }
	  }, {
	    key: "handleWidth",
	    get: function get() {
	      return this.$$.ctx[12];
	    },
	    set: function set(handleWidth) {
	      this.$$set({
	        handleWidth: handleWidth
	      });
	      flush();
	    }
	  }, {
	    key: "handleHeight",
	    get: function get() {
	      return this.$$.ctx[13];
	    },
	    set: function set(handleHeight) {
	      this.$$set({
	        handleHeight: handleHeight
	      });
	      flush();
	    }
	  }, {
	    key: "handleClass",
	    get: function get() {
	      return this.$$.ctx[1];
	    },
	    set: function set(handleClass) {
	      this.$$set({
	        handleClass: handleClass
	      });
	      flush();
	    }
	  }, {
	    key: "maxDrag",
	    get: function get() {
	      return this.$$.ctx[14];
	    },
	    set: function set(maxDrag) {
	      this.$$set({
	        maxDrag: maxDrag
	      });
	      flush();
	    }
	  }]);

	  return DragHandle;
	}(SvelteComponent);

	function add_css$i(target) {
	  append_styles(target, "svelte-zamh9q", "div.svelte-zamh9q>div.svelte-zamh9q{position:relative}div.text.svelte-zamh9q.svelte-zamh9q{border:1px solid transparent}div.text.editing.svelte-zamh9q.svelte-zamh9q{border:1px dashed #0a37ff;cursor:text;outline:none}");
	} // (141:2) {#if isEditorActive && !isEditorLocked}


	function create_if_block$f(ctx) {
	  var t;
	  var draghandle;
	  var current;
	  var if_block =
	  /*showOffsetHandle*/
	  ctx[3] && create_if_block_1$b(ctx);
	  draghandle = new DragHandle({
	    props: {
	      id:
	      /*id*/
	      ctx[0],
	      x:
	      /*textWidthHandleX*/
	      ctx[11],
	      y:
	      /*textAreaHeight*/
	      ctx[9] / 2,
	      handleWidth: "1",
	      handleHeight:
	      /*textAreaHeight*/
	      ctx[9],
	      active: "true",
	      color: "rgb(145 145 145 / 50%)",
	      handleClass: "textWidth",
	      onChange:
	      /*updateTextWidth*/
	      ctx[18]
	    }
	  });
	  return {
	    c: function c() {
	      if (if_block) if_block.c();
	      t = space();
	      create_component(draghandle.$$.fragment);
	    },
	    m: function m(target, anchor) {
	      if (if_block) if_block.m(target, anchor);
	      insert(target, t, anchor);
	      mount_component(draghandle, target, anchor);
	      current = true;
	    },
	    p: function p(ctx, dirty) {
	      if (
	      /*showOffsetHandle*/
	      ctx[3]) {
	        if (if_block) {
	          if_block.p(ctx, dirty);

	          if (dirty[0] &
	          /*showOffsetHandle*/
	          8) {
	            transition_in(if_block, 1);
	          }
	        } else {
	          if_block = create_if_block_1$b(ctx);
	          if_block.c();
	          transition_in(if_block, 1);
	          if_block.m(t.parentNode, t);
	        }
	      } else if (if_block) {
	        group_outros();
	        transition_out(if_block, 1, 1, function () {
	          if_block = null;
	        });
	        check_outros();
	      }

	      var draghandle_changes = {};
	      if (dirty[0] &
	      /*id*/
	      1) draghandle_changes.id =
	      /*id*/
	      ctx[0];
	      if (dirty[0] &
	      /*textWidthHandleX*/
	      2048) draghandle_changes.x =
	      /*textWidthHandleX*/
	      ctx[11];
	      if (dirty[0] &
	      /*textAreaHeight*/
	      512) draghandle_changes.y =
	      /*textAreaHeight*/
	      ctx[9] / 2;
	      if (dirty[0] &
	      /*textAreaHeight*/
	      512) draghandle_changes.handleHeight =
	      /*textAreaHeight*/
	      ctx[9];
	      draghandle.$set(draghandle_changes);
	    },
	    i: function i(local) {
	      if (current) return;
	      transition_in(if_block);
	      transition_in(draghandle.$$.fragment, local);
	      current = true;
	    },
	    o: function o(local) {
	      transition_out(if_block);
	      transition_out(draghandle.$$.fragment, local);
	      current = false;
	    },
	    d: function d(detaching) {
	      if (if_block) if_block.d(detaching);
	      if (detaching) detach(t);
	      destroy_component(draghandle, detaching);
	    }
	  };
	} // (142:4) {#if showOffsetHandle}


	function create_if_block_1$b(ctx) {
	  var draghandle;
	  var current;
	  draghandle = new DragHandle({
	    props: {
	      id:
	      /*id*/
	      ctx[0],
	      x:
	      /*offsetHandleX*/
	      ctx[12] +
	      /*draggingOffsetX*/
	      ctx[5],
	      y:
	      /*draggingOffsetY*/
	      ctx[6],
	      handleWidth: "7",
	      handleHeight: "7",
	      active: "true",
	      color: "rgb(255 255 255 / 56%)",
	      handleClass: "offset",
	      onChange:
	      /*updateOffset*/
	      ctx[16],
	      onComplete:
	      /*offsetComplete*/
	      ctx[17]
	    }
	  });
	  return {
	    c: function c() {
	      create_component(draghandle.$$.fragment);
	    },
	    m: function m(target, anchor) {
	      mount_component(draghandle, target, anchor);
	      current = true;
	    },
	    p: function p(ctx, dirty) {
	      var draghandle_changes = {};
	      if (dirty[0] &
	      /*id*/
	      1) draghandle_changes.id =
	      /*id*/
	      ctx[0];
	      if (dirty[0] &
	      /*offsetHandleX, draggingOffsetX*/
	      4128) draghandle_changes.x =
	      /*offsetHandleX*/
	      ctx[12] +
	      /*draggingOffsetX*/
	      ctx[5];
	      if (dirty[0] &
	      /*draggingOffsetY*/
	      64) draghandle_changes.y =
	      /*draggingOffsetY*/
	      ctx[6];
	      draghandle.$set(draghandle_changes);
	    },
	    i: function i(local) {
	      if (current) return;
	      transition_in(draghandle.$$.fragment, local);
	      current = true;
	    },
	    o: function o(local) {
	      transition_out(draghandle.$$.fragment, local);
	      current = false;
	    },
	    d: function d(detaching) {
	      destroy_component(draghandle, detaching);
	    }
	  };
	}

	function create_fragment$o(ctx) {
	  var div1;
	  var div0;
	  var div0_class_value;
	  var t;
	  var current;
	  var mounted;
	  var dispose;
	  var if_block =
	  /*isEditorActive*/
	  ctx[1] && !
	  /*isEditorLocked*/
	  ctx[2] && create_if_block$f(ctx);
	  return {
	    c: function c() {
	      div1 = element("div");
	      div0 = element("div");
	      t = space();
	      if (if_block) if_block.c();
	      attr(div0, "class", div0_class_value = "text " + (
	      /*isEditorActive*/
	      ctx[1] & !
	      /*isEditorLocked*/
	      ctx[2] ? 'editing' : '') + " " +
	      /*extraClasses*/
	      ctx[4] + " svelte-zamh9q");
	      attr(div0, "style",
	      /*textStyle*/
	      ctx[8]);
	      attr(div0, "contenteditable",
	      /*isEditorActive*/
	      ctx[1]);
	      attr(div1, "style",
	      /*style*/
	      ctx[7]);
	      attr(div1, "class", "svelte-zamh9q");
	    },
	    m: function m(target, anchor) {
	      insert(target, div1, anchor);
	      append(div1, div0);
	      div0.innerHTML =
	      /*computedText*/
	      ctx[13];
	      /*div0_binding*/

	      ctx[34](div0);
	      append(div1, t);
	      if (if_block) if_block.m(div1, null);
	      current = true;

	      if (!mounted) {
	        dispose = [listen(div0, "focus",
	        /*onFocus*/
	        ctx[14]), listen(div0, "blur",
	        /*onBlur*/
	        ctx[15])];
	        mounted = true;
	      }
	    },
	    p: function p(ctx, dirty) {
	      if (!current || dirty[0] &
	      /*computedText*/
	      8192) div0.innerHTML =
	      /*computedText*/
	      ctx[13];

	      if (!current || dirty[0] &
	      /*isEditorActive, isEditorLocked, extraClasses*/
	      22 && div0_class_value !== (div0_class_value = "text " + (
	      /*isEditorActive*/
	      ctx[1] & !
	      /*isEditorLocked*/
	      ctx[2] ? 'editing' : '') + " " +
	      /*extraClasses*/
	      ctx[4] + " svelte-zamh9q")) {
	        attr(div0, "class", div0_class_value);
	      }

	      if (!current || dirty[0] &
	      /*textStyle*/
	      256) {
	        attr(div0, "style",
	        /*textStyle*/
	        ctx[8]);
	      }

	      if (!current || dirty[0] &
	      /*isEditorActive*/
	      2) {
	        attr(div0, "contenteditable",
	        /*isEditorActive*/
	        ctx[1]);
	      }

	      if (
	      /*isEditorActive*/
	      ctx[1] && !
	      /*isEditorLocked*/
	      ctx[2]) {
	        if (if_block) {
	          if_block.p(ctx, dirty);

	          if (dirty[0] &
	          /*isEditorActive, isEditorLocked*/
	          6) {
	            transition_in(if_block, 1);
	          }
	        } else {
	          if_block = create_if_block$f(ctx);
	          if_block.c();
	          transition_in(if_block, 1);
	          if_block.m(div1, null);
	        }
	      } else if (if_block) {
	        group_outros();
	        transition_out(if_block, 1, 1, function () {
	          if_block = null;
	        });
	        check_outros();
	      }

	      if (!current || dirty[0] &
	      /*style*/
	      128) {
	        attr(div1, "style",
	        /*style*/
	        ctx[7]);
	      }
	    },
	    i: function i(local) {
	      if (current) return;
	      transition_in(if_block);
	      current = true;
	    },
	    o: function o(local) {
	      transition_out(if_block);
	      current = false;
	    },
	    d: function d(detaching) {
	      if (detaching) detach(div1);
	      /*div0_binding*/

	      ctx[34](null);
	      if (if_block) if_block.d();
	      mounted = false;
	      run_all(dispose);
	    }
	  };
	}

	var MIN_TEXT_WIDTH = 10;

	function instance$o($$self, $$props, $$invalidate) {
	  var computedText;
	  var id = $$props.id;
	  var _$$props$isEditorActi = $$props.isEditorActive,
	      isEditorActive = _$$props$isEditorActi === void 0 ? false : _$$props$isEditorActi;
	  var _$$props$isEditorLock = $$props.isEditorLocked,
	      isEditorLocked = _$$props$isEditorLock === void 0 ? false : _$$props$isEditorLock;
	  var _$$props$showOffsetHa = $$props.showOffsetHandle,
	      showOffsetHandle = _$$props$showOffsetHa === void 0 ? true : _$$props$showOffsetHa;
	  var updateDraggable = $$props.updateDraggable;
	  var setEditingText = $$props.setEditingText;
	  var _$$props$text = $$props.text,
	      text = _$$props$text === void 0 ? '' : _$$props$text;
	  var _$$props$extraClasses = $$props.extraClasses,
	      extraClasses = _$$props$extraClasses === void 0 ? '' : _$$props$extraClasses;
	  var color = $$props.color;
	  var _$$props$visible = $$props.visible,
	      visible = _$$props$visible === void 0 ? true : _$$props$visible;
	  var _$$props$align = $$props.align,
	      align = _$$props$align === void 0 ? 'left' : _$$props$align;
	  var _$$props$valign = $$props.valign,
	      valign = _$$props$valign === void 0 ? 'top' : _$$props$valign;
	  var _$$props$offsetX = $$props.offsetX,
	      offsetX = _$$props$offsetX === void 0 ? 0 : _$$props$offsetX; // user input property

	  var _$$props$offsetY = $$props.offsetY,
	      offsetY = _$$props$offsetY === void 0 ? 0 : _$$props$offsetY;
	  var _$$props$textOffsetX = $$props.textOffsetX,
	      textOffsetX = _$$props$textOffsetX === void 0 ? 0 : _$$props$textOffsetX; // calculated + user

	  var _$$props$textOffsetY = $$props.textOffsetY,
	      textOffsetY = _$$props$textOffsetY === void 0 ? 0 : _$$props$textOffsetY;
	  var _$$props$textWidth = $$props.textWidth,
	      textWidth = _$$props$textWidth === void 0 ? 100 : _$$props$textWidth;
	  var _$$props$useTextColor = $$props.useTextColor,
	      useTextColor = _$$props$useTextColor === void 0 ? false : _$$props$useTextColor;
	  var _$$props$letterSpacin = $$props.letterSpacing,
	      letterSpacing = _$$props$letterSpacin === void 0 ? 0 : _$$props$letterSpacin;
	  var fontSize = $$props.fontSize;
	  var style = '';
	  var textStyle = '';
	  var textAreaHeight = 16;
	  var domNode;
	  var draggingOffsetX = 0;
	  var draggingOffsetY = 0;
	  var textWidthHandleX;
	  var offsetHandleX = 0;

	  function onFocus(e) {
	    if (setEditingText) setEditingText(true);
	  }

	  function onBlur(e) {
	    if (setEditingText) setEditingText(false);
	    updateDraggable(id, {
	      text: domNode.innerHTML
	    });
	  }

	  function updateOffset(_ref) {
	    var x = _ref.x,
	        y = _ref.y;
	    $$invalidate(5, draggingOffsetX = x - offsetHandleX);
	    $$invalidate(6, draggingOffsetY = y);
	  }

	  function offsetComplete() {
	    updateDraggable(id, {
	      offsetX: offsetX + draggingOffsetX,
	      offsetY: offsetY + draggingOffsetY
	    });
	    $$invalidate(5, draggingOffsetX = 0);
	    $$invalidate(6, draggingOffsetY = 0);
	  }

	  function updateTextWidth(_ref2) {
	    var x = _ref2.x;
	    if (x === 0) return;
	    var newWidth = Math.max(0, x);

	    if (align === 'right') {
	      newWidth = textWidth - x;
	    }

	    $$invalidate(19, textWidth = Math.max(MIN_TEXT_WIDTH, Math.abs(newWidth)));
	    updateDraggable(id, {
	      textWidth: textWidth
	    });
	  }

	  afterUpdate(function () {
	    if (domNode && domNode.offsetHeight) {
	      $$invalidate(9, textAreaHeight = domNode.offsetHeight - 2);
	    }
	  });

	  function div0_binding($$value) {
	    binding_callbacks[$$value ? 'unshift' : 'push'](function () {
	      domNode = $$value;
	      $$invalidate(10, domNode);
	    });
	  }

	  $$self.$$set = function ($$props) {
	    if ('id' in $$props) $$invalidate(0, id = $$props.id);
	    if ('isEditorActive' in $$props) $$invalidate(1, isEditorActive = $$props.isEditorActive);
	    if ('isEditorLocked' in $$props) $$invalidate(2, isEditorLocked = $$props.isEditorLocked);
	    if ('showOffsetHandle' in $$props) $$invalidate(3, showOffsetHandle = $$props.showOffsetHandle);
	    if ('updateDraggable' in $$props) $$invalidate(20, updateDraggable = $$props.updateDraggable);
	    if ('setEditingText' in $$props) $$invalidate(21, setEditingText = $$props.setEditingText);
	    if ('text' in $$props) $$invalidate(22, text = $$props.text);
	    if ('extraClasses' in $$props) $$invalidate(4, extraClasses = $$props.extraClasses);
	    if ('color' in $$props) $$invalidate(23, color = $$props.color);
	    if ('visible' in $$props) $$invalidate(24, visible = $$props.visible);
	    if ('align' in $$props) $$invalidate(25, align = $$props.align);
	    if ('valign' in $$props) $$invalidate(26, valign = $$props.valign);
	    if ('offsetX' in $$props) $$invalidate(27, offsetX = $$props.offsetX);
	    if ('offsetY' in $$props) $$invalidate(28, offsetY = $$props.offsetY);
	    if ('textOffsetX' in $$props) $$invalidate(29, textOffsetX = $$props.textOffsetX);
	    if ('textOffsetY' in $$props) $$invalidate(30, textOffsetY = $$props.textOffsetY);
	    if ('textWidth' in $$props) $$invalidate(19, textWidth = $$props.textWidth);
	    if ('useTextColor' in $$props) $$invalidate(31, useTextColor = $$props.useTextColor);
	    if ('letterSpacing' in $$props) $$invalidate(32, letterSpacing = $$props.letterSpacing);
	    if ('fontSize' in $$props) $$invalidate(33, fontSize = $$props.fontSize);
	  };

	  $$self.$$.update = function () {
	    if ($$self.$$.dirty[0] &
	    /*text*/
	    4194304) {
	      $$invalidate(13, computedText = generateHtml(text));
	    }

	    if ($$self.$$.dirty[0] &
	    /*textWidth, align, valign, draggingOffsetX, draggingOffsetY, visible, textOffsetX, textOffsetY, color*/
	    1736966240 | $$self.$$.dirty[1] &
	    /*fontSize, letterSpacing, useTextColor*/
	    7) {
	      {
	        var xTransform = '0';
	        var yTransform = '0';
	        $$invalidate(11, textWidthHandleX = textWidth - 1);
	        $$invalidate(12, offsetHandleX = 0); // offsetHandleY = 0

	        if (align === 'right') {
	          xTransform = '-100%';
	          $$invalidate(11, textWidthHandleX = 1);
	          $$invalidate(12, offsetHandleX = textWidth);
	        }

	        if (align === 'center') xTransform = '-50%';
	        if (valign === 'bottom') yTransform = '-100%';
	        if (valign === 'center') yTransform = '-50%';
	        $$invalidate(8, textStyle = "\n      left: ".concat(draggingOffsetX, "px;\n      top: ").concat(draggingOffsetY, "px;\n      ").concat(fontSize ? "font-size: ".concat(fontSize, "px") : '', ";\n    "));
	        $$invalidate(7, style = "\n      position: absolute;\n      visibility: ".concat(visible ? 'visible' : 'hidden', ";\n      text-align: ").concat(align, ";\n      transform: translate(").concat(xTransform, ", ").concat(yTransform, ");\n      left: ").concat(textOffsetX, "px;\n      top: ").concat(textOffsetY, "px;\n      width: ").concat(textWidth, "px;\n      letter-spacing: ").concat(letterSpacing, "px;\n      ").concat(color && useTextColor ? "color: ".concat(color, ";") : '', ";\n    "));
	      }
	    }
	  };

	  return [id, isEditorActive, isEditorLocked, showOffsetHandle, extraClasses, draggingOffsetX, draggingOffsetY, style, textStyle, textAreaHeight, domNode, textWidthHandleX, offsetHandleX, computedText, onFocus, onBlur, updateOffset, offsetComplete, updateTextWidth, textWidth, updateDraggable, setEditingText, text, color, visible, align, valign, offsetX, offsetY, textOffsetX, textOffsetY, useTextColor, letterSpacing, fontSize, div0_binding];
	}

	var Text = /*#__PURE__*/function (_SvelteComponent) {
	  _inherits(Text, _SvelteComponent);

	  var _super = _createSuper(Text);

	  function Text(options) {
	    var _this;

	    _classCallCheck(this, Text);

	    _this = _super.call(this);
	    init(_assertThisInitialized(_this), options, instance$o, create_fragment$o, safe_not_equal, {
	      id: 0,
	      isEditorActive: 1,
	      isEditorLocked: 2,
	      showOffsetHandle: 3,
	      updateDraggable: 20,
	      setEditingText: 21,
	      text: 22,
	      extraClasses: 4,
	      color: 23,
	      visible: 24,
	      align: 25,
	      valign: 26,
	      offsetX: 27,
	      offsetY: 28,
	      textOffsetX: 29,
	      textOffsetY: 30,
	      textWidth: 19,
	      useTextColor: 31,
	      letterSpacing: 32,
	      fontSize: 33
	    }, add_css$i, [-1, -1]);
	    return _this;
	  }

	  _createClass(Text, [{
	    key: "id",
	    get: function get() {
	      return this.$$.ctx[0];
	    },
	    set: function set(id) {
	      this.$$set({
	        id: id
	      });
	      flush();
	    }
	  }, {
	    key: "isEditorActive",
	    get: function get() {
	      return this.$$.ctx[1];
	    },
	    set: function set(isEditorActive) {
	      this.$$set({
	        isEditorActive: isEditorActive
	      });
	      flush();
	    }
	  }, {
	    key: "isEditorLocked",
	    get: function get() {
	      return this.$$.ctx[2];
	    },
	    set: function set(isEditorLocked) {
	      this.$$set({
	        isEditorLocked: isEditorLocked
	      });
	      flush();
	    }
	  }, {
	    key: "showOffsetHandle",
	    get: function get() {
	      return this.$$.ctx[3];
	    },
	    set: function set(showOffsetHandle) {
	      this.$$set({
	        showOffsetHandle: showOffsetHandle
	      });
	      flush();
	    }
	  }, {
	    key: "updateDraggable",
	    get: function get() {
	      return this.$$.ctx[20];
	    },
	    set: function set(updateDraggable) {
	      this.$$set({
	        updateDraggable: updateDraggable
	      });
	      flush();
	    }
	  }, {
	    key: "setEditingText",
	    get: function get() {
	      return this.$$.ctx[21];
	    },
	    set: function set(setEditingText) {
	      this.$$set({
	        setEditingText: setEditingText
	      });
	      flush();
	    }
	  }, {
	    key: "text",
	    get: function get() {
	      return this.$$.ctx[22];
	    },
	    set: function set(text) {
	      this.$$set({
	        text: text
	      });
	      flush();
	    }
	  }, {
	    key: "extraClasses",
	    get: function get() {
	      return this.$$.ctx[4];
	    },
	    set: function set(extraClasses) {
	      this.$$set({
	        extraClasses: extraClasses
	      });
	      flush();
	    }
	  }, {
	    key: "color",
	    get: function get() {
	      return this.$$.ctx[23];
	    },
	    set: function set(color) {
	      this.$$set({
	        color: color
	      });
	      flush();
	    }
	  }, {
	    key: "visible",
	    get: function get() {
	      return this.$$.ctx[24];
	    },
	    set: function set(visible) {
	      this.$$set({
	        visible: visible
	      });
	      flush();
	    }
	  }, {
	    key: "align",
	    get: function get() {
	      return this.$$.ctx[25];
	    },
	    set: function set(align) {
	      this.$$set({
	        align: align
	      });
	      flush();
	    }
	  }, {
	    key: "valign",
	    get: function get() {
	      return this.$$.ctx[26];
	    },
	    set: function set(valign) {
	      this.$$set({
	        valign: valign
	      });
	      flush();
	    }
	  }, {
	    key: "offsetX",
	    get: function get() {
	      return this.$$.ctx[27];
	    },
	    set: function set(offsetX) {
	      this.$$set({
	        offsetX: offsetX
	      });
	      flush();
	    }
	  }, {
	    key: "offsetY",
	    get: function get() {
	      return this.$$.ctx[28];
	    },
	    set: function set(offsetY) {
	      this.$$set({
	        offsetY: offsetY
	      });
	      flush();
	    }
	  }, {
	    key: "textOffsetX",
	    get: function get() {
	      return this.$$.ctx[29];
	    },
	    set: function set(textOffsetX) {
	      this.$$set({
	        textOffsetX: textOffsetX
	      });
	      flush();
	    }
	  }, {
	    key: "textOffsetY",
	    get: function get() {
	      return this.$$.ctx[30];
	    },
	    set: function set(textOffsetY) {
	      this.$$set({
	        textOffsetY: textOffsetY
	      });
	      flush();
	    }
	  }, {
	    key: "textWidth",
	    get: function get() {
	      return this.$$.ctx[19];
	    },
	    set: function set(textWidth) {
	      this.$$set({
	        textWidth: textWidth
	      });
	      flush();
	    }
	  }, {
	    key: "useTextColor",
	    get: function get() {
	      return this.$$.ctx[31];
	    },
	    set: function set(useTextColor) {
	      this.$$set({
	        useTextColor: useTextColor
	      });
	      flush();
	    }
	  }, {
	    key: "letterSpacing",
	    get: function get() {
	      return this.$$.ctx[32];
	    },
	    set: function set(letterSpacing) {
	      this.$$set({
	        letterSpacing: letterSpacing
	      });
	      flush();
	    }
	  }, {
	    key: "fontSize",
	    get: function get() {
	      return this.$$.ctx[33];
	    },
	    set: function set(fontSize) {
	      this.$$set({
	        fontSize: fontSize
	      });
	      flush();
	    }
	  }]);

	  return Text;
	}(SvelteComponent);

	function create_fragment$n(ctx) {
	  var div;
	  var div_draggable_value;
	  var current;
	  var mounted;
	  var dispose;
	  var default_slot_template =
	  /*#slots*/
	  ctx[33].default;
	  var default_slot = create_slot(default_slot_template, ctx,
	  /*$$scope*/
	  ctx[32], null);
	  return {
	    c: function c() {
	      div = element("div");
	      if (default_slot) default_slot.c();
	      attr(div, "id",
	      /*id*/
	      ctx[0]);
	      attr(div, "class",
	      /*currentClass*/
	      ctx[3]);
	      attr(div, "style",
	      /*style*/
	      ctx[4]);
	      attr(div, "draggable", div_draggable_value = !
	      /*isEditorActive*/
	      ctx[1]);
	    },
	    m: function m(target, anchor) {
	      insert(target, div, anchor);

	      if (default_slot) {
	        default_slot.m(div, null);
	      }
	      /*div_binding*/


	      ctx[34](div);
	      current = true;

	      if (!mounted) {
	        dispose = [listen(window, "keydown",
	        /*keyHandler*/
	        ctx[7]), listen(div, "click",
	        /*onClick*/
	        ctx[8]), listen(div, "dragstart",
	        /*dragStart*/
	        ctx[10]), listen(div, "dragend",
	        /*dragEnd*/
	        ctx[11]), listen(div, "drag", debouncer(
	        /*drag*/
	        ctx[9])), listen(div, "mouseover",
	        /*startHover*/
	        ctx[5]), listen(div, "mouseout",
	        /*endHover*/
	        ctx[6]), listen(div, "focus", focus_handler), listen(div, "blur", blur_handler), listen(div, "keydown", keydown_handler$2)];
	        mounted = true;
	      }
	    },
	    p: function p(ctx, dirty) {
	      if (default_slot) {
	        if (default_slot.p && (!current || dirty[1] &
	        /*$$scope*/
	        2)) {
	          update_slot_base(default_slot, default_slot_template, ctx,
	          /*$$scope*/
	          ctx[32], !current ? get_all_dirty_from_scope(
	          /*$$scope*/
	          ctx[32]) : get_slot_changes(default_slot_template,
	          /*$$scope*/
	          ctx[32], dirty, null), null);
	        }
	      }

	      if (!current || dirty[0] &
	      /*id*/
	      1) {
	        attr(div, "id",
	        /*id*/
	        ctx[0]);
	      }

	      if (!current || dirty[0] &
	      /*currentClass*/
	      8) {
	        attr(div, "class",
	        /*currentClass*/
	        ctx[3]);
	      }

	      if (!current || dirty[0] &
	      /*style*/
	      16) {
	        attr(div, "style",
	        /*style*/
	        ctx[4]);
	      }

	      if (!current || dirty[0] &
	      /*isEditorActive*/
	      2 && div_draggable_value !== (div_draggable_value = !
	      /*isEditorActive*/
	      ctx[1])) {
	        attr(div, "draggable", div_draggable_value);
	      }
	    },
	    i: function i(local) {
	      if (current) return;
	      transition_in(default_slot, local);
	      current = true;
	    },
	    o: function o(local) {
	      transition_out(default_slot, local);
	      current = false;
	    },
	    d: function d(detaching) {
	      if (detaching) detach(div);
	      if (default_slot) default_slot.d(detaching);
	      /*div_binding*/

	      ctx[34](null);
	      mounted = false;
	      run_all(dispose);
	    }
	  };
	}

	var focus_handler = function focus_handler() {
	  return null;
	};

	var blur_handler = function blur_handler() {
	  return null;
	};

	var keydown_handler$2 = function keydown_handler() {
	  return null;
	};

	function instance$n($$self, $$props, $$invalidate) {
	  var style;
	  var editorClass;
	  var editorActiveClass;
	  var visibleClass;
	  var hoverClass;
	  var currentClass;
	  var _$$props$$$slots = $$props.$$slots,
	      slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots,
	      $$scope = $$props.$$scope;
	  var id = $$props.id;
	  var scale = $$props.scale;
	  var _$$props$x = $$props.x,
	      x = _$$props$x === void 0 ? 0 : _$$props$x;
	  var _$$props$y = $$props.y,
	      y = _$$props$y === void 0 ? 0 : _$$props$y;
	  var _$$props$opacity = $$props.opacity,
	      opacity = _$$props$opacity === void 0 ? 1 : _$$props$opacity;
	  var _$$props$visible = $$props.visible,
	      visible = _$$props$visible === void 0 ? true : _$$props$visible;
	  var _$$props$isEditor = $$props.isEditor,
	      isEditor = _$$props$isEditor === void 0 ? false : _$$props$isEditor;
	  var _$$props$isEditorActi = $$props.isEditorActive,
	      isEditorActive = _$$props$isEditorActi === void 0 ? false : _$$props$isEditorActi;
	  var _$$props$preventKeyHa = $$props.preventKeyHandlers,
	      preventKeyHandlers = _$$props$preventKeyHa === void 0 ? false : _$$props$preventKeyHa;
	  var editor = $$props.editor;
	  var editComponent = $$props.editComponent;
	  var editProperties = $$props.editProperties;
	  var containerWidth = $$props.containerWidth;
	  var updateDraggable = $$props.updateDraggable;
	  var finalizeDraggable = $$props.finalizeDraggable;
	  var darkMode = $$props.darkMode;
	  var _$$props$extraClasses = $$props.extraClasses,
	      extraClasses = _$$props$extraClasses === void 0 ? '' : _$$props$extraClasses;
	  var domNode;
	  var isHovering = false;

	  function startHover() {
	    $$invalidate(27, isHovering = true);
	  }

	  function endHover() {
	    $$invalidate(27, isHovering = false);
	  }

	  function keyHandler(event) {
	    if (isHovering && !preventKeyHandlers) {
	      var key = event.key;
	      var shift = null; // transform position

	      if (key === 'ArrowUp') {
	        shift = [0, -1];
	      } else if (key === 'ArrowDown') {
	        shift = [0, 1];
	      } else if (key === 'ArrowLeft') {
	        shift = [-1, 0];
	      } else if (key === 'ArrowRight') {
	        shift = [1, 0];
	      }

	      if (shift) {
	        event.preventDefault();
	        var scaled = scale.invert(containerWidth, [x + shift[0], y + shift[1]]);
	        updateDraggable(id, {
	          x: scaled[0],
	          y: scaled[1]
	        });
	      }
	    }
	  }

	  function onClick() {
	    editComponent(domNode, editProperties);
	  }

	  function getState() {
	    return {
	      x: x,
	      y: y,
	      isEditorActive: isEditorActive
	    };
	  }

	  var _makeDraggable = makeDraggable(getState, onPositionChange, onPositionComplete),
	      drag = _makeDraggable.drag,
	      dragStart = _makeDraggable.dragStart,
	      dragEnd = _makeDraggable.dragEnd;

	  function onPositionChange(props) {
	    var scaled = scale.invert(containerWidth, [props.x, props.y]);
	    updateDraggable(id, {
	      x: scaled[0],
	      y: scaled[1]
	    });

	    if (isEditor) {
	      editor.calculateBounds();
	    }
	  }

	  function onPositionComplete(props) {
	    var scaled = scale.invert(containerWidth, [props.x, props.y]);
	    finalizeDraggable(id, {
	      x: scaled[0],
	      y: scaled[1]
	    });
	  }

	  function div_binding($$value) {
	    binding_callbacks[$$value ? 'unshift' : 'push'](function () {
	      domNode = $$value;
	      $$invalidate(2, domNode);
	    });
	  }

	  $$self.$$set = function ($$props) {
	    if ('id' in $$props) $$invalidate(0, id = $$props.id);
	    if ('scale' in $$props) $$invalidate(12, scale = $$props.scale);
	    if ('x' in $$props) $$invalidate(13, x = $$props.x);
	    if ('y' in $$props) $$invalidate(14, y = $$props.y);
	    if ('opacity' in $$props) $$invalidate(15, opacity = $$props.opacity);
	    if ('visible' in $$props) $$invalidate(16, visible = $$props.visible);
	    if ('isEditor' in $$props) $$invalidate(17, isEditor = $$props.isEditor);
	    if ('isEditorActive' in $$props) $$invalidate(1, isEditorActive = $$props.isEditorActive);
	    if ('preventKeyHandlers' in $$props) $$invalidate(18, preventKeyHandlers = $$props.preventKeyHandlers);
	    if ('editor' in $$props) $$invalidate(19, editor = $$props.editor);
	    if ('editComponent' in $$props) $$invalidate(20, editComponent = $$props.editComponent);
	    if ('editProperties' in $$props) $$invalidate(21, editProperties = $$props.editProperties);
	    if ('containerWidth' in $$props) $$invalidate(22, containerWidth = $$props.containerWidth);
	    if ('updateDraggable' in $$props) $$invalidate(23, updateDraggable = $$props.updateDraggable);
	    if ('finalizeDraggable' in $$props) $$invalidate(24, finalizeDraggable = $$props.finalizeDraggable);
	    if ('darkMode' in $$props) $$invalidate(25, darkMode = $$props.darkMode);
	    if ('extraClasses' in $$props) $$invalidate(26, extraClasses = $$props.extraClasses);
	    if ('$$scope' in $$props) $$invalidate(32, $$scope = $$props.$$scope);
	  };

	  $$self.$$.update = function () {
	    if ($$self.$$.dirty[0] &
	    /*x, y, opacity*/
	    57344) {
	      $$invalidate(4, style = "transform: translate3d(".concat(x, "px, ").concat(y, "px, 0); opacity: ").concat(opacity, ";"));
	    }

	    if ($$self.$$.dirty[0] &
	    /*isEditor*/
	    131072) {
	      $$invalidate(31, editorClass = isEditor ? 'editor' : '');
	    }

	    if ($$self.$$.dirty[0] &
	    /*isEditorActive*/
	    2) {
	      $$invalidate(30, editorActiveClass = isEditorActive ? 'editorActive' : '');
	    }

	    if ($$self.$$.dirty[0] &
	    /*visible*/
	    65536) {
	      $$invalidate(29, visibleClass = visible ? 'visible' : 'hidden');
	    }

	    if ($$self.$$.dirty[0] &
	    /*isHovering*/
	    134217728) {
	      $$invalidate(28, hoverClass = isHovering ? 'hoverActive' : '');
	    }

	    if ($$self.$$.dirty[0] &
	    /*editorActiveClass, visibleClass, extraClasses, hoverClass, darkMode*/
	    1979711488 | $$self.$$.dirty[1] &
	    /*editorClass*/
	    1) {
	      $$invalidate(3, currentClass = "\n    draggable\n    ".concat(editorClass, "\n    ").concat(editorActiveClass, "\n    ").concat(visibleClass, "\n    ").concat(extraClasses, "\n    ").concat(hoverClass, "\n    ").concat(darkMode ? 'dark' : '', "\n  "));
	    }
	  };

	  return [id, isEditorActive, domNode, currentClass, style, startHover, endHover, keyHandler, onClick, drag, dragStart, dragEnd, scale, x, y, opacity, visible, isEditor, preventKeyHandlers, editor, editComponent, editProperties, containerWidth, updateDraggable, finalizeDraggable, darkMode, extraClasses, isHovering, hoverClass, visibleClass, editorActiveClass, editorClass, $$scope, slots, div_binding];
	}

	var Draggable = /*#__PURE__*/function (_SvelteComponent) {
	  _inherits(Draggable, _SvelteComponent);

	  var _super = _createSuper(Draggable);

	  function Draggable(options) {
	    var _this;

	    _classCallCheck(this, Draggable);

	    _this = _super.call(this);
	    init(_assertThisInitialized(_this), options, instance$n, create_fragment$n, safe_not_equal, {
	      id: 0,
	      scale: 12,
	      x: 13,
	      y: 14,
	      opacity: 15,
	      visible: 16,
	      isEditor: 17,
	      isEditorActive: 1,
	      preventKeyHandlers: 18,
	      editor: 19,
	      editComponent: 20,
	      editProperties: 21,
	      containerWidth: 22,
	      updateDraggable: 23,
	      finalizeDraggable: 24,
	      darkMode: 25,
	      extraClasses: 26
	    }, null, [-1, -1]);
	    return _this;
	  }

	  _createClass(Draggable, [{
	    key: "id",
	    get: function get() {
	      return this.$$.ctx[0];
	    },
	    set: function set(id) {
	      this.$$set({
	        id: id
	      });
	      flush();
	    }
	  }, {
	    key: "scale",
	    get: function get() {
	      return this.$$.ctx[12];
	    },
	    set: function set(scale) {
	      this.$$set({
	        scale: scale
	      });
	      flush();
	    }
	  }, {
	    key: "x",
	    get: function get() {
	      return this.$$.ctx[13];
	    },
	    set: function set(x) {
	      this.$$set({
	        x: x
	      });
	      flush();
	    }
	  }, {
	    key: "y",
	    get: function get() {
	      return this.$$.ctx[14];
	    },
	    set: function set(y) {
	      this.$$set({
	        y: y
	      });
	      flush();
	    }
	  }, {
	    key: "opacity",
	    get: function get() {
	      return this.$$.ctx[15];
	    },
	    set: function set(opacity) {
	      this.$$set({
	        opacity: opacity
	      });
	      flush();
	    }
	  }, {
	    key: "visible",
	    get: function get() {
	      return this.$$.ctx[16];
	    },
	    set: function set(visible) {
	      this.$$set({
	        visible: visible
	      });
	      flush();
	    }
	  }, {
	    key: "isEditor",
	    get: function get() {
	      return this.$$.ctx[17];
	    },
	    set: function set(isEditor) {
	      this.$$set({
	        isEditor: isEditor
	      });
	      flush();
	    }
	  }, {
	    key: "isEditorActive",
	    get: function get() {
	      return this.$$.ctx[1];
	    },
	    set: function set(isEditorActive) {
	      this.$$set({
	        isEditorActive: isEditorActive
	      });
	      flush();
	    }
	  }, {
	    key: "preventKeyHandlers",
	    get: function get() {
	      return this.$$.ctx[18];
	    },
	    set: function set(preventKeyHandlers) {
	      this.$$set({
	        preventKeyHandlers: preventKeyHandlers
	      });
	      flush();
	    }
	  }, {
	    key: "editor",
	    get: function get() {
	      return this.$$.ctx[19];
	    },
	    set: function set(editor) {
	      this.$$set({
	        editor: editor
	      });
	      flush();
	    }
	  }, {
	    key: "editComponent",
	    get: function get() {
	      return this.$$.ctx[20];
	    },
	    set: function set(editComponent) {
	      this.$$set({
	        editComponent: editComponent
	      });
	      flush();
	    }
	  }, {
	    key: "editProperties",
	    get: function get() {
	      return this.$$.ctx[21];
	    },
	    set: function set(editProperties) {
	      this.$$set({
	        editProperties: editProperties
	      });
	      flush();
	    }
	  }, {
	    key: "containerWidth",
	    get: function get() {
	      return this.$$.ctx[22];
	    },
	    set: function set(containerWidth) {
	      this.$$set({
	        containerWidth: containerWidth
	      });
	      flush();
	    }
	  }, {
	    key: "updateDraggable",
	    get: function get() {
	      return this.$$.ctx[23];
	    },
	    set: function set(updateDraggable) {
	      this.$$set({
	        updateDraggable: updateDraggable
	      });
	      flush();
	    }
	  }, {
	    key: "finalizeDraggable",
	    get: function get() {
	      return this.$$.ctx[24];
	    },
	    set: function set(finalizeDraggable) {
	      this.$$set({
	        finalizeDraggable: finalizeDraggable
	      });
	      flush();
	    }
	  }, {
	    key: "darkMode",
	    get: function get() {
	      return this.$$.ctx[25];
	    },
	    set: function set(darkMode) {
	      this.$$set({
	        darkMode: darkMode
	      });
	      flush();
	    }
	  }, {
	    key: "extraClasses",
	    get: function get() {
	      return this.$$.ctx[26];
	    },
	    set: function set(extraClasses) {
	      this.$$set({
	        extraClasses: extraClasses
	      });
	      flush();
	    }
	  }]);

	  return Draggable;
	}(SvelteComponent);

	function create_if_block$e(ctx) {
	  var draghandle;
	  var current;
	  draghandle = new DragHandle({
	    props: {
	      id:
	      /*id*/
	      ctx[4],
	      x: "0",
	      y: "0",
	      active: "true",
	      handleClass: "move",
	      onChange:
	      /*positionChange*/
	      ctx[25]
	    }
	  });
	  return {
	    c: function c() {
	      create_component(draghandle.$$.fragment);
	    },
	    m: function m(target, anchor) {
	      mount_component(draghandle, target, anchor);
	      current = true;
	    },
	    p: function p(ctx, dirty) {
	      var draghandle_changes = {};
	      if (dirty[0] &
	      /*id*/
	      16) draghandle_changes.id =
	      /*id*/
	      ctx[4];
	      if (dirty[0] &
	      /*positionChange*/
	      33554432) draghandle_changes.onChange =
	      /*positionChange*/
	      ctx[25];
	      draghandle.$set(draghandle_changes);
	    },
	    i: function i(local) {
	      if (current) return;
	      transition_in(draghandle.$$.fragment, local);
	      current = true;
	    },
	    o: function o(local) {
	      transition_out(draghandle.$$.fragment, local);
	      current = false;
	    },
	    d: function d(detaching) {
	      destroy_component(draghandle, detaching);
	    }
	  };
	} // (54:0) <Draggable   {id}   {x}   {y}   {visible}   {opacity}   {scale}   {editor}   {isEditor}   {isEditorActive}   {preventKeyHandlers}   {editComponent}   {containerWidth}   {updateDraggable}   {finalizeDraggable}   {extraClasses}   {darkMode} >


	function create_default_slot$6(ctx) {
	  var text_1;
	  var t;
	  var if_block_anchor;
	  var current;
	  text_1 = new Text({
	    props: {
	      id:
	      /*id*/
	      ctx[4],
	      isEditorActive:
	      /*isEditorActive*/
	      ctx[1],
	      setEditingText:
	      /*setEditingText*/
	      ctx[26],
	      updateDraggable:
	      /*updateDraggable*/
	      ctx[9],
	      finalizeDraggable:
	      /*finalizeDraggable*/
	      ctx[10],
	      text:
	      /*text*/
	      ctx[11],
	      align:
	      /*align*/
	      ctx[12],
	      valign:
	      /*valign*/
	      ctx[13],
	      color:
	      /*color*/
	      ctx[5],
	      visible:
	      /*visible*/
	      ctx[6],
	      textWidth:
	      /*textWidth*/
	      ctx[18],
	      letterSpacing:
	      /*letterSpacing*/
	      ctx[19],
	      fontSize:
	      /*fontSize*/
	      ctx[20],
	      offsetX:
	      /*offsetX*/
	      ctx[16],
	      offsetY:
	      /*offsetY*/
	      ctx[17],
	      textOffsetX:
	      /*offsetX*/
	      ctx[16],
	      textOffsetY:
	      /*offsetY*/
	      ctx[17],
	      showOffsetHandle: false
	    }
	  });
	  var if_block =
	  /*isEditorActive*/
	  ctx[1] &&
	  /*visible*/
	  ctx[6] && create_if_block$e(ctx);
	  return {
	    c: function c() {
	      create_component(text_1.$$.fragment);
	      t = space();
	      if (if_block) if_block.c();
	      if_block_anchor = empty();
	    },
	    m: function m(target, anchor) {
	      mount_component(text_1, target, anchor);
	      insert(target, t, anchor);
	      if (if_block) if_block.m(target, anchor);
	      insert(target, if_block_anchor, anchor);
	      current = true;
	    },
	    p: function p(ctx, dirty) {
	      var text_1_changes = {};
	      if (dirty[0] &
	      /*id*/
	      16) text_1_changes.id =
	      /*id*/
	      ctx[4];
	      if (dirty[0] &
	      /*isEditorActive*/
	      2) text_1_changes.isEditorActive =
	      /*isEditorActive*/
	      ctx[1];
	      if (dirty[0] &
	      /*updateDraggable*/
	      512) text_1_changes.updateDraggable =
	      /*updateDraggable*/
	      ctx[9];
	      if (dirty[0] &
	      /*finalizeDraggable*/
	      1024) text_1_changes.finalizeDraggable =
	      /*finalizeDraggable*/
	      ctx[10];
	      if (dirty[0] &
	      /*text*/
	      2048) text_1_changes.text =
	      /*text*/
	      ctx[11];
	      if (dirty[0] &
	      /*align*/
	      4096) text_1_changes.align =
	      /*align*/
	      ctx[12];
	      if (dirty[0] &
	      /*valign*/
	      8192) text_1_changes.valign =
	      /*valign*/
	      ctx[13];
	      if (dirty[0] &
	      /*color*/
	      32) text_1_changes.color =
	      /*color*/
	      ctx[5];
	      if (dirty[0] &
	      /*visible*/
	      64) text_1_changes.visible =
	      /*visible*/
	      ctx[6];
	      if (dirty[0] &
	      /*textWidth*/
	      262144) text_1_changes.textWidth =
	      /*textWidth*/
	      ctx[18];
	      if (dirty[0] &
	      /*letterSpacing*/
	      524288) text_1_changes.letterSpacing =
	      /*letterSpacing*/
	      ctx[19];
	      if (dirty[0] &
	      /*fontSize*/
	      1048576) text_1_changes.fontSize =
	      /*fontSize*/
	      ctx[20];
	      if (dirty[0] &
	      /*offsetX*/
	      65536) text_1_changes.offsetX =
	      /*offsetX*/
	      ctx[16];
	      if (dirty[0] &
	      /*offsetY*/
	      131072) text_1_changes.offsetY =
	      /*offsetY*/
	      ctx[17];
	      if (dirty[0] &
	      /*offsetX*/
	      65536) text_1_changes.textOffsetX =
	      /*offsetX*/
	      ctx[16];
	      if (dirty[0] &
	      /*offsetY*/
	      131072) text_1_changes.textOffsetY =
	      /*offsetY*/
	      ctx[17];
	      text_1.$set(text_1_changes);

	      if (
	      /*isEditorActive*/
	      ctx[1] &&
	      /*visible*/
	      ctx[6]) {
	        if (if_block) {
	          if_block.p(ctx, dirty);

	          if (dirty[0] &
	          /*isEditorActive, visible*/
	          66) {
	            transition_in(if_block, 1);
	          }
	        } else {
	          if_block = create_if_block$e(ctx);
	          if_block.c();
	          transition_in(if_block, 1);
	          if_block.m(if_block_anchor.parentNode, if_block_anchor);
	        }
	      } else if (if_block) {
	        group_outros();
	        transition_out(if_block, 1, 1, function () {
	          if_block = null;
	        });
	        check_outros();
	      }
	    },
	    i: function i(local) {
	      if (current) return;
	      transition_in(text_1.$$.fragment, local);
	      transition_in(if_block);
	      current = true;
	    },
	    o: function o(local) {
	      transition_out(text_1.$$.fragment, local);
	      transition_out(if_block);
	      current = false;
	    },
	    d: function d(detaching) {
	      destroy_component(text_1, detaching);
	      if (detaching) detach(t);
	      if (if_block) if_block.d(detaching);
	      if (detaching) detach(if_block_anchor);
	    }
	  };
	}

	function create_fragment$m(ctx) {
	  var draggable;
	  var current;
	  draggable = new Draggable({
	    props: {
	      id:
	      /*id*/
	      ctx[4],
	      x:
	      /*x*/
	      ctx[14],
	      y:
	      /*y*/
	      ctx[15],
	      visible:
	      /*visible*/
	      ctx[6],
	      opacity:
	      /*opacity*/
	      ctx[21],
	      scale:
	      /*scale*/
	      ctx[7],
	      editor:
	      /*editor*/
	      ctx[2],
	      isEditor:
	      /*isEditor*/
	      ctx[0],
	      isEditorActive:
	      /*isEditorActive*/
	      ctx[1],
	      preventKeyHandlers:
	      /*preventKeyHandlers*/
	      ctx[23],
	      editComponent:
	      /*editComponent*/
	      ctx[3],
	      containerWidth:
	      /*containerWidth*/
	      ctx[8],
	      updateDraggable:
	      /*updateDraggable*/
	      ctx[9],
	      finalizeDraggable:
	      /*finalizeDraggable*/
	      ctx[10],
	      extraClasses:
	      /*extraClasses*/
	      ctx[24],
	      darkMode:
	      /*darkMode*/
	      ctx[22],
	      $$slots: {
	        default: [create_default_slot$6]
	      },
	      $$scope: {
	        ctx: ctx
	      }
	    }
	  });
	  return {
	    c: function c() {
	      create_component(draggable.$$.fragment);
	    },
	    m: function m(target, anchor) {
	      mount_component(draggable, target, anchor);
	      current = true;
	    },
	    p: function p(ctx, dirty) {
	      var draggable_changes = {};
	      if (dirty[0] &
	      /*id*/
	      16) draggable_changes.id =
	      /*id*/
	      ctx[4];
	      if (dirty[0] &
	      /*x*/
	      16384) draggable_changes.x =
	      /*x*/
	      ctx[14];
	      if (dirty[0] &
	      /*y*/
	      32768) draggable_changes.y =
	      /*y*/
	      ctx[15];
	      if (dirty[0] &
	      /*visible*/
	      64) draggable_changes.visible =
	      /*visible*/
	      ctx[6];
	      if (dirty[0] &
	      /*opacity*/
	      2097152) draggable_changes.opacity =
	      /*opacity*/
	      ctx[21];
	      if (dirty[0] &
	      /*scale*/
	      128) draggable_changes.scale =
	      /*scale*/
	      ctx[7];
	      if (dirty[0] &
	      /*editor*/
	      4) draggable_changes.editor =
	      /*editor*/
	      ctx[2];
	      if (dirty[0] &
	      /*isEditor*/
	      1) draggable_changes.isEditor =
	      /*isEditor*/
	      ctx[0];
	      if (dirty[0] &
	      /*isEditorActive*/
	      2) draggable_changes.isEditorActive =
	      /*isEditorActive*/
	      ctx[1];
	      if (dirty[0] &
	      /*preventKeyHandlers*/
	      8388608) draggable_changes.preventKeyHandlers =
	      /*preventKeyHandlers*/
	      ctx[23];
	      if (dirty[0] &
	      /*editComponent*/
	      8) draggable_changes.editComponent =
	      /*editComponent*/
	      ctx[3];
	      if (dirty[0] &
	      /*containerWidth*/
	      256) draggable_changes.containerWidth =
	      /*containerWidth*/
	      ctx[8];
	      if (dirty[0] &
	      /*updateDraggable*/
	      512) draggable_changes.updateDraggable =
	      /*updateDraggable*/
	      ctx[9];
	      if (dirty[0] &
	      /*finalizeDraggable*/
	      1024) draggable_changes.finalizeDraggable =
	      /*finalizeDraggable*/
	      ctx[10];
	      if (dirty[0] &
	      /*extraClasses*/
	      16777216) draggable_changes.extraClasses =
	      /*extraClasses*/
	      ctx[24];
	      if (dirty[0] &
	      /*darkMode*/
	      4194304) draggable_changes.darkMode =
	      /*darkMode*/
	      ctx[22];

	      if (dirty[0] &
	      /*id, positionChange, isEditorActive, visible, updateDraggable, finalizeDraggable, text, align, valign, color, textWidth, letterSpacing, fontSize, offsetX, offsetY*/
	      35602034 | dirty[1] &
	      /*$$scope*/
	      2) {
	        draggable_changes.$$scope = {
	          dirty: dirty,
	          ctx: ctx
	        };
	      }

	      draggable.$set(draggable_changes);
	    },
	    i: function i(local) {
	      if (current) return;
	      transition_in(draggable.$$.fragment, local);
	      current = true;
	    },
	    o: function o(local) {
	      transition_out(draggable.$$.fragment, local);
	      current = false;
	    },
	    d: function d(detaching) {
	      destroy_component(draggable, detaching);
	    }
	  };
	}

	function instance$m($$self, $$props, $$invalidate) {
	  var positionChange;
	  var mobileClass;
	  var outlineClass;
	  var infoBoxClass;
	  var extraClasses;
	  var _$$props$isEditor = $$props.isEditor,
	      isEditor = _$$props$isEditor === void 0 ? false : _$$props$isEditor;
	  var _$$props$isEditorActi = $$props.isEditorActive,
	      isEditorActive = _$$props$isEditorActi === void 0 ? false : _$$props$isEditorActi;
	  var editor = $$props.editor;
	  var editComponent = $$props.editComponent;
	  var id = $$props.id;
	  var color = $$props.color;
	  var _$$props$visible = $$props.visible,
	      visible = _$$props$visible === void 0 ? true : _$$props$visible;
	  var scale = $$props.scale;
	  var containerWidth = $$props.containerWidth;
	  var updateDraggable = $$props.updateDraggable;
	  var finalizeDraggable = $$props.finalizeDraggable;
	  var _$$props$text = $$props.text,
	      text = _$$props$text === void 0 ? '' : _$$props$text;
	  var _$$props$align = $$props.align,
	      align = _$$props$align === void 0 ? 'left' : _$$props$align;
	  var _$$props$valign = $$props.valign,
	      valign = _$$props$valign === void 0 ? 'top' : _$$props$valign;
	  var _$$props$x = $$props.x,
	      x = _$$props$x === void 0 ? 0 : _$$props$x;
	  var _$$props$y = $$props.y,
	      y = _$$props$y === void 0 ? 0 : _$$props$y;
	  var _$$props$offsetX = $$props.offsetX,
	      offsetX = _$$props$offsetX === void 0 ? 0 : _$$props$offsetX;
	  var _$$props$offsetY = $$props.offsetY,
	      offsetY = _$$props$offsetY === void 0 ? 0 : _$$props$offsetY;
	  var outline = $$props.outline;
	  var infoBox = $$props.infoBox;
	  var textWidth = $$props.textWidth;
	  var letterSpacing = $$props.letterSpacing;
	  var fontSize = $$props.fontSize;
	  var opacity = $$props.opacity;
	  var darkMode = $$props.darkMode;
	  var preventKeyHandlers = false;

	  function setEditingText(editState) {
	    $$invalidate(23, preventKeyHandlers = editState);
	  }

	  $$self.$$set = function ($$props) {
	    if ('isEditor' in $$props) $$invalidate(0, isEditor = $$props.isEditor);
	    if ('isEditorActive' in $$props) $$invalidate(1, isEditorActive = $$props.isEditorActive);
	    if ('editor' in $$props) $$invalidate(2, editor = $$props.editor);
	    if ('editComponent' in $$props) $$invalidate(3, editComponent = $$props.editComponent);
	    if ('id' in $$props) $$invalidate(4, id = $$props.id);
	    if ('color' in $$props) $$invalidate(5, color = $$props.color);
	    if ('visible' in $$props) $$invalidate(6, visible = $$props.visible);
	    if ('scale' in $$props) $$invalidate(7, scale = $$props.scale);
	    if ('containerWidth' in $$props) $$invalidate(8, containerWidth = $$props.containerWidth);
	    if ('updateDraggable' in $$props) $$invalidate(9, updateDraggable = $$props.updateDraggable);
	    if ('finalizeDraggable' in $$props) $$invalidate(10, finalizeDraggable = $$props.finalizeDraggable);
	    if ('text' in $$props) $$invalidate(11, text = $$props.text);
	    if ('align' in $$props) $$invalidate(12, align = $$props.align);
	    if ('valign' in $$props) $$invalidate(13, valign = $$props.valign);
	    if ('x' in $$props) $$invalidate(14, x = $$props.x);
	    if ('y' in $$props) $$invalidate(15, y = $$props.y);
	    if ('offsetX' in $$props) $$invalidate(16, offsetX = $$props.offsetX);
	    if ('offsetY' in $$props) $$invalidate(17, offsetY = $$props.offsetY);
	    if ('outline' in $$props) $$invalidate(27, outline = $$props.outline);
	    if ('infoBox' in $$props) $$invalidate(28, infoBox = $$props.infoBox);
	    if ('textWidth' in $$props) $$invalidate(18, textWidth = $$props.textWidth);
	    if ('letterSpacing' in $$props) $$invalidate(19, letterSpacing = $$props.letterSpacing);
	    if ('fontSize' in $$props) $$invalidate(20, fontSize = $$props.fontSize);
	    if ('opacity' in $$props) $$invalidate(21, opacity = $$props.opacity);
	    if ('darkMode' in $$props) $$invalidate(22, darkMode = $$props.darkMode);
	  };

	  $$self.$$.update = function () {
	    if ($$self.$$.dirty[0] &
	    /*id, x, y, scale, containerWidth, updateDraggable, isEditor, editor*/
	    50069) {
	      $$invalidate(25, positionChange = positionChangeHandler(id, x, y, scale, containerWidth, updateDraggable, isEditor, editor));
	    }

	    if ($$self.$$.dirty[0] &
	    /*containerWidth*/
	    256) {
	      $$invalidate(31, mobileClass = containerWidth < 500 ? 'mobile' : '');
	    }

	    if ($$self.$$.dirty[0] &
	    /*outline*/
	    134217728) {
	      $$invalidate(30, outlineClass = outline ? 'outline' : '');
	    }

	    if ($$self.$$.dirty[0] &
	    /*infoBox*/
	    268435456) {
	      $$invalidate(29, infoBoxClass = infoBox ? 'infoBox' : '');
	    }

	    if ($$self.$$.dirty[0] &
	    /*outlineClass, infoBoxClass*/
	    1610612736 | $$self.$$.dirty[1] &
	    /*mobileClass*/
	    1) {
	      $$invalidate(24, extraClasses = "".concat(mobileClass, " ").concat(outlineClass, " ").concat(infoBoxClass));
	    }
	  };

	  return [isEditor, isEditorActive, editor, editComponent, id, color, visible, scale, containerWidth, updateDraggable, finalizeDraggable, text, align, valign, x, y, offsetX, offsetY, textWidth, letterSpacing, fontSize, opacity, darkMode, preventKeyHandlers, extraClasses, positionChange, setEditingText, outline, infoBox, infoBoxClass, outlineClass, mobileClass];
	}

	var Label = /*#__PURE__*/function (_SvelteComponent) {
	  _inherits(Label, _SvelteComponent);

	  var _super = _createSuper(Label);

	  function Label(options) {
	    var _this;

	    _classCallCheck(this, Label);

	    _this = _super.call(this);
	    init(_assertThisInitialized(_this), options, instance$m, create_fragment$m, safe_not_equal, {
	      isEditor: 0,
	      isEditorActive: 1,
	      editor: 2,
	      editComponent: 3,
	      id: 4,
	      color: 5,
	      visible: 6,
	      scale: 7,
	      containerWidth: 8,
	      updateDraggable: 9,
	      finalizeDraggable: 10,
	      text: 11,
	      align: 12,
	      valign: 13,
	      x: 14,
	      y: 15,
	      offsetX: 16,
	      offsetY: 17,
	      outline: 27,
	      infoBox: 28,
	      textWidth: 18,
	      letterSpacing: 19,
	      fontSize: 20,
	      opacity: 21,
	      darkMode: 22
	    }, null, [-1, -1]);
	    return _this;
	  }

	  _createClass(Label, [{
	    key: "isEditor",
	    get: function get() {
	      return this.$$.ctx[0];
	    },
	    set: function set(isEditor) {
	      this.$$set({
	        isEditor: isEditor
	      });
	      flush();
	    }
	  }, {
	    key: "isEditorActive",
	    get: function get() {
	      return this.$$.ctx[1];
	    },
	    set: function set(isEditorActive) {
	      this.$$set({
	        isEditorActive: isEditorActive
	      });
	      flush();
	    }
	  }, {
	    key: "editor",
	    get: function get() {
	      return this.$$.ctx[2];
	    },
	    set: function set(editor) {
	      this.$$set({
	        editor: editor
	      });
	      flush();
	    }
	  }, {
	    key: "editComponent",
	    get: function get() {
	      return this.$$.ctx[3];
	    },
	    set: function set(editComponent) {
	      this.$$set({
	        editComponent: editComponent
	      });
	      flush();
	    }
	  }, {
	    key: "id",
	    get: function get() {
	      return this.$$.ctx[4];
	    },
	    set: function set(id) {
	      this.$$set({
	        id: id
	      });
	      flush();
	    }
	  }, {
	    key: "color",
	    get: function get() {
	      return this.$$.ctx[5];
	    },
	    set: function set(color) {
	      this.$$set({
	        color: color
	      });
	      flush();
	    }
	  }, {
	    key: "visible",
	    get: function get() {
	      return this.$$.ctx[6];
	    },
	    set: function set(visible) {
	      this.$$set({
	        visible: visible
	      });
	      flush();
	    }
	  }, {
	    key: "scale",
	    get: function get() {
	      return this.$$.ctx[7];
	    },
	    set: function set(scale) {
	      this.$$set({
	        scale: scale
	      });
	      flush();
	    }
	  }, {
	    key: "containerWidth",
	    get: function get() {
	      return this.$$.ctx[8];
	    },
	    set: function set(containerWidth) {
	      this.$$set({
	        containerWidth: containerWidth
	      });
	      flush();
	    }
	  }, {
	    key: "updateDraggable",
	    get: function get() {
	      return this.$$.ctx[9];
	    },
	    set: function set(updateDraggable) {
	      this.$$set({
	        updateDraggable: updateDraggable
	      });
	      flush();
	    }
	  }, {
	    key: "finalizeDraggable",
	    get: function get() {
	      return this.$$.ctx[10];
	    },
	    set: function set(finalizeDraggable) {
	      this.$$set({
	        finalizeDraggable: finalizeDraggable
	      });
	      flush();
	    }
	  }, {
	    key: "text",
	    get: function get() {
	      return this.$$.ctx[11];
	    },
	    set: function set(text) {
	      this.$$set({
	        text: text
	      });
	      flush();
	    }
	  }, {
	    key: "align",
	    get: function get() {
	      return this.$$.ctx[12];
	    },
	    set: function set(align) {
	      this.$$set({
	        align: align
	      });
	      flush();
	    }
	  }, {
	    key: "valign",
	    get: function get() {
	      return this.$$.ctx[13];
	    },
	    set: function set(valign) {
	      this.$$set({
	        valign: valign
	      });
	      flush();
	    }
	  }, {
	    key: "x",
	    get: function get() {
	      return this.$$.ctx[14];
	    },
	    set: function set(x) {
	      this.$$set({
	        x: x
	      });
	      flush();
	    }
	  }, {
	    key: "y",
	    get: function get() {
	      return this.$$.ctx[15];
	    },
	    set: function set(y) {
	      this.$$set({
	        y: y
	      });
	      flush();
	    }
	  }, {
	    key: "offsetX",
	    get: function get() {
	      return this.$$.ctx[16];
	    },
	    set: function set(offsetX) {
	      this.$$set({
	        offsetX: offsetX
	      });
	      flush();
	    }
	  }, {
	    key: "offsetY",
	    get: function get() {
	      return this.$$.ctx[17];
	    },
	    set: function set(offsetY) {
	      this.$$set({
	        offsetY: offsetY
	      });
	      flush();
	    }
	  }, {
	    key: "outline",
	    get: function get() {
	      return this.$$.ctx[27];
	    },
	    set: function set(outline) {
	      this.$$set({
	        outline: outline
	      });
	      flush();
	    }
	  }, {
	    key: "infoBox",
	    get: function get() {
	      return this.$$.ctx[28];
	    },
	    set: function set(infoBox) {
	      this.$$set({
	        infoBox: infoBox
	      });
	      flush();
	    }
	  }, {
	    key: "textWidth",
	    get: function get() {
	      return this.$$.ctx[18];
	    },
	    set: function set(textWidth) {
	      this.$$set({
	        textWidth: textWidth
	      });
	      flush();
	    }
	  }, {
	    key: "letterSpacing",
	    get: function get() {
	      return this.$$.ctx[19];
	    },
	    set: function set(letterSpacing) {
	      this.$$set({
	        letterSpacing: letterSpacing
	      });
	      flush();
	    }
	  }, {
	    key: "fontSize",
	    get: function get() {
	      return this.$$.ctx[20];
	    },
	    set: function set(fontSize) {
	      this.$$set({
	        fontSize: fontSize
	      });
	      flush();
	    }
	  }, {
	    key: "opacity",
	    get: function get() {
	      return this.$$.ctx[21];
	    },
	    set: function set(opacity) {
	      this.$$set({
	        opacity: opacity
	      });
	      flush();
	    }
	  }, {
	    key: "darkMode",
	    get: function get() {
	      return this.$$.ctx[22];
	    },
	    set: function set(darkMode) {
	      this.$$set({
	        darkMode: darkMode
	      });
	      flush();
	    }
	  }]);

	  return Label;
	}(SvelteComponent);

	function add_css$h(target) {
	  append_styles(target, "svelte-3irid9", "svg.svelte-3irid9{position:absolute;overflow:visible}");
	} // (109:2) {#if visible}


	function create_if_block_1$a(ctx) {
	  var text_1;
	  var t;
	  var svg;
	  var g;
	  var path;
	  var path_d_value;
	  var g_transform_value;
	  var current;
	  text_1 = new Text({
	    props: {
	      id:
	      /*id*/
	      ctx[4],
	      isEditorActive:
	      /*isEditorActive*/
	      ctx[1],
	      setEditingText:
	      /*setEditingText*/
	      ctx[30],
	      updateDraggable:
	      /*updateDraggable*/
	      ctx[8],
	      finalizeDraggable:
	      /*finalizeDraggable*/
	      ctx[9],
	      text:
	      /*text*/
	      ctx[11],
	      align:
	      /*align*/
	      ctx[12],
	      valign:
	      /*valign*/
	      ctx[13],
	      color:
	      /*color*/
	      ctx[5],
	      textWidth:
	      /*textWidth*/
	      ctx[20],
	      fontSize:
	      /*fontSize*/
	      ctx[21],
	      offsetX:
	      /*offsetX*/
	      ctx[18],
	      offsetY:
	      /*offsetY*/
	      ctx[19],
	      textOffsetX:
	      /*textOffsetX*/
	      ctx[24],
	      textOffsetY:
	      /*textOffsetY*/
	      ctx[25],
	      visible:
	      /*visible*/
	      ctx[10]
	    }
	  });
	  return {
	    c: function c() {
	      create_component(text_1.$$.fragment);
	      t = space();
	      svg = svg_element("svg");
	      g = svg_element("g");
	      path = svg_element("path");
	      attr(path, "d", path_d_value = "M 0,0 " +
	      /*x2*/
	      ctx[16] + "," +
	      /*y2*/
	      ctx[17]);
	      attr(path, "style",
	      /*pathStyle*/
	      ctx[27]);
	      attr(g, "transform", g_transform_value = "translate(" + (
	      /*x2*/
	      ctx[16] < 0 ? Math.abs(
	      /*x2*/
	      ctx[16]) : 0) + ", " + (
	      /*y2*/
	      ctx[17] < 0 ? Math.abs(
	      /*y2*/
	      ctx[17]) : 0) + ")");
	      attr(svg, "class", "line draw-region svelte-3irid9");
	      set_style(svg, "left",
	      /*x2*/
	      ctx[16] < 0 ?
	      /*x2*/
	      ctx[16] : 0);
	      set_style(svg, "top",
	      /*y2*/
	      ctx[17] < 0 ?
	      /*y2*/
	      ctx[17] : 0);
	      set_style(svg, "width",
	      /*m10*/
	      ctx[31](
	      /*x2*/
	      ctx[16]));
	      set_style(svg, "height",
	      /*m10*/
	      ctx[31](
	      /*y2*/
	      ctx[17]));
	    },
	    m: function m(target, anchor) {
	      mount_component(text_1, target, anchor);
	      insert(target, t, anchor);
	      insert(target, svg, anchor);
	      append(svg, g);
	      append(g, path);
	      current = true;
	    },
	    p: function p(ctx, dirty) {
	      var text_1_changes = {};
	      if (dirty[0] &
	      /*id*/
	      16) text_1_changes.id =
	      /*id*/
	      ctx[4];
	      if (dirty[0] &
	      /*isEditorActive*/
	      2) text_1_changes.isEditorActive =
	      /*isEditorActive*/
	      ctx[1];
	      if (dirty[0] &
	      /*updateDraggable*/
	      256) text_1_changes.updateDraggable =
	      /*updateDraggable*/
	      ctx[8];
	      if (dirty[0] &
	      /*finalizeDraggable*/
	      512) text_1_changes.finalizeDraggable =
	      /*finalizeDraggable*/
	      ctx[9];
	      if (dirty[0] &
	      /*text*/
	      2048) text_1_changes.text =
	      /*text*/
	      ctx[11];
	      if (dirty[0] &
	      /*align*/
	      4096) text_1_changes.align =
	      /*align*/
	      ctx[12];
	      if (dirty[0] &
	      /*valign*/
	      8192) text_1_changes.valign =
	      /*valign*/
	      ctx[13];
	      if (dirty[0] &
	      /*color*/
	      32) text_1_changes.color =
	      /*color*/
	      ctx[5];
	      if (dirty[0] &
	      /*textWidth*/
	      1048576) text_1_changes.textWidth =
	      /*textWidth*/
	      ctx[20];
	      if (dirty[0] &
	      /*fontSize*/
	      2097152) text_1_changes.fontSize =
	      /*fontSize*/
	      ctx[21];
	      if (dirty[0] &
	      /*offsetX*/
	      262144) text_1_changes.offsetX =
	      /*offsetX*/
	      ctx[18];
	      if (dirty[0] &
	      /*offsetY*/
	      524288) text_1_changes.offsetY =
	      /*offsetY*/
	      ctx[19];
	      if (dirty[0] &
	      /*textOffsetX*/
	      16777216) text_1_changes.textOffsetX =
	      /*textOffsetX*/
	      ctx[24];
	      if (dirty[0] &
	      /*textOffsetY*/
	      33554432) text_1_changes.textOffsetY =
	      /*textOffsetY*/
	      ctx[25];
	      if (dirty[0] &
	      /*visible*/
	      1024) text_1_changes.visible =
	      /*visible*/
	      ctx[10];
	      text_1.$set(text_1_changes);

	      if (!current || dirty[0] &
	      /*x2, y2*/
	      196608 && path_d_value !== (path_d_value = "M 0,0 " +
	      /*x2*/
	      ctx[16] + "," +
	      /*y2*/
	      ctx[17])) {
	        attr(path, "d", path_d_value);
	      }

	      if (!current || dirty[0] &
	      /*pathStyle*/
	      134217728) {
	        attr(path, "style",
	        /*pathStyle*/
	        ctx[27]);
	      }

	      if (!current || dirty[0] &
	      /*x2, y2*/
	      196608 && g_transform_value !== (g_transform_value = "translate(" + (
	      /*x2*/
	      ctx[16] < 0 ? Math.abs(
	      /*x2*/
	      ctx[16]) : 0) + ", " + (
	      /*y2*/
	      ctx[17] < 0 ? Math.abs(
	      /*y2*/
	      ctx[17]) : 0) + ")")) {
	        attr(g, "transform", g_transform_value);
	      }

	      if (!current || dirty[0] &
	      /*x2*/
	      65536) {
	        set_style(svg, "left",
	        /*x2*/
	        ctx[16] < 0 ?
	        /*x2*/
	        ctx[16] : 0);
	      }

	      if (!current || dirty[0] &
	      /*y2*/
	      131072) {
	        set_style(svg, "top",
	        /*y2*/
	        ctx[17] < 0 ?
	        /*y2*/
	        ctx[17] : 0);
	      }

	      if (!current || dirty[0] &
	      /*x2*/
	      65536) {
	        set_style(svg, "width",
	        /*m10*/
	        ctx[31](
	        /*x2*/
	        ctx[16]));
	      }

	      if (!current || dirty[0] &
	      /*y2*/
	      131072) {
	        set_style(svg, "height",
	        /*m10*/
	        ctx[31](
	        /*y2*/
	        ctx[17]));
	      }
	    },
	    i: function i(local) {
	      if (current) return;
	      transition_in(text_1.$$.fragment, local);
	      current = true;
	    },
	    o: function o(local) {
	      transition_out(text_1.$$.fragment, local);
	      current = false;
	    },
	    d: function d(detaching) {
	      destroy_component(text_1, detaching);
	      if (detaching) detach(t);
	      if (detaching) detach(svg);
	    }
	  };
	} // (134:2) {#if isEditorActive && visible}


	function create_if_block$d(ctx) {
	  var draghandle0;
	  var t;
	  var draghandle1;
	  var current;
	  draghandle0 = new DragHandle({
	    props: {
	      id:
	      /*id*/
	      ctx[4],
	      x: "0",
	      y: "0",
	      active: "true",
	      handleClass: "move",
	      onChange:
	      /*positionChange*/
	      ctx[29]
	    }
	  });
	  draghandle1 = new DragHandle({
	    props: {
	      id:
	      /*id*/
	      ctx[4],
	      x:
	      /*x2*/
	      ctx[16],
	      y:
	      /*y2*/
	      ctx[17],
	      color: "rgb(145 145 145 / 50%)",
	      handleWidth: "8",
	      handleHeight: "8",
	      active: "true",
	      onChange:
	      /*lineChange*/
	      ctx[32]
	    }
	  });
	  return {
	    c: function c() {
	      create_component(draghandle0.$$.fragment);
	      t = space();
	      create_component(draghandle1.$$.fragment);
	    },
	    m: function m(target, anchor) {
	      mount_component(draghandle0, target, anchor);
	      insert(target, t, anchor);
	      mount_component(draghandle1, target, anchor);
	      current = true;
	    },
	    p: function p(ctx, dirty) {
	      var draghandle0_changes = {};
	      if (dirty[0] &
	      /*id*/
	      16) draghandle0_changes.id =
	      /*id*/
	      ctx[4];
	      if (dirty[0] &
	      /*positionChange*/
	      536870912) draghandle0_changes.onChange =
	      /*positionChange*/
	      ctx[29];
	      draghandle0.$set(draghandle0_changes);
	      var draghandle1_changes = {};
	      if (dirty[0] &
	      /*id*/
	      16) draghandle1_changes.id =
	      /*id*/
	      ctx[4];
	      if (dirty[0] &
	      /*x2*/
	      65536) draghandle1_changes.x =
	      /*x2*/
	      ctx[16];
	      if (dirty[0] &
	      /*y2*/
	      131072) draghandle1_changes.y =
	      /*y2*/
	      ctx[17];
	      draghandle1.$set(draghandle1_changes);
	    },
	    i: function i(local) {
	      if (current) return;
	      transition_in(draghandle0.$$.fragment, local);
	      transition_in(draghandle1.$$.fragment, local);
	      current = true;
	    },
	    o: function o(local) {
	      transition_out(draghandle0.$$.fragment, local);
	      transition_out(draghandle1.$$.fragment, local);
	      current = false;
	    },
	    d: function d(detaching) {
	      destroy_component(draghandle0, detaching);
	      if (detaching) detach(t);
	      destroy_component(draghandle1, detaching);
	    }
	  };
	} // (90:0) <Draggable   {id}   {x}   {y}   {visible}   {opacity}   {scale}   {editor}   {isEditor}   {isEditorActive}   {preventKeyHandlers}   {editComponent}   {containerWidth}   {updateDraggable}   {finalizeDraggable}   {extraClasses}   {darkMode} >


	function create_default_slot$5(ctx) {
	  var t;
	  var if_block1_anchor;
	  var current;
	  var if_block0 =
	  /*visible*/
	  ctx[10] && create_if_block_1$a(ctx);
	  var if_block1 =
	  /*isEditorActive*/
	  ctx[1] &&
	  /*visible*/
	  ctx[10] && create_if_block$d(ctx);
	  return {
	    c: function c() {
	      if (if_block0) if_block0.c();
	      t = space();
	      if (if_block1) if_block1.c();
	      if_block1_anchor = empty();
	    },
	    m: function m(target, anchor) {
	      if (if_block0) if_block0.m(target, anchor);
	      insert(target, t, anchor);
	      if (if_block1) if_block1.m(target, anchor);
	      insert(target, if_block1_anchor, anchor);
	      current = true;
	    },
	    p: function p(ctx, dirty) {
	      if (
	      /*visible*/
	      ctx[10]) {
	        if (if_block0) {
	          if_block0.p(ctx, dirty);

	          if (dirty[0] &
	          /*visible*/
	          1024) {
	            transition_in(if_block0, 1);
	          }
	        } else {
	          if_block0 = create_if_block_1$a(ctx);
	          if_block0.c();
	          transition_in(if_block0, 1);
	          if_block0.m(t.parentNode, t);
	        }
	      } else if (if_block0) {
	        group_outros();
	        transition_out(if_block0, 1, 1, function () {
	          if_block0 = null;
	        });
	        check_outros();
	      }

	      if (
	      /*isEditorActive*/
	      ctx[1] &&
	      /*visible*/
	      ctx[10]) {
	        if (if_block1) {
	          if_block1.p(ctx, dirty);

	          if (dirty[0] &
	          /*isEditorActive, visible*/
	          1026) {
	            transition_in(if_block1, 1);
	          }
	        } else {
	          if_block1 = create_if_block$d(ctx);
	          if_block1.c();
	          transition_in(if_block1, 1);
	          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
	        }
	      } else if (if_block1) {
	        group_outros();
	        transition_out(if_block1, 1, 1, function () {
	          if_block1 = null;
	        });
	        check_outros();
	      }
	    },
	    i: function i(local) {
	      if (current) return;
	      transition_in(if_block0);
	      transition_in(if_block1);
	      current = true;
	    },
	    o: function o(local) {
	      transition_out(if_block0);
	      transition_out(if_block1);
	      current = false;
	    },
	    d: function d(detaching) {
	      if (if_block0) if_block0.d(detaching);
	      if (detaching) detach(t);
	      if (if_block1) if_block1.d(detaching);
	      if (detaching) detach(if_block1_anchor);
	    }
	  };
	}

	function create_fragment$l(ctx) {
	  var draggable;
	  var current;
	  draggable = new Draggable({
	    props: {
	      id:
	      /*id*/
	      ctx[4],
	      x:
	      /*x*/
	      ctx[14],
	      y:
	      /*y*/
	      ctx[15],
	      visible:
	      /*visible*/
	      ctx[10],
	      opacity:
	      /*opacity*/
	      ctx[22],
	      scale:
	      /*scale*/
	      ctx[6],
	      editor:
	      /*editor*/
	      ctx[2],
	      isEditor:
	      /*isEditor*/
	      ctx[0],
	      isEditorActive:
	      /*isEditorActive*/
	      ctx[1],
	      preventKeyHandlers:
	      /*preventKeyHandlers*/
	      ctx[26],
	      editComponent:
	      /*editComponent*/
	      ctx[3],
	      containerWidth:
	      /*containerWidth*/
	      ctx[7],
	      updateDraggable:
	      /*updateDraggable*/
	      ctx[8],
	      finalizeDraggable:
	      /*finalizeDraggable*/
	      ctx[9],
	      extraClasses:
	      /*extraClasses*/
	      ctx[28],
	      darkMode:
	      /*darkMode*/
	      ctx[23],
	      $$slots: {
	        default: [create_default_slot$5]
	      },
	      $$scope: {
	        ctx: ctx
	      }
	    }
	  });
	  return {
	    c: function c() {
	      create_component(draggable.$$.fragment);
	    },
	    m: function m(target, anchor) {
	      mount_component(draggable, target, anchor);
	      current = true;
	    },
	    p: function p(ctx, dirty) {
	      var draggable_changes = {};
	      if (dirty[0] &
	      /*id*/
	      16) draggable_changes.id =
	      /*id*/
	      ctx[4];
	      if (dirty[0] &
	      /*x*/
	      16384) draggable_changes.x =
	      /*x*/
	      ctx[14];
	      if (dirty[0] &
	      /*y*/
	      32768) draggable_changes.y =
	      /*y*/
	      ctx[15];
	      if (dirty[0] &
	      /*visible*/
	      1024) draggable_changes.visible =
	      /*visible*/
	      ctx[10];
	      if (dirty[0] &
	      /*opacity*/
	      4194304) draggable_changes.opacity =
	      /*opacity*/
	      ctx[22];
	      if (dirty[0] &
	      /*scale*/
	      64) draggable_changes.scale =
	      /*scale*/
	      ctx[6];
	      if (dirty[0] &
	      /*editor*/
	      4) draggable_changes.editor =
	      /*editor*/
	      ctx[2];
	      if (dirty[0] &
	      /*isEditor*/
	      1) draggable_changes.isEditor =
	      /*isEditor*/
	      ctx[0];
	      if (dirty[0] &
	      /*isEditorActive*/
	      2) draggable_changes.isEditorActive =
	      /*isEditorActive*/
	      ctx[1];
	      if (dirty[0] &
	      /*preventKeyHandlers*/
	      67108864) draggable_changes.preventKeyHandlers =
	      /*preventKeyHandlers*/
	      ctx[26];
	      if (dirty[0] &
	      /*editComponent*/
	      8) draggable_changes.editComponent =
	      /*editComponent*/
	      ctx[3];
	      if (dirty[0] &
	      /*containerWidth*/
	      128) draggable_changes.containerWidth =
	      /*containerWidth*/
	      ctx[7];
	      if (dirty[0] &
	      /*updateDraggable*/
	      256) draggable_changes.updateDraggable =
	      /*updateDraggable*/
	      ctx[8];
	      if (dirty[0] &
	      /*finalizeDraggable*/
	      512) draggable_changes.finalizeDraggable =
	      /*finalizeDraggable*/
	      ctx[9];
	      if (dirty[0] &
	      /*extraClasses*/
	      268435456) draggable_changes.extraClasses =
	      /*extraClasses*/
	      ctx[28];
	      if (dirty[0] &
	      /*darkMode*/
	      8388608) draggable_changes.darkMode =
	      /*darkMode*/
	      ctx[23];

	      if (dirty[0] &
	      /*id, x2, y2, positionChange, isEditorActive, visible, pathStyle, updateDraggable, finalizeDraggable, text, align, valign, color, textWidth, fontSize, offsetX, offsetY, textOffsetX, textOffsetY*/
	      725565234 | dirty[1] &
	      /*$$scope*/
	      1024) {
	        draggable_changes.$$scope = {
	          dirty: dirty,
	          ctx: ctx
	        };
	      }

	      draggable.$set(draggable_changes);
	    },
	    i: function i(local) {
	      if (current) return;
	      transition_in(draggable.$$.fragment, local);
	      current = true;
	    },
	    o: function o(local) {
	      transition_out(draggable.$$.fragment, local);
	      current = false;
	    },
	    d: function d(detaching) {
	      destroy_component(draggable, detaching);
	    }
	  };
	}

	function instance$l($$self, $$props, $$invalidate) {
	  var positionChange;
	  var mobileClass;
	  var outlineClass;
	  var infoBoxClass;
	  var extraClasses;
	  var pathStyle;
	  var _$$props$isEditor = $$props.isEditor,
	      isEditor = _$$props$isEditor === void 0 ? false : _$$props$isEditor;
	  var _$$props$isEditorActi = $$props.isEditorActive,
	      isEditorActive = _$$props$isEditorActi === void 0 ? false : _$$props$isEditorActi;
	  var editor = $$props.editor;
	  var editComponent = $$props.editComponent;
	  var id = $$props.id;
	  var color = $$props.color;
	  var scale = $$props.scale;
	  var containerWidth = $$props.containerWidth;
	  var _$$props$maxWidth = $$props.maxWidth,
	      maxWidth = _$$props$maxWidth === void 0 ? 200 : _$$props$maxWidth;
	  var updateDraggable = $$props.updateDraggable;
	  var finalizeDraggable = $$props.finalizeDraggable;
	  var _$$props$visible = $$props.visible,
	      visible = _$$props$visible === void 0 ? true : _$$props$visible;
	  var _$$props$text = $$props.text,
	      text = _$$props$text === void 0 ? '' : _$$props$text;
	  var _$$props$align = $$props.align,
	      align = _$$props$align === void 0 ? 'left' : _$$props$align;
	  var _$$props$valign = $$props.valign,
	      valign = _$$props$valign === void 0 ? 'top' : _$$props$valign;
	  var _$$props$lineStyle = $$props.lineStyle,
	      lineStyle = _$$props$lineStyle === void 0 ? 'horizontal' : _$$props$lineStyle;
	  var _$$props$x = $$props.x,
	      x = _$$props$x === void 0 ? 0 : _$$props$x;
	  var _$$props$y = $$props.y,
	      y = _$$props$y === void 0 ? 0 : _$$props$y;
	  var _$$props$x2 = $$props.x2,
	      x2 = _$$props$x2 === void 0 ? 50 : _$$props$x2;
	  var _$$props$y2 = $$props.y2,
	      y2 = _$$props$y2 === void 0 ? 0 : _$$props$y2;
	  var _$$props$offsetX = $$props.offsetX,
	      offsetX = _$$props$offsetX === void 0 ? 0 : _$$props$offsetX;
	  var _$$props$offsetY = $$props.offsetY,
	      offsetY = _$$props$offsetY === void 0 ? 0 : _$$props$offsetY;
	  var _$$props$strokeWidth = $$props.strokeWidth,
	      strokeWidth = _$$props$strokeWidth === void 0 ? 1 : _$$props$strokeWidth;
	  var outline = $$props.outline;
	  var infoBox = $$props.infoBox;
	  var textWidth = $$props.textWidth;
	  var fontSize = $$props.fontSize;
	  var opacity = $$props.opacity;
	  var darkMode = $$props.darkMode;
	  var textOffsetX;
	  var textOffsetY;
	  var preventKeyHandlers = false;

	  function setEditingText(editState) {
	    $$invalidate(26, preventKeyHandlers = editState);
	  }

	  var m10 = function m10(n) {
	    return Math.max(10, Math.abs(n));
	  }; // we limit changes to horizontal / vertical plane here


	  function lineChange(props) {
	    if (lineStyle === 'horizontal') {
	      updateDraggable(id, {
	        x2: Math.min(maxWidth, props.x),
	        y2: 0
	      });
	    } else if (lineStyle === 'vertical') {
	      updateDraggable(id, {
	        x2: 0,
	        y2: Math.min(maxWidth, props.y)
	      });
	    } else {
	      updateDraggable(id, {
	        x2: Math.min(maxWidth, props.x),
	        y2: Math.min(maxWidth, props.y)
	      });
	    }
	  }

	  $$self.$$set = function ($$props) {
	    if ('isEditor' in $$props) $$invalidate(0, isEditor = $$props.isEditor);
	    if ('isEditorActive' in $$props) $$invalidate(1, isEditorActive = $$props.isEditorActive);
	    if ('editor' in $$props) $$invalidate(2, editor = $$props.editor);
	    if ('editComponent' in $$props) $$invalidate(3, editComponent = $$props.editComponent);
	    if ('id' in $$props) $$invalidate(4, id = $$props.id);
	    if ('color' in $$props) $$invalidate(5, color = $$props.color);
	    if ('scale' in $$props) $$invalidate(6, scale = $$props.scale);
	    if ('containerWidth' in $$props) $$invalidate(7, containerWidth = $$props.containerWidth);
	    if ('maxWidth' in $$props) $$invalidate(33, maxWidth = $$props.maxWidth);
	    if ('updateDraggable' in $$props) $$invalidate(8, updateDraggable = $$props.updateDraggable);
	    if ('finalizeDraggable' in $$props) $$invalidate(9, finalizeDraggable = $$props.finalizeDraggable);
	    if ('visible' in $$props) $$invalidate(10, visible = $$props.visible);
	    if ('text' in $$props) $$invalidate(11, text = $$props.text);
	    if ('align' in $$props) $$invalidate(12, align = $$props.align);
	    if ('valign' in $$props) $$invalidate(13, valign = $$props.valign);
	    if ('lineStyle' in $$props) $$invalidate(34, lineStyle = $$props.lineStyle);
	    if ('x' in $$props) $$invalidate(14, x = $$props.x);
	    if ('y' in $$props) $$invalidate(15, y = $$props.y);
	    if ('x2' in $$props) $$invalidate(16, x2 = $$props.x2);
	    if ('y2' in $$props) $$invalidate(17, y2 = $$props.y2);
	    if ('offsetX' in $$props) $$invalidate(18, offsetX = $$props.offsetX);
	    if ('offsetY' in $$props) $$invalidate(19, offsetY = $$props.offsetY);
	    if ('strokeWidth' in $$props) $$invalidate(35, strokeWidth = $$props.strokeWidth);
	    if ('outline' in $$props) $$invalidate(36, outline = $$props.outline);
	    if ('infoBox' in $$props) $$invalidate(37, infoBox = $$props.infoBox);
	    if ('textWidth' in $$props) $$invalidate(20, textWidth = $$props.textWidth);
	    if ('fontSize' in $$props) $$invalidate(21, fontSize = $$props.fontSize);
	    if ('opacity' in $$props) $$invalidate(22, opacity = $$props.opacity);
	    if ('darkMode' in $$props) $$invalidate(23, darkMode = $$props.darkMode);
	  };

	  $$self.$$.update = function () {
	    if ($$self.$$.dirty[0] &
	    /*id, x, y, scale, containerWidth, updateDraggable, isEditor, editor*/
	    49621) {
	      $$invalidate(29, positionChange = positionChangeHandler(id, x, y, scale, containerWidth, updateDraggable, isEditor, editor));
	    }

	    if ($$self.$$.dirty[0] &
	    /*containerWidth*/
	    128) {
	      $$invalidate(40, mobileClass = containerWidth < 500 ? 'mobile' : '');
	    }

	    if ($$self.$$.dirty[1] &
	    /*outline*/
	    32) {
	      $$invalidate(39, outlineClass = outline ? 'outline' : '');
	    }

	    if ($$self.$$.dirty[1] &
	    /*infoBox*/
	    64) {
	      $$invalidate(38, infoBoxClass = infoBox ? 'infoBox' : '');
	    }

	    if ($$self.$$.dirty[1] &
	    /*mobileClass, outlineClass, infoBoxClass*/
	    896) {
	      $$invalidate(28, extraClasses = "".concat(mobileClass, " ").concat(outlineClass, " ").concat(infoBoxClass));
	    }

	    if ($$self.$$.dirty[1] &
	    /*strokeWidth*/
	    16) {
	      $$invalidate(27, pathStyle = "stroke-width: ".concat(strokeWidth, "px;"));
	    }

	    if ($$self.$$.dirty[0] &
	    /*align, valign, x2, offsetX, y2, offsetY*/
	    995328 | $$self.$$.dirty[1] &
	    /*lineStyle*/
	    8) {
	      {
	        var _alignOffset = alignOffset(align, valign, lineStyle),
	            alignOffsetX = _alignOffset.alignOffsetX,
	            alignOffsetY = _alignOffset.alignOffsetY;

	        $$invalidate(24, textOffsetX = x2 + offsetX + alignOffsetX);
	        $$invalidate(25, textOffsetY = y2 + offsetY + alignOffsetY);
	      }
	    }
	  };

	  return [isEditor, isEditorActive, editor, editComponent, id, color, scale, containerWidth, updateDraggable, finalizeDraggable, visible, text, align, valign, x, y, x2, y2, offsetX, offsetY, textWidth, fontSize, opacity, darkMode, textOffsetX, textOffsetY, preventKeyHandlers, pathStyle, extraClasses, positionChange, setEditingText, m10, lineChange, maxWidth, lineStyle, strokeWidth, outline, infoBox, infoBoxClass, outlineClass, mobileClass];
	}

	var Line = /*#__PURE__*/function (_SvelteComponent) {
	  _inherits(Line, _SvelteComponent);

	  var _super = _createSuper(Line);

	  function Line(options) {
	    var _this;

	    _classCallCheck(this, Line);

	    _this = _super.call(this);
	    init(_assertThisInitialized(_this), options, instance$l, create_fragment$l, safe_not_equal, {
	      isEditor: 0,
	      isEditorActive: 1,
	      editor: 2,
	      editComponent: 3,
	      id: 4,
	      color: 5,
	      scale: 6,
	      containerWidth: 7,
	      maxWidth: 33,
	      updateDraggable: 8,
	      finalizeDraggable: 9,
	      visible: 10,
	      text: 11,
	      align: 12,
	      valign: 13,
	      lineStyle: 34,
	      x: 14,
	      y: 15,
	      x2: 16,
	      y2: 17,
	      offsetX: 18,
	      offsetY: 19,
	      strokeWidth: 35,
	      outline: 36,
	      infoBox: 37,
	      textWidth: 20,
	      fontSize: 21,
	      opacity: 22,
	      darkMode: 23
	    }, add_css$h, [-1, -1]);
	    return _this;
	  }

	  _createClass(Line, [{
	    key: "isEditor",
	    get: function get() {
	      return this.$$.ctx[0];
	    },
	    set: function set(isEditor) {
	      this.$$set({
	        isEditor: isEditor
	      });
	      flush();
	    }
	  }, {
	    key: "isEditorActive",
	    get: function get() {
	      return this.$$.ctx[1];
	    },
	    set: function set(isEditorActive) {
	      this.$$set({
	        isEditorActive: isEditorActive
	      });
	      flush();
	    }
	  }, {
	    key: "editor",
	    get: function get() {
	      return this.$$.ctx[2];
	    },
	    set: function set(editor) {
	      this.$$set({
	        editor: editor
	      });
	      flush();
	    }
	  }, {
	    key: "editComponent",
	    get: function get() {
	      return this.$$.ctx[3];
	    },
	    set: function set(editComponent) {
	      this.$$set({
	        editComponent: editComponent
	      });
	      flush();
	    }
	  }, {
	    key: "id",
	    get: function get() {
	      return this.$$.ctx[4];
	    },
	    set: function set(id) {
	      this.$$set({
	        id: id
	      });
	      flush();
	    }
	  }, {
	    key: "color",
	    get: function get() {
	      return this.$$.ctx[5];
	    },
	    set: function set(color) {
	      this.$$set({
	        color: color
	      });
	      flush();
	    }
	  }, {
	    key: "scale",
	    get: function get() {
	      return this.$$.ctx[6];
	    },
	    set: function set(scale) {
	      this.$$set({
	        scale: scale
	      });
	      flush();
	    }
	  }, {
	    key: "containerWidth",
	    get: function get() {
	      return this.$$.ctx[7];
	    },
	    set: function set(containerWidth) {
	      this.$$set({
	        containerWidth: containerWidth
	      });
	      flush();
	    }
	  }, {
	    key: "maxWidth",
	    get: function get() {
	      return this.$$.ctx[33];
	    },
	    set: function set(maxWidth) {
	      this.$$set({
	        maxWidth: maxWidth
	      });
	      flush();
	    }
	  }, {
	    key: "updateDraggable",
	    get: function get() {
	      return this.$$.ctx[8];
	    },
	    set: function set(updateDraggable) {
	      this.$$set({
	        updateDraggable: updateDraggable
	      });
	      flush();
	    }
	  }, {
	    key: "finalizeDraggable",
	    get: function get() {
	      return this.$$.ctx[9];
	    },
	    set: function set(finalizeDraggable) {
	      this.$$set({
	        finalizeDraggable: finalizeDraggable
	      });
	      flush();
	    }
	  }, {
	    key: "visible",
	    get: function get() {
	      return this.$$.ctx[10];
	    },
	    set: function set(visible) {
	      this.$$set({
	        visible: visible
	      });
	      flush();
	    }
	  }, {
	    key: "text",
	    get: function get() {
	      return this.$$.ctx[11];
	    },
	    set: function set(text) {
	      this.$$set({
	        text: text
	      });
	      flush();
	    }
	  }, {
	    key: "align",
	    get: function get() {
	      return this.$$.ctx[12];
	    },
	    set: function set(align) {
	      this.$$set({
	        align: align
	      });
	      flush();
	    }
	  }, {
	    key: "valign",
	    get: function get() {
	      return this.$$.ctx[13];
	    },
	    set: function set(valign) {
	      this.$$set({
	        valign: valign
	      });
	      flush();
	    }
	  }, {
	    key: "lineStyle",
	    get: function get() {
	      return this.$$.ctx[34];
	    },
	    set: function set(lineStyle) {
	      this.$$set({
	        lineStyle: lineStyle
	      });
	      flush();
	    }
	  }, {
	    key: "x",
	    get: function get() {
	      return this.$$.ctx[14];
	    },
	    set: function set(x) {
	      this.$$set({
	        x: x
	      });
	      flush();
	    }
	  }, {
	    key: "y",
	    get: function get() {
	      return this.$$.ctx[15];
	    },
	    set: function set(y) {
	      this.$$set({
	        y: y
	      });
	      flush();
	    }
	  }, {
	    key: "x2",
	    get: function get() {
	      return this.$$.ctx[16];
	    },
	    set: function set(x2) {
	      this.$$set({
	        x2: x2
	      });
	      flush();
	    }
	  }, {
	    key: "y2",
	    get: function get() {
	      return this.$$.ctx[17];
	    },
	    set: function set(y2) {
	      this.$$set({
	        y2: y2
	      });
	      flush();
	    }
	  }, {
	    key: "offsetX",
	    get: function get() {
	      return this.$$.ctx[18];
	    },
	    set: function set(offsetX) {
	      this.$$set({
	        offsetX: offsetX
	      });
	      flush();
	    }
	  }, {
	    key: "offsetY",
	    get: function get() {
	      return this.$$.ctx[19];
	    },
	    set: function set(offsetY) {
	      this.$$set({
	        offsetY: offsetY
	      });
	      flush();
	    }
	  }, {
	    key: "strokeWidth",
	    get: function get() {
	      return this.$$.ctx[35];
	    },
	    set: function set(strokeWidth) {
	      this.$$set({
	        strokeWidth: strokeWidth
	      });
	      flush();
	    }
	  }, {
	    key: "outline",
	    get: function get() {
	      return this.$$.ctx[36];
	    },
	    set: function set(outline) {
	      this.$$set({
	        outline: outline
	      });
	      flush();
	    }
	  }, {
	    key: "infoBox",
	    get: function get() {
	      return this.$$.ctx[37];
	    },
	    set: function set(infoBox) {
	      this.$$set({
	        infoBox: infoBox
	      });
	      flush();
	    }
	  }, {
	    key: "textWidth",
	    get: function get() {
	      return this.$$.ctx[20];
	    },
	    set: function set(textWidth) {
	      this.$$set({
	        textWidth: textWidth
	      });
	      flush();
	    }
	  }, {
	    key: "fontSize",
	    get: function get() {
	      return this.$$.ctx[21];
	    },
	    set: function set(fontSize) {
	      this.$$set({
	        fontSize: fontSize
	      });
	      flush();
	    }
	  }, {
	    key: "opacity",
	    get: function get() {
	      return this.$$.ctx[22];
	    },
	    set: function set(opacity) {
	      this.$$set({
	        opacity: opacity
	      });
	      flush();
	    }
	  }, {
	    key: "darkMode",
	    get: function get() {
	      return this.$$.ctx[23];
	    },
	    set: function set(darkMode) {
	      this.$$set({
	        darkMode: darkMode
	      });
	      flush();
	    }
	  }]);

	  return Line;
	}(SvelteComponent);

	function add_css$g(target) {
	  append_styles(target, "svelte-svkatf", "svg.svelte-svkatf{overflow:visible;position:absolute}");
	} // (139:2) {#if visible}


	function create_if_block_2$5(ctx) {
	  var text_1;
	  var t;
	  var svg;
	  var defs;
	  var marker;
	  var polyline;
	  var polyline_points_value;
	  var g;
	  var path_1;
	  var g_transform_value;
	  var current;
	  text_1 = new Text({
	    props: {
	      id:
	      /*id*/
	      ctx[4],
	      isEditorActive:
	      /*isEditorActive*/
	      ctx[1],
	      setEditingText:
	      /*setEditingText*/
	      ctx[36],
	      updateDraggable:
	      /*updateDraggable*/
	      ctx[5],
	      finalizeDraggable:
	      /*finalizeDraggable*/
	      ctx[6],
	      text:
	      /*text*/
	      ctx[11],
	      align:
	      /*align*/
	      ctx[12],
	      valign:
	      /*valign*/
	      ctx[13],
	      color:
	      /*color*/
	      ctx[7],
	      visible:
	      /*visible*/
	      ctx[10],
	      textWidth:
	      /*textWidth*/
	      ctx[25],
	      fontSize:
	      /*fontSize*/
	      ctx[24],
	      offsetX:
	      /*offsetX*/
	      ctx[20],
	      offsetY:
	      /*offsetY*/
	      ctx[21],
	      textOffsetX:
	      /*textOffsetX*/
	      ctx[27],
	      textOffsetY:
	      /*textOffsetY*/
	      ctx[28]
	    }
	  });
	  return {
	    c: function c() {
	      create_component(text_1.$$.fragment);
	      t = space();
	      svg = svg_element("svg");
	      defs = svg_element("defs");
	      marker = svg_element("marker");
	      polyline = svg_element("polyline");
	      g = svg_element("g");
	      path_1 = svg_element("path");
	      attr(polyline, "stroke-linejoin", "bevel");
	      attr(polyline, "points", polyline_points_value = "-" +
	      /*arrowheadSize*/
	      ctx[35] + ",-" +
	      /*arrowheadSize*/
	      ctx[35] + " 0,0 -" +
	      /*arrowheadSize*/
	      ctx[35] + "," +
	      /*arrowheadSize*/
	      ctx[35]);
	      attr(marker, "id", "arrowhead");
	      attr(marker, "viewBox", "-10 -10 20 20");
	      attr(marker, "refX", "0");
	      attr(marker, "refY", "0");
	      attr(marker, "markerWidth", "20");
	      attr(marker, "markerHeight", "20");
	      attr(marker, "stroke-width", "1");
	      attr(marker, "orient", "auto");
	      attr(path_1, "d",
	      /*path*/
	      ctx[29]);
	      attr(path_1, "marker-end", "url(#arrowhead)");
	      attr(path_1, "style",
	      /*pathStyle*/
	      ctx[33]);
	      attr(g, "transform", g_transform_value = "translate(" + (
	      /*x3*/
	      ctx[18] < 0 ? Math.abs(
	      /*x3*/
	      ctx[18]) : 0) + ", " + (
	      /*y3*/
	      ctx[19] < 0 ? Math.abs(
	      /*y3*/
	      ctx[19]) : 0) + ")");
	      attr(svg, "class", "arrow draw-region svelte-svkatf");
	      set_style(svg, "left",
	      /*x3*/
	      ctx[18] < 0 ?
	      /*x3*/
	      ctx[18] : 0);
	      set_style(svg, "top",
	      /*y3*/
	      ctx[19] < 0 ?
	      /*y3*/
	      ctx[19] : 0);
	      set_style(svg, "width",
	      /*svgWidth*/
	      ctx[30]);
	      set_style(svg, "height",
	      /*svgHeight*/
	      ctx[31]);
	    },
	    m: function m(target, anchor) {
	      mount_component(text_1, target, anchor);
	      insert(target, t, anchor);
	      insert(target, svg, anchor);
	      append(svg, defs);
	      append(defs, marker);
	      append(marker, polyline);
	      append(svg, g);
	      append(g, path_1);
	      current = true;
	    },
	    p: function p(ctx, dirty) {
	      var text_1_changes = {};
	      if (dirty[0] &
	      /*id*/
	      16) text_1_changes.id =
	      /*id*/
	      ctx[4];
	      if (dirty[0] &
	      /*isEditorActive*/
	      2) text_1_changes.isEditorActive =
	      /*isEditorActive*/
	      ctx[1];
	      if (dirty[0] &
	      /*updateDraggable*/
	      32) text_1_changes.updateDraggable =
	      /*updateDraggable*/
	      ctx[5];
	      if (dirty[0] &
	      /*finalizeDraggable*/
	      64) text_1_changes.finalizeDraggable =
	      /*finalizeDraggable*/
	      ctx[6];
	      if (dirty[0] &
	      /*text*/
	      2048) text_1_changes.text =
	      /*text*/
	      ctx[11];
	      if (dirty[0] &
	      /*align*/
	      4096) text_1_changes.align =
	      /*align*/
	      ctx[12];
	      if (dirty[0] &
	      /*valign*/
	      8192) text_1_changes.valign =
	      /*valign*/
	      ctx[13];
	      if (dirty[0] &
	      /*color*/
	      128) text_1_changes.color =
	      /*color*/
	      ctx[7];
	      if (dirty[0] &
	      /*visible*/
	      1024) text_1_changes.visible =
	      /*visible*/
	      ctx[10];
	      if (dirty[0] &
	      /*textWidth*/
	      33554432) text_1_changes.textWidth =
	      /*textWidth*/
	      ctx[25];
	      if (dirty[0] &
	      /*fontSize*/
	      16777216) text_1_changes.fontSize =
	      /*fontSize*/
	      ctx[24];
	      if (dirty[0] &
	      /*offsetX*/
	      1048576) text_1_changes.offsetX =
	      /*offsetX*/
	      ctx[20];
	      if (dirty[0] &
	      /*offsetY*/
	      2097152) text_1_changes.offsetY =
	      /*offsetY*/
	      ctx[21];
	      if (dirty[0] &
	      /*textOffsetX*/
	      134217728) text_1_changes.textOffsetX =
	      /*textOffsetX*/
	      ctx[27];
	      if (dirty[0] &
	      /*textOffsetY*/
	      268435456) text_1_changes.textOffsetY =
	      /*textOffsetY*/
	      ctx[28];
	      text_1.$set(text_1_changes);

	      if (!current || dirty[1] &
	      /*arrowheadSize*/
	      16 && polyline_points_value !== (polyline_points_value = "-" +
	      /*arrowheadSize*/
	      ctx[35] + ",-" +
	      /*arrowheadSize*/
	      ctx[35] + " 0,0 -" +
	      /*arrowheadSize*/
	      ctx[35] + "," +
	      /*arrowheadSize*/
	      ctx[35])) {
	        attr(polyline, "points", polyline_points_value);
	      }

	      if (!current || dirty[0] &
	      /*path*/
	      536870912) {
	        attr(path_1, "d",
	        /*path*/
	        ctx[29]);
	      }

	      if (!current || dirty[1] &
	      /*pathStyle*/
	      4) {
	        attr(path_1, "style",
	        /*pathStyle*/
	        ctx[33]);
	      }

	      if (!current || dirty[0] &
	      /*x3, y3*/
	      786432 && g_transform_value !== (g_transform_value = "translate(" + (
	      /*x3*/
	      ctx[18] < 0 ? Math.abs(
	      /*x3*/
	      ctx[18]) : 0) + ", " + (
	      /*y3*/
	      ctx[19] < 0 ? Math.abs(
	      /*y3*/
	      ctx[19]) : 0) + ")")) {
	        attr(g, "transform", g_transform_value);
	      }

	      if (!current || dirty[0] &
	      /*x3*/
	      262144) {
	        set_style(svg, "left",
	        /*x3*/
	        ctx[18] < 0 ?
	        /*x3*/
	        ctx[18] : 0);
	      }

	      if (!current || dirty[0] &
	      /*y3*/
	      524288) {
	        set_style(svg, "top",
	        /*y3*/
	        ctx[19] < 0 ?
	        /*y3*/
	        ctx[19] : 0);
	      }

	      if (!current || dirty[0] &
	      /*svgWidth*/
	      1073741824) {
	        set_style(svg, "width",
	        /*svgWidth*/
	        ctx[30]);
	      }

	      if (!current || dirty[1] &
	      /*svgHeight*/
	      1) {
	        set_style(svg, "height",
	        /*svgHeight*/
	        ctx[31]);
	      }
	    },
	    i: function i(local) {
	      if (current) return;
	      transition_in(text_1.$$.fragment, local);
	      current = true;
	    },
	    o: function o(local) {
	      transition_out(text_1.$$.fragment, local);
	      current = false;
	    },
	    d: function d(detaching) {
	      destroy_component(text_1, detaching);
	      if (detaching) detach(t);
	      if (detaching) detach(svg);
	    }
	  };
	} // (171:2) {#if isEditorActive && visible}


	function create_if_block$c(ctx) {
	  var draghandle0;
	  var t0;
	  var t1;
	  var draghandle1;
	  var current;
	  draghandle0 = new DragHandle({
	    props: {
	      id:
	      /*id*/
	      ctx[4],
	      x: "0",
	      y: "0",
	      active: true,
	      onChange:
	      /*anchorChange*/
	      ctx[37],
	      handleClass: "move"
	    }
	  });
	  var if_block =
	  /*arrowStyle*/
	  ctx[22] === HANDLE3 && create_if_block_1$9(ctx);
	  draghandle1 = new DragHandle({
	    props: {
	      id:
	      /*id*/
	      ctx[4],
	      x:
	      /*x3*/
	      ctx[18],
	      y:
	      /*y3*/
	      ctx[19],
	      color: "rgb(145 145 145 / 50%)",
	      handleWidth: 8,
	      handleHeight: 8,
	      active: true,
	      onChange:
	      /*startpointChange*/
	      ctx[39]
	    }
	  });
	  return {
	    c: function c() {
	      create_component(draghandle0.$$.fragment);
	      t0 = space();
	      if (if_block) if_block.c();
	      t1 = space();
	      create_component(draghandle1.$$.fragment);
	    },
	    m: function m(target, anchor) {
	      mount_component(draghandle0, target, anchor);
	      insert(target, t0, anchor);
	      if (if_block) if_block.m(target, anchor);
	      insert(target, t1, anchor);
	      mount_component(draghandle1, target, anchor);
	      current = true;
	    },
	    p: function p(ctx, dirty) {
	      var draghandle0_changes = {};
	      if (dirty[0] &
	      /*id*/
	      16) draghandle0_changes.id =
	      /*id*/
	      ctx[4];
	      draghandle0.$set(draghandle0_changes);

	      if (
	      /*arrowStyle*/
	      ctx[22] === HANDLE3) {
	        if (if_block) {
	          if_block.p(ctx, dirty);

	          if (dirty[0] &
	          /*arrowStyle*/
	          4194304) {
	            transition_in(if_block, 1);
	          }
	        } else {
	          if_block = create_if_block_1$9(ctx);
	          if_block.c();
	          transition_in(if_block, 1);
	          if_block.m(t1.parentNode, t1);
	        }
	      } else if (if_block) {
	        group_outros();
	        transition_out(if_block, 1, 1, function () {
	          if_block = null;
	        });
	        check_outros();
	      }

	      var draghandle1_changes = {};
	      if (dirty[0] &
	      /*id*/
	      16) draghandle1_changes.id =
	      /*id*/
	      ctx[4];
	      if (dirty[0] &
	      /*x3*/
	      262144) draghandle1_changes.x =
	      /*x3*/
	      ctx[18];
	      if (dirty[0] &
	      /*y3*/
	      524288) draghandle1_changes.y =
	      /*y3*/
	      ctx[19];
	      draghandle1.$set(draghandle1_changes);
	    },
	    i: function i(local) {
	      if (current) return;
	      transition_in(draghandle0.$$.fragment, local);
	      transition_in(if_block);
	      transition_in(draghandle1.$$.fragment, local);
	      current = true;
	    },
	    o: function o(local) {
	      transition_out(draghandle0.$$.fragment, local);
	      transition_out(if_block);
	      transition_out(draghandle1.$$.fragment, local);
	      current = false;
	    },
	    d: function d(detaching) {
	      destroy_component(draghandle0, detaching);
	      if (detaching) detach(t0);
	      if (if_block) if_block.d(detaching);
	      if (detaching) detach(t1);
	      destroy_component(draghandle1, detaching);
	    }
	  };
	} // (179:4) {#if arrowStyle === HANDLE3}


	function create_if_block_1$9(ctx) {
	  var draghandle;
	  var current;
	  draghandle = new DragHandle({
	    props: {
	      id:
	      /*id*/
	      ctx[4],
	      x:
	      /*x2*/
	      ctx[16],
	      y:
	      /*y2*/
	      ctx[17],
	      color: "rgb(145 145 145 / 50%)",
	      handleWidth: 8,
	      handleHeight: 8,
	      active: true,
	      onChange:
	      /*midpointChange*/
	      ctx[38]
	    }
	  });
	  return {
	    c: function c() {
	      create_component(draghandle.$$.fragment);
	    },
	    m: function m(target, anchor) {
	      mount_component(draghandle, target, anchor);
	      current = true;
	    },
	    p: function p(ctx, dirty) {
	      var draghandle_changes = {};
	      if (dirty[0] &
	      /*id*/
	      16) draghandle_changes.id =
	      /*id*/
	      ctx[4];
	      if (dirty[0] &
	      /*x2*/
	      65536) draghandle_changes.x =
	      /*x2*/
	      ctx[16];
	      if (dirty[0] &
	      /*y2*/
	      131072) draghandle_changes.y =
	      /*y2*/
	      ctx[17];
	      draghandle.$set(draghandle_changes);
	    },
	    i: function i(local) {
	      if (current) return;
	      transition_in(draghandle.$$.fragment, local);
	      current = true;
	    },
	    o: function o(local) {
	      transition_out(draghandle.$$.fragment, local);
	      current = false;
	    },
	    d: function d(detaching) {
	      destroy_component(draghandle, detaching);
	    }
	  };
	} // (121:0) <Draggable   {id}   {x}   {y}   {visible}   {opacity}   {scale}   {editor}   {isEditor}   {isEditorActive}   {preventKeyHandlers}   {editComponent}   {containerWidth}   {updateDraggable}   {finalizeDraggable}   {extraClasses}   {darkMode} >


	function create_default_slot$4(ctx) {
	  var t;
	  var if_block1_anchor;
	  var current;
	  var if_block0 =
	  /*visible*/
	  ctx[10] && create_if_block_2$5(ctx);
	  var if_block1 =
	  /*isEditorActive*/
	  ctx[1] &&
	  /*visible*/
	  ctx[10] && create_if_block$c(ctx);
	  return {
	    c: function c() {
	      if (if_block0) if_block0.c();
	      t = space();
	      if (if_block1) if_block1.c();
	      if_block1_anchor = empty();
	    },
	    m: function m(target, anchor) {
	      if (if_block0) if_block0.m(target, anchor);
	      insert(target, t, anchor);
	      if (if_block1) if_block1.m(target, anchor);
	      insert(target, if_block1_anchor, anchor);
	      current = true;
	    },
	    p: function p(ctx, dirty) {
	      if (
	      /*visible*/
	      ctx[10]) {
	        if (if_block0) {
	          if_block0.p(ctx, dirty);

	          if (dirty[0] &
	          /*visible*/
	          1024) {
	            transition_in(if_block0, 1);
	          }
	        } else {
	          if_block0 = create_if_block_2$5(ctx);
	          if_block0.c();
	          transition_in(if_block0, 1);
	          if_block0.m(t.parentNode, t);
	        }
	      } else if (if_block0) {
	        group_outros();
	        transition_out(if_block0, 1, 1, function () {
	          if_block0 = null;
	        });
	        check_outros();
	      }

	      if (
	      /*isEditorActive*/
	      ctx[1] &&
	      /*visible*/
	      ctx[10]) {
	        if (if_block1) {
	          if_block1.p(ctx, dirty);

	          if (dirty[0] &
	          /*isEditorActive, visible*/
	          1026) {
	            transition_in(if_block1, 1);
	          }
	        } else {
	          if_block1 = create_if_block$c(ctx);
	          if_block1.c();
	          transition_in(if_block1, 1);
	          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
	        }
	      } else if (if_block1) {
	        group_outros();
	        transition_out(if_block1, 1, 1, function () {
	          if_block1 = null;
	        });
	        check_outros();
	      }
	    },
	    i: function i(local) {
	      if (current) return;
	      transition_in(if_block0);
	      transition_in(if_block1);
	      current = true;
	    },
	    o: function o(local) {
	      transition_out(if_block0);
	      transition_out(if_block1);
	      current = false;
	    },
	    d: function d(detaching) {
	      if (if_block0) if_block0.d(detaching);
	      if (detaching) detach(t);
	      if (if_block1) if_block1.d(detaching);
	      if (detaching) detach(if_block1_anchor);
	    }
	  };
	}

	function create_fragment$k(ctx) {
	  var draggable;
	  var current;
	  draggable = new Draggable({
	    props: {
	      id:
	      /*id*/
	      ctx[4],
	      x:
	      /*x*/
	      ctx[14],
	      y:
	      /*y*/
	      ctx[15],
	      visible:
	      /*visible*/
	      ctx[10],
	      opacity:
	      /*opacity*/
	      ctx[23],
	      scale:
	      /*scale*/
	      ctx[8],
	      editor:
	      /*editor*/
	      ctx[2],
	      isEditor:
	      /*isEditor*/
	      ctx[0],
	      isEditorActive:
	      /*isEditorActive*/
	      ctx[1],
	      preventKeyHandlers:
	      /*preventKeyHandlers*/
	      ctx[32],
	      editComponent:
	      /*editComponent*/
	      ctx[3],
	      containerWidth:
	      /*containerWidth*/
	      ctx[9],
	      updateDraggable:
	      /*updateDraggable*/
	      ctx[5],
	      finalizeDraggable:
	      /*finalizeDraggable*/
	      ctx[6],
	      extraClasses:
	      /*extraClasses*/
	      ctx[34],
	      darkMode:
	      /*darkMode*/
	      ctx[26],
	      $$slots: {
	        default: [create_default_slot$4]
	      },
	      $$scope: {
	        ctx: ctx
	      }
	    }
	  });
	  return {
	    c: function c() {
	      create_component(draggable.$$.fragment);
	    },
	    m: function m(target, anchor) {
	      mount_component(draggable, target, anchor);
	      current = true;
	    },
	    p: function p(ctx, dirty) {
	      var draggable_changes = {};
	      if (dirty[0] &
	      /*id*/
	      16) draggable_changes.id =
	      /*id*/
	      ctx[4];
	      if (dirty[0] &
	      /*x*/
	      16384) draggable_changes.x =
	      /*x*/
	      ctx[14];
	      if (dirty[0] &
	      /*y*/
	      32768) draggable_changes.y =
	      /*y*/
	      ctx[15];
	      if (dirty[0] &
	      /*visible*/
	      1024) draggable_changes.visible =
	      /*visible*/
	      ctx[10];
	      if (dirty[0] &
	      /*opacity*/
	      8388608) draggable_changes.opacity =
	      /*opacity*/
	      ctx[23];
	      if (dirty[0] &
	      /*scale*/
	      256) draggable_changes.scale =
	      /*scale*/
	      ctx[8];
	      if (dirty[0] &
	      /*editor*/
	      4) draggable_changes.editor =
	      /*editor*/
	      ctx[2];
	      if (dirty[0] &
	      /*isEditor*/
	      1) draggable_changes.isEditor =
	      /*isEditor*/
	      ctx[0];
	      if (dirty[0] &
	      /*isEditorActive*/
	      2) draggable_changes.isEditorActive =
	      /*isEditorActive*/
	      ctx[1];
	      if (dirty[1] &
	      /*preventKeyHandlers*/
	      2) draggable_changes.preventKeyHandlers =
	      /*preventKeyHandlers*/
	      ctx[32];
	      if (dirty[0] &
	      /*editComponent*/
	      8) draggable_changes.editComponent =
	      /*editComponent*/
	      ctx[3];
	      if (dirty[0] &
	      /*containerWidth*/
	      512) draggable_changes.containerWidth =
	      /*containerWidth*/
	      ctx[9];
	      if (dirty[0] &
	      /*updateDraggable*/
	      32) draggable_changes.updateDraggable =
	      /*updateDraggable*/
	      ctx[5];
	      if (dirty[0] &
	      /*finalizeDraggable*/
	      64) draggable_changes.finalizeDraggable =
	      /*finalizeDraggable*/
	      ctx[6];
	      if (dirty[1] &
	      /*extraClasses*/
	      8) draggable_changes.extraClasses =
	      /*extraClasses*/
	      ctx[34];
	      if (dirty[0] &
	      /*darkMode*/
	      67108864) draggable_changes.darkMode =
	      /*darkMode*/
	      ctx[26];

	      if (dirty[0] &
	      /*id, x3, y3, x2, y2, arrowStyle, isEditorActive, visible, svgWidth, path, updateDraggable, finalizeDraggable, text, align, valign, color, textWidth, fontSize, offsetX, offsetY, textOffsetX, textOffsetY*/
	      2071936242 | dirty[1] &
	      /*$$scope, svgHeight, pathStyle, arrowheadSize*/
	      131093) {
	        draggable_changes.$$scope = {
	          dirty: dirty,
	          ctx: ctx
	        };
	      }

	      draggable.$set(draggable_changes);
	    },
	    i: function i(local) {
	      if (current) return;
	      transition_in(draggable.$$.fragment, local);
	      current = true;
	    },
	    o: function o(local) {
	      transition_out(draggable.$$.fragment, local);
	      current = false;
	    },
	    d: function d(detaching) {
	      destroy_component(draggable, detaching);
	    }
	  };
	}

	var HANDLE2 = 'twoHandle';
	var HANDLE3 = 'threeHandle';
	var x1 = 0;
	var y1 = 0;

	function instance$k($$self, $$props, $$invalidate) {
	  var arrowheadSize;
	  var mobileClass;
	  var outlineClass;
	  var infoBoxClass;
	  var extraClasses;
	  var pathStyle;
	  var _$$props$isEditor = $$props.isEditor,
	      isEditor = _$$props$isEditor === void 0 ? false : _$$props$isEditor;
	  var _$$props$isEditorActi = $$props.isEditorActive,
	      isEditorActive = _$$props$isEditorActi === void 0 ? false : _$$props$isEditorActi;
	  var editor = $$props.editor;
	  var editComponent = $$props.editComponent;
	  var id = $$props.id;
	  var updateDraggable = $$props.updateDraggable;
	  var finalizeDraggable = $$props.finalizeDraggable;
	  var color = $$props.color;
	  var scale = $$props.scale;
	  var containerWidth = $$props.containerWidth;
	  var _$$props$visible = $$props.visible,
	      visible = _$$props$visible === void 0 ? true : _$$props$visible;
	  var _$$props$text = $$props.text,
	      text = _$$props$text === void 0 ? '' : _$$props$text;
	  var _$$props$align = $$props.align,
	      align = _$$props$align === void 0 ? 'left' : _$$props$align;
	  var _$$props$valign = $$props.valign,
	      valign = _$$props$valign === void 0 ? 'top' : _$$props$valign;
	  var _$$props$x = $$props.x,
	      x = _$$props$x === void 0 ? 0 : _$$props$x;
	  var _$$props$y = $$props.y,
	      y = _$$props$y === void 0 ? 0 : _$$props$y;
	  var _$$props$x2 = $$props.x2,
	      x2 = _$$props$x2 === void 0 ? 40 : _$$props$x2;
	  var _$$props$y2 = $$props.y2,
	      y2 = _$$props$y2 === void 0 ? 20 : _$$props$y2;
	  var _$$props$x3 = $$props.x3,
	      x3 = _$$props$x3 === void 0 ? 100 : _$$props$x3;
	  var _$$props$y3 = $$props.y3,
	      y3 = _$$props$y3 === void 0 ? 100 : _$$props$y3;
	  var _$$props$maxWidth = $$props.maxWidth,
	      maxWidth = _$$props$maxWidth === void 0 ? 300 : _$$props$maxWidth;
	  var _$$props$offsetX = $$props.offsetX,
	      offsetX = _$$props$offsetX === void 0 ? 0 : _$$props$offsetX;
	  var _$$props$offsetY = $$props.offsetY,
	      offsetY = _$$props$offsetY === void 0 ? 0 : _$$props$offsetY;
	  var _$$props$lineStyle = $$props.lineStyle,
	      lineStyle = _$$props$lineStyle === void 0 ? 'vertical' : _$$props$lineStyle;
	  var _$$props$arrowStyle = $$props.arrowStyle,
	      arrowStyle = _$$props$arrowStyle === void 0 ? HANDLE3 : _$$props$arrowStyle;
	  var _$$props$strokeWidth = $$props.strokeWidth,
	      strokeWidth = _$$props$strokeWidth === void 0 ? 1 : _$$props$strokeWidth;
	  var opacity = $$props.opacity;
	  var outline = $$props.outline;
	  var infoBox = $$props.infoBox;
	  var fontSize = $$props.fontSize;
	  var textWidth = $$props.textWidth;
	  var darkMode = $$props.darkMode;
	  var textOffsetX;
	  var textOffsetY;
	  var path;
	  var svgWidth;
	  var svgHeight;
	  var preventKeyHandlers = false;

	  function setEditingText(editState) {
	    $$invalidate(32, preventKeyHandlers = editState);
	  }

	  function anchorChange(props) {
	    var scaled = scale.invert(containerWidth, [props.x + x, props.y + y]);
	    updateDraggable(id, {
	      x: scaled[0],
	      y: scaled[1]
	    });

	    if (isEditor) {
	      editor.calculateBounds();
	    }
	  }

	  function midpointChange(props) {
	    updateDraggable(id, {
	      x2: Math.min(maxWidth, props.x),
	      y2: Math.min(maxWidth, props.y)
	    });
	  } // on two handle mode the start handle will also drive the midpoint
	  // with some offsets based on direction


	  function startpointChange(props) {
	    var x3 = Math.min(maxWidth, props.x);
	    var y3 = Math.min(maxWidth, props.y);

	    if (arrowStyle === HANDLE2) {
	      var _arrowMidpointOffset = arrowMidpointOffset(lineStyle, x3, y3),
	          _arrowMidpointOffset2 = _slicedToArray(_arrowMidpointOffset, 2),
	          _offsetX = _arrowMidpointOffset2[0],
	          _offsetY = _arrowMidpointOffset2[1];

	      updateDraggable(id, {
	        x3: x3,
	        y3: y3,
	        x2: x3 + _offsetX,
	        y2: y3 + _offsetY
	      });
	    } else {
	      updateDraggable(id, {
	        x3: x3,
	        y3: y3
	      });
	    }
	  }

	  $$self.$$set = function ($$props) {
	    if ('isEditor' in $$props) $$invalidate(0, isEditor = $$props.isEditor);
	    if ('isEditorActive' in $$props) $$invalidate(1, isEditorActive = $$props.isEditorActive);
	    if ('editor' in $$props) $$invalidate(2, editor = $$props.editor);
	    if ('editComponent' in $$props) $$invalidate(3, editComponent = $$props.editComponent);
	    if ('id' in $$props) $$invalidate(4, id = $$props.id);
	    if ('updateDraggable' in $$props) $$invalidate(5, updateDraggable = $$props.updateDraggable);
	    if ('finalizeDraggable' in $$props) $$invalidate(6, finalizeDraggable = $$props.finalizeDraggable);
	    if ('color' in $$props) $$invalidate(7, color = $$props.color);
	    if ('scale' in $$props) $$invalidate(8, scale = $$props.scale);
	    if ('containerWidth' in $$props) $$invalidate(9, containerWidth = $$props.containerWidth);
	    if ('visible' in $$props) $$invalidate(10, visible = $$props.visible);
	    if ('text' in $$props) $$invalidate(11, text = $$props.text);
	    if ('align' in $$props) $$invalidate(12, align = $$props.align);
	    if ('valign' in $$props) $$invalidate(13, valign = $$props.valign);
	    if ('x' in $$props) $$invalidate(14, x = $$props.x);
	    if ('y' in $$props) $$invalidate(15, y = $$props.y);
	    if ('x2' in $$props) $$invalidate(16, x2 = $$props.x2);
	    if ('y2' in $$props) $$invalidate(17, y2 = $$props.y2);
	    if ('x3' in $$props) $$invalidate(18, x3 = $$props.x3);
	    if ('y3' in $$props) $$invalidate(19, y3 = $$props.y3);
	    if ('maxWidth' in $$props) $$invalidate(40, maxWidth = $$props.maxWidth);
	    if ('offsetX' in $$props) $$invalidate(20, offsetX = $$props.offsetX);
	    if ('offsetY' in $$props) $$invalidate(21, offsetY = $$props.offsetY);
	    if ('lineStyle' in $$props) $$invalidate(41, lineStyle = $$props.lineStyle);
	    if ('arrowStyle' in $$props) $$invalidate(22, arrowStyle = $$props.arrowStyle);
	    if ('strokeWidth' in $$props) $$invalidate(42, strokeWidth = $$props.strokeWidth);
	    if ('opacity' in $$props) $$invalidate(23, opacity = $$props.opacity);
	    if ('outline' in $$props) $$invalidate(43, outline = $$props.outline);
	    if ('infoBox' in $$props) $$invalidate(44, infoBox = $$props.infoBox);
	    if ('fontSize' in $$props) $$invalidate(24, fontSize = $$props.fontSize);
	    if ('textWidth' in $$props) $$invalidate(25, textWidth = $$props.textWidth);
	    if ('darkMode' in $$props) $$invalidate(26, darkMode = $$props.darkMode);
	  };

	  $$self.$$.update = function () {
	    if ($$self.$$.dirty[1] &
	    /*strokeWidth*/
	    2048) {
	      $$invalidate(35, arrowheadSize = 4.5 - strokeWidth / 2);
	    }

	    if ($$self.$$.dirty[0] &
	    /*containerWidth*/
	    512) {
	      $$invalidate(47, mobileClass = containerWidth < 500 ? 'mobile' : '');
	    }

	    if ($$self.$$.dirty[1] &
	    /*outline*/
	    4096) {
	      $$invalidate(46, outlineClass = outline ? 'outline' : '');
	    }

	    if ($$self.$$.dirty[1] &
	    /*infoBox*/
	    8192) {
	      $$invalidate(45, infoBoxClass = infoBox ? 'infoBox' : '');
	    }

	    if ($$self.$$.dirty[1] &
	    /*mobileClass, outlineClass, infoBoxClass*/
	    114688) {
	      $$invalidate(34, extraClasses = "".concat(mobileClass, " ").concat(outlineClass, " ").concat(infoBoxClass));
	    }

	    if ($$self.$$.dirty[1] &
	    /*strokeWidth*/
	    2048) {
	      $$invalidate(33, pathStyle = "stroke-width: ".concat(strokeWidth, "px;"));
	    }

	    if ($$self.$$.dirty[0] &
	    /*align, valign, x3, offsetX, y3, offsetY, x2, y2*/
	    4141056 | $$self.$$.dirty[1] &
	    /*lineStyle*/
	    1024) {
	      {
	        var _alignOffset = alignOffset(align, valign, lineStyle),
	            alignOffsetX = _alignOffset.alignOffsetX,
	            alignOffsetY = _alignOffset.alignOffsetY;

	        $$invalidate(27, textOffsetX = x3 + offsetX + alignOffsetX);
	        $$invalidate(28, textOffsetY = y3 + offsetY + alignOffsetY);
	        $$invalidate(30, svgWidth = Math.abs(x3 - x1));
	        $$invalidate(31, svgHeight = Math.abs(y3 - y1));
	        $$invalidate(29, path = calcCirclePath([x3, y3], [x1, y1], [x2, y2]));
	      }
	    }
	  };

	  return [isEditor, isEditorActive, editor, editComponent, id, updateDraggable, finalizeDraggable, color, scale, containerWidth, visible, text, align, valign, x, y, x2, y2, x3, y3, offsetX, offsetY, arrowStyle, opacity, fontSize, textWidth, darkMode, textOffsetX, textOffsetY, path, svgWidth, svgHeight, preventKeyHandlers, pathStyle, extraClasses, arrowheadSize, setEditingText, anchorChange, midpointChange, startpointChange, maxWidth, lineStyle, strokeWidth, outline, infoBox, infoBoxClass, outlineClass, mobileClass];
	}

	var Arrow = /*#__PURE__*/function (_SvelteComponent) {
	  _inherits(Arrow, _SvelteComponent);

	  var _super = _createSuper(Arrow);

	  function Arrow(options) {
	    var _this;

	    _classCallCheck(this, Arrow);

	    _this = _super.call(this);
	    init(_assertThisInitialized(_this), options, instance$k, create_fragment$k, safe_not_equal, {
	      isEditor: 0,
	      isEditorActive: 1,
	      editor: 2,
	      editComponent: 3,
	      id: 4,
	      updateDraggable: 5,
	      finalizeDraggable: 6,
	      color: 7,
	      scale: 8,
	      containerWidth: 9,
	      visible: 10,
	      text: 11,
	      align: 12,
	      valign: 13,
	      x: 14,
	      y: 15,
	      x2: 16,
	      y2: 17,
	      x3: 18,
	      y3: 19,
	      maxWidth: 40,
	      offsetX: 20,
	      offsetY: 21,
	      lineStyle: 41,
	      arrowStyle: 22,
	      strokeWidth: 42,
	      opacity: 23,
	      outline: 43,
	      infoBox: 44,
	      fontSize: 24,
	      textWidth: 25,
	      darkMode: 26
	    }, add_css$g, [-1, -1]);
	    return _this;
	  }

	  _createClass(Arrow, [{
	    key: "isEditor",
	    get: function get() {
	      return this.$$.ctx[0];
	    },
	    set: function set(isEditor) {
	      this.$$set({
	        isEditor: isEditor
	      });
	      flush();
	    }
	  }, {
	    key: "isEditorActive",
	    get: function get() {
	      return this.$$.ctx[1];
	    },
	    set: function set(isEditorActive) {
	      this.$$set({
	        isEditorActive: isEditorActive
	      });
	      flush();
	    }
	  }, {
	    key: "editor",
	    get: function get() {
	      return this.$$.ctx[2];
	    },
	    set: function set(editor) {
	      this.$$set({
	        editor: editor
	      });
	      flush();
	    }
	  }, {
	    key: "editComponent",
	    get: function get() {
	      return this.$$.ctx[3];
	    },
	    set: function set(editComponent) {
	      this.$$set({
	        editComponent: editComponent
	      });
	      flush();
	    }
	  }, {
	    key: "id",
	    get: function get() {
	      return this.$$.ctx[4];
	    },
	    set: function set(id) {
	      this.$$set({
	        id: id
	      });
	      flush();
	    }
	  }, {
	    key: "updateDraggable",
	    get: function get() {
	      return this.$$.ctx[5];
	    },
	    set: function set(updateDraggable) {
	      this.$$set({
	        updateDraggable: updateDraggable
	      });
	      flush();
	    }
	  }, {
	    key: "finalizeDraggable",
	    get: function get() {
	      return this.$$.ctx[6];
	    },
	    set: function set(finalizeDraggable) {
	      this.$$set({
	        finalizeDraggable: finalizeDraggable
	      });
	      flush();
	    }
	  }, {
	    key: "color",
	    get: function get() {
	      return this.$$.ctx[7];
	    },
	    set: function set(color) {
	      this.$$set({
	        color: color
	      });
	      flush();
	    }
	  }, {
	    key: "scale",
	    get: function get() {
	      return this.$$.ctx[8];
	    },
	    set: function set(scale) {
	      this.$$set({
	        scale: scale
	      });
	      flush();
	    }
	  }, {
	    key: "containerWidth",
	    get: function get() {
	      return this.$$.ctx[9];
	    },
	    set: function set(containerWidth) {
	      this.$$set({
	        containerWidth: containerWidth
	      });
	      flush();
	    }
	  }, {
	    key: "visible",
	    get: function get() {
	      return this.$$.ctx[10];
	    },
	    set: function set(visible) {
	      this.$$set({
	        visible: visible
	      });
	      flush();
	    }
	  }, {
	    key: "text",
	    get: function get() {
	      return this.$$.ctx[11];
	    },
	    set: function set(text) {
	      this.$$set({
	        text: text
	      });
	      flush();
	    }
	  }, {
	    key: "align",
	    get: function get() {
	      return this.$$.ctx[12];
	    },
	    set: function set(align) {
	      this.$$set({
	        align: align
	      });
	      flush();
	    }
	  }, {
	    key: "valign",
	    get: function get() {
	      return this.$$.ctx[13];
	    },
	    set: function set(valign) {
	      this.$$set({
	        valign: valign
	      });
	      flush();
	    }
	  }, {
	    key: "x",
	    get: function get() {
	      return this.$$.ctx[14];
	    },
	    set: function set(x) {
	      this.$$set({
	        x: x
	      });
	      flush();
	    }
	  }, {
	    key: "y",
	    get: function get() {
	      return this.$$.ctx[15];
	    },
	    set: function set(y) {
	      this.$$set({
	        y: y
	      });
	      flush();
	    }
	  }, {
	    key: "x2",
	    get: function get() {
	      return this.$$.ctx[16];
	    },
	    set: function set(x2) {
	      this.$$set({
	        x2: x2
	      });
	      flush();
	    }
	  }, {
	    key: "y2",
	    get: function get() {
	      return this.$$.ctx[17];
	    },
	    set: function set(y2) {
	      this.$$set({
	        y2: y2
	      });
	      flush();
	    }
	  }, {
	    key: "x3",
	    get: function get() {
	      return this.$$.ctx[18];
	    },
	    set: function set(x3) {
	      this.$$set({
	        x3: x3
	      });
	      flush();
	    }
	  }, {
	    key: "y3",
	    get: function get() {
	      return this.$$.ctx[19];
	    },
	    set: function set(y3) {
	      this.$$set({
	        y3: y3
	      });
	      flush();
	    }
	  }, {
	    key: "maxWidth",
	    get: function get() {
	      return this.$$.ctx[40];
	    },
	    set: function set(maxWidth) {
	      this.$$set({
	        maxWidth: maxWidth
	      });
	      flush();
	    }
	  }, {
	    key: "offsetX",
	    get: function get() {
	      return this.$$.ctx[20];
	    },
	    set: function set(offsetX) {
	      this.$$set({
	        offsetX: offsetX
	      });
	      flush();
	    }
	  }, {
	    key: "offsetY",
	    get: function get() {
	      return this.$$.ctx[21];
	    },
	    set: function set(offsetY) {
	      this.$$set({
	        offsetY: offsetY
	      });
	      flush();
	    }
	  }, {
	    key: "lineStyle",
	    get: function get() {
	      return this.$$.ctx[41];
	    },
	    set: function set(lineStyle) {
	      this.$$set({
	        lineStyle: lineStyle
	      });
	      flush();
	    }
	  }, {
	    key: "arrowStyle",
	    get: function get() {
	      return this.$$.ctx[22];
	    },
	    set: function set(arrowStyle) {
	      this.$$set({
	        arrowStyle: arrowStyle
	      });
	      flush();
	    }
	  }, {
	    key: "strokeWidth",
	    get: function get() {
	      return this.$$.ctx[42];
	    },
	    set: function set(strokeWidth) {
	      this.$$set({
	        strokeWidth: strokeWidth
	      });
	      flush();
	    }
	  }, {
	    key: "opacity",
	    get: function get() {
	      return this.$$.ctx[23];
	    },
	    set: function set(opacity) {
	      this.$$set({
	        opacity: opacity
	      });
	      flush();
	    }
	  }, {
	    key: "outline",
	    get: function get() {
	      return this.$$.ctx[43];
	    },
	    set: function set(outline) {
	      this.$$set({
	        outline: outline
	      });
	      flush();
	    }
	  }, {
	    key: "infoBox",
	    get: function get() {
	      return this.$$.ctx[44];
	    },
	    set: function set(infoBox) {
	      this.$$set({
	        infoBox: infoBox
	      });
	      flush();
	    }
	  }, {
	    key: "fontSize",
	    get: function get() {
	      return this.$$.ctx[24];
	    },
	    set: function set(fontSize) {
	      this.$$set({
	        fontSize: fontSize
	      });
	      flush();
	    }
	  }, {
	    key: "textWidth",
	    get: function get() {
	      return this.$$.ctx[25];
	    },
	    set: function set(textWidth) {
	      this.$$set({
	        textWidth: textWidth
	      });
	      flush();
	    }
	  }, {
	    key: "darkMode",
	    get: function get() {
	      return this.$$.ctx[26];
	    },
	    set: function set(darkMode) {
	      this.$$set({
	        darkMode: darkMode
	      });
	      flush();
	    }
	  }]);

	  return Arrow;
	}(SvelteComponent);

	function add_css$f(target) {
	  append_styles(target, "svelte-1miakub", "svg.svelte-1miakub{position:absolute;overflow:visible;top:0;left:0}");
	} // (117:2) {#if visible}


	function create_if_block_1$8(ctx) {
	  var text_1;
	  var t;
	  var svg;
	  var g;
	  var path;
	  var path_d_value;
	  var g_transform_value;
	  var current;
	  text_1 = new Text({
	    props: {
	      id:
	      /*id*/
	      ctx[4],
	      isEditorActive:
	      /*isEditorActive*/
	      ctx[1],
	      setEditingText:
	      /*setEditingText*/
	      ctx[32],
	      updateDraggable:
	      /*updateDraggable*/
	      ctx[8],
	      finalizeDraggable:
	      /*finalizeDraggable*/
	      ctx[9],
	      text:
	      /*text*/
	      ctx[11],
	      align:
	      /*align*/
	      ctx[12],
	      valign:
	      /*valign*/
	      ctx[13],
	      color:
	      /*color*/
	      ctx[5],
	      visible:
	      /*visible*/
	      ctx[10],
	      textWidth:
	      /*textWidth*/
	      ctx[22],
	      fontSize:
	      /*fontSize*/
	      ctx[23],
	      offsetX:
	      /*offsetX*/
	      ctx[20],
	      offsetY:
	      /*offsetY*/
	      ctx[21],
	      textOffsetX:
	      /*textOffsetX*/
	      ctx[26],
	      textOffsetY:
	      /*textOffsetY*/
	      ctx[27]
	    }
	  });
	  return {
	    c: function c() {
	      create_component(text_1.$$.fragment);
	      t = space();
	      svg = svg_element("svg");
	      g = svg_element("g");
	      path = svg_element("path");
	      attr(path, "d", path_d_value = "M 0,0 " +
	      /*x2*/
	      ctx[16] + "," +
	      /*y2*/
	      ctx[17] + " " +
	      /*x3*/
	      ctx[18] + "," +
	      /*y3*/
	      ctx[19]);
	      attr(path, "style",
	      /*pathStyle*/
	      ctx[29]);
	      attr(g, "transform", g_transform_value = "translate(" + (
	      /*x3*/
	      ctx[18] < 0 ? Math.abs(
	      /*x3*/
	      ctx[18]) : 0) + ", " + (
	      /*y3*/
	      ctx[19] < 0 ? Math.abs(
	      /*y3*/
	      ctx[19]) : 0) + ")");
	      attr(svg, "class", "line draw-region svelte-1miakub");
	      set_style(svg, "left",
	      /*x3*/
	      ctx[18] < 0 ?
	      /*x3*/
	      ctx[18] : 0);
	      set_style(svg, "top",
	      /*y3*/
	      ctx[19] < 0 ?
	      /*y3*/
	      ctx[19] : 0);
	      set_style(svg, "width",
	      /*m10*/
	      ctx[33](
	      /*x3*/
	      ctx[18]));
	      set_style(svg, "height",
	      /*m10*/
	      ctx[33](
	      /*y3*/
	      ctx[19]));
	    },
	    m: function m(target, anchor) {
	      mount_component(text_1, target, anchor);
	      insert(target, t, anchor);
	      insert(target, svg, anchor);
	      append(svg, g);
	      append(g, path);
	      current = true;
	    },
	    p: function p(ctx, dirty) {
	      var text_1_changes = {};
	      if (dirty[0] &
	      /*id*/
	      16) text_1_changes.id =
	      /*id*/
	      ctx[4];
	      if (dirty[0] &
	      /*isEditorActive*/
	      2) text_1_changes.isEditorActive =
	      /*isEditorActive*/
	      ctx[1];
	      if (dirty[0] &
	      /*updateDraggable*/
	      256) text_1_changes.updateDraggable =
	      /*updateDraggable*/
	      ctx[8];
	      if (dirty[0] &
	      /*finalizeDraggable*/
	      512) text_1_changes.finalizeDraggable =
	      /*finalizeDraggable*/
	      ctx[9];
	      if (dirty[0] &
	      /*text*/
	      2048) text_1_changes.text =
	      /*text*/
	      ctx[11];
	      if (dirty[0] &
	      /*align*/
	      4096) text_1_changes.align =
	      /*align*/
	      ctx[12];
	      if (dirty[0] &
	      /*valign*/
	      8192) text_1_changes.valign =
	      /*valign*/
	      ctx[13];
	      if (dirty[0] &
	      /*color*/
	      32) text_1_changes.color =
	      /*color*/
	      ctx[5];
	      if (dirty[0] &
	      /*visible*/
	      1024) text_1_changes.visible =
	      /*visible*/
	      ctx[10];
	      if (dirty[0] &
	      /*textWidth*/
	      4194304) text_1_changes.textWidth =
	      /*textWidth*/
	      ctx[22];
	      if (dirty[0] &
	      /*fontSize*/
	      8388608) text_1_changes.fontSize =
	      /*fontSize*/
	      ctx[23];
	      if (dirty[0] &
	      /*offsetX*/
	      1048576) text_1_changes.offsetX =
	      /*offsetX*/
	      ctx[20];
	      if (dirty[0] &
	      /*offsetY*/
	      2097152) text_1_changes.offsetY =
	      /*offsetY*/
	      ctx[21];
	      if (dirty[0] &
	      /*textOffsetX*/
	      67108864) text_1_changes.textOffsetX =
	      /*textOffsetX*/
	      ctx[26];
	      if (dirty[0] &
	      /*textOffsetY*/
	      134217728) text_1_changes.textOffsetY =
	      /*textOffsetY*/
	      ctx[27];
	      text_1.$set(text_1_changes);

	      if (!current || dirty[0] &
	      /*x2, y2, x3, y3*/
	      983040 && path_d_value !== (path_d_value = "M 0,0 " +
	      /*x2*/
	      ctx[16] + "," +
	      /*y2*/
	      ctx[17] + " " +
	      /*x3*/
	      ctx[18] + "," +
	      /*y3*/
	      ctx[19])) {
	        attr(path, "d", path_d_value);
	      }

	      if (!current || dirty[0] &
	      /*pathStyle*/
	      536870912) {
	        attr(path, "style",
	        /*pathStyle*/
	        ctx[29]);
	      }

	      if (!current || dirty[0] &
	      /*x3, y3*/
	      786432 && g_transform_value !== (g_transform_value = "translate(" + (
	      /*x3*/
	      ctx[18] < 0 ? Math.abs(
	      /*x3*/
	      ctx[18]) : 0) + ", " + (
	      /*y3*/
	      ctx[19] < 0 ? Math.abs(
	      /*y3*/
	      ctx[19]) : 0) + ")")) {
	        attr(g, "transform", g_transform_value);
	      }

	      if (!current || dirty[0] &
	      /*x3*/
	      262144) {
	        set_style(svg, "left",
	        /*x3*/
	        ctx[18] < 0 ?
	        /*x3*/
	        ctx[18] : 0);
	      }

	      if (!current || dirty[0] &
	      /*y3*/
	      524288) {
	        set_style(svg, "top",
	        /*y3*/
	        ctx[19] < 0 ?
	        /*y3*/
	        ctx[19] : 0);
	      }

	      if (!current || dirty[0] &
	      /*x3*/
	      262144) {
	        set_style(svg, "width",
	        /*m10*/
	        ctx[33](
	        /*x3*/
	        ctx[18]));
	      }

	      if (!current || dirty[0] &
	      /*y3*/
	      524288) {
	        set_style(svg, "height",
	        /*m10*/
	        ctx[33](
	        /*y3*/
	        ctx[19]));
	      }
	    },
	    i: function i(local) {
	      if (current) return;
	      transition_in(text_1.$$.fragment, local);
	      current = true;
	    },
	    o: function o(local) {
	      transition_out(text_1.$$.fragment, local);
	      current = false;
	    },
	    d: function d(detaching) {
	      destroy_component(text_1, detaching);
	      if (detaching) detach(t);
	      if (detaching) detach(svg);
	    }
	  };
	} // (142:2) {#if isEditorActive && visible}


	function create_if_block$b(ctx) {
	  var draghandle0;
	  var t0;
	  var draghandle1;
	  var t1;
	  var draghandle2;
	  var current;
	  draghandle0 = new DragHandle({
	    props: {
	      id:
	      /*id*/
	      ctx[4],
	      active: "true",
	      handleClass: "move",
	      onChange:
	      /*positionChange*/
	      ctx[31]
	    }
	  });
	  draghandle1 = new DragHandle({
	    props: {
	      id:
	      /*id*/
	      ctx[4],
	      x:
	      /*x2*/
	      ctx[16],
	      y:
	      /*y2*/
	      ctx[17],
	      active: "true",
	      color: "rgb(145 145 145 / 50%)",
	      handleWidth: "8",
	      handleHeight: "8",
	      onChange:
	      /*lineHandle1Change*/
	      ctx[34]
	    }
	  });
	  draghandle2 = new DragHandle({
	    props: {
	      id:
	      /*id*/
	      ctx[4],
	      x:
	      /*x3*/
	      ctx[18],
	      y:
	      /*y3*/
	      ctx[19],
	      active: "true",
	      color: "rgb(145 145 145 / 50%)",
	      handleWidth: "8",
	      handleHeight: "8",
	      onChange:
	      /*lineHandle2Change*/
	      ctx[35]
	    }
	  });
	  return {
	    c: function c() {
	      create_component(draghandle0.$$.fragment);
	      t0 = space();
	      create_component(draghandle1.$$.fragment);
	      t1 = space();
	      create_component(draghandle2.$$.fragment);
	    },
	    m: function m(target, anchor) {
	      mount_component(draghandle0, target, anchor);
	      insert(target, t0, anchor);
	      mount_component(draghandle1, target, anchor);
	      insert(target, t1, anchor);
	      mount_component(draghandle2, target, anchor);
	      current = true;
	    },
	    p: function p(ctx, dirty) {
	      var draghandle0_changes = {};
	      if (dirty[0] &
	      /*id*/
	      16) draghandle0_changes.id =
	      /*id*/
	      ctx[4];
	      if (dirty[1] &
	      /*positionChange*/
	      1) draghandle0_changes.onChange =
	      /*positionChange*/
	      ctx[31];
	      draghandle0.$set(draghandle0_changes);
	      var draghandle1_changes = {};
	      if (dirty[0] &
	      /*id*/
	      16) draghandle1_changes.id =
	      /*id*/
	      ctx[4];
	      if (dirty[0] &
	      /*x2*/
	      65536) draghandle1_changes.x =
	      /*x2*/
	      ctx[16];
	      if (dirty[0] &
	      /*y2*/
	      131072) draghandle1_changes.y =
	      /*y2*/
	      ctx[17];
	      draghandle1.$set(draghandle1_changes);
	      var draghandle2_changes = {};
	      if (dirty[0] &
	      /*id*/
	      16) draghandle2_changes.id =
	      /*id*/
	      ctx[4];
	      if (dirty[0] &
	      /*x3*/
	      262144) draghandle2_changes.x =
	      /*x3*/
	      ctx[18];
	      if (dirty[0] &
	      /*y3*/
	      524288) draghandle2_changes.y =
	      /*y3*/
	      ctx[19];
	      draghandle2.$set(draghandle2_changes);
	    },
	    i: function i(local) {
	      if (current) return;
	      transition_in(draghandle0.$$.fragment, local);
	      transition_in(draghandle1.$$.fragment, local);
	      transition_in(draghandle2.$$.fragment, local);
	      current = true;
	    },
	    o: function o(local) {
	      transition_out(draghandle0.$$.fragment, local);
	      transition_out(draghandle1.$$.fragment, local);
	      transition_out(draghandle2.$$.fragment, local);
	      current = false;
	    },
	    d: function d(detaching) {
	      destroy_component(draghandle0, detaching);
	      if (detaching) detach(t0);
	      destroy_component(draghandle1, detaching);
	      if (detaching) detach(t1);
	      destroy_component(draghandle2, detaching);
	    }
	  };
	} // (98:0) <Draggable   {id}   {x}   {y}   {visible}   {opacity}   {scale}   {editor}   {isEditor}   {isEditorActive}   {preventKeyHandlers}   {editComponent}   {containerWidth}   {updateDraggable}   {finalizeDraggable}   {extraClasses}   {darkMode} >


	function create_default_slot$3(ctx) {
	  var t;
	  var if_block1_anchor;
	  var current;
	  var if_block0 =
	  /*visible*/
	  ctx[10] && create_if_block_1$8(ctx);
	  var if_block1 =
	  /*isEditorActive*/
	  ctx[1] &&
	  /*visible*/
	  ctx[10] && create_if_block$b(ctx);
	  return {
	    c: function c() {
	      if (if_block0) if_block0.c();
	      t = space();
	      if (if_block1) if_block1.c();
	      if_block1_anchor = empty();
	    },
	    m: function m(target, anchor) {
	      if (if_block0) if_block0.m(target, anchor);
	      insert(target, t, anchor);
	      if (if_block1) if_block1.m(target, anchor);
	      insert(target, if_block1_anchor, anchor);
	      current = true;
	    },
	    p: function p(ctx, dirty) {
	      if (
	      /*visible*/
	      ctx[10]) {
	        if (if_block0) {
	          if_block0.p(ctx, dirty);

	          if (dirty[0] &
	          /*visible*/
	          1024) {
	            transition_in(if_block0, 1);
	          }
	        } else {
	          if_block0 = create_if_block_1$8(ctx);
	          if_block0.c();
	          transition_in(if_block0, 1);
	          if_block0.m(t.parentNode, t);
	        }
	      } else if (if_block0) {
	        group_outros();
	        transition_out(if_block0, 1, 1, function () {
	          if_block0 = null;
	        });
	        check_outros();
	      }

	      if (
	      /*isEditorActive*/
	      ctx[1] &&
	      /*visible*/
	      ctx[10]) {
	        if (if_block1) {
	          if_block1.p(ctx, dirty);

	          if (dirty[0] &
	          /*isEditorActive, visible*/
	          1026) {
	            transition_in(if_block1, 1);
	          }
	        } else {
	          if_block1 = create_if_block$b(ctx);
	          if_block1.c();
	          transition_in(if_block1, 1);
	          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
	        }
	      } else if (if_block1) {
	        group_outros();
	        transition_out(if_block1, 1, 1, function () {
	          if_block1 = null;
	        });
	        check_outros();
	      }
	    },
	    i: function i(local) {
	      if (current) return;
	      transition_in(if_block0);
	      transition_in(if_block1);
	      current = true;
	    },
	    o: function o(local) {
	      transition_out(if_block0);
	      transition_out(if_block1);
	      current = false;
	    },
	    d: function d(detaching) {
	      if (if_block0) if_block0.d(detaching);
	      if (detaching) detach(t);
	      if (if_block1) if_block1.d(detaching);
	      if (detaching) detach(if_block1_anchor);
	    }
	  };
	}

	function create_fragment$j(ctx) {
	  var draggable;
	  var current;
	  draggable = new Draggable({
	    props: {
	      id:
	      /*id*/
	      ctx[4],
	      x:
	      /*x*/
	      ctx[14],
	      y:
	      /*y*/
	      ctx[15],
	      visible:
	      /*visible*/
	      ctx[10],
	      opacity:
	      /*opacity*/
	      ctx[24],
	      scale:
	      /*scale*/
	      ctx[6],
	      editor:
	      /*editor*/
	      ctx[2],
	      isEditor:
	      /*isEditor*/
	      ctx[0],
	      isEditorActive:
	      /*isEditorActive*/
	      ctx[1],
	      preventKeyHandlers:
	      /*preventKeyHandlers*/
	      ctx[28],
	      editComponent:
	      /*editComponent*/
	      ctx[3],
	      containerWidth:
	      /*containerWidth*/
	      ctx[7],
	      updateDraggable:
	      /*updateDraggable*/
	      ctx[8],
	      finalizeDraggable:
	      /*finalizeDraggable*/
	      ctx[9],
	      extraClasses:
	      /*extraClasses*/
	      ctx[30],
	      darkMode:
	      /*darkMode*/
	      ctx[25],
	      $$slots: {
	        default: [create_default_slot$3]
	      },
	      $$scope: {
	        ctx: ctx
	      }
	    }
	  });
	  return {
	    c: function c() {
	      create_component(draggable.$$.fragment);
	    },
	    m: function m(target, anchor) {
	      mount_component(draggable, target, anchor);
	      current = true;
	    },
	    p: function p(ctx, dirty) {
	      var draggable_changes = {};
	      if (dirty[0] &
	      /*id*/
	      16) draggable_changes.id =
	      /*id*/
	      ctx[4];
	      if (dirty[0] &
	      /*x*/
	      16384) draggable_changes.x =
	      /*x*/
	      ctx[14];
	      if (dirty[0] &
	      /*y*/
	      32768) draggable_changes.y =
	      /*y*/
	      ctx[15];
	      if (dirty[0] &
	      /*visible*/
	      1024) draggable_changes.visible =
	      /*visible*/
	      ctx[10];
	      if (dirty[0] &
	      /*opacity*/
	      16777216) draggable_changes.opacity =
	      /*opacity*/
	      ctx[24];
	      if (dirty[0] &
	      /*scale*/
	      64) draggable_changes.scale =
	      /*scale*/
	      ctx[6];
	      if (dirty[0] &
	      /*editor*/
	      4) draggable_changes.editor =
	      /*editor*/
	      ctx[2];
	      if (dirty[0] &
	      /*isEditor*/
	      1) draggable_changes.isEditor =
	      /*isEditor*/
	      ctx[0];
	      if (dirty[0] &
	      /*isEditorActive*/
	      2) draggable_changes.isEditorActive =
	      /*isEditorActive*/
	      ctx[1];
	      if (dirty[0] &
	      /*preventKeyHandlers*/
	      268435456) draggable_changes.preventKeyHandlers =
	      /*preventKeyHandlers*/
	      ctx[28];
	      if (dirty[0] &
	      /*editComponent*/
	      8) draggable_changes.editComponent =
	      /*editComponent*/
	      ctx[3];
	      if (dirty[0] &
	      /*containerWidth*/
	      128) draggable_changes.containerWidth =
	      /*containerWidth*/
	      ctx[7];
	      if (dirty[0] &
	      /*updateDraggable*/
	      256) draggable_changes.updateDraggable =
	      /*updateDraggable*/
	      ctx[8];
	      if (dirty[0] &
	      /*finalizeDraggable*/
	      512) draggable_changes.finalizeDraggable =
	      /*finalizeDraggable*/
	      ctx[9];
	      if (dirty[0] &
	      /*extraClasses*/
	      1073741824) draggable_changes.extraClasses =
	      /*extraClasses*/
	      ctx[30];
	      if (dirty[0] &
	      /*darkMode*/
	      33554432) draggable_changes.darkMode =
	      /*darkMode*/
	      ctx[25];

	      if (dirty[0] &
	      /*id, x3, y3, x2, y2, isEditorActive, visible, pathStyle, updateDraggable, finalizeDraggable, text, align, valign, color, textWidth, fontSize, offsetX, offsetY, textOffsetX, textOffsetY*/
	      754925362 | dirty[1] &
	      /*$$scope, positionChange*/
	      8193) {
	        draggable_changes.$$scope = {
	          dirty: dirty,
	          ctx: ctx
	        };
	      }

	      draggable.$set(draggable_changes);
	    },
	    i: function i(local) {
	      if (current) return;
	      transition_in(draggable.$$.fragment, local);
	      current = true;
	    },
	    o: function o(local) {
	      transition_out(draggable.$$.fragment, local);
	      current = false;
	    },
	    d: function d(detaching) {
	      destroy_component(draggable, detaching);
	    }
	  };
	}

	function instance$j($$self, $$props, $$invalidate) {
	  var positionChange;
	  var mobileClass;
	  var outlineClass;
	  var infoBoxClass;
	  var extraClasses;
	  var pathStyle;
	  var _$$props$isEditor = $$props.isEditor,
	      isEditor = _$$props$isEditor === void 0 ? false : _$$props$isEditor;
	  var _$$props$isEditorActi = $$props.isEditorActive,
	      isEditorActive = _$$props$isEditorActi === void 0 ? false : _$$props$isEditorActi;
	  var editor = $$props.editor;
	  var editComponent = $$props.editComponent;
	  var id = $$props.id;
	  var color = $$props.color;
	  var scale = $$props.scale;
	  var containerWidth = $$props.containerWidth;
	  var _$$props$maxWidth = $$props.maxWidth,
	      maxWidth = _$$props$maxWidth === void 0 ? 200 : _$$props$maxWidth;
	  var updateDraggable = $$props.updateDraggable;
	  var finalizeDraggable = $$props.finalizeDraggable;
	  var _$$props$visible = $$props.visible,
	      visible = _$$props$visible === void 0 ? true : _$$props$visible;
	  var _$$props$text = $$props.text,
	      text = _$$props$text === void 0 ? '' : _$$props$text;
	  var _$$props$align = $$props.align,
	      align = _$$props$align === void 0 ? 'left' : _$$props$align;
	  var _$$props$valign = $$props.valign,
	      valign = _$$props$valign === void 0 ? 'top' : _$$props$valign;
	  var _$$props$lineStyle = $$props.lineStyle,
	      lineStyle = _$$props$lineStyle === void 0 ? 'vertical' : _$$props$lineStyle;
	  var _$$props$x = $$props.x,
	      x = _$$props$x === void 0 ? 0 : _$$props$x;
	  var _$$props$y = $$props.y,
	      y = _$$props$y === void 0 ? 0 : _$$props$y;
	  var _$$props$x2 = $$props.x2,
	      x2 = _$$props$x2 === void 0 ? 50 : _$$props$x2;
	  var _$$props$y2 = $$props.y2,
	      y2 = _$$props$y2 === void 0 ? 0 : _$$props$y2;
	  var _$$props$x3 = $$props.x3,
	      x3 = _$$props$x3 === void 0 ? 50 : _$$props$x3;
	  var _$$props$y3 = $$props.y3,
	      y3 = _$$props$y3 === void 0 ? 80 : _$$props$y3;
	  var _$$props$offsetX = $$props.offsetX,
	      offsetX = _$$props$offsetX === void 0 ? 0 : _$$props$offsetX;
	  var _$$props$offsetY = $$props.offsetY,
	      offsetY = _$$props$offsetY === void 0 ? 0 : _$$props$offsetY;
	  var _$$props$strokeWidth = $$props.strokeWidth,
	      strokeWidth = _$$props$strokeWidth === void 0 ? 1.0 : _$$props$strokeWidth;
	  var outline = $$props.outline;
	  var infoBox = $$props.infoBox;
	  var textWidth = $$props.textWidth;
	  var fontSize = $$props.fontSize;
	  var opacity = $$props.opacity;
	  var darkMode = $$props.darkMode;
	  var textOffsetX;
	  var textOffsetY;
	  var preventKeyHandlers = false;

	  function setEditingText(editState) {
	    $$invalidate(28, preventKeyHandlers = editState);
	  }

	  var m10 = function m10(n) {
	    return Math.max(10, Math.abs(n));
	  };

	  function lineHandle1Change(props) {
	    if (lineStyle === 'vertical') {
	      var newX = Math.min(maxWidth, props.x);
	      updateDraggable(id, {
	        x2: newX,
	        x3: newX
	      });
	    } else {
	      var newY = Math.min(maxWidth, props.y);
	      updateDraggable(id, {
	        y2: newY,
	        y3: newY
	      });
	    }
	  }

	  function lineHandle2Change(props) {
	    if (lineStyle === 'vertical') {
	      updateDraggable(id, {
	        y3: Math.min(maxWidth, props.y)
	      });
	    } else {
	      updateDraggable(id, {
	        x3: Math.min(maxWidth, props.x)
	      });
	    }
	  }

	  $$self.$$set = function ($$props) {
	    if ('isEditor' in $$props) $$invalidate(0, isEditor = $$props.isEditor);
	    if ('isEditorActive' in $$props) $$invalidate(1, isEditorActive = $$props.isEditorActive);
	    if ('editor' in $$props) $$invalidate(2, editor = $$props.editor);
	    if ('editComponent' in $$props) $$invalidate(3, editComponent = $$props.editComponent);
	    if ('id' in $$props) $$invalidate(4, id = $$props.id);
	    if ('color' in $$props) $$invalidate(5, color = $$props.color);
	    if ('scale' in $$props) $$invalidate(6, scale = $$props.scale);
	    if ('containerWidth' in $$props) $$invalidate(7, containerWidth = $$props.containerWidth);
	    if ('maxWidth' in $$props) $$invalidate(36, maxWidth = $$props.maxWidth);
	    if ('updateDraggable' in $$props) $$invalidate(8, updateDraggable = $$props.updateDraggable);
	    if ('finalizeDraggable' in $$props) $$invalidate(9, finalizeDraggable = $$props.finalizeDraggable);
	    if ('visible' in $$props) $$invalidate(10, visible = $$props.visible);
	    if ('text' in $$props) $$invalidate(11, text = $$props.text);
	    if ('align' in $$props) $$invalidate(12, align = $$props.align);
	    if ('valign' in $$props) $$invalidate(13, valign = $$props.valign);
	    if ('lineStyle' in $$props) $$invalidate(37, lineStyle = $$props.lineStyle);
	    if ('x' in $$props) $$invalidate(14, x = $$props.x);
	    if ('y' in $$props) $$invalidate(15, y = $$props.y);
	    if ('x2' in $$props) $$invalidate(16, x2 = $$props.x2);
	    if ('y2' in $$props) $$invalidate(17, y2 = $$props.y2);
	    if ('x3' in $$props) $$invalidate(18, x3 = $$props.x3);
	    if ('y3' in $$props) $$invalidate(19, y3 = $$props.y3);
	    if ('offsetX' in $$props) $$invalidate(20, offsetX = $$props.offsetX);
	    if ('offsetY' in $$props) $$invalidate(21, offsetY = $$props.offsetY);
	    if ('strokeWidth' in $$props) $$invalidate(38, strokeWidth = $$props.strokeWidth);
	    if ('outline' in $$props) $$invalidate(39, outline = $$props.outline);
	    if ('infoBox' in $$props) $$invalidate(40, infoBox = $$props.infoBox);
	    if ('textWidth' in $$props) $$invalidate(22, textWidth = $$props.textWidth);
	    if ('fontSize' in $$props) $$invalidate(23, fontSize = $$props.fontSize);
	    if ('opacity' in $$props) $$invalidate(24, opacity = $$props.opacity);
	    if ('darkMode' in $$props) $$invalidate(25, darkMode = $$props.darkMode);
	  };

	  $$self.$$.update = function () {
	    if ($$self.$$.dirty[0] &
	    /*id, x, y, scale, containerWidth, updateDraggable, isEditor, editor*/
	    49621) {
	      $$invalidate(31, positionChange = positionChangeHandler(id, x, y, scale, containerWidth, updateDraggable, isEditor, editor));
	    }

	    if ($$self.$$.dirty[0] &
	    /*containerWidth*/
	    128) {
	      $$invalidate(43, mobileClass = containerWidth < 500 ? 'mobile' : '');
	    }

	    if ($$self.$$.dirty[1] &
	    /*outline*/
	    256) {
	      $$invalidate(42, outlineClass = outline ? 'outline' : '');
	    }

	    if ($$self.$$.dirty[1] &
	    /*infoBox*/
	    512) {
	      $$invalidate(41, infoBoxClass = infoBox ? 'infoBox' : '');
	    }

	    if ($$self.$$.dirty[1] &
	    /*mobileClass, outlineClass, infoBoxClass*/
	    7168) {
	      $$invalidate(30, extraClasses = "".concat(mobileClass, " ").concat(outlineClass, " ").concat(infoBoxClass));
	    }

	    if ($$self.$$.dirty[1] &
	    /*strokeWidth*/
	    128) {
	      $$invalidate(29, pathStyle = "stroke-width: ".concat(strokeWidth, "px;"));
	    }

	    if ($$self.$$.dirty[0] &
	    /*align, valign, x3, offsetX, y3, offsetY*/
	    3944448 | $$self.$$.dirty[1] &
	    /*lineStyle*/
	    64) {
	      {
	        var _alignOffset = alignOffset(align, valign, lineStyle),
	            alignOffsetX = _alignOffset.alignOffsetX,
	            alignOffsetY = _alignOffset.alignOffsetY;

	        $$invalidate(26, textOffsetX = x3 + offsetX + alignOffsetX);
	        $$invalidate(27, textOffsetY = y3 + offsetY + alignOffsetY);
	      }
	    }
	  };

	  return [isEditor, isEditorActive, editor, editComponent, id, color, scale, containerWidth, updateDraggable, finalizeDraggable, visible, text, align, valign, x, y, x2, y2, x3, y3, offsetX, offsetY, textWidth, fontSize, opacity, darkMode, textOffsetX, textOffsetY, preventKeyHandlers, pathStyle, extraClasses, positionChange, setEditingText, m10, lineHandle1Change, lineHandle2Change, maxWidth, lineStyle, strokeWidth, outline, infoBox, infoBoxClass, outlineClass, mobileClass];
	}

	var DoubleLine = /*#__PURE__*/function (_SvelteComponent) {
	  _inherits(DoubleLine, _SvelteComponent);

	  var _super = _createSuper(DoubleLine);

	  function DoubleLine(options) {
	    var _this;

	    _classCallCheck(this, DoubleLine);

	    _this = _super.call(this);
	    init(_assertThisInitialized(_this), options, instance$j, create_fragment$j, safe_not_equal, {
	      isEditor: 0,
	      isEditorActive: 1,
	      editor: 2,
	      editComponent: 3,
	      id: 4,
	      color: 5,
	      scale: 6,
	      containerWidth: 7,
	      maxWidth: 36,
	      updateDraggable: 8,
	      finalizeDraggable: 9,
	      visible: 10,
	      text: 11,
	      align: 12,
	      valign: 13,
	      lineStyle: 37,
	      x: 14,
	      y: 15,
	      x2: 16,
	      y2: 17,
	      x3: 18,
	      y3: 19,
	      offsetX: 20,
	      offsetY: 21,
	      strokeWidth: 38,
	      outline: 39,
	      infoBox: 40,
	      textWidth: 22,
	      fontSize: 23,
	      opacity: 24,
	      darkMode: 25
	    }, add_css$f, [-1, -1]);
	    return _this;
	  }

	  _createClass(DoubleLine, [{
	    key: "isEditor",
	    get: function get() {
	      return this.$$.ctx[0];
	    },
	    set: function set(isEditor) {
	      this.$$set({
	        isEditor: isEditor
	      });
	      flush();
	    }
	  }, {
	    key: "isEditorActive",
	    get: function get() {
	      return this.$$.ctx[1];
	    },
	    set: function set(isEditorActive) {
	      this.$$set({
	        isEditorActive: isEditorActive
	      });
	      flush();
	    }
	  }, {
	    key: "editor",
	    get: function get() {
	      return this.$$.ctx[2];
	    },
	    set: function set(editor) {
	      this.$$set({
	        editor: editor
	      });
	      flush();
	    }
	  }, {
	    key: "editComponent",
	    get: function get() {
	      return this.$$.ctx[3];
	    },
	    set: function set(editComponent) {
	      this.$$set({
	        editComponent: editComponent
	      });
	      flush();
	    }
	  }, {
	    key: "id",
	    get: function get() {
	      return this.$$.ctx[4];
	    },
	    set: function set(id) {
	      this.$$set({
	        id: id
	      });
	      flush();
	    }
	  }, {
	    key: "color",
	    get: function get() {
	      return this.$$.ctx[5];
	    },
	    set: function set(color) {
	      this.$$set({
	        color: color
	      });
	      flush();
	    }
	  }, {
	    key: "scale",
	    get: function get() {
	      return this.$$.ctx[6];
	    },
	    set: function set(scale) {
	      this.$$set({
	        scale: scale
	      });
	      flush();
	    }
	  }, {
	    key: "containerWidth",
	    get: function get() {
	      return this.$$.ctx[7];
	    },
	    set: function set(containerWidth) {
	      this.$$set({
	        containerWidth: containerWidth
	      });
	      flush();
	    }
	  }, {
	    key: "maxWidth",
	    get: function get() {
	      return this.$$.ctx[36];
	    },
	    set: function set(maxWidth) {
	      this.$$set({
	        maxWidth: maxWidth
	      });
	      flush();
	    }
	  }, {
	    key: "updateDraggable",
	    get: function get() {
	      return this.$$.ctx[8];
	    },
	    set: function set(updateDraggable) {
	      this.$$set({
	        updateDraggable: updateDraggable
	      });
	      flush();
	    }
	  }, {
	    key: "finalizeDraggable",
	    get: function get() {
	      return this.$$.ctx[9];
	    },
	    set: function set(finalizeDraggable) {
	      this.$$set({
	        finalizeDraggable: finalizeDraggable
	      });
	      flush();
	    }
	  }, {
	    key: "visible",
	    get: function get() {
	      return this.$$.ctx[10];
	    },
	    set: function set(visible) {
	      this.$$set({
	        visible: visible
	      });
	      flush();
	    }
	  }, {
	    key: "text",
	    get: function get() {
	      return this.$$.ctx[11];
	    },
	    set: function set(text) {
	      this.$$set({
	        text: text
	      });
	      flush();
	    }
	  }, {
	    key: "align",
	    get: function get() {
	      return this.$$.ctx[12];
	    },
	    set: function set(align) {
	      this.$$set({
	        align: align
	      });
	      flush();
	    }
	  }, {
	    key: "valign",
	    get: function get() {
	      return this.$$.ctx[13];
	    },
	    set: function set(valign) {
	      this.$$set({
	        valign: valign
	      });
	      flush();
	    }
	  }, {
	    key: "lineStyle",
	    get: function get() {
	      return this.$$.ctx[37];
	    },
	    set: function set(lineStyle) {
	      this.$$set({
	        lineStyle: lineStyle
	      });
	      flush();
	    }
	  }, {
	    key: "x",
	    get: function get() {
	      return this.$$.ctx[14];
	    },
	    set: function set(x) {
	      this.$$set({
	        x: x
	      });
	      flush();
	    }
	  }, {
	    key: "y",
	    get: function get() {
	      return this.$$.ctx[15];
	    },
	    set: function set(y) {
	      this.$$set({
	        y: y
	      });
	      flush();
	    }
	  }, {
	    key: "x2",
	    get: function get() {
	      return this.$$.ctx[16];
	    },
	    set: function set(x2) {
	      this.$$set({
	        x2: x2
	      });
	      flush();
	    }
	  }, {
	    key: "y2",
	    get: function get() {
	      return this.$$.ctx[17];
	    },
	    set: function set(y2) {
	      this.$$set({
	        y2: y2
	      });
	      flush();
	    }
	  }, {
	    key: "x3",
	    get: function get() {
	      return this.$$.ctx[18];
	    },
	    set: function set(x3) {
	      this.$$set({
	        x3: x3
	      });
	      flush();
	    }
	  }, {
	    key: "y3",
	    get: function get() {
	      return this.$$.ctx[19];
	    },
	    set: function set(y3) {
	      this.$$set({
	        y3: y3
	      });
	      flush();
	    }
	  }, {
	    key: "offsetX",
	    get: function get() {
	      return this.$$.ctx[20];
	    },
	    set: function set(offsetX) {
	      this.$$set({
	        offsetX: offsetX
	      });
	      flush();
	    }
	  }, {
	    key: "offsetY",
	    get: function get() {
	      return this.$$.ctx[21];
	    },
	    set: function set(offsetY) {
	      this.$$set({
	        offsetY: offsetY
	      });
	      flush();
	    }
	  }, {
	    key: "strokeWidth",
	    get: function get() {
	      return this.$$.ctx[38];
	    },
	    set: function set(strokeWidth) {
	      this.$$set({
	        strokeWidth: strokeWidth
	      });
	      flush();
	    }
	  }, {
	    key: "outline",
	    get: function get() {
	      return this.$$.ctx[39];
	    },
	    set: function set(outline) {
	      this.$$set({
	        outline: outline
	      });
	      flush();
	    }
	  }, {
	    key: "infoBox",
	    get: function get() {
	      return this.$$.ctx[40];
	    },
	    set: function set(infoBox) {
	      this.$$set({
	        infoBox: infoBox
	      });
	      flush();
	    }
	  }, {
	    key: "textWidth",
	    get: function get() {
	      return this.$$.ctx[22];
	    },
	    set: function set(textWidth) {
	      this.$$set({
	        textWidth: textWidth
	      });
	      flush();
	    }
	  }, {
	    key: "fontSize",
	    get: function get() {
	      return this.$$.ctx[23];
	    },
	    set: function set(fontSize) {
	      this.$$set({
	        fontSize: fontSize
	      });
	      flush();
	    }
	  }, {
	    key: "opacity",
	    get: function get() {
	      return this.$$.ctx[24];
	    },
	    set: function set(opacity) {
	      this.$$set({
	        opacity: opacity
	      });
	      flush();
	    }
	  }, {
	    key: "darkMode",
	    get: function get() {
	      return this.$$.ctx[25];
	    },
	    set: function set(darkMode) {
	      this.$$set({
	        darkMode: darkMode
	      });
	      flush();
	    }
	  }]);

	  return DoubleLine;
	}(SvelteComponent);

	function create_if_block_1$7(ctx) {
	  var draghandle;
	  var current;
	  draghandle = new DragHandle({
	    props: {
	      id:
	      /*id*/
	      ctx[0],
	      x:
	      /*radius*/
	      ctx[12] * 2,
	      y:
	      /*radius*/
	      ctx[12],
	      handleWidth: "8",
	      handleHeight: "8",
	      active: "true",
	      color: "rgb(145 145 145 / 50%)",
	      onChange:
	      /*radiusChange*/
	      ctx[34]
	    }
	  });
	  return {
	    c: function c() {
	      create_component(draghandle.$$.fragment);
	    },
	    m: function m(target, anchor) {
	      mount_component(draghandle, target, anchor);
	      current = true;
	    },
	    p: function p(ctx, dirty) {
	      var draghandle_changes = {};
	      if (dirty[0] &
	      /*id*/
	      1) draghandle_changes.id =
	      /*id*/
	      ctx[0];
	      if (dirty[0] &
	      /*radius*/
	      4096) draghandle_changes.x =
	      /*radius*/
	      ctx[12] * 2;
	      if (dirty[0] &
	      /*radius*/
	      4096) draghandle_changes.y =
	      /*radius*/
	      ctx[12];
	      draghandle.$set(draghandle_changes);
	    },
	    i: function i(local) {
	      if (current) return;
	      transition_in(draghandle.$$.fragment, local);
	      current = true;
	    },
	    o: function o(local) {
	      transition_out(draghandle.$$.fragment, local);
	      current = false;
	    },
	    d: function d(detaching) {
	      destroy_component(draghandle, detaching);
	    }
	  };
	} // (121:4) {#if text}


	function create_if_block$a(ctx) {
	  var text_1;
	  var current;
	  text_1 = new Text({
	    props: {
	      id:
	      /*id*/
	      ctx[0],
	      isEditorActive:
	      /*isEditorActive*/
	      ctx[7],
	      setEditingText:
	      /*setEditingText*/
	      ctx[33],
	      updateDraggable:
	      /*updateDraggable*/
	      ctx[10],
	      finalizeDraggable:
	      /*finalizeDraggable*/
	      ctx[11],
	      text:
	      /*text*/
	      ctx[5],
	      align:
	      /*align*/
	      ctx[14],
	      valign:
	      /*valign*/
	      ctx[15],
	      color:
	      /*color*/
	      ctx[13],
	      visible:
	      /*visible*/
	      ctx[19],
	      textWidth:
	      /*textWidth*/
	      ctx[23],
	      letterSpacing:
	      /*letterSpacing*/
	      ctx[24],
	      fontSize:
	      /*fontSize*/
	      ctx[22],
	      offsetX:
	      /*offsetX*/
	      ctx[20],
	      offsetY:
	      /*offsetY*/
	      ctx[21],
	      textOffsetX:
	      /*textOffsetX*/
	      ctx[29],
	      textOffsetY:
	      /*textOffsetY*/
	      ctx[30]
	    }
	  });
	  return {
	    c: function c() {
	      create_component(text_1.$$.fragment);
	    },
	    m: function m(target, anchor) {
	      mount_component(text_1, target, anchor);
	      current = true;
	    },
	    p: function p(ctx, dirty) {
	      var text_1_changes = {};
	      if (dirty[0] &
	      /*id*/
	      1) text_1_changes.id =
	      /*id*/
	      ctx[0];
	      if (dirty[0] &
	      /*isEditorActive*/
	      128) text_1_changes.isEditorActive =
	      /*isEditorActive*/
	      ctx[7];
	      if (dirty[0] &
	      /*updateDraggable*/
	      1024) text_1_changes.updateDraggable =
	      /*updateDraggable*/
	      ctx[10];
	      if (dirty[0] &
	      /*finalizeDraggable*/
	      2048) text_1_changes.finalizeDraggable =
	      /*finalizeDraggable*/
	      ctx[11];
	      if (dirty[0] &
	      /*text*/
	      32) text_1_changes.text =
	      /*text*/
	      ctx[5];
	      if (dirty[0] &
	      /*align*/
	      16384) text_1_changes.align =
	      /*align*/
	      ctx[14];
	      if (dirty[0] &
	      /*valign*/
	      32768) text_1_changes.valign =
	      /*valign*/
	      ctx[15];
	      if (dirty[0] &
	      /*color*/
	      8192) text_1_changes.color =
	      /*color*/
	      ctx[13];
	      if (dirty[0] &
	      /*visible*/
	      524288) text_1_changes.visible =
	      /*visible*/
	      ctx[19];
	      if (dirty[0] &
	      /*textWidth*/
	      8388608) text_1_changes.textWidth =
	      /*textWidth*/
	      ctx[23];
	      if (dirty[0] &
	      /*letterSpacing*/
	      16777216) text_1_changes.letterSpacing =
	      /*letterSpacing*/
	      ctx[24];
	      if (dirty[0] &
	      /*fontSize*/
	      4194304) text_1_changes.fontSize =
	      /*fontSize*/
	      ctx[22];
	      if (dirty[0] &
	      /*offsetX*/
	      1048576) text_1_changes.offsetX =
	      /*offsetX*/
	      ctx[20];
	      if (dirty[0] &
	      /*offsetY*/
	      2097152) text_1_changes.offsetY =
	      /*offsetY*/
	      ctx[21];
	      if (dirty[0] &
	      /*textOffsetX*/
	      536870912) text_1_changes.textOffsetX =
	      /*textOffsetX*/
	      ctx[29];
	      if (dirty[0] &
	      /*textOffsetY*/
	      1073741824) text_1_changes.textOffsetY =
	      /*textOffsetY*/
	      ctx[30];
	      text_1.$set(text_1_changes);
	    },
	    i: function i(local) {
	      if (current) return;
	      transition_in(text_1.$$.fragment, local);
	      current = true;
	    },
	    o: function o(local) {
	      transition_out(text_1.$$.fragment, local);
	      current = false;
	    },
	    d: function d(detaching) {
	      destroy_component(text_1, detaching);
	    }
	  };
	} // (81:0) <Draggable   {id}   {x}   {y}   {visible}   {opacity}   {scale}   {editor}   {isEditor}   {isEditorActive}   {preventKeyHandlers}   {editComponent}   {containerWidth}   {updateDraggable}   {finalizeDraggable}   {darkMode} >


	function create_default_slot$2(ctx) {
	  var div;
	  var svg;
	  var circle;
	  var circle_fill_value;
	  var circle_stroke_value;
	  var t0;
	  var t1;
	  var current;
	  var if_block0 =
	  /*isEditorActive*/
	  ctx[7] &&
	  /*visible*/
	  ctx[19] && create_if_block_1$7(ctx);
	  var if_block1 =
	  /*text*/
	  ctx[5] && create_if_block$a(ctx);
	  return {
	    c: function c() {
	      div = element("div");
	      svg = svg_element("svg");
	      circle = svg_element("circle");
	      t0 = space();
	      if (if_block0) if_block0.c();
	      t1 = space();
	      if (if_block1) if_block1.c();
	      attr(circle, "cx",
	      /*offset*/
	      ctx[27]);
	      attr(circle, "cy",
	      /*offset*/
	      ctx[27]);
	      attr(circle, "r",
	      /*radius*/
	      ctx[12]);
	      attr(circle, "fill", circle_fill_value =
	      /*fill*/
	      ctx[16] || 'transparent');
	      attr(circle, "stroke", circle_stroke_value =
	      /*stroke*/
	      ctx[17] ||
	      /*darkMode*/
	      ctx[26] ? 'white' : 'black');
	      attr(circle, "stroke-width",
	      /*strokeWidth*/
	      ctx[18]);
	      attr(svg, "class", "circle draw-region");
	      attr(svg, "style",
	      /*svgStyle*/
	      ctx[32]);
	      attr(div, "style",
	      /*style*/
	      ctx[28]);
	    },
	    m: function m(target, anchor) {
	      insert(target, div, anchor);
	      append(div, svg);
	      append(svg, circle);
	      append(div, t0);
	      if (if_block0) if_block0.m(div, null);
	      append(div, t1);
	      if (if_block1) if_block1.m(div, null);
	      current = true;
	    },
	    p: function p(ctx, dirty) {
	      if (!current || dirty[0] &
	      /*offset*/
	      134217728) {
	        attr(circle, "cx",
	        /*offset*/
	        ctx[27]);
	      }

	      if (!current || dirty[0] &
	      /*offset*/
	      134217728) {
	        attr(circle, "cy",
	        /*offset*/
	        ctx[27]);
	      }

	      if (!current || dirty[0] &
	      /*radius*/
	      4096) {
	        attr(circle, "r",
	        /*radius*/
	        ctx[12]);
	      }

	      if (!current || dirty[0] &
	      /*fill*/
	      65536 && circle_fill_value !== (circle_fill_value =
	      /*fill*/
	      ctx[16] || 'transparent')) {
	        attr(circle, "fill", circle_fill_value);
	      }

	      if (!current || dirty[0] &
	      /*stroke, darkMode*/
	      67239936 && circle_stroke_value !== (circle_stroke_value =
	      /*stroke*/
	      ctx[17] ||
	      /*darkMode*/
	      ctx[26] ? 'white' : 'black')) {
	        attr(circle, "stroke", circle_stroke_value);
	      }

	      if (!current || dirty[0] &
	      /*strokeWidth*/
	      262144) {
	        attr(circle, "stroke-width",
	        /*strokeWidth*/
	        ctx[18]);
	      }

	      if (!current || dirty[1] &
	      /*svgStyle*/
	      2) {
	        attr(svg, "style",
	        /*svgStyle*/
	        ctx[32]);
	      }

	      if (
	      /*isEditorActive*/
	      ctx[7] &&
	      /*visible*/
	      ctx[19]) {
	        if (if_block0) {
	          if_block0.p(ctx, dirty);

	          if (dirty[0] &
	          /*isEditorActive, visible*/
	          524416) {
	            transition_in(if_block0, 1);
	          }
	        } else {
	          if_block0 = create_if_block_1$7(ctx);
	          if_block0.c();
	          transition_in(if_block0, 1);
	          if_block0.m(div, t1);
	        }
	      } else if (if_block0) {
	        group_outros();
	        transition_out(if_block0, 1, 1, function () {
	          if_block0 = null;
	        });
	        check_outros();
	      }

	      if (
	      /*text*/
	      ctx[5]) {
	        if (if_block1) {
	          if_block1.p(ctx, dirty);

	          if (dirty[0] &
	          /*text*/
	          32) {
	            transition_in(if_block1, 1);
	          }
	        } else {
	          if_block1 = create_if_block$a(ctx);
	          if_block1.c();
	          transition_in(if_block1, 1);
	          if_block1.m(div, null);
	        }
	      } else if (if_block1) {
	        group_outros();
	        transition_out(if_block1, 1, 1, function () {
	          if_block1 = null;
	        });
	        check_outros();
	      }

	      if (!current || dirty[0] &
	      /*style*/
	      268435456) {
	        attr(div, "style",
	        /*style*/
	        ctx[28]);
	      }
	    },
	    i: function i(local) {
	      if (current) return;
	      transition_in(if_block0);
	      transition_in(if_block1);
	      current = true;
	    },
	    o: function o(local) {
	      transition_out(if_block0);
	      transition_out(if_block1);
	      current = false;
	    },
	    d: function d(detaching) {
	      if (detaching) detach(div);
	      if (if_block0) if_block0.d();
	      if (if_block1) if_block1.d();
	    }
	  };
	}

	function create_fragment$i(ctx) {
	  var draggable;
	  var current;
	  draggable = new Draggable({
	    props: {
	      id:
	      /*id*/
	      ctx[0],
	      x:
	      /*x*/
	      ctx[2],
	      y:
	      /*y*/
	      ctx[3],
	      visible:
	      /*visible*/
	      ctx[19],
	      opacity:
	      /*opacity*/
	      ctx[25],
	      scale:
	      /*scale*/
	      ctx[1],
	      editor:
	      /*editor*/
	      ctx[4],
	      isEditor:
	      /*isEditor*/
	      ctx[6],
	      isEditorActive:
	      /*isEditorActive*/
	      ctx[7],
	      preventKeyHandlers:
	      /*preventKeyHandlers*/
	      ctx[31],
	      editComponent:
	      /*editComponent*/
	      ctx[8],
	      containerWidth:
	      /*containerWidth*/
	      ctx[9],
	      updateDraggable:
	      /*updateDraggable*/
	      ctx[10],
	      finalizeDraggable:
	      /*finalizeDraggable*/
	      ctx[11],
	      darkMode:
	      /*darkMode*/
	      ctx[26],
	      $$slots: {
	        default: [create_default_slot$2]
	      },
	      $$scope: {
	        ctx: ctx
	      }
	    }
	  });
	  return {
	    c: function c() {
	      create_component(draggable.$$.fragment);
	    },
	    m: function m(target, anchor) {
	      mount_component(draggable, target, anchor);
	      current = true;
	    },
	    p: function p(ctx, dirty) {
	      var draggable_changes = {};
	      if (dirty[0] &
	      /*id*/
	      1) draggable_changes.id =
	      /*id*/
	      ctx[0];
	      if (dirty[0] &
	      /*x*/
	      4) draggable_changes.x =
	      /*x*/
	      ctx[2];
	      if (dirty[0] &
	      /*y*/
	      8) draggable_changes.y =
	      /*y*/
	      ctx[3];
	      if (dirty[0] &
	      /*visible*/
	      524288) draggable_changes.visible =
	      /*visible*/
	      ctx[19];
	      if (dirty[0] &
	      /*opacity*/
	      33554432) draggable_changes.opacity =
	      /*opacity*/
	      ctx[25];
	      if (dirty[0] &
	      /*scale*/
	      2) draggable_changes.scale =
	      /*scale*/
	      ctx[1];
	      if (dirty[0] &
	      /*editor*/
	      16) draggable_changes.editor =
	      /*editor*/
	      ctx[4];
	      if (dirty[0] &
	      /*isEditor*/
	      64) draggable_changes.isEditor =
	      /*isEditor*/
	      ctx[6];
	      if (dirty[0] &
	      /*isEditorActive*/
	      128) draggable_changes.isEditorActive =
	      /*isEditorActive*/
	      ctx[7];
	      if (dirty[1] &
	      /*preventKeyHandlers*/
	      1) draggable_changes.preventKeyHandlers =
	      /*preventKeyHandlers*/
	      ctx[31];
	      if (dirty[0] &
	      /*editComponent*/
	      256) draggable_changes.editComponent =
	      /*editComponent*/
	      ctx[8];
	      if (dirty[0] &
	      /*containerWidth*/
	      512) draggable_changes.containerWidth =
	      /*containerWidth*/
	      ctx[9];
	      if (dirty[0] &
	      /*updateDraggable*/
	      1024) draggable_changes.updateDraggable =
	      /*updateDraggable*/
	      ctx[10];
	      if (dirty[0] &
	      /*finalizeDraggable*/
	      2048) draggable_changes.finalizeDraggable =
	      /*finalizeDraggable*/
	      ctx[11];
	      if (dirty[0] &
	      /*darkMode*/
	      67108864) draggable_changes.darkMode =
	      /*darkMode*/
	      ctx[26];

	      if (dirty[0] &
	      /*style, id, isEditorActive, updateDraggable, finalizeDraggable, text, align, valign, color, visible, textWidth, letterSpacing, fontSize, offsetX, offsetY, textOffsetX, textOffsetY, radius, offset, fill, stroke, darkMode, strokeWidth*/
	      2113928353 | dirty[1] &
	      /*$$scope, svgStyle*/
	      18) {
	        draggable_changes.$$scope = {
	          dirty: dirty,
	          ctx: ctx
	        };
	      }

	      draggable.$set(draggable_changes);
	    },
	    i: function i(local) {
	      if (current) return;
	      transition_in(draggable.$$.fragment, local);
	      current = true;
	    },
	    o: function o(local) {
	      transition_out(draggable.$$.fragment, local);
	      current = false;
	    },
	    d: function d(detaching) {
	      destroy_component(draggable, detaching);
	    }
	  };
	}

	function instance$i($$self, $$props, $$invalidate) {
	  var offset;
	  var svgStyle;
	  var id = $$props.id;
	  var scale = $$props.scale;
	  var _$$props$x = $$props.x,
	      x = _$$props$x === void 0 ? 0 : _$$props$x;
	  var _$$props$y = $$props.y,
	      y = _$$props$y === void 0 ? 0 : _$$props$y;
	  var editor = $$props.editor;
	  var _$$props$text = $$props.text,
	      text = _$$props$text === void 0 ? '' : _$$props$text;
	  var _$$props$isEditor = $$props.isEditor,
	      isEditor = _$$props$isEditor === void 0 ? false : _$$props$isEditor;
	  var _$$props$isEditorActi = $$props.isEditorActive,
	      isEditorActive = _$$props$isEditorActi === void 0 ? false : _$$props$isEditorActi;
	  var editComponent = $$props.editComponent;
	  var containerWidth = $$props.containerWidth;
	  var updateDraggable = $$props.updateDraggable;
	  var finalizeDraggable = $$props.finalizeDraggable;
	  var _$$props$radius = $$props.radius,
	      radius = _$$props$radius === void 0 ? 15 : _$$props$radius;
	  var color = $$props.color;
	  var _$$props$align = $$props.align,
	      align = _$$props$align === void 0 ? 'center' : _$$props$align;
	  var _$$props$valign = $$props.valign,
	      valign = _$$props$valign === void 0 ? 'bottom' : _$$props$valign;
	  var fill = $$props.fill;
	  var stroke = $$props.stroke;
	  var _$$props$strokeWidth = $$props.strokeWidth,
	      strokeWidth = _$$props$strokeWidth === void 0 ? 1 : _$$props$strokeWidth;
	  var _$$props$visible = $$props.visible,
	      visible = _$$props$visible === void 0 ? true : _$$props$visible;
	  var _$$props$offsetX = $$props.offsetX,
	      offsetX = _$$props$offsetX === void 0 ? 0 : _$$props$offsetX;
	  var _$$props$offsetY = $$props.offsetY,
	      offsetY = _$$props$offsetY === void 0 ? 0 : _$$props$offsetY;
	  var fontSize = $$props.fontSize;
	  var textWidth = $$props.textWidth;
	  var letterSpacing = $$props.letterSpacing;
	  var opacity = $$props.opacity;
	  var darkMode = $$props.darkMode;
	  var style = '';
	  var textOffsetX = 0;
	  var textOffsetY = 0; // TODO :: templatize this

	  var preventKeyHandlers = false;

	  function setEditingText(editState) {
	    $$invalidate(31, preventKeyHandlers = editState);
	  } // instead of using a text editor, this tells the editor
	  // which properties to render
	  // const editProperties = [
	  //   { name: 'radius', type: 'number' },
	  //   { name: 'color', type: 'string' },
	  //   { name: 'fill', type: 'string' },
	  //   { name: 'stroke', type: 'string' },
	  //   { name: 'strokeWidth', type: 'string' }
	  // ]


	  function radiusChange(props) {
	    updateDraggable(id, {
	      radius: props.x / 2
	    });
	  }

	  $$self.$$set = function ($$props) {
	    if ('id' in $$props) $$invalidate(0, id = $$props.id);
	    if ('scale' in $$props) $$invalidate(1, scale = $$props.scale);
	    if ('x' in $$props) $$invalidate(2, x = $$props.x);
	    if ('y' in $$props) $$invalidate(3, y = $$props.y);
	    if ('editor' in $$props) $$invalidate(4, editor = $$props.editor);
	    if ('text' in $$props) $$invalidate(5, text = $$props.text);
	    if ('isEditor' in $$props) $$invalidate(6, isEditor = $$props.isEditor);
	    if ('isEditorActive' in $$props) $$invalidate(7, isEditorActive = $$props.isEditorActive);
	    if ('editComponent' in $$props) $$invalidate(8, editComponent = $$props.editComponent);
	    if ('containerWidth' in $$props) $$invalidate(9, containerWidth = $$props.containerWidth);
	    if ('updateDraggable' in $$props) $$invalidate(10, updateDraggable = $$props.updateDraggable);
	    if ('finalizeDraggable' in $$props) $$invalidate(11, finalizeDraggable = $$props.finalizeDraggable);
	    if ('radius' in $$props) $$invalidate(12, radius = $$props.radius);
	    if ('color' in $$props) $$invalidate(13, color = $$props.color);
	    if ('align' in $$props) $$invalidate(14, align = $$props.align);
	    if ('valign' in $$props) $$invalidate(15, valign = $$props.valign);
	    if ('fill' in $$props) $$invalidate(16, fill = $$props.fill);
	    if ('stroke' in $$props) $$invalidate(17, stroke = $$props.stroke);
	    if ('strokeWidth' in $$props) $$invalidate(18, strokeWidth = $$props.strokeWidth);
	    if ('visible' in $$props) $$invalidate(19, visible = $$props.visible);
	    if ('offsetX' in $$props) $$invalidate(20, offsetX = $$props.offsetX);
	    if ('offsetY' in $$props) $$invalidate(21, offsetY = $$props.offsetY);
	    if ('fontSize' in $$props) $$invalidate(22, fontSize = $$props.fontSize);
	    if ('textWidth' in $$props) $$invalidate(23, textWidth = $$props.textWidth);
	    if ('letterSpacing' in $$props) $$invalidate(24, letterSpacing = $$props.letterSpacing);
	    if ('opacity' in $$props) $$invalidate(25, opacity = $$props.opacity);
	    if ('darkMode' in $$props) $$invalidate(26, darkMode = $$props.darkMode);
	  };

	  $$self.$$.update = function () {
	    if ($$self.$$.dirty[0] &
	    /*radius, strokeWidth*/
	    266240) {
	      $$invalidate(27, offset = radius + strokeWidth);
	    }

	    if ($$self.$$.dirty[0] &
	    /*visible, radius*/
	    528384) {
	      $$invalidate(28, style = "\n    position: absolute;\n    display: ".concat(visible ? 'block' : 'none', ";\n    transform: translate(").concat(radius * -1, "px, ").concat(radius * -1, "px);\n  "));
	    }

	    if ($$self.$$.dirty[0] &
	    /*offset*/
	    134217728) {
	      $$invalidate(32, svgStyle = "\n    width: ".concat(offset * 2, "px;\n    height: ").concat(offset * 2, "px;\n    overflow: visible;\n  "));
	    }

	    if ($$self.$$.dirty[0] &
	    /*align, valign, radius, offsetX, offsetY*/
	    3198976) {
	      {
	        var _circleAlignOffset = circleAlignOffset(align, valign, radius),
	            alignOffsetX = _circleAlignOffset.alignOffsetX,
	            alignOffsetY = _circleAlignOffset.alignOffsetY;

	        $$invalidate(29, textOffsetX = offsetX + alignOffsetX);
	        $$invalidate(30, textOffsetY = offsetY + alignOffsetY);
	      }
	    }
	  };

	  return [id, scale, x, y, editor, text, isEditor, isEditorActive, editComponent, containerWidth, updateDraggable, finalizeDraggable, radius, color, align, valign, fill, stroke, strokeWidth, visible, offsetX, offsetY, fontSize, textWidth, letterSpacing, opacity, darkMode, offset, style, textOffsetX, textOffsetY, preventKeyHandlers, svgStyle, setEditingText, radiusChange];
	}

	var Circle = /*#__PURE__*/function (_SvelteComponent) {
	  _inherits(Circle, _SvelteComponent);

	  var _super = _createSuper(Circle);

	  function Circle(options) {
	    var _this;

	    _classCallCheck(this, Circle);

	    _this = _super.call(this);
	    init(_assertThisInitialized(_this), options, instance$i, create_fragment$i, safe_not_equal, {
	      id: 0,
	      scale: 1,
	      x: 2,
	      y: 3,
	      editor: 4,
	      text: 5,
	      isEditor: 6,
	      isEditorActive: 7,
	      editComponent: 8,
	      containerWidth: 9,
	      updateDraggable: 10,
	      finalizeDraggable: 11,
	      radius: 12,
	      color: 13,
	      align: 14,
	      valign: 15,
	      fill: 16,
	      stroke: 17,
	      strokeWidth: 18,
	      visible: 19,
	      offsetX: 20,
	      offsetY: 21,
	      fontSize: 22,
	      textWidth: 23,
	      letterSpacing: 24,
	      opacity: 25,
	      darkMode: 26
	    }, null, [-1, -1]);
	    return _this;
	  }

	  _createClass(Circle, [{
	    key: "id",
	    get: function get() {
	      return this.$$.ctx[0];
	    },
	    set: function set(id) {
	      this.$$set({
	        id: id
	      });
	      flush();
	    }
	  }, {
	    key: "scale",
	    get: function get() {
	      return this.$$.ctx[1];
	    },
	    set: function set(scale) {
	      this.$$set({
	        scale: scale
	      });
	      flush();
	    }
	  }, {
	    key: "x",
	    get: function get() {
	      return this.$$.ctx[2];
	    },
	    set: function set(x) {
	      this.$$set({
	        x: x
	      });
	      flush();
	    }
	  }, {
	    key: "y",
	    get: function get() {
	      return this.$$.ctx[3];
	    },
	    set: function set(y) {
	      this.$$set({
	        y: y
	      });
	      flush();
	    }
	  }, {
	    key: "editor",
	    get: function get() {
	      return this.$$.ctx[4];
	    },
	    set: function set(editor) {
	      this.$$set({
	        editor: editor
	      });
	      flush();
	    }
	  }, {
	    key: "text",
	    get: function get() {
	      return this.$$.ctx[5];
	    },
	    set: function set(text) {
	      this.$$set({
	        text: text
	      });
	      flush();
	    }
	  }, {
	    key: "isEditor",
	    get: function get() {
	      return this.$$.ctx[6];
	    },
	    set: function set(isEditor) {
	      this.$$set({
	        isEditor: isEditor
	      });
	      flush();
	    }
	  }, {
	    key: "isEditorActive",
	    get: function get() {
	      return this.$$.ctx[7];
	    },
	    set: function set(isEditorActive) {
	      this.$$set({
	        isEditorActive: isEditorActive
	      });
	      flush();
	    }
	  }, {
	    key: "editComponent",
	    get: function get() {
	      return this.$$.ctx[8];
	    },
	    set: function set(editComponent) {
	      this.$$set({
	        editComponent: editComponent
	      });
	      flush();
	    }
	  }, {
	    key: "containerWidth",
	    get: function get() {
	      return this.$$.ctx[9];
	    },
	    set: function set(containerWidth) {
	      this.$$set({
	        containerWidth: containerWidth
	      });
	      flush();
	    }
	  }, {
	    key: "updateDraggable",
	    get: function get() {
	      return this.$$.ctx[10];
	    },
	    set: function set(updateDraggable) {
	      this.$$set({
	        updateDraggable: updateDraggable
	      });
	      flush();
	    }
	  }, {
	    key: "finalizeDraggable",
	    get: function get() {
	      return this.$$.ctx[11];
	    },
	    set: function set(finalizeDraggable) {
	      this.$$set({
	        finalizeDraggable: finalizeDraggable
	      });
	      flush();
	    }
	  }, {
	    key: "radius",
	    get: function get() {
	      return this.$$.ctx[12];
	    },
	    set: function set(radius) {
	      this.$$set({
	        radius: radius
	      });
	      flush();
	    }
	  }, {
	    key: "color",
	    get: function get() {
	      return this.$$.ctx[13];
	    },
	    set: function set(color) {
	      this.$$set({
	        color: color
	      });
	      flush();
	    }
	  }, {
	    key: "align",
	    get: function get() {
	      return this.$$.ctx[14];
	    },
	    set: function set(align) {
	      this.$$set({
	        align: align
	      });
	      flush();
	    }
	  }, {
	    key: "valign",
	    get: function get() {
	      return this.$$.ctx[15];
	    },
	    set: function set(valign) {
	      this.$$set({
	        valign: valign
	      });
	      flush();
	    }
	  }, {
	    key: "fill",
	    get: function get() {
	      return this.$$.ctx[16];
	    },
	    set: function set(fill) {
	      this.$$set({
	        fill: fill
	      });
	      flush();
	    }
	  }, {
	    key: "stroke",
	    get: function get() {
	      return this.$$.ctx[17];
	    },
	    set: function set(stroke) {
	      this.$$set({
	        stroke: stroke
	      });
	      flush();
	    }
	  }, {
	    key: "strokeWidth",
	    get: function get() {
	      return this.$$.ctx[18];
	    },
	    set: function set(strokeWidth) {
	      this.$$set({
	        strokeWidth: strokeWidth
	      });
	      flush();
	    }
	  }, {
	    key: "visible",
	    get: function get() {
	      return this.$$.ctx[19];
	    },
	    set: function set(visible) {
	      this.$$set({
	        visible: visible
	      });
	      flush();
	    }
	  }, {
	    key: "offsetX",
	    get: function get() {
	      return this.$$.ctx[20];
	    },
	    set: function set(offsetX) {
	      this.$$set({
	        offsetX: offsetX
	      });
	      flush();
	    }
	  }, {
	    key: "offsetY",
	    get: function get() {
	      return this.$$.ctx[21];
	    },
	    set: function set(offsetY) {
	      this.$$set({
	        offsetY: offsetY
	      });
	      flush();
	    }
	  }, {
	    key: "fontSize",
	    get: function get() {
	      return this.$$.ctx[22];
	    },
	    set: function set(fontSize) {
	      this.$$set({
	        fontSize: fontSize
	      });
	      flush();
	    }
	  }, {
	    key: "textWidth",
	    get: function get() {
	      return this.$$.ctx[23];
	    },
	    set: function set(textWidth) {
	      this.$$set({
	        textWidth: textWidth
	      });
	      flush();
	    }
	  }, {
	    key: "letterSpacing",
	    get: function get() {
	      return this.$$.ctx[24];
	    },
	    set: function set(letterSpacing) {
	      this.$$set({
	        letterSpacing: letterSpacing
	      });
	      flush();
	    }
	  }, {
	    key: "opacity",
	    get: function get() {
	      return this.$$.ctx[25];
	    },
	    set: function set(opacity) {
	      this.$$set({
	        opacity: opacity
	      });
	      flush();
	    }
	  }, {
	    key: "darkMode",
	    get: function get() {
	      return this.$$.ctx[26];
	    },
	    set: function set(darkMode) {
	      this.$$set({
	        darkMode: darkMode
	      });
	      flush();
	    }
	  }]);

	  return Circle;
	}(SvelteComponent);

	var earthquake = "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<!-- Generator: Adobe Illustrator 24.2.1, SVG Export Plug-In . SVG Version: 6.00 Build 0)  -->\n<svg version=\"1.1\" id=\"Layer_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\"\n\t viewBox=\"0 0 20 20\" style=\"enable-background:new 0 0 20 20;\" xml:space=\"preserve\">\n<path d=\"M10,2c4.41,0,8,3.59,8,8s-3.59,8-8,8s-8-3.59-8-8S5.59,2,10,2 M10,0C4.48,0,0,4.48,0,10s4.48,10,10,10s10-4.48,10-10\n\tS15.52,0,10,0L10,0z\"/>\n<path d=\"M10,6c2.21,0,4,1.79,4,4s-1.79,4-4,4s-4-1.79-4-4S7.79,6,10,6 M10,4c-3.31,0-6,2.69-6,6s2.69,6,6,6s6-2.69,6-6S13.31,4,10,4\n\tL10,4z\"/>\n<g>\n\t<circle cx=\"10\" cy=\"10\" r=\"2\"/>\n</g>\n</svg>";

	var capitol = "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<!-- Generator: Adobe Illustrator 25.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0)  -->\n<svg version=\"1.1\" id=\"Layer_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\"\n\t width=\"20px\" height=\"20px\" viewBox=\"0 0 20 20\" style=\"enable-background:new 0 0 20 20;\" xml:space=\"preserve\">\n<style type=\"text/css\">\n\t.st0{fill:#FFFFFF;}\n</style>\n<path class=\"st0\" d=\"M10,0c5.5,0,10,4.5,10,10s-4.5,10-10,10S0,15.5,0,10S4.5,0,10,0\"/>\n<path d=\"M10,2.5c4.1,0,7.5,3.4,7.5,7.5s-3.4,7.5-7.5,7.5S2.5,14.1,2.5,10S5.9,2.5,10,2.5 M10,0C4.5,0,0,4.5,0,10s4.5,10,10,10\n\ts10-4.5,10-10S15.5,0,10,0L10,0z\"/>\n<path class=\"st0\" d=\"M10,2.5c4.1,0,7.5,3.4,7.5,7.5s-3.4,7.5-7.5,7.5S2.5,14.1,2.5,10S5.9,2.5,10,2.5\"/>\n<path d=\"M10,7c1.7,0,3,1.3,3,3s-1.3,3-3,3s-3-1.3-3-3S8.3,7,10,7\"/>\n</svg>";

	var NAMED_SVGS = {
	  earthquake: earthquake,
	  capitol: capitol
	}; // svgs can set currentColor directly to inherit the
	// css color of the parent, but often we need to set two colors
	// (usually black / white) which we can do with {primaryColor} and
	// {secondaryColor} as template strings in the svg

	function customSVG(svg) {
	  var primaryColor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '#000000';
	  var secondaryColor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '#ffffff';
	  return svg.replace(/{primaryColor}/g, primaryColor).replace(/{secondaryColor}/g, secondaryColor);
	}
	function namedSVG(name, primaryColor, secondaryColor) {
	  var svg = NAMED_SVGS[name] || '';
	  return customSVG(svg, primaryColor, secondaryColor);
	}

	function create_else_block$4(ctx) {
	  var text_1;
	  var current;
	  text_1 = new Text({
	    props: {
	      text:
	      /*iconText*/
	      ctx[12],
	      color:
	      /*iconColorActive*/
	      ctx[33],
	      fontSize:
	      /*iconSize*/
	      ctx[15],
	      textWidth:
	      /*iconSize*/
	      ctx[15],
	      isEditorLocked: "true",
	      isEditorActive: "false",
	      extraClasses: "icon",
	      align: "center",
	      valign: "center",
	      useTextColor: "true",
	      id:
	      /*id*/
	      ctx[4],
	      updateDraggable:
	      /*updateDraggable*/
	      ctx[9],
	      finalizeDraggable:
	      /*finalizeDraggable*/
	      ctx[10],
	      visible:
	      /*visible*/
	      ctx[6]
	    }
	  });
	  return {
	    c: function c() {
	      create_component(text_1.$$.fragment);
	    },
	    m: function m(target, anchor) {
	      mount_component(text_1, target, anchor);
	      current = true;
	    },
	    p: function p(ctx, dirty) {
	      var text_1_changes = {};
	      if (dirty[0] &
	      /*iconText*/
	      4096) text_1_changes.text =
	      /*iconText*/
	      ctx[12];
	      if (dirty[0] &
	      /*iconSize*/
	      32768) text_1_changes.fontSize =
	      /*iconSize*/
	      ctx[15];
	      if (dirty[0] &
	      /*iconSize*/
	      32768) text_1_changes.textWidth =
	      /*iconSize*/
	      ctx[15];
	      if (dirty[0] &
	      /*id*/
	      16) text_1_changes.id =
	      /*id*/
	      ctx[4];
	      if (dirty[0] &
	      /*updateDraggable*/
	      512) text_1_changes.updateDraggable =
	      /*updateDraggable*/
	      ctx[9];
	      if (dirty[0] &
	      /*finalizeDraggable*/
	      1024) text_1_changes.finalizeDraggable =
	      /*finalizeDraggable*/
	      ctx[10];
	      if (dirty[0] &
	      /*visible*/
	      64) text_1_changes.visible =
	      /*visible*/
	      ctx[6];
	      text_1.$set(text_1_changes);
	    },
	    i: function i(local) {
	      if (current) return;
	      transition_in(text_1.$$.fragment, local);
	      current = true;
	    },
	    o: function o(local) {
	      transition_out(text_1.$$.fragment, local);
	      current = false;
	    },
	    d: function d(detaching) {
	      destroy_component(text_1, detaching);
	    }
	  };
	} // (103:20) 


	function create_if_block_3$4(ctx) {
	  var div;
	  var raw_value = customSVG(
	  /*iconSVG*/
	  ctx[14],
	  /*iconColorActive*/
	  ctx[33],
	  /*secondaryColorActive*/
	  ctx[34]) + "";
	  return {
	    c: function c() {
	      div = element("div");
	      attr(div, "class", "svg-icon custom");
	      attr(div, "style",
	      /*svgSizeStyle*/
	      ctx[30]);
	    },
	    m: function m(target, anchor) {
	      insert(target, div, anchor);
	      div.innerHTML = raw_value;
	    },
	    p: function p(ctx, dirty) {
	      if (dirty[0] &
	      /*iconSVG*/
	      16384 && raw_value !== (raw_value = customSVG(
	      /*iconSVG*/
	      ctx[14],
	      /*iconColorActive*/
	      ctx[33],
	      /*secondaryColorActive*/
	      ctx[34]) + "")) div.innerHTML = raw_value;

	      if (dirty[0] &
	      /*svgSizeStyle*/
	      1073741824) {
	        attr(div, "style",
	        /*svgSizeStyle*/
	        ctx[30]);
	      }
	    },
	    i: noop,
	    o: noop,
	    d: function d(detaching) {
	      if (detaching) detach(div);
	    }
	  };
	} // (99:2) {#if iconNamedSVG}


	function create_if_block_2$4(ctx) {
	  var div;
	  var raw_value = namedSVG(
	  /*iconNamedSVG*/
	  ctx[13],
	  /*iconColorActive*/
	  ctx[33],
	  /*secondaryColorActive*/
	  ctx[34]) + "";
	  return {
	    c: function c() {
	      div = element("div");
	      attr(div, "class", "svg-icon");
	      attr(div, "style",
	      /*svgSizeStyle*/
	      ctx[30]);
	    },
	    m: function m(target, anchor) {
	      insert(target, div, anchor);
	      div.innerHTML = raw_value;
	    },
	    p: function p(ctx, dirty) {
	      if (dirty[0] &
	      /*iconNamedSVG*/
	      8192 && raw_value !== (raw_value = namedSVG(
	      /*iconNamedSVG*/
	      ctx[13],
	      /*iconColorActive*/
	      ctx[33],
	      /*secondaryColorActive*/
	      ctx[34]) + "")) div.innerHTML = raw_value;

	      if (dirty[0] &
	      /*svgSizeStyle*/
	      1073741824) {
	        attr(div, "style",
	        /*svgSizeStyle*/
	        ctx[30]);
	      }
	    },
	    i: noop,
	    o: noop,
	    d: function d(detaching) {
	      if (detaching) detach(div);
	    }
	  };
	} // (124:2) {#if text}


	function create_if_block_1$6(ctx) {
	  var text_1;
	  var current;
	  text_1 = new Text({
	    props: {
	      useTextColor: "true",
	      id:
	      /*id*/
	      ctx[4],
	      isEditorActive:
	      /*isEditorActive*/
	      ctx[1],
	      setEditingText:
	      /*setEditingText*/
	      ctx[35],
	      updateDraggable:
	      /*updateDraggable*/
	      ctx[9],
	      finalizeDraggable:
	      /*finalizeDraggable*/
	      ctx[10],
	      text:
	      /*text*/
	      ctx[11],
	      align:
	      /*align*/
	      ctx[16],
	      valign:
	      /*valign*/
	      ctx[17],
	      color:
	      /*color*/
	      ctx[5],
	      visible:
	      /*visible*/
	      ctx[6],
	      textWidth:
	      /*textWidth*/
	      ctx[23],
	      letterSpacing:
	      /*letterSpacing*/
	      ctx[24],
	      fontSize:
	      /*fontSize*/
	      ctx[22],
	      offsetX:
	      /*offsetX*/
	      ctx[20],
	      offsetY:
	      /*offsetY*/
	      ctx[21],
	      textOffsetX:
	      /*textOffsetX*/
	      ctx[27],
	      textOffsetY:
	      /*textOffsetY*/
	      ctx[28]
	    }
	  });
	  return {
	    c: function c() {
	      create_component(text_1.$$.fragment);
	    },
	    m: function m(target, anchor) {
	      mount_component(text_1, target, anchor);
	      current = true;
	    },
	    p: function p(ctx, dirty) {
	      var text_1_changes = {};
	      if (dirty[0] &
	      /*id*/
	      16) text_1_changes.id =
	      /*id*/
	      ctx[4];
	      if (dirty[0] &
	      /*isEditorActive*/
	      2) text_1_changes.isEditorActive =
	      /*isEditorActive*/
	      ctx[1];
	      if (dirty[0] &
	      /*updateDraggable*/
	      512) text_1_changes.updateDraggable =
	      /*updateDraggable*/
	      ctx[9];
	      if (dirty[0] &
	      /*finalizeDraggable*/
	      1024) text_1_changes.finalizeDraggable =
	      /*finalizeDraggable*/
	      ctx[10];
	      if (dirty[0] &
	      /*text*/
	      2048) text_1_changes.text =
	      /*text*/
	      ctx[11];
	      if (dirty[0] &
	      /*align*/
	      65536) text_1_changes.align =
	      /*align*/
	      ctx[16];
	      if (dirty[0] &
	      /*valign*/
	      131072) text_1_changes.valign =
	      /*valign*/
	      ctx[17];
	      if (dirty[0] &
	      /*color*/
	      32) text_1_changes.color =
	      /*color*/
	      ctx[5];
	      if (dirty[0] &
	      /*visible*/
	      64) text_1_changes.visible =
	      /*visible*/
	      ctx[6];
	      if (dirty[0] &
	      /*textWidth*/
	      8388608) text_1_changes.textWidth =
	      /*textWidth*/
	      ctx[23];
	      if (dirty[0] &
	      /*letterSpacing*/
	      16777216) text_1_changes.letterSpacing =
	      /*letterSpacing*/
	      ctx[24];
	      if (dirty[0] &
	      /*fontSize*/
	      4194304) text_1_changes.fontSize =
	      /*fontSize*/
	      ctx[22];
	      if (dirty[0] &
	      /*offsetX*/
	      1048576) text_1_changes.offsetX =
	      /*offsetX*/
	      ctx[20];
	      if (dirty[0] &
	      /*offsetY*/
	      2097152) text_1_changes.offsetY =
	      /*offsetY*/
	      ctx[21];
	      if (dirty[0] &
	      /*textOffsetX*/
	      134217728) text_1_changes.textOffsetX =
	      /*textOffsetX*/
	      ctx[27];
	      if (dirty[0] &
	      /*textOffsetY*/
	      268435456) text_1_changes.textOffsetY =
	      /*textOffsetY*/
	      ctx[28];
	      text_1.$set(text_1_changes);
	    },
	    i: function i(local) {
	      if (current) return;
	      transition_in(text_1.$$.fragment, local);
	      current = true;
	    },
	    o: function o(local) {
	      transition_out(text_1.$$.fragment, local);
	      current = false;
	    },
	    d: function d(detaching) {
	      destroy_component(text_1, detaching);
	    }
	  };
	} // (145:2) {#if isEditorActive && visible}


	function create_if_block$9(ctx) {
	  var draghandle;
	  var current;
	  draghandle = new DragHandle({
	    props: {
	      id:
	      /*id*/
	      ctx[4],
	      x: "0",
	      y: "0",
	      active: "true",
	      handleClass: "move",
	      onChange:
	      /*positionChange*/
	      ctx[32]
	    }
	  });
	  return {
	    c: function c() {
	      create_component(draghandle.$$.fragment);
	    },
	    m: function m(target, anchor) {
	      mount_component(draghandle, target, anchor);
	      current = true;
	    },
	    p: function p(ctx, dirty) {
	      var draghandle_changes = {};
	      if (dirty[0] &
	      /*id*/
	      16) draghandle_changes.id =
	      /*id*/
	      ctx[4];
	      if (dirty[1] &
	      /*positionChange*/
	      2) draghandle_changes.onChange =
	      /*positionChange*/
	      ctx[32];
	      draghandle.$set(draghandle_changes);
	    },
	    i: function i(local) {
	      if (current) return;
	      transition_in(draghandle.$$.fragment, local);
	      current = true;
	    },
	    o: function o(local) {
	      transition_out(draghandle.$$.fragment, local);
	      current = false;
	    },
	    d: function d(detaching) {
	      destroy_component(draghandle, detaching);
	    }
	  };
	} // (81:0) <Draggable   {id}   {x}   {y}   {visible}   {opacity}   {scale}   {editor}   {isEditor}   {isEditorActive}   {preventKeyHandlers}   {editComponent}   {containerWidth}   {updateDraggable}   {finalizeDraggable}   {extraClasses}   {darkMode} >


	function create_default_slot$1(ctx) {
	  var current_block_type_index;
	  var if_block0;
	  var t0;
	  var t1;
	  var if_block2_anchor;
	  var current;
	  var if_block_creators = [create_if_block_2$4, create_if_block_3$4, create_else_block$4];
	  var if_blocks = [];

	  function select_block_type(ctx, dirty) {
	    if (
	    /*iconNamedSVG*/
	    ctx[13]) return 0;
	    if (
	    /*iconSVG*/
	    ctx[14]) return 1;
	    return 2;
	  }

	  current_block_type_index = select_block_type(ctx);
	  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	  var if_block1 =
	  /*text*/
	  ctx[11] && create_if_block_1$6(ctx);
	  var if_block2 =
	  /*isEditorActive*/
	  ctx[1] &&
	  /*visible*/
	  ctx[6] && create_if_block$9(ctx);
	  return {
	    c: function c() {
	      if_block0.c();
	      t0 = space();
	      if (if_block1) if_block1.c();
	      t1 = space();
	      if (if_block2) if_block2.c();
	      if_block2_anchor = empty();
	    },
	    m: function m(target, anchor) {
	      if_blocks[current_block_type_index].m(target, anchor);
	      insert(target, t0, anchor);
	      if (if_block1) if_block1.m(target, anchor);
	      insert(target, t1, anchor);
	      if (if_block2) if_block2.m(target, anchor);
	      insert(target, if_block2_anchor, anchor);
	      current = true;
	    },
	    p: function p(ctx, dirty) {
	      var previous_block_index = current_block_type_index;
	      current_block_type_index = select_block_type(ctx);

	      if (current_block_type_index === previous_block_index) {
	        if_blocks[current_block_type_index].p(ctx, dirty);
	      } else {
	        group_outros();
	        transition_out(if_blocks[previous_block_index], 1, 1, function () {
	          if_blocks[previous_block_index] = null;
	        });
	        check_outros();
	        if_block0 = if_blocks[current_block_type_index];

	        if (!if_block0) {
	          if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	          if_block0.c();
	        } else {
	          if_block0.p(ctx, dirty);
	        }

	        transition_in(if_block0, 1);
	        if_block0.m(t0.parentNode, t0);
	      }

	      if (
	      /*text*/
	      ctx[11]) {
	        if (if_block1) {
	          if_block1.p(ctx, dirty);

	          if (dirty[0] &
	          /*text*/
	          2048) {
	            transition_in(if_block1, 1);
	          }
	        } else {
	          if_block1 = create_if_block_1$6(ctx);
	          if_block1.c();
	          transition_in(if_block1, 1);
	          if_block1.m(t1.parentNode, t1);
	        }
	      } else if (if_block1) {
	        group_outros();
	        transition_out(if_block1, 1, 1, function () {
	          if_block1 = null;
	        });
	        check_outros();
	      }

	      if (
	      /*isEditorActive*/
	      ctx[1] &&
	      /*visible*/
	      ctx[6]) {
	        if (if_block2) {
	          if_block2.p(ctx, dirty);

	          if (dirty[0] &
	          /*isEditorActive, visible*/
	          66) {
	            transition_in(if_block2, 1);
	          }
	        } else {
	          if_block2 = create_if_block$9(ctx);
	          if_block2.c();
	          transition_in(if_block2, 1);
	          if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
	        }
	      } else if (if_block2) {
	        group_outros();
	        transition_out(if_block2, 1, 1, function () {
	          if_block2 = null;
	        });
	        check_outros();
	      }
	    },
	    i: function i(local) {
	      if (current) return;
	      transition_in(if_block0);
	      transition_in(if_block1);
	      transition_in(if_block2);
	      current = true;
	    },
	    o: function o(local) {
	      transition_out(if_block0);
	      transition_out(if_block1);
	      transition_out(if_block2);
	      current = false;
	    },
	    d: function d(detaching) {
	      if_blocks[current_block_type_index].d(detaching);
	      if (detaching) detach(t0);
	      if (if_block1) if_block1.d(detaching);
	      if (detaching) detach(t1);
	      if (if_block2) if_block2.d(detaching);
	      if (detaching) detach(if_block2_anchor);
	    }
	  };
	}

	function create_fragment$h(ctx) {
	  var draggable;
	  var current;
	  draggable = new Draggable({
	    props: {
	      id:
	      /*id*/
	      ctx[4],
	      x:
	      /*x*/
	      ctx[18],
	      y:
	      /*y*/
	      ctx[19],
	      visible:
	      /*visible*/
	      ctx[6],
	      opacity:
	      /*opacity*/
	      ctx[25],
	      scale:
	      /*scale*/
	      ctx[7],
	      editor:
	      /*editor*/
	      ctx[2],
	      isEditor:
	      /*isEditor*/
	      ctx[0],
	      isEditorActive:
	      /*isEditorActive*/
	      ctx[1],
	      preventKeyHandlers:
	      /*preventKeyHandlers*/
	      ctx[29],
	      editComponent:
	      /*editComponent*/
	      ctx[3],
	      containerWidth:
	      /*containerWidth*/
	      ctx[8],
	      updateDraggable:
	      /*updateDraggable*/
	      ctx[9],
	      finalizeDraggable:
	      /*finalizeDraggable*/
	      ctx[10],
	      extraClasses:
	      /*extraClasses*/
	      ctx[31],
	      darkMode:
	      /*darkMode*/
	      ctx[26],
	      $$slots: {
	        default: [create_default_slot$1]
	      },
	      $$scope: {
	        ctx: ctx
	      }
	    }
	  });
	  return {
	    c: function c() {
	      create_component(draggable.$$.fragment);
	    },
	    m: function m(target, anchor) {
	      mount_component(draggable, target, anchor);
	      current = true;
	    },
	    p: function p(ctx, dirty) {
	      var draggable_changes = {};
	      if (dirty[0] &
	      /*id*/
	      16) draggable_changes.id =
	      /*id*/
	      ctx[4];
	      if (dirty[0] &
	      /*x*/
	      262144) draggable_changes.x =
	      /*x*/
	      ctx[18];
	      if (dirty[0] &
	      /*y*/
	      524288) draggable_changes.y =
	      /*y*/
	      ctx[19];
	      if (dirty[0] &
	      /*visible*/
	      64) draggable_changes.visible =
	      /*visible*/
	      ctx[6];
	      if (dirty[0] &
	      /*opacity*/
	      33554432) draggable_changes.opacity =
	      /*opacity*/
	      ctx[25];
	      if (dirty[0] &
	      /*scale*/
	      128) draggable_changes.scale =
	      /*scale*/
	      ctx[7];
	      if (dirty[0] &
	      /*editor*/
	      4) draggable_changes.editor =
	      /*editor*/
	      ctx[2];
	      if (dirty[0] &
	      /*isEditor*/
	      1) draggable_changes.isEditor =
	      /*isEditor*/
	      ctx[0];
	      if (dirty[0] &
	      /*isEditorActive*/
	      2) draggable_changes.isEditorActive =
	      /*isEditorActive*/
	      ctx[1];
	      if (dirty[0] &
	      /*preventKeyHandlers*/
	      536870912) draggable_changes.preventKeyHandlers =
	      /*preventKeyHandlers*/
	      ctx[29];
	      if (dirty[0] &
	      /*editComponent*/
	      8) draggable_changes.editComponent =
	      /*editComponent*/
	      ctx[3];
	      if (dirty[0] &
	      /*containerWidth*/
	      256) draggable_changes.containerWidth =
	      /*containerWidth*/
	      ctx[8];
	      if (dirty[0] &
	      /*updateDraggable*/
	      512) draggable_changes.updateDraggable =
	      /*updateDraggable*/
	      ctx[9];
	      if (dirty[0] &
	      /*finalizeDraggable*/
	      1024) draggable_changes.finalizeDraggable =
	      /*finalizeDraggable*/
	      ctx[10];
	      if (dirty[1] &
	      /*extraClasses*/
	      1) draggable_changes.extraClasses =
	      /*extraClasses*/
	      ctx[31];
	      if (dirty[0] &
	      /*darkMode*/
	      67108864) draggable_changes.darkMode =
	      /*darkMode*/
	      ctx[26];

	      if (dirty[0] &
	      /*id, isEditorActive, visible, updateDraggable, finalizeDraggable, text, align, valign, color, textWidth, letterSpacing, fontSize, offsetX, offsetY, textOffsetX, textOffsetY, svgSizeStyle, iconNamedSVG, iconSVG, iconText, iconSize*/
	      1509162610 | dirty[1] &
	      /*$$scope, positionChange*/
	      4098) {
	        draggable_changes.$$scope = {
	          dirty: dirty,
	          ctx: ctx
	        };
	      }

	      draggable.$set(draggable_changes);
	    },
	    i: function i(local) {
	      if (current) return;
	      transition_in(draggable.$$.fragment, local);
	      current = true;
	    },
	    o: function o(local) {
	      transition_out(draggable.$$.fragment, local);
	      current = false;
	    },
	    d: function d(detaching) {
	      destroy_component(draggable, detaching);
	    }
	  };
	}

	function instance$h($$self, $$props, $$invalidate) {
	  var positionChange;
	  var mobileClass;
	  var outlineClass;
	  var infoBoxClass;
	  var extraClasses;
	  var svgSizeStyle;
	  var _$$props$isEditor = $$props.isEditor,
	      isEditor = _$$props$isEditor === void 0 ? false : _$$props$isEditor;
	  var _$$props$isEditorActi = $$props.isEditorActive,
	      isEditorActive = _$$props$isEditorActi === void 0 ? false : _$$props$isEditorActi;
	  var editor = $$props.editor;
	  var editComponent = $$props.editComponent;
	  var id = $$props.id;
	  var color = $$props.color;
	  var _$$props$visible = $$props.visible,
	      visible = _$$props$visible === void 0 ? true : _$$props$visible;
	  var scale = $$props.scale;
	  var containerWidth = $$props.containerWidth;
	  var updateDraggable = $$props.updateDraggable;
	  var finalizeDraggable = $$props.finalizeDraggable;
	  var _$$props$text = $$props.text,
	      text = _$$props$text === void 0 ? '' : _$$props$text;
	  var _$$props$iconText = $$props.iconText,
	      iconText = _$$props$iconText === void 0 ? 'â' : _$$props$iconText; // icon text won't be editable

	  var _$$props$iconNamedSVG = $$props.iconNamedSVG,
	      iconNamedSVG = _$$props$iconNamedSVG === void 0 ? null : _$$props$iconNamedSVG; // provide option for named default svg icons

	  var _$$props$iconSVG = $$props.iconSVG,
	      iconSVG = _$$props$iconSVG === void 0 ? null : _$$props$iconSVG; // provide option for svg content passed into config

	  var iconColor = $$props.iconColor;
	  var iconSecondaryColor = $$props.iconSecondaryColor;
	  var _$$props$iconSize = $$props.iconSize,
	      iconSize = _$$props$iconSize === void 0 ? 14 : _$$props$iconSize;
	  var _$$props$align = $$props.align,
	      align = _$$props$align === void 0 ? 'left' : _$$props$align;
	  var _$$props$valign = $$props.valign,
	      valign = _$$props$valign === void 0 ? 'top' : _$$props$valign;
	  var _$$props$x = $$props.x,
	      x = _$$props$x === void 0 ? 0 : _$$props$x;
	  var _$$props$y = $$props.y,
	      y = _$$props$y === void 0 ? 0 : _$$props$y;
	  var _$$props$offsetX = $$props.offsetX,
	      offsetX = _$$props$offsetX === void 0 ? 20 : _$$props$offsetX;
	  var _$$props$offsetY = $$props.offsetY,
	      offsetY = _$$props$offsetY === void 0 ? 0 : _$$props$offsetY;
	  var fontSize = $$props.fontSize;
	  var outline = $$props.outline;
	  var infoBox = $$props.infoBox;
	  var textWidth = $$props.textWidth;
	  var letterSpacing = $$props.letterSpacing;
	  var opacity = $$props.opacity;
	  var darkMode = $$props.darkMode;
	  var textOffsetX = 0;
	  var textOffsetY = 0;
	  var iconColorActive = iconColor || (darkMode ? '#ffffff' : '#000000');
	  var secondaryColorActive = iconSecondaryColor || (darkMode ? '#000000' : '#ffffff');
	  var preventKeyHandlers = false;

	  function setEditingText(editState) {
	    $$invalidate(29, preventKeyHandlers = editState);
	  }

	  $$self.$$set = function ($$props) {
	    if ('isEditor' in $$props) $$invalidate(0, isEditor = $$props.isEditor);
	    if ('isEditorActive' in $$props) $$invalidate(1, isEditorActive = $$props.isEditorActive);
	    if ('editor' in $$props) $$invalidate(2, editor = $$props.editor);
	    if ('editComponent' in $$props) $$invalidate(3, editComponent = $$props.editComponent);
	    if ('id' in $$props) $$invalidate(4, id = $$props.id);
	    if ('color' in $$props) $$invalidate(5, color = $$props.color);
	    if ('visible' in $$props) $$invalidate(6, visible = $$props.visible);
	    if ('scale' in $$props) $$invalidate(7, scale = $$props.scale);
	    if ('containerWidth' in $$props) $$invalidate(8, containerWidth = $$props.containerWidth);
	    if ('updateDraggable' in $$props) $$invalidate(9, updateDraggable = $$props.updateDraggable);
	    if ('finalizeDraggable' in $$props) $$invalidate(10, finalizeDraggable = $$props.finalizeDraggable);
	    if ('text' in $$props) $$invalidate(11, text = $$props.text);
	    if ('iconText' in $$props) $$invalidate(12, iconText = $$props.iconText);
	    if ('iconNamedSVG' in $$props) $$invalidate(13, iconNamedSVG = $$props.iconNamedSVG);
	    if ('iconSVG' in $$props) $$invalidate(14, iconSVG = $$props.iconSVG);
	    if ('iconColor' in $$props) $$invalidate(36, iconColor = $$props.iconColor);
	    if ('iconSecondaryColor' in $$props) $$invalidate(37, iconSecondaryColor = $$props.iconSecondaryColor);
	    if ('iconSize' in $$props) $$invalidate(15, iconSize = $$props.iconSize);
	    if ('align' in $$props) $$invalidate(16, align = $$props.align);
	    if ('valign' in $$props) $$invalidate(17, valign = $$props.valign);
	    if ('x' in $$props) $$invalidate(18, x = $$props.x);
	    if ('y' in $$props) $$invalidate(19, y = $$props.y);
	    if ('offsetX' in $$props) $$invalidate(20, offsetX = $$props.offsetX);
	    if ('offsetY' in $$props) $$invalidate(21, offsetY = $$props.offsetY);
	    if ('fontSize' in $$props) $$invalidate(22, fontSize = $$props.fontSize);
	    if ('outline' in $$props) $$invalidate(38, outline = $$props.outline);
	    if ('infoBox' in $$props) $$invalidate(39, infoBox = $$props.infoBox);
	    if ('textWidth' in $$props) $$invalidate(23, textWidth = $$props.textWidth);
	    if ('letterSpacing' in $$props) $$invalidate(24, letterSpacing = $$props.letterSpacing);
	    if ('opacity' in $$props) $$invalidate(25, opacity = $$props.opacity);
	    if ('darkMode' in $$props) $$invalidate(26, darkMode = $$props.darkMode);
	  };

	  $$self.$$.update = function () {
	    if ($$self.$$.dirty[0] &
	    /*id, x, y, scale, containerWidth, updateDraggable, isEditor, editor*/
	    787349) {
	      $$invalidate(32, positionChange = positionChangeHandler(id, x, y, scale, containerWidth, updateDraggable, isEditor, editor));
	    }

	    if ($$self.$$.dirty[0] &
	    /*containerWidth*/
	    256) {
	      $$invalidate(42, mobileClass = containerWidth < 500 ? 'mobile' : '');
	    }

	    if ($$self.$$.dirty[1] &
	    /*outline*/
	    128) {
	      $$invalidate(41, outlineClass = outline ? 'outline' : '');
	    }

	    if ($$self.$$.dirty[1] &
	    /*infoBox*/
	    256) {
	      $$invalidate(40, infoBoxClass = infoBox ? 'infoBox' : '');
	    }

	    if ($$self.$$.dirty[1] &
	    /*mobileClass, outlineClass, infoBoxClass*/
	    3584) {
	      $$invalidate(31, extraClasses = "".concat(mobileClass, " ").concat(outlineClass, " ").concat(infoBoxClass));
	    }

	    if ($$self.$$.dirty[0] &
	    /*iconSize*/
	    32768) {
	      $$invalidate(30, svgSizeStyle = "\n    width: ".concat(iconSize, "px;\n    height: ").concat(iconSize, "px;\n    margin-left: ").concat(-1 * iconSize / 2, "px;\n    margin-top: ").concat(-1 * iconSize / 2, "px;\n  "));
	    }

	    if ($$self.$$.dirty[0] &
	    /*align, valign, iconSize, fontSize, offsetX, offsetY*/
	    7569408) {
	      {
	        var _iconAlignOffset = iconAlignOffset(align, valign, iconSize),
	            alignOffsetX = _iconAlignOffset.alignOffsetX,
	            alignOffsetY = _iconAlignOffset.alignOffsetY;

	        $$invalidate(27, textOffsetX = offsetX + alignOffsetX);
	        $$invalidate(28, textOffsetY = offsetY + alignOffsetY);
	      }
	    }
	  };

	  return [isEditor, isEditorActive, editor, editComponent, id, color, visible, scale, containerWidth, updateDraggable, finalizeDraggable, text, iconText, iconNamedSVG, iconSVG, iconSize, align, valign, x, y, offsetX, offsetY, fontSize, textWidth, letterSpacing, opacity, darkMode, textOffsetX, textOffsetY, preventKeyHandlers, svgSizeStyle, extraClasses, positionChange, iconColorActive, secondaryColorActive, setEditingText, iconColor, iconSecondaryColor, outline, infoBox, infoBoxClass, outlineClass, mobileClass];
	}

	var IconLabel = /*#__PURE__*/function (_SvelteComponent) {
	  _inherits(IconLabel, _SvelteComponent);

	  var _super = _createSuper(IconLabel);

	  function IconLabel(options) {
	    var _this;

	    _classCallCheck(this, IconLabel);

	    _this = _super.call(this);
	    init(_assertThisInitialized(_this), options, instance$h, create_fragment$h, safe_not_equal, {
	      isEditor: 0,
	      isEditorActive: 1,
	      editor: 2,
	      editComponent: 3,
	      id: 4,
	      color: 5,
	      visible: 6,
	      scale: 7,
	      containerWidth: 8,
	      updateDraggable: 9,
	      finalizeDraggable: 10,
	      text: 11,
	      iconText: 12,
	      iconNamedSVG: 13,
	      iconSVG: 14,
	      iconColor: 36,
	      iconSecondaryColor: 37,
	      iconSize: 15,
	      align: 16,
	      valign: 17,
	      x: 18,
	      y: 19,
	      offsetX: 20,
	      offsetY: 21,
	      fontSize: 22,
	      outline: 38,
	      infoBox: 39,
	      textWidth: 23,
	      letterSpacing: 24,
	      opacity: 25,
	      darkMode: 26
	    }, null, [-1, -1]);
	    return _this;
	  }

	  _createClass(IconLabel, [{
	    key: "isEditor",
	    get: function get() {
	      return this.$$.ctx[0];
	    },
	    set: function set(isEditor) {
	      this.$$set({
	        isEditor: isEditor
	      });
	      flush();
	    }
	  }, {
	    key: "isEditorActive",
	    get: function get() {
	      return this.$$.ctx[1];
	    },
	    set: function set(isEditorActive) {
	      this.$$set({
	        isEditorActive: isEditorActive
	      });
	      flush();
	    }
	  }, {
	    key: "editor",
	    get: function get() {
	      return this.$$.ctx[2];
	    },
	    set: function set(editor) {
	      this.$$set({
	        editor: editor
	      });
	      flush();
	    }
	  }, {
	    key: "editComponent",
	    get: function get() {
	      return this.$$.ctx[3];
	    },
	    set: function set(editComponent) {
	      this.$$set({
	        editComponent: editComponent
	      });
	      flush();
	    }
	  }, {
	    key: "id",
	    get: function get() {
	      return this.$$.ctx[4];
	    },
	    set: function set(id) {
	      this.$$set({
	        id: id
	      });
	      flush();
	    }
	  }, {
	    key: "color",
	    get: function get() {
	      return this.$$.ctx[5];
	    },
	    set: function set(color) {
	      this.$$set({
	        color: color
	      });
	      flush();
	    }
	  }, {
	    key: "visible",
	    get: function get() {
	      return this.$$.ctx[6];
	    },
	    set: function set(visible) {
	      this.$$set({
	        visible: visible
	      });
	      flush();
	    }
	  }, {
	    key: "scale",
	    get: function get() {
	      return this.$$.ctx[7];
	    },
	    set: function set(scale) {
	      this.$$set({
	        scale: scale
	      });
	      flush();
	    }
	  }, {
	    key: "containerWidth",
	    get: function get() {
	      return this.$$.ctx[8];
	    },
	    set: function set(containerWidth) {
	      this.$$set({
	        containerWidth: containerWidth
	      });
	      flush();
	    }
	  }, {
	    key: "updateDraggable",
	    get: function get() {
	      return this.$$.ctx[9];
	    },
	    set: function set(updateDraggable) {
	      this.$$set({
	        updateDraggable: updateDraggable
	      });
	      flush();
	    }
	  }, {
	    key: "finalizeDraggable",
	    get: function get() {
	      return this.$$.ctx[10];
	    },
	    set: function set(finalizeDraggable) {
	      this.$$set({
	        finalizeDraggable: finalizeDraggable
	      });
	      flush();
	    }
	  }, {
	    key: "text",
	    get: function get() {
	      return this.$$.ctx[11];
	    },
	    set: function set(text) {
	      this.$$set({
	        text: text
	      });
	      flush();
	    }
	  }, {
	    key: "iconText",
	    get: function get() {
	      return this.$$.ctx[12];
	    },
	    set: function set(iconText) {
	      this.$$set({
	        iconText: iconText
	      });
	      flush();
	    }
	  }, {
	    key: "iconNamedSVG",
	    get: function get() {
	      return this.$$.ctx[13];
	    },
	    set: function set(iconNamedSVG) {
	      this.$$set({
	        iconNamedSVG: iconNamedSVG
	      });
	      flush();
	    }
	  }, {
	    key: "iconSVG",
	    get: function get() {
	      return this.$$.ctx[14];
	    },
	    set: function set(iconSVG) {
	      this.$$set({
	        iconSVG: iconSVG
	      });
	      flush();
	    }
	  }, {
	    key: "iconColor",
	    get: function get() {
	      return this.$$.ctx[36];
	    },
	    set: function set(iconColor) {
	      this.$$set({
	        iconColor: iconColor
	      });
	      flush();
	    }
	  }, {
	    key: "iconSecondaryColor",
	    get: function get() {
	      return this.$$.ctx[37];
	    },
	    set: function set(iconSecondaryColor) {
	      this.$$set({
	        iconSecondaryColor: iconSecondaryColor
	      });
	      flush();
	    }
	  }, {
	    key: "iconSize",
	    get: function get() {
	      return this.$$.ctx[15];
	    },
	    set: function set(iconSize) {
	      this.$$set({
	        iconSize: iconSize
	      });
	      flush();
	    }
	  }, {
	    key: "align",
	    get: function get() {
	      return this.$$.ctx[16];
	    },
	    set: function set(align) {
	      this.$$set({
	        align: align
	      });
	      flush();
	    }
	  }, {
	    key: "valign",
	    get: function get() {
	      return this.$$.ctx[17];
	    },
	    set: function set(valign) {
	      this.$$set({
	        valign: valign
	      });
	      flush();
	    }
	  }, {
	    key: "x",
	    get: function get() {
	      return this.$$.ctx[18];
	    },
	    set: function set(x) {
	      this.$$set({
	        x: x
	      });
	      flush();
	    }
	  }, {
	    key: "y",
	    get: function get() {
	      return this.$$.ctx[19];
	    },
	    set: function set(y) {
	      this.$$set({
	        y: y
	      });
	      flush();
	    }
	  }, {
	    key: "offsetX",
	    get: function get() {
	      return this.$$.ctx[20];
	    },
	    set: function set(offsetX) {
	      this.$$set({
	        offsetX: offsetX
	      });
	      flush();
	    }
	  }, {
	    key: "offsetY",
	    get: function get() {
	      return this.$$.ctx[21];
	    },
	    set: function set(offsetY) {
	      this.$$set({
	        offsetY: offsetY
	      });
	      flush();
	    }
	  }, {
	    key: "fontSize",
	    get: function get() {
	      return this.$$.ctx[22];
	    },
	    set: function set(fontSize) {
	      this.$$set({
	        fontSize: fontSize
	      });
	      flush();
	    }
	  }, {
	    key: "outline",
	    get: function get() {
	      return this.$$.ctx[38];
	    },
	    set: function set(outline) {
	      this.$$set({
	        outline: outline
	      });
	      flush();
	    }
	  }, {
	    key: "infoBox",
	    get: function get() {
	      return this.$$.ctx[39];
	    },
	    set: function set(infoBox) {
	      this.$$set({
	        infoBox: infoBox
	      });
	      flush();
	    }
	  }, {
	    key: "textWidth",
	    get: function get() {
	      return this.$$.ctx[23];
	    },
	    set: function set(textWidth) {
	      this.$$set({
	        textWidth: textWidth
	      });
	      flush();
	    }
	  }, {
	    key: "letterSpacing",
	    get: function get() {
	      return this.$$.ctx[24];
	    },
	    set: function set(letterSpacing) {
	      this.$$set({
	        letterSpacing: letterSpacing
	      });
	      flush();
	    }
	  }, {
	    key: "opacity",
	    get: function get() {
	      return this.$$.ctx[25];
	    },
	    set: function set(opacity) {
	      this.$$set({
	        opacity: opacity
	      });
	      flush();
	    }
	  }, {
	    key: "darkMode",
	    get: function get() {
	      return this.$$.ctx[26];
	    },
	    set: function set(darkMode) {
	      this.$$set({
	        darkMode: darkMode
	      });
	      flush();
	    }
	  }]);

	  return IconLabel;
	}(SvelteComponent);

	function create_fragment$g(ctx) {
	  var switch_instance;
	  var switch_instance_anchor;
	  var current;
	  var switch_instance_spread_levels = [{
	    editor:
	    /*editor*/
	    ctx[1]
	  }, {
	    isEditor:
	    /*isEditor*/
	    ctx[0]
	  }, {
	    isEditorActive:
	    /*isEditorActive*/
	    ctx[13]
	  }, {
	    editComponent:
	    /*editComponent*/
	    ctx[14]
	  }, {
	    darkMode:
	    /*darkMode*/
	    ctx[6]
	  }, {
	    id:
	    /*id*/
	    ctx[11]
	  }, {
	    type:
	    /*type*/
	    ctx[12]
	  }, {
	    updateDraggable:
	    /*onDraggableUpdate*/
	    ctx[15]
	  }, {
	    finalizeDraggable:
	    /*finalizeDraggable*/
	    ctx[2]
	  }, {
	    removeDraggable:
	    /*removeDraggable*/
	    ctx[3]
	  }, {
	    scale:
	    /*scale*/
	    ctx[4]
	  }, {
	    containerWidth:
	    /*containerWidth*/
	    ctx[5]
	  },
	  /*derivedDraggable*/
	  ctx[7], {
	    x:
	    /*xPos*/
	    ctx[8]
	  }, {
	    y:
	    /*yPos*/
	    ctx[9]
	  }];
	  var switch_value =
	  /*ComponentType*/
	  ctx[10];

	  function switch_props(ctx) {
	    var switch_instance_props = {};

	    for (var i = 0; i < switch_instance_spread_levels.length; i += 1) {
	      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
	    }

	    return {
	      props: switch_instance_props
	    };
	  }

	  if (switch_value) {
	    switch_instance = construct_svelte_component(switch_value, switch_props());
	  }

	  return {
	    c: function c() {
	      if (switch_instance) create_component(switch_instance.$$.fragment);
	      switch_instance_anchor = empty();
	    },
	    m: function m(target, anchor) {
	      if (switch_instance) mount_component(switch_instance, target, anchor);
	      insert(target, switch_instance_anchor, anchor);
	      current = true;
	    },
	    p: function p(ctx, _ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	          dirty = _ref2[0];

	      var switch_instance_changes = dirty &
	      /*editor, isEditor, isEditorActive, editComponent, darkMode, id, type, onDraggableUpdate, finalizeDraggable, removeDraggable, scale, containerWidth, derivedDraggable, xPos, yPos*/
	      64511 ? get_spread_update(switch_instance_spread_levels, [dirty &
	      /*editor*/
	      2 && {
	        editor:
	        /*editor*/
	        ctx[1]
	      }, dirty &
	      /*isEditor*/
	      1 && {
	        isEditor:
	        /*isEditor*/
	        ctx[0]
	      }, dirty &
	      /*isEditorActive*/
	      8192 && {
	        isEditorActive:
	        /*isEditorActive*/
	        ctx[13]
	      }, dirty &
	      /*editComponent*/
	      16384 && {
	        editComponent:
	        /*editComponent*/
	        ctx[14]
	      }, dirty &
	      /*darkMode*/
	      64 && {
	        darkMode:
	        /*darkMode*/
	        ctx[6]
	      }, dirty &
	      /*id*/
	      2048 && {
	        id:
	        /*id*/
	        ctx[11]
	      }, dirty &
	      /*type*/
	      4096 && {
	        type:
	        /*type*/
	        ctx[12]
	      }, dirty &
	      /*onDraggableUpdate*/
	      32768 && {
	        updateDraggable:
	        /*onDraggableUpdate*/
	        ctx[15]
	      }, dirty &
	      /*finalizeDraggable*/
	      4 && {
	        finalizeDraggable:
	        /*finalizeDraggable*/
	        ctx[2]
	      }, dirty &
	      /*removeDraggable*/
	      8 && {
	        removeDraggable:
	        /*removeDraggable*/
	        ctx[3]
	      }, dirty &
	      /*scale*/
	      16 && {
	        scale:
	        /*scale*/
	        ctx[4]
	      }, dirty &
	      /*containerWidth*/
	      32 && {
	        containerWidth:
	        /*containerWidth*/
	        ctx[5]
	      }, dirty &
	      /*derivedDraggable*/
	      128 && get_spread_object(
	      /*derivedDraggable*/
	      ctx[7]), dirty &
	      /*xPos*/
	      256 && {
	        x:
	        /*xPos*/
	        ctx[8]
	      }, dirty &
	      /*yPos*/
	      512 && {
	        y:
	        /*yPos*/
	        ctx[9]
	      }]) : {};

	      if (switch_value !== (switch_value =
	      /*ComponentType*/
	      ctx[10])) {
	        if (switch_instance) {
	          group_outros();
	          var old_component = switch_instance;
	          transition_out(old_component.$$.fragment, 1, 0, function () {
	            destroy_component(old_component, 1);
	          });
	          check_outros();
	        }

	        if (switch_value) {
	          switch_instance = construct_svelte_component(switch_value, switch_props());
	          create_component(switch_instance.$$.fragment);
	          transition_in(switch_instance.$$.fragment, 1);
	          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
	        } else {
	          switch_instance = null;
	        }
	      } else if (switch_value) {
	        switch_instance.$set(switch_instance_changes);
	      }
	    },
	    i: function i(local) {
	      if (current) return;
	      if (switch_instance) transition_in(switch_instance.$$.fragment, local);
	      current = true;
	    },
	    o: function o(local) {
	      if (switch_instance) transition_out(switch_instance.$$.fragment, local);
	      current = false;
	    },
	    d: function d(detaching) {
	      if (detaching) detach(switch_instance_anchor);
	      if (switch_instance) destroy_component(switch_instance, detaching);
	    }
	  };
	}

	function instance$g($$self, $$props, $$invalidate) {
	  var isEditor = $$props.isEditor;
	  var editor = $$props.editor;
	  var draggable = $$props.draggable;
	  var updateDraggable = $$props.updateDraggable;
	  var finalizeDraggable = $$props.finalizeDraggable;
	  var removeDraggable = $$props.removeDraggable;
	  var onShowEditor = $$props.onShowEditor;
	  var onHideEditor = $$props.onHideEditor;
	  var scale = $$props.scale;
	  var breakpoint = $$props.breakpoint;
	  var containerWidth = $$props.containerWidth;
	  var darkMode = $$props.darkMode;
	  var customTypes = $$props.customTypes;
	  var xPos;
	  var yPos;
	  var derivedDraggable;
	  var ComponentType;
	  var id;
	  var type;
	  var isEditorActive = false;

	  function editComponent(domNode, editProperties) {
	    if (derivedDraggable && !isEditorActive) {
	      if (onShowEditor) onShowEditor(derivedDraggable.id); // any text editor editable fields need to go here

	      var fields = {
	        id: derivedDraggable.id,
	        type: derivedDraggable.type,
	        x: derivedDraggable.x,
	        y: derivedDraggable.y,
	        visible: derivedDraggable.visible,
	        text: derivedDraggable.text,
	        align: derivedDraggable.align,
	        valign: derivedDraggable.valign,
	        color: derivedDraggable.color,
	        outline: derivedDraggable.outline,
	        infoBox: derivedDraggable.infoBox,
	        textWidth: derivedDraggable.textWidth,
	        letterSpacing: derivedDraggable.letterSpacing,
	        offsetX: derivedDraggable.offsetX,
	        offsetY: derivedDraggable.offsetY,
	        opacity: derivedDraggable.opacity
	      };

	      var onClose = function onClose() {
	        $$invalidate(13, isEditorActive = false);
	        if (onHideEditor) onHideEditor(derivedDraggable.id);
	      };

	      $$invalidate(13, isEditorActive = true);
	      var isVisible = derivedDraggable.visible !== false;
	      var textNode = isVisible ? domNode.querySelector('.text') || domNode : domNode;
	      var drawNode = isVisible ? domNode.querySelector('.draw-region') || domNode : domNode;
	      var bounds = domNode.getBoundingClientRect();
	      var textBounds = textNode.getBoundingClientRect();
	      var drawBounds = drawNode.getBoundingClientRect();
	      var editorBounds = editor ? editor.domNode.getBoundingClientRect() : drawBounds;
	      var allBounds = {
	        x: Math.min(textBounds.x, bounds.x, drawBounds.x),
	        y: Math.min(textBounds.y, bounds.y, drawBounds.y),
	        width: Math.max(textBounds.width, bounds.width, drawBounds.width),
	        height: Math.max(textBounds.height, bounds.height, drawBounds.height)
	      };
	      var pos = [allBounds.x - editorBounds.x + allBounds.width / 2 - 40, allBounds.y - editorBounds.y - 12]; // if pos is above editor flip to bottom of element

	      if (pos[1] < 30) {
	        pos[1] = allBounds.y - editorBounds.y + allBounds.height + 50;
	      }

	      if (pos[0] < 30) {
	        pos[0] = allBounds.x - editorBounds.x + allBounds.width + 50;
	      } // if editor properties are defined, show those in editor


	      if (editProperties) {
	        editor.mountGenericEditor(editProperties, fields, updateDraggable, removeDraggable, onClose, pos);
	      } else {
	        editor.mountTextEditor(fields, updateDraggable, removeDraggable, onClose, pos);
	      } // focus on the contentEditable text area
	      // focusContentEditable(domNode.querySelector('.text'))
	      // ok now the tricky part, bind close to clicking anywhere outside
	      // of either editor or the draggable


	      editor.bindDocumentCloseHandler(domNode, onClose);
	    }
	  }

	  function onDraggableUpdate(id, props) {
	    if (isEditorActive) {
	      editor.updateFields(props);
	    }

	    updateDraggable(id, props);
	  }

	  var TYPE_MAP = {
	    label: Label,
	    line: Line,
	    linebend: DoubleLine,
	    arrow: Arrow,
	    circle: Circle,
	    icon: IconLabel
	  };

	  var typeMap = _objectSpread2(_objectSpread2({}, TYPE_MAP), customTypes);

	  $$self.$$set = function ($$props) {
	    if ('isEditor' in $$props) $$invalidate(0, isEditor = $$props.isEditor);
	    if ('editor' in $$props) $$invalidate(1, editor = $$props.editor);
	    if ('draggable' in $$props) $$invalidate(16, draggable = $$props.draggable);
	    if ('updateDraggable' in $$props) $$invalidate(17, updateDraggable = $$props.updateDraggable);
	    if ('finalizeDraggable' in $$props) $$invalidate(2, finalizeDraggable = $$props.finalizeDraggable);
	    if ('removeDraggable' in $$props) $$invalidate(3, removeDraggable = $$props.removeDraggable);
	    if ('onShowEditor' in $$props) $$invalidate(18, onShowEditor = $$props.onShowEditor);
	    if ('onHideEditor' in $$props) $$invalidate(19, onHideEditor = $$props.onHideEditor);
	    if ('scale' in $$props) $$invalidate(4, scale = $$props.scale);
	    if ('breakpoint' in $$props) $$invalidate(20, breakpoint = $$props.breakpoint);
	    if ('containerWidth' in $$props) $$invalidate(5, containerWidth = $$props.containerWidth);
	    if ('darkMode' in $$props) $$invalidate(6, darkMode = $$props.darkMode);
	    if ('customTypes' in $$props) $$invalidate(21, customTypes = $$props.customTypes);
	  };

	  $$self.$$.update = function () {
	    if ($$self.$$.dirty &
	    /*draggable*/
	    65536) {
	      {
	        $$invalidate(11, id = draggable.id);
	        $$invalidate(12, type = draggable.type);
	        $$invalidate(10, ComponentType = typeMap[draggable.type] || Label);
	      }
	    }

	    if ($$self.$$.dirty &
	    /*breakpoint, draggable, scale, containerWidth, derivedDraggable*/
	    1114288) {
	      {
	        var _pos, _pos2;

	        if (breakpoint && draggable.breakpoints && draggable.breakpoints[breakpoint.name]) {
	          $$invalidate(7, derivedDraggable = _extends({}, draggable, draggable.breakpoints[breakpoint.name]));
	        } else {
	          $$invalidate(7, derivedDraggable = draggable);
	        }

	        var pos = scale(containerWidth, [derivedDraggable.x, derivedDraggable.y]);
	        $$invalidate(8, (_pos = pos, _pos2 = _slicedToArray(_pos, 2), xPos = _pos2[0], yPos = _pos2[1], _pos), xPos, ((((($$invalidate(9, yPos), $$invalidate(20, breakpoint)), $$invalidate(16, draggable)), $$invalidate(4, scale)), $$invalidate(5, containerWidth)), $$invalidate(7, derivedDraggable)));
	      }
	    }
	  };

	  return [isEditor, editor, finalizeDraggable, removeDraggable, scale, containerWidth, darkMode, derivedDraggable, xPos, yPos, ComponentType, id, type, isEditorActive, editComponent, onDraggableUpdate, draggable, updateDraggable, onShowEditor, onHideEditor, breakpoint, customTypes];
	}

	var Container = /*#__PURE__*/function (_SvelteComponent) {
	  _inherits(Container, _SvelteComponent);

	  var _super = _createSuper(Container);

	  function Container(options) {
	    var _this;

	    _classCallCheck(this, Container);

	    _this = _super.call(this);
	    init(_assertThisInitialized(_this), options, instance$g, create_fragment$g, safe_not_equal, {
	      isEditor: 0,
	      editor: 1,
	      draggable: 16,
	      updateDraggable: 17,
	      finalizeDraggable: 2,
	      removeDraggable: 3,
	      onShowEditor: 18,
	      onHideEditor: 19,
	      scale: 4,
	      breakpoint: 20,
	      containerWidth: 5,
	      darkMode: 6,
	      customTypes: 21
	    });
	    return _this;
	  }

	  _createClass(Container, [{
	    key: "isEditor",
	    get: function get() {
	      return this.$$.ctx[0];
	    },
	    set: function set(isEditor) {
	      this.$$set({
	        isEditor: isEditor
	      });
	      flush();
	    }
	  }, {
	    key: "editor",
	    get: function get() {
	      return this.$$.ctx[1];
	    },
	    set: function set(editor) {
	      this.$$set({
	        editor: editor
	      });
	      flush();
	    }
	  }, {
	    key: "draggable",
	    get: function get() {
	      return this.$$.ctx[16];
	    },
	    set: function set(draggable) {
	      this.$$set({
	        draggable: draggable
	      });
	      flush();
	    }
	  }, {
	    key: "updateDraggable",
	    get: function get() {
	      return this.$$.ctx[17];
	    },
	    set: function set(updateDraggable) {
	      this.$$set({
	        updateDraggable: updateDraggable
	      });
	      flush();
	    }
	  }, {
	    key: "finalizeDraggable",
	    get: function get() {
	      return this.$$.ctx[2];
	    },
	    set: function set(finalizeDraggable) {
	      this.$$set({
	        finalizeDraggable: finalizeDraggable
	      });
	      flush();
	    }
	  }, {
	    key: "removeDraggable",
	    get: function get() {
	      return this.$$.ctx[3];
	    },
	    set: function set(removeDraggable) {
	      this.$$set({
	        removeDraggable: removeDraggable
	      });
	      flush();
	    }
	  }, {
	    key: "onShowEditor",
	    get: function get() {
	      return this.$$.ctx[18];
	    },
	    set: function set(onShowEditor) {
	      this.$$set({
	        onShowEditor: onShowEditor
	      });
	      flush();
	    }
	  }, {
	    key: "onHideEditor",
	    get: function get() {
	      return this.$$.ctx[19];
	    },
	    set: function set(onHideEditor) {
	      this.$$set({
	        onHideEditor: onHideEditor
	      });
	      flush();
	    }
	  }, {
	    key: "scale",
	    get: function get() {
	      return this.$$.ctx[4];
	    },
	    set: function set(scale) {
	      this.$$set({
	        scale: scale
	      });
	      flush();
	    }
	  }, {
	    key: "breakpoint",
	    get: function get() {
	      return this.$$.ctx[20];
	    },
	    set: function set(breakpoint) {
	      this.$$set({
	        breakpoint: breakpoint
	      });
	      flush();
	    }
	  }, {
	    key: "containerWidth",
	    get: function get() {
	      return this.$$.ctx[5];
	    },
	    set: function set(containerWidth) {
	      this.$$set({
	        containerWidth: containerWidth
	      });
	      flush();
	    }
	  }, {
	    key: "darkMode",
	    get: function get() {
	      return this.$$.ctx[6];
	    },
	    set: function set(darkMode) {
	      this.$$set({
	        darkMode: darkMode
	      });
	      flush();
	    }
	  }, {
	    key: "customTypes",
	    get: function get() {
	      return this.$$.ctx[21];
	    },
	    set: function set(customTypes) {
	      this.$$set({
	        customTypes: customTypes
	      });
	      flush();
	    }
	  }]);

	  return Container;
	}(SvelteComponent);

	function add_css$e(target) {
	  append_styles(target, "svelte-5gc1hn", ".group.svelte-5gc1hn{box-shadow:1px 0 0 grey}");
	}

	function get_each_context$6(ctx, list, i) {
	  var child_ctx = ctx.slice();
	  child_ctx[13] = list[i];
	  return child_ctx;
	} // (26:2) {#each items as draggable (draggable.id)}


	function create_each_block$6(key_1, ctx) {
	  var first;
	  var container;
	  var current;
	  container = new Container({
	    props: {
	      draggable:
	      /*draggable*/
	      ctx[13],
	      isEditor:
	      /*isEditor*/
	      ctx[0],
	      editor:
	      /*editor*/
	      ctx[1],
	      options:
	      /*options*/
	      ctx[5],
	      onChange:
	      /*onChange*/
	      ctx[6],
	      addDraggable:
	      /*addDraggable*/
	      ctx[9],
	      updateDraggable:
	      /*updateDraggable*/
	      ctx[7],
	      removeDraggable:
	      /*removeDraggable*/
	      ctx[8],
	      containerWidth:
	      /*containerWidth*/
	      ctx[2],
	      scale:
	      /*scale*/
	      ctx[3],
	      breakpoint:
	      /*breakpoint*/
	      ctx[10],
	      darkMode:
	      /*darkMode*/
	      ctx[11],
	      customTypes:
	      /*customTypes*/
	      ctx[12]
	    }
	  });
	  return {
	    key: key_1,
	    first: null,
	    c: function c() {
	      first = empty();
	      create_component(container.$$.fragment);
	      this.first = first;
	    },
	    m: function m(target, anchor) {
	      insert(target, first, anchor);
	      mount_component(container, target, anchor);
	      current = true;
	    },
	    p: function p(new_ctx, dirty) {
	      ctx = new_ctx;
	      var container_changes = {};
	      if (dirty &
	      /*items*/
	      16) container_changes.draggable =
	      /*draggable*/
	      ctx[13];
	      if (dirty &
	      /*isEditor*/
	      1) container_changes.isEditor =
	      /*isEditor*/
	      ctx[0];
	      if (dirty &
	      /*editor*/
	      2) container_changes.editor =
	      /*editor*/
	      ctx[1];
	      if (dirty &
	      /*options*/
	      32) container_changes.options =
	      /*options*/
	      ctx[5];
	      if (dirty &
	      /*onChange*/
	      64) container_changes.onChange =
	      /*onChange*/
	      ctx[6];
	      if (dirty &
	      /*addDraggable*/
	      512) container_changes.addDraggable =
	      /*addDraggable*/
	      ctx[9];
	      if (dirty &
	      /*updateDraggable*/
	      128) container_changes.updateDraggable =
	      /*updateDraggable*/
	      ctx[7];
	      if (dirty &
	      /*removeDraggable*/
	      256) container_changes.removeDraggable =
	      /*removeDraggable*/
	      ctx[8];
	      if (dirty &
	      /*containerWidth*/
	      4) container_changes.containerWidth =
	      /*containerWidth*/
	      ctx[2];
	      if (dirty &
	      /*scale*/
	      8) container_changes.scale =
	      /*scale*/
	      ctx[3];
	      if (dirty &
	      /*breakpoint*/
	      1024) container_changes.breakpoint =
	      /*breakpoint*/
	      ctx[10];
	      if (dirty &
	      /*darkMode*/
	      2048) container_changes.darkMode =
	      /*darkMode*/
	      ctx[11];
	      if (dirty &
	      /*customTypes*/
	      4096) container_changes.customTypes =
	      /*customTypes*/
	      ctx[12];
	      container.$set(container_changes);
	    },
	    i: function i(local) {
	      if (current) return;
	      transition_in(container.$$.fragment, local);
	      current = true;
	    },
	    o: function o(local) {
	      transition_out(container.$$.fragment, local);
	      current = false;
	    },
	    d: function d(detaching) {
	      if (detaching) detach(first);
	      destroy_component(container, detaching);
	    }
	  };
	}

	function create_fragment$f(ctx) {
	  var div;
	  var each_blocks = [];
	  var each_1_lookup = new Map();
	  var current;
	  var each_value =
	  /*items*/
	  ctx[4];

	  var get_key = function get_key(ctx) {
	    return (
	      /*draggable*/
	      ctx[13].id
	    );
	  };

	  for (var i = 0; i < each_value.length; i += 1) {
	    var child_ctx = get_each_context$6(ctx, each_value, i);
	    var key = get_key(child_ctx);
	    each_1_lookup.set(key, each_blocks[i] = create_each_block$6(key, child_ctx));
	  }

	  return {
	    c: function c() {
	      div = element("div");

	      for (var _i = 0; _i < each_blocks.length; _i += 1) {
	        each_blocks[_i].c();
	      }

	      attr(div, "class", "group svelte-5gc1hn");
	    },
	    m: function m(target, anchor) {
	      insert(target, div, anchor);

	      for (var _i2 = 0; _i2 < each_blocks.length; _i2 += 1) {
	        each_blocks[_i2].m(div, null);
	      }

	      current = true;
	    },
	    p: function p(ctx, _ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	          dirty = _ref2[0];

	      if (dirty &
	      /*items, isEditor, editor, options, onChange, addDraggable, updateDraggable, removeDraggable, containerWidth, scale, breakpoint, darkMode, customTypes*/
	      8191) {
	        each_value =
	        /*items*/
	        ctx[4];
	        group_outros();
	        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block$6, null, get_each_context$6);
	        check_outros();
	      }
	    },
	    i: function i(local) {
	      if (current) return;

	      for (var _i3 = 0; _i3 < each_value.length; _i3 += 1) {
	        transition_in(each_blocks[_i3]);
	      }

	      current = true;
	    },
	    o: function o(local) {
	      for (var _i4 = 0; _i4 < each_blocks.length; _i4 += 1) {
	        transition_out(each_blocks[_i4]);
	      }

	      current = false;
	    },
	    d: function d(detaching) {
	      if (detaching) detach(div);

	      for (var _i5 = 0; _i5 < each_blocks.length; _i5 += 1) {
	        each_blocks[_i5].d();
	      }
	    }
	  };
	}

	function instance$f($$self, $$props, $$invalidate) {
	  var _$$props$isEditor = $$props.isEditor,
	      isEditor = _$$props$isEditor === void 0 ? false : _$$props$isEditor;
	  var editor = $$props.editor;
	  var _$$props$containerWid = $$props.containerWidth,
	      containerWidth = _$$props$containerWid === void 0 ? 900 : _$$props$containerWid;
	  var scale = $$props.scale;
	  var items = $$props.items;
	  var options = $$props.options;
	  var onChange = $$props.onChange;
	  var updateDraggable = $$props.updateDraggable;
	  var removeDraggable = $$props.removeDraggable;
	  var addDraggable = $$props.addDraggable;
	  var breakpoint = $$props.breakpoint;
	  var darkMode = $$props.darkMode;
	  var customTypes = $$props.customTypes;

	  $$self.$$set = function ($$props) {
	    if ('isEditor' in $$props) $$invalidate(0, isEditor = $$props.isEditor);
	    if ('editor' in $$props) $$invalidate(1, editor = $$props.editor);
	    if ('containerWidth' in $$props) $$invalidate(2, containerWidth = $$props.containerWidth);
	    if ('scale' in $$props) $$invalidate(3, scale = $$props.scale);
	    if ('items' in $$props) $$invalidate(4, items = $$props.items);
	    if ('options' in $$props) $$invalidate(5, options = $$props.options);
	    if ('onChange' in $$props) $$invalidate(6, onChange = $$props.onChange);
	    if ('updateDraggable' in $$props) $$invalidate(7, updateDraggable = $$props.updateDraggable);
	    if ('removeDraggable' in $$props) $$invalidate(8, removeDraggable = $$props.removeDraggable);
	    if ('addDraggable' in $$props) $$invalidate(9, addDraggable = $$props.addDraggable);
	    if ('breakpoint' in $$props) $$invalidate(10, breakpoint = $$props.breakpoint);
	    if ('darkMode' in $$props) $$invalidate(11, darkMode = $$props.darkMode);
	    if ('customTypes' in $$props) $$invalidate(12, customTypes = $$props.customTypes);
	  };

	  return [isEditor, editor, containerWidth, scale, items, options, onChange, updateDraggable, removeDraggable, addDraggable, breakpoint, darkMode, customTypes];
	}

	var Group = /*#__PURE__*/function (_SvelteComponent) {
	  _inherits(Group, _SvelteComponent);

	  var _super = _createSuper(Group);

	  function Group(options) {
	    var _this;

	    _classCallCheck(this, Group);

	    _this = _super.call(this);
	    init(_assertThisInitialized(_this), options, instance$f, create_fragment$f, safe_not_equal, {
	      isEditor: 0,
	      editor: 1,
	      containerWidth: 2,
	      scale: 3,
	      items: 4,
	      options: 5,
	      onChange: 6,
	      updateDraggable: 7,
	      removeDraggable: 8,
	      addDraggable: 9,
	      breakpoint: 10,
	      darkMode: 11,
	      customTypes: 12
	    }, add_css$e);
	    return _this;
	  }

	  _createClass(Group, [{
	    key: "isEditor",
	    get: function get() {
	      return this.$$.ctx[0];
	    },
	    set: function set(isEditor) {
	      this.$$set({
	        isEditor: isEditor
	      });
	      flush();
	    }
	  }, {
	    key: "editor",
	    get: function get() {
	      return this.$$.ctx[1];
	    },
	    set: function set(editor) {
	      this.$$set({
	        editor: editor
	      });
	      flush();
	    }
	  }, {
	    key: "containerWidth",
	    get: function get() {
	      return this.$$.ctx[2];
	    },
	    set: function set(containerWidth) {
	      this.$$set({
	        containerWidth: containerWidth
	      });
	      flush();
	    }
	  }, {
	    key: "scale",
	    get: function get() {
	      return this.$$.ctx[3];
	    },
	    set: function set(scale) {
	      this.$$set({
	        scale: scale
	      });
	      flush();
	    }
	  }, {
	    key: "items",
	    get: function get() {
	      return this.$$.ctx[4];
	    },
	    set: function set(items) {
	      this.$$set({
	        items: items
	      });
	      flush();
	    }
	  }, {
	    key: "options",
	    get: function get() {
	      return this.$$.ctx[5];
	    },
	    set: function set(options) {
	      this.$$set({
	        options: options
	      });
	      flush();
	    }
	  }, {
	    key: "onChange",
	    get: function get() {
	      return this.$$.ctx[6];
	    },
	    set: function set(onChange) {
	      this.$$set({
	        onChange: onChange
	      });
	      flush();
	    }
	  }, {
	    key: "updateDraggable",
	    get: function get() {
	      return this.$$.ctx[7];
	    },
	    set: function set(updateDraggable) {
	      this.$$set({
	        updateDraggable: updateDraggable
	      });
	      flush();
	    }
	  }, {
	    key: "removeDraggable",
	    get: function get() {
	      return this.$$.ctx[8];
	    },
	    set: function set(removeDraggable) {
	      this.$$set({
	        removeDraggable: removeDraggable
	      });
	      flush();
	    }
	  }, {
	    key: "addDraggable",
	    get: function get() {
	      return this.$$.ctx[9];
	    },
	    set: function set(addDraggable) {
	      this.$$set({
	        addDraggable: addDraggable
	      });
	      flush();
	    }
	  }, {
	    key: "breakpoint",
	    get: function get() {
	      return this.$$.ctx[10];
	    },
	    set: function set(breakpoint) {
	      this.$$set({
	        breakpoint: breakpoint
	      });
	      flush();
	    }
	  }, {
	    key: "darkMode",
	    get: function get() {
	      return this.$$.ctx[11];
	    },
	    set: function set(darkMode) {
	      this.$$set({
	        darkMode: darkMode
	      });
	      flush();
	    }
	  }, {
	    key: "customTypes",
	    get: function get() {
	      return this.$$.ctx[12];
	    },
	    set: function set(customTypes) {
	      this.$$set({
	        customTypes: customTypes
	      });
	      flush();
	    }
	  }]);

	  return Group;
	}(SvelteComponent);

	function add_css$d(target) {
	  append_styles(target, "svelte-180h7p4", ".draggable{z-index:1;position:absolute;color:black;font-family:\"BWHaasDingbat\", \"BWHaasText\", \"Helvetica Neue\", Helvetica,\n      Arial, sans-serif;font-size:14px;line-height:1.2;pointer-events:none}.draggable.dark{color:white}.draggable.editor{pointer-events:all}.draggable.editing{z-index:100}.draggable a{color:black}.draggable.dark a{color:white}.draggable strong{text-transform:uppercase;font-weight:800;letter-spacing:1.5px}.draggable em{color:#777777;font-size:12px}.draggable small{font-size:10px}.draggable h1,.draggable h2,.draggable h3,.draggable h4,.draggable h5,.draggable h6{margin:0;color:inherit}.draggable h1{display:inline-block;font-size:32px}.draggable h2{display:inline-block;font-size:26px;line-height:25px}.draggable h3{display:inline-block;font-size:22px;font-size:22px}.draggable h4{display:inline-block;font-size:18px}.draggable h5{display:inline-block;font-size:16px}.draggable h6{display:inline-block;font-size:16px;font-weight:normal}.draggable table{width:100%;border:none;font-size:14px;border-collapse:collapse}.draggable table.noline{border-collapse:unset}.draggable tr{border:solid;border-width:1px 0}.draggable tr:first-child{border-top:none}.draggable tr:last-child{border-bottom:none}.draggable table td{border:none;padding:4px 0}.draggable table.noline td{padding:1px 0}.draggable td:last-child{text-align:right}.draggable table.lastValueBold td:last-child{font-weight:bold}.draggable.outline{outline-style:none}.draggable.outline > * > .text:not(.icon){text-shadow:-1px -1px 1px #ffffff,-1px -0.5px 1px #ffffff,-1px 0px 1px #ffffff,-1px 0.5px 1px #ffffff,-1px 1px 1px #ffffff,-0.5px -1px 1px #ffffff,-0.5px -0.5px 1px #ffffff,-0.5px 0px 1px #ffffff,-0.5px 0.5px 1px #ffffff,-0.5px 1px 1px #ffffff,0px -0.5px 1px #ffffff,0px -0.5px 1px #ffffff,0px 1px 1px #ffffff,0px 1px 1px #ffffff,0.5px -1px 1px #ffffff,0.5px -0.5px 1px #ffffff,0.5px 0px 1px #ffffff,0.5px 0.5px 1px #ffffff,0.5px 1px 1px #ffffff,1px -1px 1px #ffffff,1px -0.5px 1px #ffffff,1px 0px 1px #ffffff,1px 0.5px 1px #ffffff,1px 1px 1px #ffffff}.draggable.outline.dark > * > .text:not(.icon){text-shadow:-1px -1px 1px #000000,-1px -0.5px 1px #000000,-1px 0px 1px #000000,-1px 0.5px 1px #000000,-1px 1px 1px #000000,-0.5px -1px 1px #000000,-0.5px -0.5px 1px #000000,-0.5px 0px 1px #000000,-0.5px 0.5px 1px #000000,-0.5px 1px 1px #000000,0px -0.5px 1px #000000,0px -0.5px 1px #000000,0px 1px 1px #000000,0px 1px 1px #000000,0.5px -1px 1px #000000,0.5px -0.5px 1px #000000,0.5px 0px 1px #000000,0.5px 0.5px 1px #000000,0.5px 1px 1px #000000,1px -1px 1px #000000,1px -0.5px 1px #000000,1px 0px 1px #000000,1px 0.5px 1px #000000,1px 1px 1px #000000}.draggable.outline .text.icon{text-shadow:none}.draggable.infoBox .text{background:white;padding:7px;border:1px solid black}.draggable.infoBox.dark .text{background:black;border-color:white}.draggable svg.line path, .draggable svg.arrow path, .draggable #arrowhead{stroke:black;fill:none}.draggable.dark svg.line path, .draggable.dark svg.arrow path, .draggable.dark #arrowhead{stroke:white}.draggable button, .draggable-editor button{display:inline-block;border-color:black;cursor:pointer;background:white}.draggable.dark button, .draggable-editor.dark button{border-color:white;background:black}.draggable button:hover, .draggable-editor button{background:black;color:white}.draggable.dark button:hover, .draggable-editor.dark button{background:white;color:black}.draggable.hidden svg, .draggable.hidden div{display:none}.draggable div, .draggable button, .draggable textarea{font-family:\"BWHaasDingbat\", \"BWHaasText\", \"Helvetica Neue\", Helvetica,\n      Arial, sans-serif}.draggable.editor{cursor:move}.draggable.editor.editorActive{cursor:default}.draggable.editor.hoverActive .text, .draggable.editor.hoverActive svg{border:1px dashed #3a73ff}.draggable.editor.hidden{min-width:12px;min-height:12px;background:rgba(255, 183, 0, 0.18);border:1px solid #ffb700}.draggable.editor.hidden:hover{background:#ffb700}.draggable.mobile{font-size:12px}.draggable.mobile em{font-size:14px}.draggable.mobile small{font-size:11px}.draggable.mobile h1{font-size:26px}.draggable.mobile h2{font-size:22px}.draggable.mobile h3{font-size:18px}.draggable.mobile h4{font-size:16px}.draggable.mobile h5{font-size:14px}.draggable.mobile h6{font-size:14px}.draggable.mobile table{font-size:12px}.svg-icon svg{width:100%;height:100%}");
	}

	function get_each_context$5(ctx, list, i) {
	  var child_ctx = ctx.slice();
	  child_ctx[21] = list[i];
	  return child_ctx;
	} // (388:2) {:else}


	function create_else_block$3(ctx) {
	  var container;
	  var current;
	  container = new Container({
	    props: {
	      draggable:
	      /*draggable*/
	      ctx[21],
	      isEditor:
	      /*isEditor*/
	      ctx[1],
	      editor:
	      /*editor*/
	      ctx[2],
	      updateDraggable:
	      /*updateDraggable*/
	      ctx[11],
	      finalizeDraggable:
	      /*finalizeDraggable*/
	      ctx[12],
	      removeDraggable:
	      /*removeDraggable*/
	      ctx[9],
	      onShowEditor:
	      /*onShowEditor*/
	      ctx[5],
	      onHideEditor:
	      /*onHideEditor*/
	      ctx[6],
	      containerWidth:
	      /*containerWidth*/
	      ctx[3],
	      scale:
	      /*scale*/
	      ctx[4],
	      breakpoint:
	      /*breakpoint*/
	      ctx[10],
	      darkMode:
	      /*darkMode*/
	      ctx[7],
	      customTypes:
	      /*customTypes*/
	      ctx[8]
	    }
	  });
	  return {
	    c: function c() {
	      create_component(container.$$.fragment);
	    },
	    m: function m(target, anchor) {
	      mount_component(container, target, anchor);
	      current = true;
	    },
	    p: function p(ctx, dirty) {
	      var container_changes = {};
	      if (dirty &
	      /*items*/
	      1) container_changes.draggable =
	      /*draggable*/
	      ctx[21];
	      if (dirty &
	      /*isEditor*/
	      2) container_changes.isEditor =
	      /*isEditor*/
	      ctx[1];
	      if (dirty &
	      /*editor*/
	      4) container_changes.editor =
	      /*editor*/
	      ctx[2];
	      if (dirty &
	      /*onShowEditor*/
	      32) container_changes.onShowEditor =
	      /*onShowEditor*/
	      ctx[5];
	      if (dirty &
	      /*onHideEditor*/
	      64) container_changes.onHideEditor =
	      /*onHideEditor*/
	      ctx[6];
	      if (dirty &
	      /*containerWidth*/
	      8) container_changes.containerWidth =
	      /*containerWidth*/
	      ctx[3];
	      if (dirty &
	      /*scale*/
	      16) container_changes.scale =
	      /*scale*/
	      ctx[4];
	      if (dirty &
	      /*breakpoint*/
	      1024) container_changes.breakpoint =
	      /*breakpoint*/
	      ctx[10];
	      if (dirty &
	      /*darkMode*/
	      128) container_changes.darkMode =
	      /*darkMode*/
	      ctx[7];
	      if (dirty &
	      /*customTypes*/
	      256) container_changes.customTypes =
	      /*customTypes*/
	      ctx[8];
	      container.$set(container_changes);
	    },
	    i: function i(local) {
	      if (current) return;
	      transition_in(container.$$.fragment, local);
	      current = true;
	    },
	    o: function o(local) {
	      transition_out(container.$$.fragment, local);
	      current = false;
	    },
	    d: function d(detaching) {
	      destroy_component(container, detaching);
	    }
	  };
	} // (374:2) {#if draggable.type === 'group'}


	function create_if_block$8(ctx) {
	  var group;
	  var current;
	  group = new Group({
	    props: {
	      draggable:
	      /*draggable*/
	      ctx[21],
	      isEditor:
	      /*isEditor*/
	      ctx[1],
	      editor:
	      /*editor*/
	      ctx[2],
	      updateDraggable:
	      /*updateDraggable*/
	      ctx[11],
	      finalizeDraggable:
	      /*finalizeDraggable*/
	      ctx[12],
	      removeDraggable:
	      /*removeDraggable*/
	      ctx[9],
	      containerWidth:
	      /*containerWidth*/
	      ctx[3],
	      scale:
	      /*scale*/
	      ctx[4],
	      breakpoint:
	      /*breakpoint*/
	      ctx[10],
	      darkMode:
	      /*darkMode*/
	      ctx[7],
	      customTypes:
	      /*customTypes*/
	      ctx[8]
	    }
	  });
	  return {
	    c: function c() {
	      create_component(group.$$.fragment);
	    },
	    m: function m(target, anchor) {
	      mount_component(group, target, anchor);
	      current = true;
	    },
	    p: function p(ctx, dirty) {
	      var group_changes = {};
	      if (dirty &
	      /*items*/
	      1) group_changes.draggable =
	      /*draggable*/
	      ctx[21];
	      if (dirty &
	      /*isEditor*/
	      2) group_changes.isEditor =
	      /*isEditor*/
	      ctx[1];
	      if (dirty &
	      /*editor*/
	      4) group_changes.editor =
	      /*editor*/
	      ctx[2];
	      if (dirty &
	      /*containerWidth*/
	      8) group_changes.containerWidth =
	      /*containerWidth*/
	      ctx[3];
	      if (dirty &
	      /*scale*/
	      16) group_changes.scale =
	      /*scale*/
	      ctx[4];
	      if (dirty &
	      /*breakpoint*/
	      1024) group_changes.breakpoint =
	      /*breakpoint*/
	      ctx[10];
	      if (dirty &
	      /*darkMode*/
	      128) group_changes.darkMode =
	      /*darkMode*/
	      ctx[7];
	      if (dirty &
	      /*customTypes*/
	      256) group_changes.customTypes =
	      /*customTypes*/
	      ctx[8];
	      group.$set(group_changes);
	    },
	    i: function i(local) {
	      if (current) return;
	      transition_in(group.$$.fragment, local);
	      current = true;
	    },
	    o: function o(local) {
	      transition_out(group.$$.fragment, local);
	      current = false;
	    },
	    d: function d(detaching) {
	      destroy_component(group, detaching);
	    }
	  };
	} // (373:0) {#each items as draggable (draggable.id)}


	function create_each_block$5(key_1, ctx) {
	  var first;
	  var current_block_type_index;
	  var if_block;
	  var if_block_anchor;
	  var current;
	  var if_block_creators = [create_if_block$8, create_else_block$3];
	  var if_blocks = [];

	  function select_block_type(ctx, dirty) {
	    if (
	    /*draggable*/
	    ctx[21].type === 'group') return 0;
	    return 1;
	  }

	  current_block_type_index = select_block_type(ctx);
	  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	  return {
	    key: key_1,
	    first: null,
	    c: function c() {
	      first = empty();
	      if_block.c();
	      if_block_anchor = empty();
	      this.first = first;
	    },
	    m: function m(target, anchor) {
	      insert(target, first, anchor);
	      if_blocks[current_block_type_index].m(target, anchor);
	      insert(target, if_block_anchor, anchor);
	      current = true;
	    },
	    p: function p(new_ctx, dirty) {
	      ctx = new_ctx;
	      var previous_block_index = current_block_type_index;
	      current_block_type_index = select_block_type(ctx);

	      if (current_block_type_index === previous_block_index) {
	        if_blocks[current_block_type_index].p(ctx, dirty);
	      } else {
	        group_outros();
	        transition_out(if_blocks[previous_block_index], 1, 1, function () {
	          if_blocks[previous_block_index] = null;
	        });
	        check_outros();
	        if_block = if_blocks[current_block_type_index];

	        if (!if_block) {
	          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	          if_block.c();
	        } else {
	          if_block.p(ctx, dirty);
	        }

	        transition_in(if_block, 1);
	        if_block.m(if_block_anchor.parentNode, if_block_anchor);
	      }
	    },
	    i: function i(local) {
	      if (current) return;
	      transition_in(if_block);
	      current = true;
	    },
	    o: function o(local) {
	      transition_out(if_block);
	      current = false;
	    },
	    d: function d(detaching) {
	      if (detaching) detach(first);
	      if_blocks[current_block_type_index].d(detaching);
	      if (detaching) detach(if_block_anchor);
	    }
	  };
	}

	function create_fragment$e(ctx) {
	  var each_blocks = [];
	  var each_1_lookup = new Map();
	  var each_1_anchor;
	  var current;
	  var each_value =
	  /*items*/
	  ctx[0];

	  var get_key = function get_key(ctx) {
	    return (
	      /*draggable*/
	      ctx[21].id
	    );
	  };

	  for (var i = 0; i < each_value.length; i += 1) {
	    var child_ctx = get_each_context$5(ctx, each_value, i);
	    var key = get_key(child_ctx);
	    each_1_lookup.set(key, each_blocks[i] = create_each_block$5(key, child_ctx));
	  }

	  return {
	    c: function c() {
	      for (var _i = 0; _i < each_blocks.length; _i += 1) {
	        each_blocks[_i].c();
	      }

	      each_1_anchor = empty();
	    },
	    m: function m(target, anchor) {
	      for (var _i2 = 0; _i2 < each_blocks.length; _i2 += 1) {
	        each_blocks[_i2].m(target, anchor);
	      }

	      insert(target, each_1_anchor, anchor);
	      current = true;
	    },
	    p: function p(ctx, _ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	          dirty = _ref2[0];

	      if (dirty &
	      /*items, isEditor, editor, updateDraggable, finalizeDraggable, removeDraggable, containerWidth, scale, breakpoint, darkMode, customTypes, onShowEditor, onHideEditor*/
	      8191) {
	        each_value =
	        /*items*/
	        ctx[0];
	        group_outros();
	        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block$5, each_1_anchor, get_each_context$5);
	        check_outros();
	      }
	    },
	    i: function i(local) {
	      if (current) return;

	      for (var _i3 = 0; _i3 < each_value.length; _i3 += 1) {
	        transition_in(each_blocks[_i3]);
	      }

	      current = true;
	    },
	    o: function o(local) {
	      for (var _i4 = 0; _i4 < each_blocks.length; _i4 += 1) {
	        transition_out(each_blocks[_i4]);
	      }

	      current = false;
	    },
	    d: function d(detaching) {
	      for (var _i5 = 0; _i5 < each_blocks.length; _i5 += 1) {
	        each_blocks[_i5].d(detaching);
	      }

	      if (detaching) detach(each_1_anchor);
	    }
	  };
	}

	function instance$e($$self, $$props, $$invalidate) {
	  var _$$props$isEditor = $$props.isEditor,
	      isEditor = _$$props$isEditor === void 0 ? false : _$$props$isEditor;
	  var editor = $$props.editor;
	  var _$$props$containerWid = $$props.containerWidth,
	      containerWidth = _$$props$containerWid === void 0 ? 900 : _$$props$containerWid;
	  var scale = $$props.scale;
	  var items = $$props.items;
	  var options = $$props.options;
	  var onChange = $$props.onChange;
	  var onChangeComplete = $$props.onChangeComplete;
	  var onShowEditor = $$props.onShowEditor;
	  var onHideEditor = $$props.onHideEditor;
	  var darkMode = $$props.darkMode;
	  var customTypes = $$props.customTypes;
	  var breakpoint;
	  setContext('isEditor', isEditor); // if we are within a breakpoint that isn't "default", we assign any property
	  // changes to the breakpoint itself rather than on the object

	  function updateDraggable(id, props) {
	    var index = items.map(function (a) {
	      return a.id;
	    }).indexOf(id);

	    if (index != null && items[index]) {
	      if (breakpoint) {
	        if (!items[index].breakpoints) {
	          $$invalidate(0, items[index].breakpoints = {}, items);
	        }

	        if (!items[index].breakpoints[breakpoint.name]) {
	          $$invalidate(0, items[index].breakpoints[breakpoint.name] = {}, items);
	        }

	        Object.keys(props).forEach(function (key) {
	          $$invalidate(0, items[index].breakpoints[breakpoint.name][key] = props[key], items);
	        });
	      } else {
	        Object.keys(props).forEach(function (key) {
	          $$invalidate(0, items[index][key] = props[key], items);
	        });
	      }
	    }

	    onChange({
	      id: id,
	      props: props
	    });
	  }

	  function emptyDraggable(id) {
	    var index = items.map(function (a) {
	      return a.id;
	    }).indexOf(id);

	    if (index != null && items[index]) {
	      if (breakpoint) {
	        $$invalidate(0, items[index].breakpoints = {
	          id: id
	        }, items);
	      } else {
	        $$invalidate(0, items[index] = {
	          id: id
	        }, items);
	      }
	    }
	  }

	  function finalizeDraggable(id, props) {
	    setTimeout(function () {
	      onChangeComplete({
	        id: id,
	        props: props
	      });
	    }, 1);
	  }

	  function removeDraggable(id) {
	    var updatedDraggables = items.filter(function (row) {
	      return row.id !== id;
	    });
	    onChange({
	      remove: id
	    });
	    $$invalidate(0, items = []); // clear the drawing then update

	    setTimeout(function () {
	      $$invalidate(0, items = updatedDraggables);
	    }, 1);
	  }

	  function addDraggable(draggable) {
	    $$invalidate(0, items = items.concat(draggable));
	    onChange({
	      add: draggable
	    });
	  }

	  function updateOptions($options) {
	    Object.keys($options).forEach(function (key) {
	      $$invalidate(13, options[key] = $options[key], options);
	    });
	    onChange({
	      options: $options
	    });
	  }

	  function moveDraggable(id, x, y) {
	    updateDraggable(id, {
	      x: x,
	      y: y
	    });
	  }

	  function modifyDraggable(id, props) {
	    updateDraggable(id, props);
	  }

	  $$self.$$set = function ($$props) {
	    if ('isEditor' in $$props) $$invalidate(1, isEditor = $$props.isEditor);
	    if ('editor' in $$props) $$invalidate(2, editor = $$props.editor);
	    if ('containerWidth' in $$props) $$invalidate(3, containerWidth = $$props.containerWidth);
	    if ('scale' in $$props) $$invalidate(4, scale = $$props.scale);
	    if ('items' in $$props) $$invalidate(0, items = $$props.items);
	    if ('options' in $$props) $$invalidate(13, options = $$props.options);
	    if ('onChange' in $$props) $$invalidate(14, onChange = $$props.onChange);
	    if ('onChangeComplete' in $$props) $$invalidate(15, onChangeComplete = $$props.onChangeComplete);
	    if ('onShowEditor' in $$props) $$invalidate(5, onShowEditor = $$props.onShowEditor);
	    if ('onHideEditor' in $$props) $$invalidate(6, onHideEditor = $$props.onHideEditor);
	    if ('darkMode' in $$props) $$invalidate(7, darkMode = $$props.darkMode);
	    if ('customTypes' in $$props) $$invalidate(8, customTypes = $$props.customTypes);
	  };

	  $$self.$$.update = function () {
	    if ($$self.$$.dirty &
	    /*containerWidth, options*/
	    8200) {
	      $$invalidate(10, breakpoint = getBreakpoint(containerWidth, options.breakpoints));
	    }
	  };

	  return [items, isEditor, editor, containerWidth, scale, onShowEditor, onHideEditor, darkMode, customTypes, removeDraggable, breakpoint, updateDraggable, finalizeDraggable, options, onChange, onChangeComplete, emptyDraggable, addDraggable, updateOptions, moveDraggable, modifyDraggable];
	}

	var Draggables = /*#__PURE__*/function (_SvelteComponent) {
	  _inherits(Draggables, _SvelteComponent);

	  var _super = _createSuper(Draggables);

	  function Draggables(options) {
	    var _this;

	    _classCallCheck(this, Draggables);

	    _this = _super.call(this);
	    init(_assertThisInitialized(_this), options, instance$e, create_fragment$e, safe_not_equal, {
	      isEditor: 1,
	      editor: 2,
	      containerWidth: 3,
	      scale: 4,
	      items: 0,
	      options: 13,
	      onChange: 14,
	      onChangeComplete: 15,
	      onShowEditor: 5,
	      onHideEditor: 6,
	      darkMode: 7,
	      customTypes: 8,
	      emptyDraggable: 16,
	      removeDraggable: 9,
	      addDraggable: 17,
	      updateOptions: 18,
	      moveDraggable: 19,
	      modifyDraggable: 20
	    }, add_css$d);
	    return _this;
	  }

	  _createClass(Draggables, [{
	    key: "isEditor",
	    get: function get() {
	      return this.$$.ctx[1];
	    },
	    set: function set(isEditor) {
	      this.$$set({
	        isEditor: isEditor
	      });
	      flush();
	    }
	  }, {
	    key: "editor",
	    get: function get() {
	      return this.$$.ctx[2];
	    },
	    set: function set(editor) {
	      this.$$set({
	        editor: editor
	      });
	      flush();
	    }
	  }, {
	    key: "containerWidth",
	    get: function get() {
	      return this.$$.ctx[3];
	    },
	    set: function set(containerWidth) {
	      this.$$set({
	        containerWidth: containerWidth
	      });
	      flush();
	    }
	  }, {
	    key: "scale",
	    get: function get() {
	      return this.$$.ctx[4];
	    },
	    set: function set(scale) {
	      this.$$set({
	        scale: scale
	      });
	      flush();
	    }
	  }, {
	    key: "items",
	    get: function get() {
	      return this.$$.ctx[0];
	    },
	    set: function set(items) {
	      this.$$set({
	        items: items
	      });
	      flush();
	    }
	  }, {
	    key: "options",
	    get: function get() {
	      return this.$$.ctx[13];
	    },
	    set: function set(options) {
	      this.$$set({
	        options: options
	      });
	      flush();
	    }
	  }, {
	    key: "onChange",
	    get: function get() {
	      return this.$$.ctx[14];
	    },
	    set: function set(onChange) {
	      this.$$set({
	        onChange: onChange
	      });
	      flush();
	    }
	  }, {
	    key: "onChangeComplete",
	    get: function get() {
	      return this.$$.ctx[15];
	    },
	    set: function set(onChangeComplete) {
	      this.$$set({
	        onChangeComplete: onChangeComplete
	      });
	      flush();
	    }
	  }, {
	    key: "onShowEditor",
	    get: function get() {
	      return this.$$.ctx[5];
	    },
	    set: function set(onShowEditor) {
	      this.$$set({
	        onShowEditor: onShowEditor
	      });
	      flush();
	    }
	  }, {
	    key: "onHideEditor",
	    get: function get() {
	      return this.$$.ctx[6];
	    },
	    set: function set(onHideEditor) {
	      this.$$set({
	        onHideEditor: onHideEditor
	      });
	      flush();
	    }
	  }, {
	    key: "darkMode",
	    get: function get() {
	      return this.$$.ctx[7];
	    },
	    set: function set(darkMode) {
	      this.$$set({
	        darkMode: darkMode
	      });
	      flush();
	    }
	  }, {
	    key: "customTypes",
	    get: function get() {
	      return this.$$.ctx[8];
	    },
	    set: function set(customTypes) {
	      this.$$set({
	        customTypes: customTypes
	      });
	      flush();
	    }
	  }, {
	    key: "emptyDraggable",
	    get: function get() {
	      return this.$$.ctx[16];
	    }
	  }, {
	    key: "removeDraggable",
	    get: function get() {
	      return this.$$.ctx[9];
	    }
	  }, {
	    key: "addDraggable",
	    get: function get() {
	      return this.$$.ctx[17];
	    }
	  }, {
	    key: "updateOptions",
	    get: function get() {
	      return this.$$.ctx[18];
	    }
	  }, {
	    key: "moveDraggable",
	    get: function get() {
	      return this.$$.ctx[19];
	    }
	  }, {
	    key: "modifyDraggable",
	    get: function get() {
	      return this.$$.ctx[20];
	    }
	  }]);

	  return Draggables;
	}(SvelteComponent);

	var nativeGetOwnPropertyNames$1 = objectGetOwnPropertyNames.f;

	var toString = {}.toString;

	var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
	  ? Object.getOwnPropertyNames(window) : [];

	var getWindowNames = function (it) {
	  try {
	    return nativeGetOwnPropertyNames$1(it);
	  } catch (error) {
	    return windowNames.slice();
	  }
	};

	// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
	var f$1 = function getOwnPropertyNames(it) {
	  return windowNames && toString.call(it) == '[object Window]'
	    ? getWindowNames(it)
	    : nativeGetOwnPropertyNames$1(toIndexedObject(it));
	};

	var objectGetOwnPropertyNamesExternal = {
		f: f$1
	};

	var f = wellKnownSymbol;

	var wellKnownSymbolWrapped = {
		f: f
	};

	var defineProperty$1 = objectDefineProperty.f;

	var defineWellKnownSymbol = function (NAME) {
	  var Symbol = path$1.Symbol || (path$1.Symbol = {});
	  if (!has$1(Symbol, NAME)) defineProperty$1(Symbol, NAME, {
	    value: wellKnownSymbolWrapped.f(NAME)
	  });
	};

	var $forEach = arrayIteration.forEach;

	var HIDDEN = sharedKey('hidden');
	var SYMBOL = 'Symbol';
	var PROTOTYPE = 'prototype';
	var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');
	var setInternalState = internalState.set;
	var getInternalState = internalState.getterFor(SYMBOL);
	var ObjectPrototype = Object[PROTOTYPE];
	var $Symbol = global_1.Symbol;
	var $stringify = getBuiltIn('JSON', 'stringify');
	var nativeGetOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;
	var nativeDefineProperty = objectDefineProperty.f;
	var nativeGetOwnPropertyNames = objectGetOwnPropertyNamesExternal.f;
	var nativePropertyIsEnumerable = objectPropertyIsEnumerable.f;
	var AllSymbols = shared('symbols');
	var ObjectPrototypeSymbols = shared('op-symbols');
	var StringToSymbolRegistry = shared('string-to-symbol-registry');
	var SymbolToStringRegistry = shared('symbol-to-string-registry');
	var WellKnownSymbolsStore = shared('wks');
	var QObject = global_1.QObject;
	// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
	var USE_SETTER = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

	// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
	var setSymbolDescriptor = descriptors && fails(function () {
	  return objectCreate$1(nativeDefineProperty({}, 'a', {
	    get: function () { return nativeDefineProperty(this, 'a', { value: 7 }).a; }
	  })).a != 7;
	}) ? function (O, P, Attributes) {
	  var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor(ObjectPrototype, P);
	  if (ObjectPrototypeDescriptor) delete ObjectPrototype[P];
	  nativeDefineProperty(O, P, Attributes);
	  if (ObjectPrototypeDescriptor && O !== ObjectPrototype) {
	    nativeDefineProperty(ObjectPrototype, P, ObjectPrototypeDescriptor);
	  }
	} : nativeDefineProperty;

	var wrap = function (tag, description) {
	  var symbol = AllSymbols[tag] = objectCreate$1($Symbol[PROTOTYPE]);
	  setInternalState(symbol, {
	    type: SYMBOL,
	    tag: tag,
	    description: description
	  });
	  if (!descriptors) symbol.description = description;
	  return symbol;
	};

	var isSymbol = useSymbolAsUid ? function (it) {
	  return typeof it == 'symbol';
	} : function (it) {
	  return Object(it) instanceof $Symbol;
	};

	var $defineProperty = function defineProperty(O, P, Attributes) {
	  if (O === ObjectPrototype) $defineProperty(ObjectPrototypeSymbols, P, Attributes);
	  anObject(O);
	  var key = toPrimitive(P, true);
	  anObject(Attributes);
	  if (has$1(AllSymbols, key)) {
	    if (!Attributes.enumerable) {
	      if (!has$1(O, HIDDEN)) nativeDefineProperty(O, HIDDEN, createPropertyDescriptor(1, {}));
	      O[HIDDEN][key] = true;
	    } else {
	      if (has$1(O, HIDDEN) && O[HIDDEN][key]) O[HIDDEN][key] = false;
	      Attributes = objectCreate$1(Attributes, { enumerable: createPropertyDescriptor(0, false) });
	    } return setSymbolDescriptor(O, key, Attributes);
	  } return nativeDefineProperty(O, key, Attributes);
	};

	var $defineProperties = function defineProperties(O, Properties) {
	  anObject(O);
	  var properties = toIndexedObject(Properties);
	  var keys = objectKeys(properties).concat($getOwnPropertySymbols(properties));
	  $forEach(keys, function (key) {
	    if (!descriptors || $propertyIsEnumerable.call(properties, key)) $defineProperty(O, key, properties[key]);
	  });
	  return O;
	};

	var $create = function create(O, Properties) {
	  return Properties === undefined ? objectCreate$1(O) : $defineProperties(objectCreate$1(O), Properties);
	};

	var $propertyIsEnumerable = function propertyIsEnumerable(V) {
	  var P = toPrimitive(V, true);
	  var enumerable = nativePropertyIsEnumerable.call(this, P);
	  if (this === ObjectPrototype && has$1(AllSymbols, P) && !has$1(ObjectPrototypeSymbols, P)) return false;
	  return enumerable || !has$1(this, P) || !has$1(AllSymbols, P) || has$1(this, HIDDEN) && this[HIDDEN][P] ? enumerable : true;
	};

	var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(O, P) {
	  var it = toIndexedObject(O);
	  var key = toPrimitive(P, true);
	  if (it === ObjectPrototype && has$1(AllSymbols, key) && !has$1(ObjectPrototypeSymbols, key)) return;
	  var descriptor = nativeGetOwnPropertyDescriptor(it, key);
	  if (descriptor && has$1(AllSymbols, key) && !(has$1(it, HIDDEN) && it[HIDDEN][key])) {
	    descriptor.enumerable = true;
	  }
	  return descriptor;
	};

	var $getOwnPropertyNames = function getOwnPropertyNames(O) {
	  var names = nativeGetOwnPropertyNames(toIndexedObject(O));
	  var result = [];
	  $forEach(names, function (key) {
	    if (!has$1(AllSymbols, key) && !has$1(hiddenKeys$1, key)) result.push(key);
	  });
	  return result;
	};

	var $getOwnPropertySymbols = function getOwnPropertySymbols(O) {
	  var IS_OBJECT_PROTOTYPE = O === ObjectPrototype;
	  var names = nativeGetOwnPropertyNames(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject(O));
	  var result = [];
	  $forEach(names, function (key) {
	    if (has$1(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || has$1(ObjectPrototype, key))) {
	      result.push(AllSymbols[key]);
	    }
	  });
	  return result;
	};

	// `Symbol` constructor
	// https://tc39.github.io/ecma262/#sec-symbol-constructor
	if (!nativeSymbol) {
	  $Symbol = function Symbol() {
	    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor');
	    var description = !arguments.length || arguments[0] === undefined ? undefined : String(arguments[0]);
	    var tag = uid(description);
	    var setter = function (value) {
	      if (this === ObjectPrototype) setter.call(ObjectPrototypeSymbols, value);
	      if (has$1(this, HIDDEN) && has$1(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
	      setSymbolDescriptor(this, tag, createPropertyDescriptor(1, value));
	    };
	    if (descriptors && USE_SETTER) setSymbolDescriptor(ObjectPrototype, tag, { configurable: true, set: setter });
	    return wrap(tag, description);
	  };

	  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
	    return getInternalState(this).tag;
	  });

	  redefine($Symbol, 'withoutSetter', function (description) {
	    return wrap(uid(description), description);
	  });

	  objectPropertyIsEnumerable.f = $propertyIsEnumerable;
	  objectDefineProperty.f = $defineProperty;
	  objectGetOwnPropertyDescriptor.f = $getOwnPropertyDescriptor;
	  objectGetOwnPropertyNames.f = objectGetOwnPropertyNamesExternal.f = $getOwnPropertyNames;
	  objectGetOwnPropertySymbols.f = $getOwnPropertySymbols;

	  wellKnownSymbolWrapped.f = function (name) {
	    return wrap(wellKnownSymbol(name), name);
	  };

	  if (descriptors) {
	    // https://github.com/tc39/proposal-Symbol-description
	    nativeDefineProperty($Symbol[PROTOTYPE], 'description', {
	      configurable: true,
	      get: function description() {
	        return getInternalState(this).description;
	      }
	    });
	    {
	      redefine(ObjectPrototype, 'propertyIsEnumerable', $propertyIsEnumerable, { unsafe: true });
	    }
	  }
	}

	_export({ global: true, wrap: true, forced: !nativeSymbol, sham: !nativeSymbol }, {
	  Symbol: $Symbol
	});

	$forEach(objectKeys(WellKnownSymbolsStore), function (name) {
	  defineWellKnownSymbol(name);
	});

	_export({ target: SYMBOL, stat: true, forced: !nativeSymbol }, {
	  // `Symbol.for` method
	  // https://tc39.github.io/ecma262/#sec-symbol.for
	  'for': function (key) {
	    var string = String(key);
	    if (has$1(StringToSymbolRegistry, string)) return StringToSymbolRegistry[string];
	    var symbol = $Symbol(string);
	    StringToSymbolRegistry[string] = symbol;
	    SymbolToStringRegistry[symbol] = string;
	    return symbol;
	  },
	  // `Symbol.keyFor` method
	  // https://tc39.github.io/ecma262/#sec-symbol.keyfor
	  keyFor: function keyFor(sym) {
	    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol');
	    if (has$1(SymbolToStringRegistry, sym)) return SymbolToStringRegistry[sym];
	  },
	  useSetter: function () { USE_SETTER = true; },
	  useSimple: function () { USE_SETTER = false; }
	});

	_export({ target: 'Object', stat: true, forced: !nativeSymbol, sham: !descriptors }, {
	  // `Object.create` method
	  // https://tc39.github.io/ecma262/#sec-object.create
	  create: $create,
	  // `Object.defineProperty` method
	  // https://tc39.github.io/ecma262/#sec-object.defineproperty
	  defineProperty: $defineProperty,
	  // `Object.defineProperties` method
	  // https://tc39.github.io/ecma262/#sec-object.defineproperties
	  defineProperties: $defineProperties,
	  // `Object.getOwnPropertyDescriptor` method
	  // https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptors
	  getOwnPropertyDescriptor: $getOwnPropertyDescriptor
	});

	_export({ target: 'Object', stat: true, forced: !nativeSymbol }, {
	  // `Object.getOwnPropertyNames` method
	  // https://tc39.github.io/ecma262/#sec-object.getownpropertynames
	  getOwnPropertyNames: $getOwnPropertyNames,
	  // `Object.getOwnPropertySymbols` method
	  // https://tc39.github.io/ecma262/#sec-object.getownpropertysymbols
	  getOwnPropertySymbols: $getOwnPropertySymbols
	});

	// Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives
	// https://bugs.chromium.org/p/v8/issues/detail?id=3443
	_export({ target: 'Object', stat: true, forced: fails(function () { objectGetOwnPropertySymbols.f(1); }) }, {
	  getOwnPropertySymbols: function getOwnPropertySymbols(it) {
	    return objectGetOwnPropertySymbols.f(toObject(it));
	  }
	});

	// `JSON.stringify` method behavior with symbols
	// https://tc39.github.io/ecma262/#sec-json.stringify
	if ($stringify) {
	  var FORCED_JSON_STRINGIFY = !nativeSymbol || fails(function () {
	    var symbol = $Symbol();
	    // MS Edge converts symbol values to JSON as {}
	    return $stringify([symbol]) != '[null]'
	      // WebKit converts symbol values to JSON as null
	      || $stringify({ a: symbol }) != '{}'
	      // V8 throws on boxed symbols
	      || $stringify(Object(symbol)) != '{}';
	  });

	  _export({ target: 'JSON', stat: true, forced: FORCED_JSON_STRINGIFY }, {
	    // eslint-disable-next-line no-unused-vars
	    stringify: function stringify(it, replacer, space) {
	      var args = [it];
	      var index = 1;
	      var $replacer;
	      while (arguments.length > index) args.push(arguments[index++]);
	      $replacer = replacer;
	      if (!isObject$3(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
	      if (!isArray$3(replacer)) replacer = function (key, value) {
	        if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
	        if (!isSymbol(value)) return value;
	      };
	      args[1] = replacer;
	      return $stringify.apply(null, args);
	    }
	  });
	}

	// `Symbol.prototype[@@toPrimitive]` method
	// https://tc39.github.io/ecma262/#sec-symbol.prototype-@@toprimitive
	if (!$Symbol[PROTOTYPE][TO_PRIMITIVE]) {
	  createNonEnumerableProperty($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
	}
	// `Symbol.prototype[@@toStringTag]` property
	// https://tc39.github.io/ecma262/#sec-symbol.prototype-@@tostringtag
	setToStringTag($Symbol, SYMBOL);

	hiddenKeys$1[HIDDEN] = true;

	var defineProperty = objectDefineProperty.f;


	var NativeSymbol = global_1.Symbol;

	if (descriptors && typeof NativeSymbol == 'function' && (!('description' in NativeSymbol.prototype) ||
	  // Safari 12 bug
	  NativeSymbol().description !== undefined
	)) {
	  var EmptyStringDescriptionStore = {};
	  // wrap Symbol constructor for correct work with undefined description
	  var SymbolWrapper = function Symbol() {
	    var description = arguments.length < 1 || arguments[0] === undefined ? undefined : String(arguments[0]);
	    var result = this instanceof SymbolWrapper
	      ? new NativeSymbol(description)
	      // in Edge 13, String(Symbol(undefined)) === 'Symbol(undefined)'
	      : description === undefined ? NativeSymbol() : NativeSymbol(description);
	    if (description === '') EmptyStringDescriptionStore[result] = true;
	    return result;
	  };
	  copyConstructorProperties(SymbolWrapper, NativeSymbol);
	  var symbolPrototype = SymbolWrapper.prototype = NativeSymbol.prototype;
	  symbolPrototype.constructor = SymbolWrapper;

	  var symbolToString = symbolPrototype.toString;
	  var native = String(NativeSymbol('test')) == 'Symbol(test)';
	  var regexp = /^Symbol\((.*)\)[^)]+$/;
	  defineProperty(symbolPrototype, 'description', {
	    configurable: true,
	    get: function description() {
	      var symbol = isObject$3(this) ? this.valueOf() : this;
	      var string = symbolToString.call(symbol);
	      if (has$1(EmptyStringDescriptionStore, symbol)) return '';
	      var desc = native ? string.slice(7, -1) : string.replace(regexp, '$1');
	      return desc === '' ? undefined : desc;
	    }
	  });

	  _export({ global: true, forced: true }, {
	    Symbol: SymbolWrapper
	  });
	}

	function add_css$c(target) {
	  append_styles(target, "svelte-exkzm6", ".button-menu.svelte-exkzm6.svelte-exkzm6{padding-top:8px;display:inline-block;min-height:26px}.button-group.svelte-exkzm6.svelte-exkzm6{display:inline-block}button.svelte-exkzm6.svelte-exkzm6{border:solid 2px transparent;cursor:pointer}button.svelte-exkzm6.svelte-exkzm6:hover,button.active.svelte-exkzm6.svelte-exkzm6{border-color:#001aaa}.button-menu.icon.svelte-exkzm6 button.svelte-exkzm6{padding:0 2px;margin:0 1px;width:23px;height:20px}.button-menu.icon.svelte-exkzm6 .button-group.svelte-exkzm6{transform:translateY(5px)}.button-menu.color.svelte-exkzm6 button.svelte-exkzm6{display:inline-block;width:10px;height:15px;margin:0 1px;transform:translateY(1px)}.button-menu.icon-size.svelte-exkzm6 button.svelte-exkzm6{display:inline-block;color:black}.button-menu.icon-size.svelte-exkzm6 button.svelte-exkzm6:hover,.button-menu.icon-size.svelte-exkzm6 button.active.svelte-exkzm6{border-color:#001aaa}");
	}

	function get_each_context_2$1(ctx, list, i) {
	  var child_ctx = ctx.slice();
	  child_ctx[17] = list[i][0];
	  child_ctx[5] = list[i][1];
	  return child_ctx;
	}

	function get_each_context_1$3(ctx, list, i) {
	  var child_ctx = ctx.slice();
	  child_ctx[14] = list[i];
	  return child_ctx;
	}

	function get_each_context$4(ctx, list, i) {
	  var child_ctx = ctx.slice();
	  child_ctx[11] = list[i];
	  return child_ctx;
	} // (87:4) {:else}


	function create_else_block$2(ctx) {
	  var each_1_anchor;
	  var each_value_2 =
	  /*buttons*/
	  ctx[4];
	  var each_blocks = [];

	  for (var i = 0; i < each_value_2.length; i += 1) {
	    each_blocks[i] = create_each_block_2$1(get_each_context_2$1(ctx, each_value_2, i));
	  }

	  return {
	    c: function c() {
	      for (var _i = 0; _i < each_blocks.length; _i += 1) {
	        each_blocks[_i].c();
	      }

	      each_1_anchor = empty();
	    },
	    m: function m(target, anchor) {
	      for (var _i2 = 0; _i2 < each_blocks.length; _i2 += 1) {
	        each_blocks[_i2].m(target, anchor);
	      }

	      insert(target, each_1_anchor, anchor);
	    },
	    p: function p(ctx, dirty) {
	      if (dirty &
	      /*extraClasses, selected, buttons, select*/
	      83) {
	        each_value_2 =
	        /*buttons*/
	        ctx[4];

	        var _i3;

	        for (_i3 = 0; _i3 < each_value_2.length; _i3 += 1) {
	          var child_ctx = get_each_context_2$1(ctx, each_value_2, _i3);

	          if (each_blocks[_i3]) {
	            each_blocks[_i3].p(child_ctx, dirty);
	          } else {
	            each_blocks[_i3] = create_each_block_2$1(child_ctx);

	            each_blocks[_i3].c();

	            each_blocks[_i3].m(each_1_anchor.parentNode, each_1_anchor);
	          }
	        }

	        for (; _i3 < each_blocks.length; _i3 += 1) {
	          each_blocks[_i3].d(1);
	        }

	        each_blocks.length = each_value_2.length;
	      }
	    },
	    d: function d(detaching) {
	      destroy_each(each_blocks, detaching);
	      if (detaching) detach(each_1_anchor);
	    }
	  };
	} // (80:35) 


	function create_if_block_1$5(ctx) {
	  var each_1_anchor;
	  var each_value_1 =
	  /*buttons*/
	  ctx[4];
	  var each_blocks = [];

	  for (var i = 0; i < each_value_1.length; i += 1) {
	    each_blocks[i] = create_each_block_1$3(get_each_context_1$3(ctx, each_value_1, i));
	  }

	  return {
	    c: function c() {
	      for (var _i4 = 0; _i4 < each_blocks.length; _i4 += 1) {
	        each_blocks[_i4].c();
	      }

	      each_1_anchor = empty();
	    },
	    m: function m(target, anchor) {
	      for (var _i5 = 0; _i5 < each_blocks.length; _i5 += 1) {
	        each_blocks[_i5].m(target, anchor);
	      }

	      insert(target, each_1_anchor, anchor);
	    },
	    p: function p(ctx, dirty) {
	      if (dirty &
	      /*extraClasses, selected, buttons, select, iconDisplay*/
	      91) {
	        each_value_1 =
	        /*buttons*/
	        ctx[4];

	        var _i6;

	        for (_i6 = 0; _i6 < each_value_1.length; _i6 += 1) {
	          var child_ctx = get_each_context_1$3(ctx, each_value_1, _i6);

	          if (each_blocks[_i6]) {
	            each_blocks[_i6].p(child_ctx, dirty);
	          } else {
	            each_blocks[_i6] = create_each_block_1$3(child_ctx);

	            each_blocks[_i6].c();

	            each_blocks[_i6].m(each_1_anchor.parentNode, each_1_anchor);
	          }
	        }

	        for (; _i6 < each_blocks.length; _i6 += 1) {
	          each_blocks[_i6].d(1);
	        }

	        each_blocks.length = each_value_1.length;
	      }
	    },
	    d: function d(detaching) {
	      destroy_each(each_blocks, detaching);
	      if (detaching) detach(each_1_anchor);
	    }
	  };
	} // (73:4) {#if mode === 'color'}


	function create_if_block$7(ctx) {
	  var each_1_anchor;
	  var each_value =
	  /*buttons*/
	  ctx[4];
	  var each_blocks = [];

	  for (var i = 0; i < each_value.length; i += 1) {
	    each_blocks[i] = create_each_block$4(get_each_context$4(ctx, each_value, i));
	  }

	  return {
	    c: function c() {
	      for (var _i7 = 0; _i7 < each_blocks.length; _i7 += 1) {
	        each_blocks[_i7].c();
	      }

	      each_1_anchor = empty();
	    },
	    m: function m(target, anchor) {
	      for (var _i8 = 0; _i8 < each_blocks.length; _i8 += 1) {
	        each_blocks[_i8].m(target, anchor);
	      }

	      insert(target, each_1_anchor, anchor);
	    },
	    p: function p(ctx, dirty) {
	      if (dirty &
	      /*extraClasses, selected, buttons, select*/
	      83) {
	        each_value =
	        /*buttons*/
	        ctx[4];

	        var _i9;

	        for (_i9 = 0; _i9 < each_value.length; _i9 += 1) {
	          var child_ctx = get_each_context$4(ctx, each_value, _i9);

	          if (each_blocks[_i9]) {
	            each_blocks[_i9].p(child_ctx, dirty);
	          } else {
	            each_blocks[_i9] = create_each_block$4(child_ctx);

	            each_blocks[_i9].c();

	            each_blocks[_i9].m(each_1_anchor.parentNode, each_1_anchor);
	          }
	        }

	        for (; _i9 < each_blocks.length; _i9 += 1) {
	          each_blocks[_i9].d(1);
	        }

	        each_blocks.length = each_value.length;
	      }
	    },
	    d: function d(detaching) {
	      destroy_each(each_blocks, detaching);
	      if (detaching) detach(each_1_anchor);
	    }
	  };
	} // (88:6) {#each buttons as [value, label]}


	function create_each_block_2$1(ctx) {
	  var button;
	  var html_tag;
	  var raw_value =
	  /*label*/
	  ctx[5] + "";
	  var t;
	  var button_class_value;
	  var mounted;
	  var dispose;

	  function click_handler_2() {
	    return (
	      /*click_handler_2*/
	      ctx[10](
	      /*value*/
	      ctx[17])
	    );
	  }

	  return {
	    c: function c() {
	      button = element("button");
	      html_tag = new HtmlTag(false);
	      t = space();
	      html_tag.a = t;
	      attr(button, "class", button_class_value = "" + (
	      /*extraClasses*/
	      ctx[1] + " " + (
	      /*selected*/
	      ctx[0] ===
	      /*value*/
	      ctx[17] ? 'active' : '') + " svelte-exkzm6"));
	    },
	    m: function m(target, anchor) {
	      insert(target, button, anchor);
	      html_tag.m(raw_value, button);
	      append(button, t);

	      if (!mounted) {
	        dispose = listen(button, "click", click_handler_2);
	        mounted = true;
	      }
	    },
	    p: function p(new_ctx, dirty) {
	      ctx = new_ctx;
	      if (dirty &
	      /*buttons*/
	      16 && raw_value !== (raw_value =
	      /*label*/
	      ctx[5] + "")) html_tag.p(raw_value);

	      if (dirty &
	      /*extraClasses, selected, buttons*/
	      19 && button_class_value !== (button_class_value = "" + (
	      /*extraClasses*/
	      ctx[1] + " " + (
	      /*selected*/
	      ctx[0] ===
	      /*value*/
	      ctx[17] ? 'active' : '') + " svelte-exkzm6"))) {
	        attr(button, "class", button_class_value);
	      }
	    },
	    d: function d(detaching) {
	      if (detaching) detach(button);
	      mounted = false;
	      dispose();
	    }
	  };
	} // (81:6) {#each buttons as size}


	function create_each_block_1$3(ctx) {
	  var button;
	  var t;
	  var button_class_value;
	  var mounted;
	  var dispose;

	  function click_handler_1() {
	    return (
	      /*click_handler_1*/
	      ctx[9](
	      /*size*/
	      ctx[14])
	    );
	  }

	  return {
	    c: function c() {
	      button = element("button");
	      t = text(
	      /*iconDisplay*/
	      ctx[3]);
	      attr(button, "class", button_class_value = "" + (
	      /*extraClasses*/
	      ctx[1] + " " + (
	      /*selected*/
	      ctx[0] ===
	      /*size*/
	      ctx[14] ? 'active' : '') + " svelte-exkzm6"));
	      set_style(button, "font-size",
	      /*size*/
	      ctx[14] + "px");
	    },
	    m: function m(target, anchor) {
	      insert(target, button, anchor);
	      append(button, t);

	      if (!mounted) {
	        dispose = listen(button, "click", click_handler_1);
	        mounted = true;
	      }
	    },
	    p: function p(new_ctx, dirty) {
	      ctx = new_ctx;
	      if (dirty &
	      /*iconDisplay*/
	      8) set_data(t,
	      /*iconDisplay*/
	      ctx[3]);

	      if (dirty &
	      /*extraClasses, selected, buttons*/
	      19 && button_class_value !== (button_class_value = "" + (
	      /*extraClasses*/
	      ctx[1] + " " + (
	      /*selected*/
	      ctx[0] ===
	      /*size*/
	      ctx[14] ? 'active' : '') + " svelte-exkzm6"))) {
	        attr(button, "class", button_class_value);
	      }

	      if (dirty &
	      /*buttons*/
	      16) {
	        set_style(button, "font-size",
	        /*size*/
	        ctx[14] + "px");
	      }
	    },
	    d: function d(detaching) {
	      if (detaching) detach(button);
	      mounted = false;
	      dispose();
	    }
	  };
	} // (74:6) {#each buttons as color}


	function create_each_block$4(ctx) {
	  var button;
	  var button_class_value;
	  var mounted;
	  var dispose;

	  function click_handler() {
	    return (
	      /*click_handler*/
	      ctx[8](
	      /*color*/
	      ctx[11])
	    );
	  }

	  return {
	    c: function c() {
	      button = element("button");
	      attr(button, "class", button_class_value = "" + (
	      /*extraClasses*/
	      ctx[1] + " " + (
	      /*selected*/
	      ctx[0] ===
	      /*color*/
	      ctx[11] ? 'active' : '') + " svelte-exkzm6"));
	      set_style(button, "background-color",
	      /*color*/
	      ctx[11]);
	    },
	    m: function m(target, anchor) {
	      insert(target, button, anchor);

	      if (!mounted) {
	        dispose = listen(button, "click", click_handler);
	        mounted = true;
	      }
	    },
	    p: function p(new_ctx, dirty) {
	      ctx = new_ctx;

	      if (dirty &
	      /*extraClasses, selected, buttons*/
	      19 && button_class_value !== (button_class_value = "" + (
	      /*extraClasses*/
	      ctx[1] + " " + (
	      /*selected*/
	      ctx[0] ===
	      /*color*/
	      ctx[11] ? 'active' : '') + " svelte-exkzm6"))) {
	        attr(button, "class", button_class_value);
	      }

	      if (dirty &
	      /*buttons*/
	      16) {
	        set_style(button, "background-color",
	        /*color*/
	        ctx[11]);
	      }
	    },
	    d: function d(detaching) {
	      if (detaching) detach(button);
	      mounted = false;
	      dispose();
	    }
	  };
	}

	function create_fragment$d(ctx) {
	  var div1;
	  var t0;
	  var t1;
	  var div0;
	  var div1_class_value;

	  function select_block_type(ctx, dirty) {
	    if (
	    /*mode*/
	    ctx[2] === 'color') return create_if_block$7;
	    if (
	    /*mode*/
	    ctx[2] === 'icon-size') return create_if_block_1$5;
	    return create_else_block$2;
	  }

	  var current_block_type = select_block_type(ctx);
	  var if_block = current_block_type(ctx);
	  return {
	    c: function c() {
	      div1 = element("div");
	      t0 = text(
	      /*label*/
	      ctx[5]);
	      t1 = space();
	      div0 = element("div");
	      if_block.c();
	      attr(div0, "class", "button-group svelte-exkzm6");
	      attr(div1, "class", div1_class_value = "button-menu " +
	      /*mode*/
	      ctx[2] + " svelte-exkzm6");
	    },
	    m: function m(target, anchor) {
	      insert(target, div1, anchor);
	      append(div1, t0);
	      append(div1, t1);
	      append(div1, div0);
	      if_block.m(div0, null);
	    },
	    p: function p(ctx, _ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	          dirty = _ref2[0];

	      if (dirty &
	      /*label*/
	      32) set_data(t0,
	      /*label*/
	      ctx[5]);

	      if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
	        if_block.p(ctx, dirty);
	      } else {
	        if_block.d(1);
	        if_block = current_block_type(ctx);

	        if (if_block) {
	          if_block.c();
	          if_block.m(div0, null);
	        }
	      }

	      if (dirty &
	      /*mode*/
	      4 && div1_class_value !== (div1_class_value = "button-menu " +
	      /*mode*/
	      ctx[2] + " svelte-exkzm6")) {
	        attr(div1, "class", div1_class_value);
	      }
	    },
	    i: noop,
	    o: noop,
	    d: function d(detaching) {
	      if (detaching) detach(div1);
	      if_block.d();
	    }
	  };
	}

	function instance$d($$self, $$props, $$invalidate) {
	  var _$$props$label = $$props.label,
	      label = _$$props$label === void 0 ? '' : _$$props$label;
	  var _$$props$extraClasses = $$props.extraClasses,
	      extraClasses = _$$props$extraClasses === void 0 ? 'flat icon' : _$$props$extraClasses;
	  var _$$props$mode = $$props.mode,
	      mode = _$$props$mode === void 0 ? 'icon' : _$$props$mode;
	  var _$$props$iconDisplay = $$props.iconDisplay,
	      iconDisplay = _$$props$iconDisplay === void 0 ? 'â' : _$$props$iconDisplay;
	  var _$$props$buttons = $$props.buttons,
	      buttons = _$$props$buttons === void 0 ? [['value', 'label']] : _$$props$buttons;
	  var _$$props$onChange = $$props.onChange,
	      onChange = _$$props$onChange === void 0 ? function () {
	    return null;
	  } : _$$props$onChange;
	  var selected = $$props.selected;

	  function select(val) {
	    $$invalidate(0, selected = val);
	    onChange(val);
	  }

	  var click_handler = function click_handler(color) {
	    return select(color);
	  };

	  var click_handler_1 = function click_handler_1(size) {
	    return select(size);
	  };

	  var click_handler_2 = function click_handler_2(value) {
	    return select(value);
	  };

	  $$self.$$set = function ($$props) {
	    if ('label' in $$props) $$invalidate(5, label = $$props.label);
	    if ('extraClasses' in $$props) $$invalidate(1, extraClasses = $$props.extraClasses);
	    if ('mode' in $$props) $$invalidate(2, mode = $$props.mode);
	    if ('iconDisplay' in $$props) $$invalidate(3, iconDisplay = $$props.iconDisplay);
	    if ('buttons' in $$props) $$invalidate(4, buttons = $$props.buttons);
	    if ('onChange' in $$props) $$invalidate(7, onChange = $$props.onChange);
	    if ('selected' in $$props) $$invalidate(0, selected = $$props.selected);
	  };

	  return [selected, extraClasses, mode, iconDisplay, buttons, label, select, onChange, click_handler, click_handler_1, click_handler_2];
	}

	var EditorButtonMenu = /*#__PURE__*/function (_SvelteComponent) {
	  _inherits(EditorButtonMenu, _SvelteComponent);

	  var _super = _createSuper(EditorButtonMenu);

	  function EditorButtonMenu(options) {
	    var _this;

	    _classCallCheck(this, EditorButtonMenu);

	    _this = _super.call(this);
	    init(_assertThisInitialized(_this), options, instance$d, create_fragment$d, safe_not_equal, {
	      label: 5,
	      extraClasses: 1,
	      mode: 2,
	      iconDisplay: 3,
	      buttons: 4,
	      onChange: 7,
	      selected: 0
	    }, add_css$c);
	    return _this;
	  }

	  _createClass(EditorButtonMenu, [{
	    key: "label",
	    get: function get() {
	      return this.$$.ctx[5];
	    },
	    set: function set(label) {
	      this.$$set({
	        label: label
	      });
	      flush();
	    }
	  }, {
	    key: "extraClasses",
	    get: function get() {
	      return this.$$.ctx[1];
	    },
	    set: function set(extraClasses) {
	      this.$$set({
	        extraClasses: extraClasses
	      });
	      flush();
	    }
	  }, {
	    key: "mode",
	    get: function get() {
	      return this.$$.ctx[2];
	    },
	    set: function set(mode) {
	      this.$$set({
	        mode: mode
	      });
	      flush();
	    }
	  }, {
	    key: "iconDisplay",
	    get: function get() {
	      return this.$$.ctx[3];
	    },
	    set: function set(iconDisplay) {
	      this.$$set({
	        iconDisplay: iconDisplay
	      });
	      flush();
	    }
	  }, {
	    key: "buttons",
	    get: function get() {
	      return this.$$.ctx[4];
	    },
	    set: function set(buttons) {
	      this.$$set({
	        buttons: buttons
	      });
	      flush();
	    }
	  }, {
	    key: "onChange",
	    get: function get() {
	      return this.$$.ctx[7];
	    },
	    set: function set(onChange) {
	      this.$$set({
	        onChange: onChange
	      });
	      flush();
	    }
	  }, {
	    key: "selected",
	    get: function get() {
	      return this.$$.ctx[0];
	    },
	    set: function set(selected) {
	      this.$$set({
	        selected: selected
	      });
	      flush();
	    }
	  }]);

	  return EditorButtonMenu;
	}(SvelteComponent);

	var MAPBOX_ALT_COLOR = '#aaabac'; // singleSelection type will avoid any sub
	// _role must include the type you are looking to apply
	// the modifications to -- ie. arrows and lines don't get all of the
	// style options that icon and text do
	// _replace: allows a string for replacing only part of the text with the incoming
	// text (used to apply given text to a style)

	var LOCATOR_MAP_TEXT_STYLES = [{
	  type: 'text',
	  outline: true,
	  align: 'center',
	  x: 0.5,
	  y: 0.4,
	  text: 'New York City',
	  color: 'black',
	  _info: 'Default label',
	  _warn: 'Use for cities, features, or any single item. All other sizes are just to match the map.',
	  _roles: ['text', 'icon', 'line', 'linebend', 'arrow']
	}, {
	  type: 'text',
	  outline: true,
	  align: 'center',
	  x: 0.5,
	  y: 0.4,
	  text: 'Port Ridge<br><b>9.5M</b>',
	  color: 'black',
	  _info: 'Location and Number',
	  _warn: 'Convention is to display a number on second line in bold',
	  _roles: ['text', 'icon', 'line', 'linebend'],
	  _replace: 'Port Ridge' // incoming text will replace this part

	}, {
	  type: 'text',
	  outline: true,
	  align: 'center',
	  x: 0.5,
	  y: 0.4,
	  text: '<b>$9.5M</b>',
	  color: 'black',
	  _info: 'Bold numerical label',
	  _warn: 'Only bold use to display numerical values',
	  _roles: ['text', 'icon', 'line', 'linebend'],
	  _replace: '$9.5M' // incoming text will replace this part

	}, {
	  type: 'text',
	  outline: true,
	  align: 'center',
	  x: 0.5,
	  y: 0.4,
	  text: 'Large City',
	  color: MAPBOX_ALT_COLOR,
	  iconColor: MAPBOX_ALT_COLOR,
	  _info: 'De-emphasized label',
	  _roles: ['text', 'icon']
	}]; // type collection for maps - for other chart types map items like
	// lake and country text will be filtered out

	var labelCollectionMaps = {
	  id: 'labelCollectionMaps',
	  type: 'collection',
	  title: 'Basic Text Labels',
	  description: 'Single and multi line text variations for labeling large regions or providing additional context.',
	  warning: '<b><i>Please adhere to the style guide:</i></b> <br>These templates have been chosen for specific cases to get a uniform look sitewide so please stick to the intended purpose and don\'t abuse.',
	  variations: {// align: true,
	    // valign: true
	  },
	  previewItem: {
	    type: 'text',
	    text: 'Feature Label',
	    outline: true,
	    align: 'center',
	    x: 0.5,
	    y: 0.4
	  },
	  items: LOCATOR_MAP_TEXT_STYLES
	}; // type variations are the last step, where a user has chosen an icon or
	// arrow type and position and now we want to provide a selection of text
	// treatments that can go along with that

	var typeVariations = {
	  id: 'typeVariations',
	  type: 'collection',
	  title: 'Select a type template for your label',
	  description: 'Almost there. Set alignment and choose from the available type templates for the scenario that fits the data you are trying to display.',
	  // warning: '<b><i>Please adhere to the style guide:</i></b> <br>These templates have been chosen for specific cases to get a uniform look sitewide so please stick to the intended purpose and don\'t abuse.',
	  items: LOCATOR_MAP_TEXT_STYLES.map(function (v) {
	    return filterNonTextProperties(v);
	  })
	};

	// a collection of the same item but with text variations
	// pass in the current text to replace all the type with
	// existing text

	function createTypeVariations(item, replaceText) {
	  var filter = item.type;

	  var newItem = _objectSpread2(_objectSpread2({}, item), {}, {
	    _typeVariations: undefined
	  });

	  var filteredItems = typeVariations.items.filter(function (variant) {
	    return variant._roles.includes(filter);
	  }).map(function (variant) {
	    if (replaceText) {
	      variant.text = replaceItemText(variant, replaceText);
	    }

	    return _objectSpread2(_objectSpread2({}, newItem), variant);
	  });

	  var newCollection = _objectSpread2(_objectSpread2({}, typeVariations), {}, {
	    items: filteredItems
	  }); // if item._variations override the collection variations


	  if (item._variations) {
	    newCollection.variations = item._variations;
	  }

	  return newCollection;
	} // all properties leading with underscore are merely for
	// metadata in the selection flow and can be removed once
	// the item is ready to be added

	function filterUnderscoreProperties() {
	  var item = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	  var returnObj = {};
	  Object.keys(item).filter(function (key) {
	    return key[0] !== '_';
	  }).forEach(function (prop) {
	    returnObj[prop] = item[prop];
	  });
	  return returnObj;
	} // get rid of any x,y properties contained in the default
	// text variation set

	function filterNonTextProperties() {
	  var item = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	  var excludeProps = ['x', 'y', 'align', 'valign'];
	  var returnObj = {};
	  Object.keys(item).filter(function (key) {
	    return !excludeProps.includes(key);
	  }).forEach(function (prop) {
	    returnObj[prop] = item[prop];
	  });
	  return returnObj;
	} // takes whatever text you pass in, strips any existing <>
	// style brackets, and then applies the new text to the item

	function replaceItemText(item, replaceText) {
	  var sanitizedText = replaceText.replace(/<[^>]*>/g, '');

	  if (item._replace) {
	    return item.text.replace(item._replace, sanitizedText);
	  }

	  return sanitizedText;
	}

	var alignCenter = "<svg xmlns=\"http://www.w3.org/2000/svg\" class=\"icon icon-tabler icon-tabler-align-center\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" stroke-width=\"2\" stroke=\"currentColor\" fill=\"none\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n  <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\"/>\n  <line x1=\"4\" y1=\"6\" x2=\"20\" y2=\"6\" />\n  <line x1=\"8\" y1=\"12\" x2=\"16\" y2=\"12\" />\n  <line x1=\"6\" y1=\"18\" x2=\"18\" y2=\"18\" />\n</svg>";

	var alignLeft = "<svg xmlns=\"http://www.w3.org/2000/svg\" class=\"icon icon-tabler icon-tabler-align-left\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" stroke-width=\"2\" stroke=\"currentColor\" fill=\"none\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n  <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\"/>\n  <line x1=\"4\" y1=\"6\" x2=\"20\" y2=\"6\" />\n  <line x1=\"4\" y1=\"12\" x2=\"14\" y2=\"12\" />\n  <line x1=\"4\" y1=\"18\" x2=\"18\" y2=\"18\" />\n</svg>";

	var alignRight = "<svg xmlns=\"http://www.w3.org/2000/svg\" class=\"icon icon-tabler icon-tabler-align-right\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" stroke-width=\"2\" stroke=\"currentColor\" fill=\"none\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n  <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\"/>\n  <line x1=\"4\" y1=\"6\" x2=\"20\" y2=\"6\" />\n  <line x1=\"10\" y1=\"12\" x2=\"20\" y2=\"12\" />\n  <line x1=\"6\" y1=\"18\" x2=\"20\" y2=\"18\" />\n</svg>";

	var alignVTop = "<svg xmlns=\"http://www.w3.org/2000/svg\" class=\"icon icon-tabler icon-tabler-layout-align-top\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" stroke-width=\"2\" stroke=\"currentColor\" fill=\"none\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n  <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\"/>\n  <line x1=\"4\" y1=\"4\" x2=\"20\" y2=\"4\" />\n  <rect x=\"9\" y=\"8\" width=\"6\" height=\"12\" rx=\"2\" />\n</svg>";

	var alignVCenter = "<svg xmlns=\"http://www.w3.org/2000/svg\" class=\"icon icon-tabler icon-tabler-layout-align-center\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" stroke-width=\"2\" stroke=\"currentColor\" fill=\"none\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n  <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\"/>\n  <line x1=\"12\" y1=\"4\" x2=\"12\" y2=\"9\" />\n  <line x1=\"12\" y1=\"15\" x2=\"12\" y2=\"20\" />\n  <rect x=\"6\" y=\"9\" width=\"12\" height=\"6\" rx=\"2\" />\n</svg>";

	var alignVBottom = "<svg xmlns=\"http://www.w3.org/2000/svg\" class=\"icon icon-tabler icon-tabler-layout-align-bottom\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" stroke-width=\"2\" stroke=\"currentColor\" fill=\"none\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n  <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\"/>\n  <line x1=\"4\" y1=\"20\" x2=\"20\" y2=\"20\" />\n  <rect x=\"9\" y=\"4\" width=\"6\" height=\"12\" rx=\"2\" />\n</svg>";

	// just some common icon button menu pairings
	var alignButtons = [['left', alignLeft], ['center', alignCenter], ['right', alignRight]];
	var valignButtons = [['top', alignVTop], ['center', alignVCenter], ['bottom', alignVBottom]];
	var valignButtonsNoCenter = [['top', alignVTop], ['bottom', alignVBottom]];

	var cornerDownLeft = "<svg xmlns=\"http://www.w3.org/2000/svg\" class=\"icon icon-tabler icon-tabler-corner-down-left\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" stroke-width=\"2\" stroke=\"currentColor\" fill=\"none\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n  <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\"/>\n  <path d=\"M18 6v6a3 3 0 0 1 -3 3h-10l4 -4m0 8l-4 -4\" />\n</svg>";

	var circlePlus = "<svg xmlns=\"http://www.w3.org/2000/svg\" class=\"icon icon-tabler icon-tabler-circle-plus\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" stroke-width=\"2\" stroke=\"currentColor\" fill=\"none\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n  <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\"/>\n  <circle cx=\"12\" cy=\"12\" r=\"9\" />\n  <line x1=\"9\" y1=\"12\" x2=\"15\" y2=\"12\" />\n  <line x1=\"12\" y1=\"9\" x2=\"12\" y2=\"15\" />\n</svg>";

	function add_css$b(target) {
	  append_styles(target, "svelte-16vwvhb", ".select.svelte-16vwvhb.svelte-16vwvhb{color:#001aaa}.preview.svelte-16vwvhb.svelte-16vwvhb{position:relative;display:inline-block;width:120px;background:linear-gradient(to bottom, #ffffff 0%,#c6d7ff 100%);margin:8px 6px;height:100px;cursor:pointer;overflow:hidden}.preview > .draggable{pointer-events:none}.warning.collection.svelte-16vwvhb.svelte-16vwvhb{background:#ffd382;padding:5px;max-width:340px;margin-left:35px}.warning.item.svelte-16vwvhb.svelte-16vwvhb{font-size:10px;font-weight:bold;font-style:italic;margin-top:-11px}.collection-row.svelte-16vwvhb.svelte-16vwvhb{display:flex;background:#ffffff;border-radius:10px;padding:0 0 0 10px;border:solid 1px transparent;cursor:pointer}h2.svelte-16vwvhb.svelte-16vwvhb,h3.svelte-16vwvhb.svelte-16vwvhb,p.svelte-16vwvhb.svelte-16vwvhb{display:block;font-size:1em;margin-block-start:1em;margin-block-end:1em;margin-inline-start:0px;margin-inline-end:0px}h2.svelte-16vwvhb.svelte-16vwvhb{font-size:1.5em}h3.svelte-16vwvhb.svelte-16vwvhb{font-size:1.17em;font-weight:bold}.collection-row.svelte-16vwvhb.svelte-16vwvhb:hover{background:#fafbff;border:solid 1px #001aaa}.collection-row.svelte-16vwvhb .info.svelte-16vwvhb{width:60%}.collection-row.svelte-16vwvhb .preview.svelte-16vwvhb{margin-left:30px}.action-icon.svelte-16vwvhb.svelte-16vwvhb,.variant-icon.svelte-16vwvhb.svelte-16vwvhb{position:absolute;right:40px;z-index:35;top:50%;transform:translateY(-50%) translateX(-50%);opacity:0;transition:all 0.13s ease-out}.action-icon svg, .variant-icon svg{width:40px;height:40px}.collection-row.svelte-16vwvhb:hover .action-icon.svelte-16vwvhb{right:25px;opacity:1.0}.collection-item.svelte-16vwvhb.svelte-16vwvhb{display:inline-block;width:140px;vertical-align:top}.collection-item.svelte-16vwvhb .preview.svelte-16vwvhb{padding:0}.collection-item.svelte-16vwvhb .action-icon.svelte-16vwvhb{right:auto;left:50%;top:60%}.collection-item.svelte-16vwvhb:hover .action-icon.svelte-16vwvhb{top:50%;opacity:1.0}.collection-item.svelte-16vwvhb:hover .variant-icon.svelte-16vwvhb{right:25px;opacity:1.0}.collection-item.svelte-16vwvhb .info.svelte-16vwvhb{margin:-22px 8px 8px 8px}.roles.svelte-16vwvhb.svelte-16vwvhb{margin-top:-10px}.roles.svelte-16vwvhb span.svelte-16vwvhb{background:#ffd382;padding:2px 6px;font-size:10px}.menu-footer.svelte-16vwvhb.svelte-16vwvhb{display:flex;justify-content:center;;}.back.svelte-16vwvhb.svelte-16vwvhb{cursor:pointer;position:absolute;left:5px}.back.svelte-16vwvhb.svelte-16vwvhb:hover{color:black}.back.svelte-16vwvhb span.svelte-16vwvhb{transform:translateY(-8px);display:inline-block}.variations-menu.svelte-16vwvhb.svelte-16vwvhb{margin-left:40px}.variations-menu .button-menu{display:inline-block;margin-right:20px;min-width:140px;min-height:26px}");
	}

	function get_each_context$3(ctx, list, i) {
	  var child_ctx = ctx.slice();
	  child_ctx[21] = list[i];
	  return child_ctx;
	}

	function get_each_context_2(ctx, list, i) {
	  var child_ctx = ctx.slice();
	  child_ctx[24] = list[i];
	  return child_ctx;
	}

	function get_each_context_1$2(ctx, list, i) {
	  var child_ctx = ctx.slice();
	  child_ctx[24] = list[i];
	  return child_ctx;
	} // (294:2) {#if activeCollection.description}


	function create_if_block_13(ctx) {
	  var _p;

	  var raw_value =
	  /*activeCollection*/
	  ctx[0].description + "";
	  return {
	    c: function c() {
	      _p = element("p");
	      attr(_p, "class", "description svelte-16vwvhb");
	    },
	    m: function m(target, anchor) {
	      insert(target, _p, anchor);
	      _p.innerHTML = raw_value;
	    },
	    p: function p(ctx, dirty) {
	      if (dirty &
	      /*activeCollection*/
	      1 && raw_value !== (raw_value =
	      /*activeCollection*/
	      ctx[0].description + "")) _p.innerHTML = raw_value;
	    },
	    d: function d(detaching) {
	      if (detaching) detach(_p);
	    }
	  };
	} // (297:2) {#if activeCollection.warning}


	function create_if_block_12(ctx) {
	  var _p2;

	  var raw_value =
	  /*activeCollection*/
	  ctx[0].warning + "";
	  return {
	    c: function c() {
	      _p2 = element("p");
	      attr(_p2, "class", "warning collection svelte-16vwvhb");
	    },
	    m: function m(target, anchor) {
	      insert(target, _p2, anchor);
	      _p2.innerHTML = raw_value;
	    },
	    p: function p(ctx, dirty) {
	      if (dirty &
	      /*activeCollection*/
	      1 && raw_value !== (raw_value =
	      /*activeCollection*/
	      ctx[0].warning + "")) _p2.innerHTML = raw_value;
	    },
	    d: function d(detaching) {
	      if (detaching) detach(_p2);
	    }
	  };
	} // (300:2) {#if activeCollection.variations}


	function create_if_block_7$1(ctx) {
	  var div;
	  var t0;
	  var t1;
	  var br;
	  var t2;
	  var t3;
	  var current;
	  var if_block0 =
	  /*activeCollection*/
	  ctx[0].variations.iconColor && create_if_block_11(ctx);
	  var if_block1 =
	  /*activeCollection*/
	  ctx[0].variations.iconSize && create_if_block_10(ctx);
	  var if_block2 =
	  /*activeCollection*/
	  ctx[0].variations.align && create_if_block_9$1(ctx);
	  var if_block3 =
	  /*activeCollection*/
	  ctx[0].variations.valign && create_if_block_8$1(ctx);
	  return {
	    c: function c() {
	      div = element("div");
	      if (if_block0) if_block0.c();
	      t0 = space();
	      if (if_block1) if_block1.c();
	      t1 = space();
	      br = element("br");
	      t2 = space();
	      if (if_block2) if_block2.c();
	      t3 = space();
	      if (if_block3) if_block3.c();
	      attr(div, "class", "variations-menu svelte-16vwvhb");
	    },
	    m: function m(target, anchor) {
	      insert(target, div, anchor);
	      if (if_block0) if_block0.m(div, null);
	      append(div, t0);
	      if (if_block1) if_block1.m(div, null);
	      append(div, t1);
	      append(div, br);
	      append(div, t2);
	      if (if_block2) if_block2.m(div, null);
	      append(div, t3);
	      if (if_block3) if_block3.m(div, null);
	      current = true;
	    },
	    p: function p(ctx, dirty) {
	      if (
	      /*activeCollection*/
	      ctx[0].variations.iconColor) {
	        if (if_block0) {
	          if_block0.p(ctx, dirty);

	          if (dirty &
	          /*activeCollection*/
	          1) {
	            transition_in(if_block0, 1);
	          }
	        } else {
	          if_block0 = create_if_block_11(ctx);
	          if_block0.c();
	          transition_in(if_block0, 1);
	          if_block0.m(div, t0);
	        }
	      } else if (if_block0) {
	        group_outros();
	        transition_out(if_block0, 1, 1, function () {
	          if_block0 = null;
	        });
	        check_outros();
	      }

	      if (
	      /*activeCollection*/
	      ctx[0].variations.iconSize) {
	        if (if_block1) {
	          if_block1.p(ctx, dirty);

	          if (dirty &
	          /*activeCollection*/
	          1) {
	            transition_in(if_block1, 1);
	          }
	        } else {
	          if_block1 = create_if_block_10(ctx);
	          if_block1.c();
	          transition_in(if_block1, 1);
	          if_block1.m(div, t1);
	        }
	      } else if (if_block1) {
	        group_outros();
	        transition_out(if_block1, 1, 1, function () {
	          if_block1 = null;
	        });
	        check_outros();
	      }

	      if (
	      /*activeCollection*/
	      ctx[0].variations.align) {
	        if (if_block2) {
	          if_block2.p(ctx, dirty);

	          if (dirty &
	          /*activeCollection*/
	          1) {
	            transition_in(if_block2, 1);
	          }
	        } else {
	          if_block2 = create_if_block_9$1(ctx);
	          if_block2.c();
	          transition_in(if_block2, 1);
	          if_block2.m(div, t3);
	        }
	      } else if (if_block2) {
	        group_outros();
	        transition_out(if_block2, 1, 1, function () {
	          if_block2 = null;
	        });
	        check_outros();
	      }

	      if (
	      /*activeCollection*/
	      ctx[0].variations.valign) {
	        if (if_block3) {
	          if_block3.p(ctx, dirty);

	          if (dirty &
	          /*activeCollection*/
	          1) {
	            transition_in(if_block3, 1);
	          }
	        } else {
	          if_block3 = create_if_block_8$1(ctx);
	          if_block3.c();
	          transition_in(if_block3, 1);
	          if_block3.m(div, null);
	        }
	      } else if (if_block3) {
	        group_outros();
	        transition_out(if_block3, 1, 1, function () {
	          if_block3 = null;
	        });
	        check_outros();
	      }
	    },
	    i: function i(local) {
	      if (current) return;
	      transition_in(if_block0);
	      transition_in(if_block1);
	      transition_in(if_block2);
	      transition_in(if_block3);
	      current = true;
	    },
	    o: function o(local) {
	      transition_out(if_block0);
	      transition_out(if_block1);
	      transition_out(if_block2);
	      transition_out(if_block3);
	      current = false;
	    },
	    d: function d(detaching) {
	      if (detaching) detach(div);
	      if (if_block0) if_block0.d();
	      if (if_block1) if_block1.d();
	      if (if_block2) if_block2.d();
	      if (if_block3) if_block3.d();
	    }
	  };
	} // (302:6) {#if activeCollection.variations.iconColor}


	function create_if_block_11(ctx) {
	  var editorbuttonmenu;
	  var current;
	  editorbuttonmenu = new EditorButtonMenu({
	    props: {
	      label: "Icon color:",
	      mode: "color",
	      selected:
	      /*iconColors*/
	      ctx[3][0],
	      onChange:
	      /*setIconColor*/
	      ctx[8],
	      buttons:
	      /*iconColors*/
	      ctx[3]
	    }
	  });
	  return {
	    c: function c() {
	      create_component(editorbuttonmenu.$$.fragment);
	    },
	    m: function m(target, anchor) {
	      mount_component(editorbuttonmenu, target, anchor);
	      current = true;
	    },
	    p: noop,
	    i: function i(local) {
	      if (current) return;
	      transition_in(editorbuttonmenu.$$.fragment, local);
	      current = true;
	    },
	    o: function o(local) {
	      transition_out(editorbuttonmenu.$$.fragment, local);
	      current = false;
	    },
	    d: function d(detaching) {
	      destroy_component(editorbuttonmenu, detaching);
	    }
	  };
	} // (310:6) {#if activeCollection.variations.iconSize}


	function create_if_block_10(ctx) {
	  var editorbuttonmenu;
	  var current;
	  editorbuttonmenu = new EditorButtonMenu({
	    props: {
	      label: "Icon size:",
	      mode: "icon-size",
	      selected:
	      /*iconSizes*/
	      ctx[4][2],
	      onChange:
	      /*setIconSize*/
	      ctx[9],
	      buttons:
	      /*iconSizes*/
	      ctx[4]
	    }
	  });
	  return {
	    c: function c() {
	      create_component(editorbuttonmenu.$$.fragment);
	    },
	    m: function m(target, anchor) {
	      mount_component(editorbuttonmenu, target, anchor);
	      current = true;
	    },
	    p: noop,
	    i: function i(local) {
	      if (current) return;
	      transition_in(editorbuttonmenu.$$.fragment, local);
	      current = true;
	    },
	    o: function o(local) {
	      transition_out(editorbuttonmenu.$$.fragment, local);
	      current = false;
	    },
	    d: function d(detaching) {
	      destroy_component(editorbuttonmenu, detaching);
	    }
	  };
	} // (319:6) {#if activeCollection.variations.align}


	function create_if_block_9$1(ctx) {
	  var editorbuttonmenu;
	  var current;
	  editorbuttonmenu = new EditorButtonMenu({
	    props: {
	      label: "Align:",
	      selected: "center",
	      onChange:
	      /*setAlign*/
	      ctx[10],
	      buttons: alignButtons
	    }
	  });
	  return {
	    c: function c() {
	      create_component(editorbuttonmenu.$$.fragment);
	    },
	    m: function m(target, anchor) {
	      mount_component(editorbuttonmenu, target, anchor);
	      current = true;
	    },
	    p: noop,
	    i: function i(local) {
	      if (current) return;
	      transition_in(editorbuttonmenu.$$.fragment, local);
	      current = true;
	    },
	    o: function o(local) {
	      transition_out(editorbuttonmenu.$$.fragment, local);
	      current = false;
	    },
	    d: function d(detaching) {
	      destroy_component(editorbuttonmenu, detaching);
	    }
	  };
	} // (326:6) {#if activeCollection.variations.valign}


	function create_if_block_8$1(ctx) {
	  var editorbuttonmenu;
	  var current;
	  editorbuttonmenu = new EditorButtonMenu({
	    props: {
	      label: "Vertical Align:",
	      selected: "top",
	      onChange:
	      /*setValign*/
	      ctx[11],
	      buttons:
	      /*activeCollection*/
	      ctx[0].variations.disableValignCenter ? valignButtonsNoCenter : valignButtons
	    }
	  });
	  return {
	    c: function c() {
	      create_component(editorbuttonmenu.$$.fragment);
	    },
	    m: function m(target, anchor) {
	      mount_component(editorbuttonmenu, target, anchor);
	      current = true;
	    },
	    p: function p(ctx, dirty) {
	      var editorbuttonmenu_changes = {};
	      if (dirty &
	      /*activeCollection*/
	      1) editorbuttonmenu_changes.buttons =
	      /*activeCollection*/
	      ctx[0].variations.disableValignCenter ? valignButtonsNoCenter : valignButtons;
	      editorbuttonmenu.$set(editorbuttonmenu_changes);
	    },
	    i: function i(local) {
	      if (current) return;
	      transition_in(editorbuttonmenu.$$.fragment, local);
	      current = true;
	    },
	    o: function o(local) {
	      transition_out(editorbuttonmenu.$$.fragment, local);
	      current = false;
	    },
	    d: function d(detaching) {
	      destroy_component(editorbuttonmenu, detaching);
	    }
	  };
	} // (376:4) {:else}


	function create_else_block$1(ctx) {
	  var div2;
	  var div0;
	  var container;
	  var t0;
	  var t1;
	  var div1;
	  var t2;
	  var t3;
	  var t4;
	  var current;
	  var mounted;
	  var dispose;
	  container = new Container({
	    props: {
	      isEditor: false,
	      breakpoint: null,
	      draggable:
	      /*item*/
	      ctx[21],
	      updateDraggable: nullHandler,
	      finalizeDraggable: nullHandler,
	      removeDraggable: nullHandler,
	      scale:
	      /*previewScale*/
	      ctx[5],
	      containerWidth: 120
	    }
	  });

	  function select_block_type_1(ctx, dirty) {
	    if (
	    /*item*/
	    ctx[21]._typeVariations) return create_if_block_6$1;
	    return create_else_block_1;
	  }

	  var current_block_type = select_block_type_1(ctx);
	  var if_block0 = current_block_type(ctx);
	  var if_block1 =
	  /*item*/
	  ctx[21].roles && create_if_block_5$2(ctx);
	  var if_block2 =
	  /*item*/
	  ctx[21]._info && create_if_block_4$3(ctx);
	  var if_block3 =
	  /*item*/
	  ctx[21]._warn && create_if_block_3$3(ctx);

	  function click_handler_1() {
	    return (
	      /*click_handler_1*/
	      ctx[16](
	      /*item*/
	      ctx[21])
	    );
	  }

	  return {
	    c: function c() {
	      div2 = element("div");
	      div0 = element("div");
	      create_component(container.$$.fragment);
	      t0 = space();
	      if_block0.c();
	      t1 = space();
	      div1 = element("div");
	      if (if_block1) if_block1.c();
	      t2 = space();
	      if (if_block2) if_block2.c();
	      t3 = space();
	      if (if_block3) if_block3.c();
	      t4 = space();
	      attr(div0, "class", "preview svelte-16vwvhb");
	      attr(div1, "class", "info svelte-16vwvhb");
	      attr(div2, "class", "collection-item svelte-16vwvhb");
	    },
	    m: function m(target, anchor) {
	      insert(target, div2, anchor);
	      append(div2, div0);
	      mount_component(container, div0, null);
	      append(div0, t0);
	      if_block0.m(div0, null);
	      append(div2, t1);
	      append(div2, div1);
	      if (if_block1) if_block1.m(div1, null);
	      append(div1, t2);
	      if (if_block2) if_block2.m(div1, null);
	      append(div1, t3);
	      if (if_block3) if_block3.m(div1, null);
	      append(div2, t4);
	      current = true;

	      if (!mounted) {
	        dispose = [listen(div2, "click", click_handler_1), listen(div2, "keydown", keydown_handler_1), listen(div2, "keypress", keypress_handler_1)];
	        mounted = true;
	      }
	    },
	    p: function p(new_ctx, dirty) {
	      ctx = new_ctx;
	      var container_changes = {};
	      if (dirty &
	      /*activeCollection*/
	      1) container_changes.draggable =
	      /*item*/
	      ctx[21];
	      container.$set(container_changes);

	      if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block0) {
	        if_block0.p(ctx, dirty);
	      } else {
	        if_block0.d(1);
	        if_block0 = current_block_type(ctx);

	        if (if_block0) {
	          if_block0.c();
	          if_block0.m(div0, null);
	        }
	      }

	      if (
	      /*item*/
	      ctx[21].roles) {
	        if (if_block1) {
	          if_block1.p(ctx, dirty);
	        } else {
	          if_block1 = create_if_block_5$2(ctx);
	          if_block1.c();
	          if_block1.m(div1, t2);
	        }
	      } else if (if_block1) {
	        if_block1.d(1);
	        if_block1 = null;
	      }

	      if (
	      /*item*/
	      ctx[21]._info) {
	        if (if_block2) {
	          if_block2.p(ctx, dirty);
	        } else {
	          if_block2 = create_if_block_4$3(ctx);
	          if_block2.c();
	          if_block2.m(div1, t3);
	        }
	      } else if (if_block2) {
	        if_block2.d(1);
	        if_block2 = null;
	      }

	      if (
	      /*item*/
	      ctx[21]._warn) {
	        if (if_block3) {
	          if_block3.p(ctx, dirty);
	        } else {
	          if_block3 = create_if_block_3$3(ctx);
	          if_block3.c();
	          if_block3.m(div1, null);
	        }
	      } else if (if_block3) {
	        if_block3.d(1);
	        if_block3 = null;
	      }
	    },
	    i: function i(local) {
	      if (current) return;
	      transition_in(container.$$.fragment, local);
	      current = true;
	    },
	    o: function o(local) {
	      transition_out(container.$$.fragment, local);
	      current = false;
	    },
	    d: function d(detaching) {
	      if (detaching) detach(div2);
	      destroy_component(container);
	      if_block0.d();
	      if (if_block1) if_block1.d();
	      if (if_block2) if_block2.d();
	      if (if_block3) if_block3.d();
	      mounted = false;
	      run_all(dispose);
	    }
	  };
	} // (336:4) {#if item.type === 'collection' || item.type === 'singleSelection'}


	function create_if_block_1$4(ctx) {
	  var div3;
	  var div0;
	  var h3;
	  var t0_value =
	  /*item*/
	  ctx[21].title + "";
	  var t0;
	  var t1;
	  var t2;

	  var _p3;

	  var raw_value =
	  /*item*/
	  ctx[21].description + "";
	  var t3;
	  var div2;
	  var container;
	  var t4;
	  var div1;
	  var t5;
	  var current;
	  var mounted;
	  var dispose;
	  var if_block =
	  /*item*/
	  ctx[21].roles && create_if_block_2$3(ctx);
	  container = new Container({
	    props: {
	      isEditor: false,
	      breakpoint: null,
	      draggable:
	      /*item*/
	      ctx[21].previewItem,
	      updateDraggable: nullHandler,
	      finalizeDraggable: nullHandler,
	      removeDraggable: nullHandler,
	      scale:
	      /*previewScale*/
	      ctx[5],
	      containerWidth: 120
	    }
	  });

	  function click_handler() {
	    return (
	      /*click_handler*/
	      ctx[15](
	      /*item*/
	      ctx[21])
	    );
	  }

	  return {
	    c: function c() {
	      div3 = element("div");
	      div0 = element("div");
	      h3 = element("h3");
	      t0 = text(t0_value);
	      t1 = space();
	      if (if_block) if_block.c();
	      t2 = space();
	      _p3 = element("p");
	      t3 = space();
	      div2 = element("div");
	      create_component(container.$$.fragment);
	      t4 = space();
	      div1 = element("div");
	      div1.innerHTML = "<svg xmlns=\"http://www.w3.org/2000/svg\" class=\"icon icon-tabler icon-tabler-arrow-right-circle\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" stroke-width=\"2\" stroke=\"currentColor\" fill=\"none\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path stroke=\"none\" d=\"M0 0h24v24H0z\"></path><circle cx=\"12\" cy=\"12\" r=\"9\"></circle><line x1=\"16\" y1=\"12\" x2=\"8\" y2=\"12\"></line><line x1=\"16\" y1=\"12\" x2=\"12\" y2=\"16\"></line><line x1=\"16\" y1=\"12\" x2=\"12\" y2=\"8\"></line></svg>";
	      t5 = space();
	      attr(h3, "class", "svelte-16vwvhb");
	      attr(_p3, "class", "description svelte-16vwvhb");
	      attr(div0, "class", "info svelte-16vwvhb");
	      attr(div1, "class", "action-icon svelte-16vwvhb");
	      attr(div2, "class", "preview svelte-16vwvhb");
	      attr(div3, "class", "collection-row svelte-16vwvhb");
	    },
	    m: function m(target, anchor) {
	      insert(target, div3, anchor);
	      append(div3, div0);
	      append(div0, h3);
	      append(h3, t0);
	      append(div0, t1);
	      if (if_block) if_block.m(div0, null);
	      append(div0, t2);
	      append(div0, _p3);
	      _p3.innerHTML = raw_value;
	      append(div3, t3);
	      append(div3, div2);
	      mount_component(container, div2, null);
	      append(div2, t4);
	      append(div2, div1);
	      append(div3, t5);
	      current = true;

	      if (!mounted) {
	        dispose = [listen(div3, "click", click_handler), listen(div3, "keydown", keydown_handler$1), listen(div3, "keypress", keypress_handler)];
	        mounted = true;
	      }
	    },
	    p: function p(new_ctx, dirty) {
	      ctx = new_ctx;
	      if ((!current || dirty &
	      /*activeCollection*/
	      1) && t0_value !== (t0_value =
	      /*item*/
	      ctx[21].title + "")) set_data(t0, t0_value);

	      if (
	      /*item*/
	      ctx[21].roles) {
	        if (if_block) {
	          if_block.p(ctx, dirty);
	        } else {
	          if_block = create_if_block_2$3(ctx);
	          if_block.c();
	          if_block.m(div0, t2);
	        }
	      } else if (if_block) {
	        if_block.d(1);
	        if_block = null;
	      }

	      if ((!current || dirty &
	      /*activeCollection*/
	      1) && raw_value !== (raw_value =
	      /*item*/
	      ctx[21].description + "")) _p3.innerHTML = raw_value;
	      var container_changes = {};
	      if (dirty &
	      /*activeCollection*/
	      1) container_changes.draggable =
	      /*item*/
	      ctx[21].previewItem;
	      container.$set(container_changes);
	    },
	    i: function i(local) {
	      if (current) return;
	      transition_in(container.$$.fragment, local);
	      current = true;
	    },
	    o: function o(local) {
	      transition_out(container.$$.fragment, local);
	      current = false;
	    },
	    d: function d(detaching) {
	      if (detaching) detach(div3);
	      if (if_block) if_block.d();
	      destroy_component(container);
	      mounted = false;
	      run_all(dispose);
	    }
	  };
	} // (404:12) {:else}


	function create_else_block_1(ctx) {
	  var div;
	  return {
	    c: function c() {
	      div = element("div");
	      attr(div, "class", "action-icon svelte-16vwvhb");
	    },
	    m: function m(target, anchor) {
	      insert(target, div, anchor);
	      div.innerHTML = circlePlus;
	    },
	    p: noop,
	    d: function d(detaching) {
	      if (detaching) detach(div);
	    }
	  };
	} // (393:12) {#if item._typeVariations}


	function create_if_block_6$1(ctx) {
	  var div;
	  return {
	    c: function c() {
	      div = element("div");
	      div.innerHTML = "<svg xmlns=\"http://www.w3.org/2000/svg\" class=\"icon icon-tabler icon-tabler-arrow-right-circle\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" stroke-width=\"2\" stroke=\"currentColor\" fill=\"none\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path stroke=\"none\" d=\"M0 0h24v24H0z\"></path><circle cx=\"12\" cy=\"12\" r=\"9\"></circle><line x1=\"16\" y1=\"12\" x2=\"8\" y2=\"12\"></line><line x1=\"16\" y1=\"12\" x2=\"12\" y2=\"16\"></line><line x1=\"16\" y1=\"12\" x2=\"12\" y2=\"8\"></line></svg>";
	      attr(div, "class", "variant-icon svelte-16vwvhb");
	    },
	    m: function m(target, anchor) {
	      insert(target, div, anchor);
	    },
	    p: noop,
	    d: function d(detaching) {
	      if (detaching) detach(div);
	    }
	  };
	} // (411:10) {#if item.roles}


	function create_if_block_5$2(ctx) {
	  var div;
	  var each_value_2 =
	  /*item*/
	  ctx[21].roles;
	  var each_blocks = [];

	  for (var i = 0; i < each_value_2.length; i += 1) {
	    each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
	  }

	  return {
	    c: function c() {
	      div = element("div");

	      for (var _i = 0; _i < each_blocks.length; _i += 1) {
	        each_blocks[_i].c();
	      }

	      attr(div, "class", "roles svelte-16vwvhb");
	    },
	    m: function m(target, anchor) {
	      insert(target, div, anchor);

	      for (var _i2 = 0; _i2 < each_blocks.length; _i2 += 1) {
	        each_blocks[_i2].m(div, null);
	      }
	    },
	    p: function p(ctx, dirty) {
	      if (dirty &
	      /*ROLE_MAP, activeCollection*/
	      5) {
	        each_value_2 =
	        /*item*/
	        ctx[21].roles;

	        var _i3;

	        for (_i3 = 0; _i3 < each_value_2.length; _i3 += 1) {
	          var child_ctx = get_each_context_2(ctx, each_value_2, _i3);

	          if (each_blocks[_i3]) {
	            each_blocks[_i3].p(child_ctx, dirty);
	          } else {
	            each_blocks[_i3] = create_each_block_2(child_ctx);

	            each_blocks[_i3].c();

	            each_blocks[_i3].m(div, null);
	          }
	        }

	        for (; _i3 < each_blocks.length; _i3 += 1) {
	          each_blocks[_i3].d(1);
	        }

	        each_blocks.length = each_value_2.length;
	      }
	    },
	    d: function d(detaching) {
	      if (detaching) detach(div);
	      destroy_each(each_blocks, detaching);
	    }
	  };
	} // (413:14) {#each item.roles as role}


	function create_each_block_2(ctx) {
	  var span;
	  var t_value =
	  /*ROLE_MAP*/
	  ctx[2][
	  /*role*/
	  ctx[24]] + "";
	  var t;
	  return {
	    c: function c() {
	      span = element("span");
	      t = text(t_value);
	      attr(span, "class", "svelte-16vwvhb");
	    },
	    m: function m(target, anchor) {
	      insert(target, span, anchor);
	      append(span, t);
	    },
	    p: function p(ctx, dirty) {
	      if (dirty &
	      /*activeCollection*/
	      1 && t_value !== (t_value =
	      /*ROLE_MAP*/
	      ctx[2][
	      /*role*/
	      ctx[24]] + "")) set_data(t, t_value);
	    },
	    d: function d(detaching) {
	      if (detaching) detach(span);
	    }
	  };
	} // (418:10) {#if item._info}


	function create_if_block_4$3(ctx) {
	  var _p4;

	  var raw_value =
	  /*item*/
	  ctx[21]._info + "";
	  return {
	    c: function c() {
	      _p4 = element("p");
	      attr(_p4, "class", "description svelte-16vwvhb");
	    },
	    m: function m(target, anchor) {
	      insert(target, _p4, anchor);
	      _p4.innerHTML = raw_value;
	    },
	    p: function p(ctx, dirty) {
	      if (dirty &
	      /*activeCollection*/
	      1 && raw_value !== (raw_value =
	      /*item*/
	      ctx[21]._info + "")) _p4.innerHTML = raw_value;
	    },
	    d: function d(detaching) {
	      if (detaching) detach(_p4);
	    }
	  };
	} // (421:10) {#if item._warn}


	function create_if_block_3$3(ctx) {
	  var _p5;

	  var raw_value =
	  /*item*/
	  ctx[21]._warn + "";
	  return {
	    c: function c() {
	      _p5 = element("p");
	      attr(_p5, "class", "warning item svelte-16vwvhb");
	    },
	    m: function m(target, anchor) {
	      insert(target, _p5, anchor);
	      _p5.innerHTML = raw_value;
	    },
	    p: function p(ctx, dirty) {
	      if (dirty &
	      /*activeCollection*/
	      1 && raw_value !== (raw_value =
	      /*item*/
	      ctx[21]._warn + "")) _p5.innerHTML = raw_value;
	    },
	    d: function d(detaching) {
	      if (detaching) detach(_p5);
	    }
	  };
	} // (345:10) {#if item.roles}


	function create_if_block_2$3(ctx) {
	  var div;
	  var each_value_1 =
	  /*item*/
	  ctx[21].roles;
	  var each_blocks = [];

	  for (var i = 0; i < each_value_1.length; i += 1) {
	    each_blocks[i] = create_each_block_1$2(get_each_context_1$2(ctx, each_value_1, i));
	  }

	  return {
	    c: function c() {
	      div = element("div");

	      for (var _i4 = 0; _i4 < each_blocks.length; _i4 += 1) {
	        each_blocks[_i4].c();
	      }

	      attr(div, "class", "roles svelte-16vwvhb");
	    },
	    m: function m(target, anchor) {
	      insert(target, div, anchor);

	      for (var _i5 = 0; _i5 < each_blocks.length; _i5 += 1) {
	        each_blocks[_i5].m(div, null);
	      }
	    },
	    p: function p(ctx, dirty) {
	      if (dirty &
	      /*ROLE_MAP, activeCollection*/
	      5) {
	        each_value_1 =
	        /*item*/
	        ctx[21].roles;

	        var _i6;

	        for (_i6 = 0; _i6 < each_value_1.length; _i6 += 1) {
	          var child_ctx = get_each_context_1$2(ctx, each_value_1, _i6);

	          if (each_blocks[_i6]) {
	            each_blocks[_i6].p(child_ctx, dirty);
	          } else {
	            each_blocks[_i6] = create_each_block_1$2(child_ctx);

	            each_blocks[_i6].c();

	            each_blocks[_i6].m(div, null);
	          }
	        }

	        for (; _i6 < each_blocks.length; _i6 += 1) {
	          each_blocks[_i6].d(1);
	        }

	        each_blocks.length = each_value_1.length;
	      }
	    },
	    d: function d(detaching) {
	      if (detaching) detach(div);
	      destroy_each(each_blocks, detaching);
	    }
	  };
	} // (347:14) {#each item.roles as role}


	function create_each_block_1$2(ctx) {
	  var span;
	  var t_value =
	  /*ROLE_MAP*/
	  ctx[2][
	  /*role*/
	  ctx[24]] + "";
	  var t;
	  return {
	    c: function c() {
	      span = element("span");
	      t = text(t_value);
	      attr(span, "class", "svelte-16vwvhb");
	    },
	    m: function m(target, anchor) {
	      insert(target, span, anchor);
	      append(span, t);
	    },
	    p: function p(ctx, dirty) {
	      if (dirty &
	      /*activeCollection*/
	      1 && t_value !== (t_value =
	      /*ROLE_MAP*/
	      ctx[2][
	      /*role*/
	      ctx[24]] + "")) set_data(t, t_value);
	    },
	    d: function d(detaching) {
	      if (detaching) detach(span);
	    }
	  };
	} // (335:2) {#each activeCollection.items as item}


	function create_each_block$3(ctx) {
	  var current_block_type_index;
	  var if_block;
	  var if_block_anchor;
	  var current;
	  var if_block_creators = [create_if_block_1$4, create_else_block$1];
	  var if_blocks = [];

	  function select_block_type(ctx, dirty) {
	    if (
	    /*item*/
	    ctx[21].type === 'collection' ||
	    /*item*/
	    ctx[21].type === 'singleSelection') return 0;
	    return 1;
	  }

	  current_block_type_index = select_block_type(ctx);
	  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	  return {
	    c: function c() {
	      if_block.c();
	      if_block_anchor = empty();
	    },
	    m: function m(target, anchor) {
	      if_blocks[current_block_type_index].m(target, anchor);
	      insert(target, if_block_anchor, anchor);
	      current = true;
	    },
	    p: function p(ctx, dirty) {
	      var previous_block_index = current_block_type_index;
	      current_block_type_index = select_block_type(ctx);

	      if (current_block_type_index === previous_block_index) {
	        if_blocks[current_block_type_index].p(ctx, dirty);
	      } else {
	        group_outros();
	        transition_out(if_blocks[previous_block_index], 1, 1, function () {
	          if_blocks[previous_block_index] = null;
	        });
	        check_outros();
	        if_block = if_blocks[current_block_type_index];

	        if (!if_block) {
	          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	          if_block.c();
	        } else {
	          if_block.p(ctx, dirty);
	        }

	        transition_in(if_block, 1);
	        if_block.m(if_block_anchor.parentNode, if_block_anchor);
	      }
	    },
	    i: function i(local) {
	      if (current) return;
	      transition_in(if_block);
	      current = true;
	    },
	    o: function o(local) {
	      transition_out(if_block);
	      current = false;
	    },
	    d: function d(detaching) {
	      if_blocks[current_block_type_index].d(detaching);
	      if (detaching) detach(if_block_anchor);
	    }
	  };
	} // (430:2) {#if collectionStack.length > 1}


	function create_if_block$6(ctx) {
	  var div;
	  var html_tag;
	  var t0;
	  var span;
	  var mounted;
	  var dispose;
	  return {
	    c: function c() {
	      div = element("div");
	      html_tag = new HtmlTag(false);
	      t0 = space();
	      span = element("span");
	      span.textContent = "Back";
	      html_tag.a = t0;
	      attr(span, "class", "svelte-16vwvhb");
	      attr(div, "class", "back svelte-16vwvhb");
	    },
	    m: function m(target, anchor) {
	      insert(target, div, anchor);
	      html_tag.m(cornerDownLeft, div);
	      append(div, t0);
	      append(div, span);

	      if (!mounted) {
	        dispose = [listen(div, "click",
	        /*backToParent*/
	        ctx[7]), listen(div, "keydown", keydown_handler_2), listen(div, "keypress", keypress_handler_2)];
	        mounted = true;
	      }
	    },
	    p: noop,
	    d: function d(detaching) {
	      if (detaching) detach(div);
	      mounted = false;
	      run_all(dispose);
	    }
	  };
	}

	function create_fragment$c(ctx) {
	  var div0;
	  var h2;
	  var t0_value =
	  /*activeCollection*/
	  ctx[0].title + "";
	  var t0;
	  var t1;
	  var t2;
	  var t3;
	  var t4;
	  var t5;
	  var div1;
	  var current;
	  var if_block0 =
	  /*activeCollection*/
	  ctx[0].description && create_if_block_13(ctx);
	  var if_block1 =
	  /*activeCollection*/
	  ctx[0].warning && create_if_block_12(ctx);
	  var if_block2 =
	  /*activeCollection*/
	  ctx[0].variations && create_if_block_7$1(ctx);
	  var each_value =
	  /*activeCollection*/
	  ctx[0].items;
	  var each_blocks = [];

	  for (var i = 0; i < each_value.length; i += 1) {
	    each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
	  }

	  var out = function out(i) {
	    return transition_out(each_blocks[i], 1, 1, function () {
	      each_blocks[i] = null;
	    });
	  };

	  var if_block3 =
	  /*collectionStack*/
	  ctx[1].length > 1 && create_if_block$6(ctx);
	  return {
	    c: function c() {
	      div0 = element("div");
	      h2 = element("h2");
	      t0 = text(t0_value);
	      t1 = space();
	      if (if_block0) if_block0.c();
	      t2 = space();
	      if (if_block1) if_block1.c();
	      t3 = space();
	      if (if_block2) if_block2.c();
	      t4 = space();

	      for (var _i7 = 0; _i7 < each_blocks.length; _i7 += 1) {
	        each_blocks[_i7].c();
	      }

	      t5 = space();
	      div1 = element("div");
	      if (if_block3) if_block3.c();
	      attr(h2, "class", "svelte-16vwvhb");
	      attr(div0, "class", "select svelte-16vwvhb");
	      attr(div1, "class", "menu menu-footer svelte-16vwvhb");
	    },
	    m: function m(target, anchor) {
	      insert(target, div0, anchor);
	      append(div0, h2);
	      append(h2, t0);
	      append(div0, t1);
	      if (if_block0) if_block0.m(div0, null);
	      append(div0, t2);
	      if (if_block1) if_block1.m(div0, null);
	      append(div0, t3);
	      if (if_block2) if_block2.m(div0, null);
	      append(div0, t4);

	      for (var _i8 = 0; _i8 < each_blocks.length; _i8 += 1) {
	        each_blocks[_i8].m(div0, null);
	      }

	      insert(target, t5, anchor);
	      insert(target, div1, anchor);
	      if (if_block3) if_block3.m(div1, null);
	      current = true;
	    },
	    p: function p(ctx, _ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	          dirty = _ref2[0];

	      if ((!current || dirty &
	      /*activeCollection*/
	      1) && t0_value !== (t0_value =
	      /*activeCollection*/
	      ctx[0].title + "")) set_data(t0, t0_value);

	      if (
	      /*activeCollection*/
	      ctx[0].description) {
	        if (if_block0) {
	          if_block0.p(ctx, dirty);
	        } else {
	          if_block0 = create_if_block_13(ctx);
	          if_block0.c();
	          if_block0.m(div0, t2);
	        }
	      } else if (if_block0) {
	        if_block0.d(1);
	        if_block0 = null;
	      }

	      if (
	      /*activeCollection*/
	      ctx[0].warning) {
	        if (if_block1) {
	          if_block1.p(ctx, dirty);
	        } else {
	          if_block1 = create_if_block_12(ctx);
	          if_block1.c();
	          if_block1.m(div0, t3);
	        }
	      } else if (if_block1) {
	        if_block1.d(1);
	        if_block1 = null;
	      }

	      if (
	      /*activeCollection*/
	      ctx[0].variations) {
	        if (if_block2) {
	          if_block2.p(ctx, dirty);

	          if (dirty &
	          /*activeCollection*/
	          1) {
	            transition_in(if_block2, 1);
	          }
	        } else {
	          if_block2 = create_if_block_7$1(ctx);
	          if_block2.c();
	          transition_in(if_block2, 1);
	          if_block2.m(div0, t4);
	        }
	      } else if (if_block2) {
	        group_outros();
	        transition_out(if_block2, 1, 1, function () {
	          if_block2 = null;
	        });
	        check_outros();
	      }

	      if (dirty &
	      /*selectItem, activeCollection, nullHandler, previewScale, ROLE_MAP, circlePlus*/
	      101) {
	        each_value =
	        /*activeCollection*/
	        ctx[0].items;

	        var _i9;

	        for (_i9 = 0; _i9 < each_value.length; _i9 += 1) {
	          var child_ctx = get_each_context$3(ctx, each_value, _i9);

	          if (each_blocks[_i9]) {
	            each_blocks[_i9].p(child_ctx, dirty);

	            transition_in(each_blocks[_i9], 1);
	          } else {
	            each_blocks[_i9] = create_each_block$3(child_ctx);

	            each_blocks[_i9].c();

	            transition_in(each_blocks[_i9], 1);

	            each_blocks[_i9].m(div0, null);
	          }
	        }

	        group_outros();

	        for (_i9 = each_value.length; _i9 < each_blocks.length; _i9 += 1) {
	          out(_i9);
	        }

	        check_outros();
	      }

	      if (
	      /*collectionStack*/
	      ctx[1].length > 1) {
	        if (if_block3) {
	          if_block3.p(ctx, dirty);
	        } else {
	          if_block3 = create_if_block$6(ctx);
	          if_block3.c();
	          if_block3.m(div1, null);
	        }
	      } else if (if_block3) {
	        if_block3.d(1);
	        if_block3 = null;
	      }
	    },
	    i: function i(local) {
	      if (current) return;
	      transition_in(if_block2);

	      for (var _i10 = 0; _i10 < each_value.length; _i10 += 1) {
	        transition_in(each_blocks[_i10]);
	      }

	      current = true;
	    },
	    o: function o(local) {
	      transition_out(if_block2);
	      each_blocks = each_blocks.filter(Boolean);

	      for (var _i11 = 0; _i11 < each_blocks.length; _i11 += 1) {
	        transition_out(each_blocks[_i11]);
	      }

	      current = false;
	    },
	    d: function d(detaching) {
	      if (detaching) detach(div0);
	      if (if_block0) if_block0.d();
	      if (if_block1) if_block1.d();
	      if (if_block2) if_block2.d();
	      destroy_each(each_blocks, detaching);
	      if (detaching) detach(t5);
	      if (detaching) detach(div1);
	      if (if_block3) if_block3.d();
	    }
	  };
	}

	var keydown_handler$1 = function keydown_handler() {
	  return null;
	};

	var keypress_handler = function keypress_handler() {
	  return null;
	};

	var keydown_handler_1 = function keydown_handler_1() {
	  return null;
	};

	var keypress_handler_1 = function keypress_handler_1() {
	  return null;
	};

	var keydown_handler_2 = function keydown_handler_2() {
	  return null;
	};

	var keypress_handler_2 = function keypress_handler_2() {
	  return null;
	};

	function instance$c($$self, $$props, $$invalidate) {
	  var DEFAULT_ICON_COLORS = ['#000000', '#00aeff', '#ffc400', '#ff008c'];
	  var DEFAULT_ICON_SIZES = [6, 8, 10, 14];
	  var ROLE_MAP = {
	    advanced: 'Advanced Role Only'
	  };
	  var options = $$props.options;
	  var collection = $$props.collection;
	  var onComplete = $$props.onComplete;
	  var activeCollection = collection;
	  var collectionStack = [activeCollection]; // TODO :: derive from external options

	  var iconColors = DEFAULT_ICON_COLORS;
	  var iconSizes = DEFAULT_ICON_SIZES; // scale is now set to scaleLinear

	  var previewScale = scaleLinear(options); // if selected item is a collection load into view, otherwise
	  // finalize selection for placement

	  function selectItem() {
	    var item = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	    if (item.type === 'collection') {
	      $$invalidate(1, collectionStack = collectionStack.concat([item]));
	      clearItemsThen(function () {
	        $$invalidate(0, activeCollection = item);
	      });
	    } else {
	      // create one more screen if typeVariations are set
	      if (item._typeVariations) {
	        clearItemsThen(function () {
	          // now set as new collection
	          var newCollection = createTypeVariations(item);
	          $$invalidate(1, collectionStack = collectionStack.concat([newCollection]));
	          $$invalidate(0, activeCollection = newCollection);
	        });
	      } else {
	        var selected = item.previewItem ? item.previewItem : item; // pass a clone of the selected item back
	        // to the callback

	        onComplete(filterUnderscoreProperties(selected));
	      }
	    }
	  } // get around an issue with preview items rendering over eachother


	  function clearItemsThen(callback) {
	    $$invalidate(0, activeCollection = _objectSpread2(_objectSpread2({}, activeCollection), {}, {
	      items: []
	    }));
	    setTimeout(callback, 1);
	  } // simply go one up to prior collection


	  function backToParent() {
	    $$invalidate(1, collectionStack = collectionStack.slice(0, -1));
	    clearItemsThen(function () {
	      $$invalidate(0, activeCollection = collectionStack[collectionStack.length - 1]);
	    });
	  }

	  function updateActiveItems(updates) {
	    $$invalidate(0, activeCollection.items = activeCollection.items.map(function (item) {
	      return _objectSpread2(_objectSpread2({}, item), updates);
	    }), activeCollection);
	  }

	  function setIconColor(color) {
	    updateActiveItems({
	      iconColor: color
	    });
	  }

	  function setIconSize(size) {
	    updateActiveItems({
	      iconSize: size
	    });
	  }

	  function setAlign(alignment) {
	    updateActiveItems({
	      align: alignment,
	      x: previewAlignX(alignment)
	    });
	  }

	  function setValign(alignment) {
	    updateActiveItems({
	      valign: alignment,
	      y: previewAlignY(alignment)
	    });
	  }

	  var click_handler = function click_handler(item) {
	    return selectItem(item);
	  };

	  var click_handler_1 = function click_handler_1(item) {
	    return selectItem(item);
	  };

	  $$self.$$set = function ($$props) {
	    if ('options' in $$props) $$invalidate(12, options = $$props.options);
	    if ('collection' in $$props) $$invalidate(13, collection = $$props.collection);
	    if ('onComplete' in $$props) $$invalidate(14, onComplete = $$props.onComplete);
	  };

	  return [activeCollection, collectionStack, ROLE_MAP, iconColors, iconSizes, previewScale, selectItem, backToParent, setIconColor, setIconSize, setAlign, setValign, options, collection, onComplete, click_handler, click_handler_1];
	}

	var EditorSelect = /*#__PURE__*/function (_SvelteComponent) {
	  _inherits(EditorSelect, _SvelteComponent);

	  var _super = _createSuper(EditorSelect);

	  function EditorSelect(options) {
	    var _this;

	    _classCallCheck(this, EditorSelect);

	    _this = _super.call(this);
	    init(_assertThisInitialized(_this), options, instance$c, create_fragment$c, safe_not_equal, {
	      options: 12,
	      collection: 13,
	      onComplete: 14
	    }, add_css$b);
	    return _this;
	  }

	  _createClass(EditorSelect, [{
	    key: "options",
	    get: function get() {
	      return this.$$.ctx[12];
	    },
	    set: function set(options) {
	      this.$$set({
	        options: options
	      });
	      flush();
	    }
	  }, {
	    key: "collection",
	    get: function get() {
	      return this.$$.ctx[13];
	    },
	    set: function set(collection) {
	      this.$$set({
	        collection: collection
	      });
	      flush();
	    }
	  }, {
	    key: "onComplete",
	    get: function get() {
	      return this.$$.ctx[14];
	    },
	    set: function set(onComplete) {
	      this.$$set({
	        onComplete: onComplete
	      });
	      flush();
	    }
	  }]);

	  return EditorSelect;
	}(SvelteComponent);

	var closeIcon = "<svg xmlns=\"http://www.w3.org/2000/svg\" class=\"icon icon-tabler icon-tabler-circle-x\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" stroke-width=\"2\" stroke=\"currentColor\" fill=\"none\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n  <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\"/>\n  <circle cx=\"12\" cy=\"12\" r=\"9\" />\n  <path d=\"M10 10l4 4m0 -4l-4 4\" />\n</svg>";

	function add_css$a(target) {
	  append_styles(target, "svelte-10vlykt", ".dialog.svelte-10vlykt{z-index:100;width:220px;position:absolute;top:0;left:101%;background:#eeeeee;box-shadow:3px 3px 4px rgba(41, 32, 226, .13);border-radius:3px;border:1px solid #001aaa;padding:8px}button.closer.svelte-10vlykt{position:absolute;cursor:pointer;color:#001aaa;background:#eeeeee;right:0;top:2px;z-index:100;font-size:12px;font-weight:bold;border:none;box-shadow:none}button.closer.svelte-10vlykt:hover{color:#a4a4d5;background:transparent}button.closer svg{width:18px;height:18px}.handle.dialog > svg{display:inline-block;max-height:14px;color:#001aaa;margin:6px -8.5px;padding:0}.dialog > div{position:relative;margin:8px 0;font-size:12px}");
	}

	var get_content_slot_changes$1 = function get_content_slot_changes(dirty) {
	  return {};
	};

	var get_content_slot_context$1 = function get_content_slot_context(ctx) {
	  return {};
	};

	function create_fragment$b(ctx) {
	  var div;
	  var button;
	  var t0;
	  var draghandle;
	  var t1;
	  var div_class_value;
	  var current;
	  var mounted;
	  var dispose;
	  draghandle = new DragHandle({
	    props: {
	      id:
	      /*id*/
	      ctx[5],
	      handleWidth:
	      /*width*/
	      ctx[3] - 20,
	      handleHeight: 4,
	      maxDrag: 500,
	      color: "transparent",
	      x: (
	      /*width*/
	      ctx[3] - 20) / 2,
	      y: -8,
	      active: true,
	      handleClass: "dialog",
	      onChange:
	      /*handleReposition*/
	      ctx[7]
	    }
	  });
	  var content_slot_template =
	  /*#slots*/
	  ctx[10].content;
	  var content_slot = create_slot(content_slot_template, ctx,
	  /*$$scope*/
	  ctx[9], get_content_slot_context$1);
	  return {
	    c: function c() {
	      div = element("div");
	      button = element("button");
	      t0 = space();
	      create_component(draghandle.$$.fragment);
	      t1 = space();
	      if (content_slot) content_slot.c();
	      attr(button, "class", "closer svelte-10vlykt");
	      attr(div, "class", div_class_value = "dialog " +
	      /*className*/
	      ctx[2] + " svelte-10vlykt");
	      set_style(div, "left",
	      /*x*/
	      ctx[0] + "px");
	      set_style(div, "top",
	      /*y*/
	      ctx[1] + "px");
	      set_style(div, "width",
	      /*width*/
	      ctx[3] + "px");
	    },
	    m: function m(target, anchor) {
	      insert(target, div, anchor);
	      append(div, button);
	      button.innerHTML = closeIcon;
	      append(div, t0);
	      mount_component(draghandle, div, null);
	      append(div, t1);

	      if (content_slot) {
	        content_slot.m(div, null);
	      }
	      /*div_binding*/


	      ctx[11](div);
	      current = true;

	      if (!mounted) {
	        dispose = listen(button, "click",
	        /*closeAction*/
	        ctx[6]);
	        mounted = true;
	      }
	    },
	    p: function p(ctx, _ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	          dirty = _ref2[0];

	      var draghandle_changes = {};
	      if (dirty &
	      /*width*/
	      8) draghandle_changes.handleWidth =
	      /*width*/
	      ctx[3] - 20;
	      if (dirty &
	      /*width*/
	      8) draghandle_changes.x = (
	      /*width*/
	      ctx[3] - 20) / 2;
	      draghandle.$set(draghandle_changes);

	      if (content_slot) {
	        if (content_slot.p && (!current || dirty &
	        /*$$scope*/
	        512)) {
	          update_slot_base(content_slot, content_slot_template, ctx,
	          /*$$scope*/
	          ctx[9], !current ? get_all_dirty_from_scope(
	          /*$$scope*/
	          ctx[9]) : get_slot_changes(content_slot_template,
	          /*$$scope*/
	          ctx[9], dirty, get_content_slot_changes$1), get_content_slot_context$1);
	        }
	      }

	      if (!current || dirty &
	      /*className*/
	      4 && div_class_value !== (div_class_value = "dialog " +
	      /*className*/
	      ctx[2] + " svelte-10vlykt")) {
	        attr(div, "class", div_class_value);
	      }

	      if (!current || dirty &
	      /*x*/
	      1) {
	        set_style(div, "left",
	        /*x*/
	        ctx[0] + "px");
	      }

	      if (!current || dirty &
	      /*y*/
	      2) {
	        set_style(div, "top",
	        /*y*/
	        ctx[1] + "px");
	      }

	      if (!current || dirty &
	      /*width*/
	      8) {
	        set_style(div, "width",
	        /*width*/
	        ctx[3] + "px");
	      }
	    },
	    i: function i(local) {
	      if (current) return;
	      transition_in(draghandle.$$.fragment, local);
	      transition_in(content_slot, local);
	      current = true;
	    },
	    o: function o(local) {
	      transition_out(draghandle.$$.fragment, local);
	      transition_out(content_slot, local);
	      current = false;
	    },
	    d: function d(detaching) {
	      if (detaching) detach(div);
	      destroy_component(draghandle);
	      if (content_slot) content_slot.d(detaching);
	      /*div_binding*/

	      ctx[11](null);
	      mounted = false;
	      dispose();
	    }
	  };
	}

	function instance$b($$self, $$props, $$invalidate) {
	  var _$$props$$$slots = $$props.$$slots,
	      slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots,
	      $$scope = $$props.$$scope;
	  var onClose = $$props.onClose;
	  var _$$props$className = $$props.className,
	      className = _$$props$className === void 0 ? '' : _$$props$className;
	  var _$$props$width = $$props.width,
	      width = _$$props$width === void 0 ? 220 : _$$props$width;
	  var _$$props$x = $$props.x,
	      x = _$$props$x === void 0 ? 0 : _$$props$x;
	  var _$$props$y = $$props.y,
	      y = _$$props$y === void 0 ? 0 : _$$props$y;
	  var id = Math.round(Math.random() * 99999);
	  var dialogElement;

	  function closeAction() {
	    onClose();
	  }

	  function handleReposition(props) {
	    $$invalidate(0, x = x + props.x - (width - 20));
	    $$invalidate(1, y = y + props.y);
	  }

	  function div_binding($$value) {
	    binding_callbacks[$$value ? 'unshift' : 'push'](function () {
	      dialogElement = $$value;
	      $$invalidate(4, dialogElement);
	    });
	  }

	  $$self.$$set = function ($$props) {
	    if ('onClose' in $$props) $$invalidate(8, onClose = $$props.onClose);
	    if ('className' in $$props) $$invalidate(2, className = $$props.className);
	    if ('width' in $$props) $$invalidate(3, width = $$props.width);
	    if ('x' in $$props) $$invalidate(0, x = $$props.x);
	    if ('y' in $$props) $$invalidate(1, y = $$props.y);
	    if ('$$scope' in $$props) $$invalidate(9, $$scope = $$props.$$scope);
	  };

	  return [x, y, className, width, dialogElement, id, closeAction, handleReposition, onClose, $$scope, slots, div_binding];
	}

	var Dialog = /*#__PURE__*/function (_SvelteComponent) {
	  _inherits(Dialog, _SvelteComponent);

	  var _super = _createSuper(Dialog);

	  function Dialog(options) {
	    var _this;

	    _classCallCheck(this, Dialog);

	    _this = _super.call(this);
	    init(_assertThisInitialized(_this), options, instance$b, create_fragment$b, safe_not_equal, {
	      onClose: 8,
	      className: 2,
	      width: 3,
	      x: 0,
	      y: 1
	    }, add_css$a);
	    return _this;
	  }

	  _createClass(Dialog, [{
	    key: "onClose",
	    get: function get() {
	      return this.$$.ctx[8];
	    },
	    set: function set(onClose) {
	      this.$$set({
	        onClose: onClose
	      });
	      flush();
	    }
	  }, {
	    key: "className",
	    get: function get() {
	      return this.$$.ctx[2];
	    },
	    set: function set(className) {
	      this.$$set({
	        className: className
	      });
	      flush();
	    }
	  }, {
	    key: "width",
	    get: function get() {
	      return this.$$.ctx[3];
	    },
	    set: function set(width) {
	      this.$$set({
	        width: width
	      });
	      flush();
	    }
	  }, {
	    key: "x",
	    get: function get() {
	      return this.$$.ctx[0];
	    },
	    set: function set(x) {
	      this.$$set({
	        x: x
	      });
	      flush();
	    }
	  }, {
	    key: "y",
	    get: function get() {
	      return this.$$.ctx[1];
	    },
	    set: function set(y) {
	      this.$$set({
	        y: y
	      });
	      flush();
	    }
	  }]);

	  return Dialog;
	}(SvelteComponent);

	function add_css$9(target) {
	  append_styles(target, "svelte-x0z9ju", "div.svelte-x0z9ju{max-height:610px;overflow-y:auto;overflow-x:hidden}");
	} // (33:2) 


	function create_content_slot$1(ctx) {
	  var div;
	  var editorselect;
	  var current;
	  editorselect = new EditorSelect({
	    props: {
	      options:
	      /*options*/
	      ctx[0],
	      collection:
	      /*collection*/
	      ctx[1],
	      onComplete:
	      /*onComplete*/
	      ctx[2]
	    }
	  });
	  return {
	    c: function c() {
	      div = element("div");
	      create_component(editorselect.$$.fragment);
	      attr(div, "slot", "content");
	      attr(div, "class", "svelte-x0z9ju");
	    },
	    m: function m(target, anchor) {
	      insert(target, div, anchor);
	      mount_component(editorselect, div, null);
	      current = true;
	    },
	    p: function p(ctx, dirty) {
	      var editorselect_changes = {};
	      if (dirty &
	      /*options*/
	      1) editorselect_changes.options =
	      /*options*/
	      ctx[0];
	      if (dirty &
	      /*collection*/
	      2) editorselect_changes.collection =
	      /*collection*/
	      ctx[1];
	      if (dirty &
	      /*onComplete*/
	      4) editorselect_changes.onComplete =
	      /*onComplete*/
	      ctx[2];
	      editorselect.$set(editorselect_changes);
	    },
	    i: function i(local) {
	      if (current) return;
	      transition_in(editorselect.$$.fragment, local);
	      current = true;
	    },
	    o: function o(local) {
	      transition_out(editorselect.$$.fragment, local);
	      current = false;
	    },
	    d: function d(detaching) {
	      if (detaching) detach(div);
	      destroy_component(editorselect);
	    }
	  };
	}

	function create_fragment$a(ctx) {
	  var dialog;
	  var current;
	  dialog = new Dialog({
	    props: {
	      className: "dialog",
	      width: "450",
	      x: 5,
	      y: 5,
	      onClose:
	      /*closeDialog*/
	      ctx[3],
	      $$slots: {
	        content: [create_content_slot$1]
	      },
	      $$scope: {
	        ctx: ctx
	      }
	    }
	  });
	  return {
	    c: function c() {
	      create_component(dialog.$$.fragment);
	    },
	    m: function m(target, anchor) {
	      mount_component(dialog, target, anchor);
	      current = true;
	    },
	    p: function p(ctx, _ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	          dirty = _ref2[0];

	      var dialog_changes = {};

	      if (dirty &
	      /*$$scope, options, collection, onComplete*/
	      23) {
	        dialog_changes.$$scope = {
	          dirty: dirty,
	          ctx: ctx
	        };
	      }

	      dialog.$set(dialog_changes);
	    },
	    i: function i(local) {
	      if (current) return;
	      transition_in(dialog.$$.fragment, local);
	      current = true;
	    },
	    o: function o(local) {
	      transition_out(dialog.$$.fragment, local);
	      current = false;
	    },
	    d: function d(detaching) {
	      destroy_component(dialog, detaching);
	    }
	  };
	}

	function instance$a($$self, $$props, $$invalidate) {
	  var options = $$props.options;
	  var collection = $$props.collection;
	  var onComplete = $$props.onComplete;

	  function closeDialog() {
	    onComplete();
	  }

	  $$self.$$set = function ($$props) {
	    if ('options' in $$props) $$invalidate(0, options = $$props.options);
	    if ('collection' in $$props) $$invalidate(1, collection = $$props.collection);
	    if ('onComplete' in $$props) $$invalidate(2, onComplete = $$props.onComplete);
	  };

	  return [options, collection, onComplete, closeDialog];
	}

	var EditorAddDialog = /*#__PURE__*/function (_SvelteComponent) {
	  _inherits(EditorAddDialog, _SvelteComponent);

	  var _super = _createSuper(EditorAddDialog);

	  function EditorAddDialog(options) {
	    var _this;

	    _classCallCheck(this, EditorAddDialog);

	    _this = _super.call(this);
	    init(_assertThisInitialized(_this), options, instance$a, create_fragment$a, safe_not_equal, {
	      options: 0,
	      collection: 1,
	      onComplete: 2
	    }, add_css$9);
	    return _this;
	  }

	  _createClass(EditorAddDialog, [{
	    key: "options",
	    get: function get() {
	      return this.$$.ctx[0];
	    },
	    set: function set(options) {
	      this.$$set({
	        options: options
	      });
	      flush();
	    }
	  }, {
	    key: "collection",
	    get: function get() {
	      return this.$$.ctx[1];
	    },
	    set: function set(collection) {
	      this.$$set({
	        collection: collection
	      });
	      flush();
	    }
	  }, {
	    key: "onComplete",
	    get: function get() {
	      return this.$$.ctx[2];
	    },
	    set: function set(onComplete) {
	      this.$$set({
	        onComplete: onComplete
	      });
	      flush();
	    }
	  }]);

	  return EditorAddDialog;
	}(SvelteComponent);

	function add_css$8(target) {
	  append_styles(target, "svelte-1oc08qn", ".placement.svelte-1oc08qn.svelte-1oc08qn{z-index:100;position:absolute;top:0;right:0;width:100%;height:100%;overflow:auto;background:linear-gradient(to bottom, #ffffff00 0%,#c6d7ff80 100%);cursor:cell;pointer-events:all}.placement.svelte-1oc08qn h2.svelte-1oc08qn{font-size:24px;color:#001aaa;opacity:0.9;font-family:sans-serif;position:absolute;top:50%;left:50%;transform:translate(-50%, -50%);pointer-events:none}");
	}

	function create_fragment$9(ctx) {
	  var div;
	  var h2;
	  var t;
	  var mounted;
	  var dispose;
	  return {
	    c: function c() {
	      div = element("div");
	      h2 = element("h2");
	      t = text(
	      /*placementMessage*/
	      ctx[0]);
	      attr(h2, "class", "svelte-1oc08qn");
	      attr(div, "class", "placement svelte-1oc08qn");
	      attr(div, "style",
	      /*placementStyle*/
	      ctx[1]);
	    },
	    m: function m(target, anchor) {
	      insert(target, div, anchor);
	      append(div, h2);
	      append(h2, t);

	      if (!mounted) {
	        dispose = [listen(div, "click",
	        /*placeDraggable*/
	        ctx[2]), listen(div, "keydown", keydown_handler)];
	        mounted = true;
	      }
	    },
	    p: function p(ctx, _ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	          dirty = _ref2[0];

	      if (dirty &
	      /*placementMessage*/
	      1) set_data(t,
	      /*placementMessage*/
	      ctx[0]);

	      if (dirty &
	      /*placementStyle*/
	      2) {
	        attr(div, "style",
	        /*placementStyle*/
	        ctx[1]);
	      }
	    },
	    i: noop,
	    o: noop,
	    d: function d(detaching) {
	      if (detaching) detach(div);
	      mounted = false;
	      run_all(dispose);
	    }
	  };
	}

	var keydown_handler = function keydown_handler() {
	  return null;
	};

	function instance$9($$self, $$props, $$invalidate) {
	  var editorBounds;
	  var targetBounds;
	  var targetHeight;
	  var placementStyle;
	  var draggable = $$props.draggable; // the item to be placed

	  var scale = $$props.scale;
	  var options = $$props.options;
	  var editorTarget = $$props.editorTarget;
	  var draggablesTarget = $$props.draggablesTarget;
	  var onComplete = $$props.onComplete;
	  var addDraggable = $$props.addDraggable;
	  var containerWidth = $$props.containerWidth;
	  var _$$props$placementMes = $$props.placementMessage,
	      placementMessage = _$$props$placementMes === void 0 ? 'Place your draggable' : _$$props$placementMes;

	  function placeDraggable(_ref3) {
	    var offsetX = _ref3.offsetX,
	        offsetY = _ref3.offsetY;

	    var _scale$invert = scale.invert(containerWidth, [offsetX, offsetY]),
	        _scale$invert2 = _slicedToArray(_scale$invert, 2),
	        newX = _scale$invert2[0],
	        newY = _scale$invert2[1];

	    $$invalidate(3, draggable.id = Math.round(Math.random() * 99999), draggable);
	    $$invalidate(3, draggable.x = newX, draggable);
	    $$invalidate(3, draggable.y = newY, draggable);
	    addDraggable(draggable);
	    onComplete(draggable);
	  }

	  $$self.$$set = function ($$props) {
	    if ('draggable' in $$props) $$invalidate(3, draggable = $$props.draggable);
	    if ('scale' in $$props) $$invalidate(4, scale = $$props.scale);
	    if ('options' in $$props) $$invalidate(5, options = $$props.options);
	    if ('editorTarget' in $$props) $$invalidate(6, editorTarget = $$props.editorTarget);
	    if ('draggablesTarget' in $$props) $$invalidate(7, draggablesTarget = $$props.draggablesTarget);
	    if ('onComplete' in $$props) $$invalidate(8, onComplete = $$props.onComplete);
	    if ('addDraggable' in $$props) $$invalidate(9, addDraggable = $$props.addDraggable);
	    if ('containerWidth' in $$props) $$invalidate(10, containerWidth = $$props.containerWidth);
	    if ('placementMessage' in $$props) $$invalidate(0, placementMessage = $$props.placementMessage);
	  };

	  $$self.$$.update = function () {
	    if ($$self.$$.dirty &
	    /*editorTarget*/
	    64) {
	      $$invalidate(13, editorBounds = editorTarget.getBoundingClientRect());
	    }

	    if ($$self.$$.dirty &
	    /*draggablesTarget, editorBounds*/
	    8320) {
	      $$invalidate(12, targetBounds = draggablesTarget ? draggablesTarget.getBoundingClientRect() : editorBounds);
	    }

	    if ($$self.$$.dirty &
	    /*draggablesTarget*/
	    128) {
	      $$invalidate(11, targetHeight = getNonZeroContainerHeight(draggablesTarget));
	    }

	    if ($$self.$$.dirty &
	    /*targetBounds, editorBounds, targetHeight, options*/
	    14368) {
	      $$invalidate(1, placementStyle = "\n      top: ".concat(targetBounds.y - editorBounds.y, "px;\n      left: ").concat(targetBounds.x - editorBounds.x, "px;\n      width: ").concat(targetBounds.width, "px;\n      height: ").concat(Math.max(targetHeight, options.minimumCanvasHeight || 0), "px;\n    "));
	    }
	  };

	  return [placementMessage, placementStyle, placeDraggable, draggable, scale, options, editorTarget, draggablesTarget, onComplete, addDraggable, containerWidth, targetHeight, targetBounds, editorBounds];
	}

	var EditorPlacement = /*#__PURE__*/function (_SvelteComponent) {
	  _inherits(EditorPlacement, _SvelteComponent);

	  var _super = _createSuper(EditorPlacement);

	  function EditorPlacement(options) {
	    var _this;

	    _classCallCheck(this, EditorPlacement);

	    _this = _super.call(this);
	    init(_assertThisInitialized(_this), options, instance$9, create_fragment$9, safe_not_equal, {
	      draggable: 3,
	      scale: 4,
	      options: 5,
	      editorTarget: 6,
	      draggablesTarget: 7,
	      onComplete: 8,
	      addDraggable: 9,
	      containerWidth: 10,
	      placementMessage: 0
	    }, add_css$8);
	    return _this;
	  }

	  _createClass(EditorPlacement, [{
	    key: "draggable",
	    get: function get() {
	      return this.$$.ctx[3];
	    },
	    set: function set(draggable) {
	      this.$$set({
	        draggable: draggable
	      });
	      flush();
	    }
	  }, {
	    key: "scale",
	    get: function get() {
	      return this.$$.ctx[4];
	    },
	    set: function set(scale) {
	      this.$$set({
	        scale: scale
	      });
	      flush();
	    }
	  }, {
	    key: "options",
	    get: function get() {
	      return this.$$.ctx[5];
	    },
	    set: function set(options) {
	      this.$$set({
	        options: options
	      });
	      flush();
	    }
	  }, {
	    key: "editorTarget",
	    get: function get() {
	      return this.$$.ctx[6];
	    },
	    set: function set(editorTarget) {
	      this.$$set({
	        editorTarget: editorTarget
	      });
	      flush();
	    }
	  }, {
	    key: "draggablesTarget",
	    get: function get() {
	      return this.$$.ctx[7];
	    },
	    set: function set(draggablesTarget) {
	      this.$$set({
	        draggablesTarget: draggablesTarget
	      });
	      flush();
	    }
	  }, {
	    key: "onComplete",
	    get: function get() {
	      return this.$$.ctx[8];
	    },
	    set: function set(onComplete) {
	      this.$$set({
	        onComplete: onComplete
	      });
	      flush();
	    }
	  }, {
	    key: "addDraggable",
	    get: function get() {
	      return this.$$.ctx[9];
	    },
	    set: function set(addDraggable) {
	      this.$$set({
	        addDraggable: addDraggable
	      });
	      flush();
	    }
	  }, {
	    key: "containerWidth",
	    get: function get() {
	      return this.$$.ctx[10];
	    },
	    set: function set(containerWidth) {
	      this.$$set({
	        containerWidth: containerWidth
	      });
	      flush();
	    }
	  }, {
	    key: "placementMessage",
	    get: function get() {
	      return this.$$.ctx[0];
	    },
	    set: function set(placementMessage) {
	      this.$$set({
	        placementMessage: placementMessage
	      });
	      flush();
	    }
	  }]);

	  return EditorPlacement;
	}(SvelteComponent);

	function add_css$7(target) {
	  append_styles(target, "svelte-15lutl9", ".dialog.svelte-15lutl9.svelte-15lutl9{font-family:sans-serif;z-index:100;position:absolute;top:0;right:0;background:white;border:1px solid black;padding:8px;width:350px}.dialog.svelte-15lutl9 button.closer.svelte-15lutl9{position:absolute;right:0;top:2px;z-index:100;font-size:10px;border:none}.dialog.svelte-15lutl9 div.svelte-15lutl9{position:relative;margin:6px 0;font-size:12px}");
	}

	function get_each_context$2(ctx, list, i) {
	  var child_ctx = ctx.slice();
	  child_ctx[11] = list[i];
	  child_ctx[12] = list;
	  child_ctx[13] = i;
	  return child_ctx;
	}

	function get_each_context_1$1(ctx, list, i) {
	  var child_ctx = ctx.slice();
	  child_ctx[14] = list[i];
	  return child_ctx;
	} // (65:6) {#each scaleOptions as opt}


	function create_each_block_1$1(ctx) {
	  var option;
	  var t_value =
	  /*opt*/
	  ctx[14].label + "";
	  var t;
	  return {
	    c: function c() {
	      option = element("option");
	      t = text(t_value);
	      option.__value = /*opt*/
	      ctx[14].type;
	      option.value = option.__value;
	    },
	    m: function m(target, anchor) {
	      insert(target, option, anchor);
	      append(option, t);
	    },
	    p: noop,
	    d: function d(detaching) {
	      if (detaching) detach(option);
	    }
	  };
	} // (73:4) {#each options.breakpoints as breakpoint}


	function create_each_block$2(ctx) {
	  var div;
	  var input0;
	  var t;
	  var input1;
	  var mounted;
	  var dispose;

	  function input0_input_handler() {
	    /*input0_input_handler*/
	    ctx[9].call(input0,
	    /*each_value*/
	    ctx[12],
	    /*breakpoint_index*/
	    ctx[13]);
	  }

	  function input1_input_handler() {
	    /*input1_input_handler*/
	    ctx[10].call(input1,
	    /*each_value*/
	    ctx[12],
	    /*breakpoint_index*/
	    ctx[13]);
	  }

	  return {
	    c: function c() {
	      div = element("div");
	      input0 = element("input");
	      t = space();
	      input1 = element("input");
	      attr(input0, "placeholder", "name");
	      attr(input1, "placeholder", "size");
	      attr(input1, "type", "number");
	      set_style(div, "padding-left", "10px");
	      attr(div, "class", "svelte-15lutl9");
	    },
	    m: function m(target, anchor) {
	      insert(target, div, anchor);
	      append(div, input0);
	      set_input_value(input0,
	      /*breakpoint*/
	      ctx[11].name);
	      append(div, t);
	      append(div, input1);
	      set_input_value(input1,
	      /*breakpoint*/
	      ctx[11].size);

	      if (!mounted) {
	        dispose = [listen(input0, "input", input0_input_handler), listen(input1, "input", input1_input_handler)];
	        mounted = true;
	      }
	    },
	    p: function p(new_ctx, dirty) {
	      ctx = new_ctx;

	      if (dirty &
	      /*options, scaleOptions*/
	      5 && input0.value !==
	      /*breakpoint*/
	      ctx[11].name) {
	        set_input_value(input0,
	        /*breakpoint*/
	        ctx[11].name);
	      }

	      if (dirty &
	      /*options, scaleOptions*/
	      5 && to_number(input1.value) !==
	      /*breakpoint*/
	      ctx[11].size) {
	        set_input_value(input1,
	        /*breakpoint*/
	        ctx[11].size);
	      }
	    },
	    d: function d(detaching) {
	      if (detaching) detach(div);
	      mounted = false;
	      run_all(dispose);
	    }
	  };
	}

	function create_fragment$8(ctx) {
	  var div4;
	  var button0;
	  var t1;
	  var div0;
	  var t2;
	  var select;
	  var t3;
	  var div1;
	  var t4;
	  var br;
	  var t5;
	  var t6;
	  var button1;
	  var t8;
	  var button2;
	  var t10;
	  var div3;
	  var div2;
	  var textarea;
	  var t11;
	  var button3;
	  var mounted;
	  var dispose;
	  var each_value_1 =
	  /*scaleOptions*/
	  ctx[2];
	  var each_blocks_1 = [];

	  for (var i = 0; i < each_value_1.length; i += 1) {
	    each_blocks_1[i] = create_each_block_1$1(get_each_context_1$1(ctx, each_value_1, i));
	  }

	  var each_value =
	  /*options*/
	  ctx[0].breakpoints;
	  var each_blocks = [];

	  for (var _i = 0; _i < each_value.length; _i += 1) {
	    each_blocks[_i] = create_each_block$2(get_each_context$2(ctx, each_value, _i));
	  }

	  return {
	    c: function c() {
	      div4 = element("div");
	      button0 = element("button");
	      button0.textContent = "X";
	      t1 = space();
	      div0 = element("div");
	      t2 = text("Scale:\n    ");
	      select = element("select");

	      for (var _i2 = 0; _i2 < each_blocks_1.length; _i2 += 1) {
	        each_blocks_1[_i2].c();
	      }

	      t3 = space();
	      div1 = element("div");
	      t4 = text("Breakpoints (Artboards): ");
	      br = element("br");
	      t5 = space();

	      for (var _i3 = 0; _i3 < each_blocks.length; _i3 += 1) {
	        each_blocks[_i3].c();
	      }

	      t6 = space();
	      button1 = element("button");
	      button1.textContent = "Add Breakpoint";
	      t8 = space();
	      button2 = element("button");
	      button2.textContent = "Remove Breakpoint";
	      t10 = space();
	      div3 = element("div");
	      div2 = element("div");
	      textarea = element("textarea");
	      t11 = space();
	      button3 = element("button");
	      button3.textContent = "Copy JSON to clipboard";
	      attr(button0, "class", "closer svelte-15lutl9");
	      if (
	      /*options*/
	      ctx[0].scale === void 0) add_render_callback(function () {
	        return (
	          /*select_change_handler*/
	          ctx[8].call(select)
	        );
	      });
	      attr(div0, "class", "svelte-15lutl9");
	      attr(div1, "class", "svelte-15lutl9");
	      set_style(textarea, "min-height", "140px");
	      set_style(textarea, "min-width", "280px");
	      textarea.value =
	      /*componentJSON*/
	      ctx[1];
	      attr(div2, "class", "svelte-15lutl9");
	      attr(div3, "class", "svelte-15lutl9");
	      attr(div4, "class", "dialog svelte-15lutl9");
	    },
	    m: function m(target, anchor) {
	      insert(target, div4, anchor);
	      append(div4, button0);
	      append(div4, t1);
	      append(div4, div0);
	      append(div0, t2);
	      append(div0, select);

	      for (var _i4 = 0; _i4 < each_blocks_1.length; _i4 += 1) {
	        each_blocks_1[_i4].m(select, null);
	      }

	      select_option(select,
	      /*options*/
	      ctx[0].scale);
	      append(div4, t3);
	      append(div4, div1);
	      append(div1, t4);
	      append(div1, br);
	      append(div1, t5);

	      for (var _i5 = 0; _i5 < each_blocks.length; _i5 += 1) {
	        each_blocks[_i5].m(div1, null);
	      }

	      append(div1, t6);
	      append(div1, button1);
	      append(div1, t8);
	      append(div1, button2);
	      append(div4, t10);
	      append(div4, div3);
	      append(div3, div2);
	      append(div2, textarea);
	      append(div3, t11);
	      append(div3, button3);

	      if (!mounted) {
	        dispose = [listen(button0, "click",
	        /*closeAndUpdate*/
	        ctx[5]), listen(select, "change",
	        /*select_change_handler*/
	        ctx[8]), listen(button1, "click",
	        /*addBreakpoint*/
	        ctx[3]), listen(button2, "click",
	        /*removeBreakpoint*/
	        ctx[4]), listen(button3, "click",
	        /*removeBreakpoint*/
	        ctx[4])];
	        mounted = true;
	      }
	    },
	    p: function p(ctx, _ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	          dirty = _ref2[0];

	      if (dirty &
	      /*scaleOptions*/
	      4) {
	        each_value_1 =
	        /*scaleOptions*/
	        ctx[2];

	        var _i6;

	        for (_i6 = 0; _i6 < each_value_1.length; _i6 += 1) {
	          var child_ctx = get_each_context_1$1(ctx, each_value_1, _i6);

	          if (each_blocks_1[_i6]) {
	            each_blocks_1[_i6].p(child_ctx, dirty);
	          } else {
	            each_blocks_1[_i6] = create_each_block_1$1(child_ctx);

	            each_blocks_1[_i6].c();

	            each_blocks_1[_i6].m(select, null);
	          }
	        }

	        for (; _i6 < each_blocks_1.length; _i6 += 1) {
	          each_blocks_1[_i6].d(1);
	        }

	        each_blocks_1.length = each_value_1.length;
	      }

	      if (dirty &
	      /*options, scaleOptions*/
	      5) {
	        select_option(select,
	        /*options*/
	        ctx[0].scale);
	      }

	      if (dirty &
	      /*options*/
	      1) {
	        each_value =
	        /*options*/
	        ctx[0].breakpoints;

	        var _i7;

	        for (_i7 = 0; _i7 < each_value.length; _i7 += 1) {
	          var _child_ctx = get_each_context$2(ctx, each_value, _i7);

	          if (each_blocks[_i7]) {
	            each_blocks[_i7].p(_child_ctx, dirty);
	          } else {
	            each_blocks[_i7] = create_each_block$2(_child_ctx);

	            each_blocks[_i7].c();

	            each_blocks[_i7].m(div1, t6);
	          }
	        }

	        for (; _i7 < each_blocks.length; _i7 += 1) {
	          each_blocks[_i7].d(1);
	        }

	        each_blocks.length = each_value.length;
	      }

	      if (dirty &
	      /*componentJSON*/
	      2) {
	        textarea.value =
	        /*componentJSON*/
	        ctx[1];
	      }
	    },
	    i: noop,
	    o: noop,
	    d: function d(detaching) {
	      if (detaching) detach(div4);
	      destroy_each(each_blocks_1, detaching);
	      destroy_each(each_blocks, detaching);
	      mounted = false;
	      run_all(dispose);
	    }
	  };
	}

	function instance$8($$self, $$props, $$invalidate) {
	  var componentJSON;
	  var closeOptions = $$props.closeOptions;
	  var _$$props$options = $$props.options,
	      options = _$$props$options === void 0 ? {} : _$$props$options;
	  var draggablesComponent = $$props.draggablesComponent;
	  var scaleOptions = [{
	    type: 'linear',
	    label: 'Linear Scale (Default)'
	  }, {
	    type: 'absolute',
	    label: 'Absolute (No Scaling)'
	  }, {
	    type: 'uniform',
	    label: 'Uniform Scaling (Font sizes scale)'
	  }, {
	    type: 'geo',
	    label: 'Geo Coordinates (Lat/Lon)'
	  }, {
	    type: 'custom',
	    label: 'custom'
	  }];

	  function addBreakpoint() {
	    $$invalidate(0, options.breakpoints = options.breakpoints.concat({
	      name: shortyId(),
	      size: null
	    }), options);
	  }

	  function removeBreakpoint() {
	    $$invalidate(0, options.breakpoints = options.breakpoints.slice(0, -1), options);
	  }

	  function closeAndUpdate() {
	    closeOptions(options);
	  }

	  function select_change_handler() {
	    options.scale = select_value(this);
	    $$invalidate(0, options);
	    $$invalidate(2, scaleOptions);
	  }

	  function input0_input_handler(each_value, breakpoint_index) {
	    each_value[breakpoint_index].name = this.value;
	    $$invalidate(0, options);
	    $$invalidate(2, scaleOptions);
	  }

	  function input1_input_handler(each_value, breakpoint_index) {
	    each_value[breakpoint_index].size = to_number(this.value);
	    $$invalidate(0, options);
	    $$invalidate(2, scaleOptions);
	  }

	  $$self.$$set = function ($$props) {
	    if ('closeOptions' in $$props) $$invalidate(6, closeOptions = $$props.closeOptions);
	    if ('options' in $$props) $$invalidate(0, options = $$props.options);
	    if ('draggablesComponent' in $$props) $$invalidate(7, draggablesComponent = $$props.draggablesComponent);
	  };

	  $$self.$$.update = function () {
	    if ($$self.$$.dirty &
	    /*draggablesComponent*/
	    128) {
	      $$invalidate(1, componentJSON = JSON.stringify(draggablesComponent.items, null, '  '));
	    }
	  };

	  return [options, componentJSON, scaleOptions, addBreakpoint, removeBreakpoint, closeAndUpdate, closeOptions, draggablesComponent, select_change_handler, input0_input_handler, input1_input_handler];
	}

	var EditorOptions = /*#__PURE__*/function (_SvelteComponent) {
	  _inherits(EditorOptions, _SvelteComponent);

	  var _super = _createSuper(EditorOptions);

	  function EditorOptions(options) {
	    var _this;

	    _classCallCheck(this, EditorOptions);

	    _this = _super.call(this);
	    init(_assertThisInitialized(_this), options, instance$8, create_fragment$8, safe_not_equal, {
	      closeOptions: 6,
	      options: 0,
	      draggablesComponent: 7
	    }, add_css$7);
	    return _this;
	  }

	  _createClass(EditorOptions, [{
	    key: "closeOptions",
	    get: function get() {
	      return this.$$.ctx[6];
	    },
	    set: function set(closeOptions) {
	      this.$$set({
	        closeOptions: closeOptions
	      });
	      flush();
	    }
	  }, {
	    key: "options",
	    get: function get() {
	      return this.$$.ctx[0];
	    },
	    set: function set(options) {
	      this.$$set({
	        options: options
	      });
	      flush();
	    }
	  }, {
	    key: "draggablesComponent",
	    get: function get() {
	      return this.$$.ctx[7];
	    },
	    set: function set(draggablesComponent) {
	      this.$$set({
	        draggablesComponent: draggablesComponent
	      });
	      flush();
	    }
	  }]);

	  return EditorOptions;
	}(SvelteComponent);

	function add_css$6(target) {
	  append_styles(target, "svelte-wg66ol", ".bar-button.svelte-wg66ol.svelte-wg66ol{z-index:100;position:absolute}.example-text.svelte-wg66ol button.svelte-wg66ol{font-size:12px;padding:1px;color:#001aaa;border:none;box-shadow:none}.example-text.svelte-wg66ol button.svelte-wg66ol:focus{outline:none}.example-text.svelte-wg66ol button.svelte-wg66ol:hover{color:#001aaa;background:#c7c7c7}.menu-row.svelte-wg66ol.svelte-wg66ol{min-height:26px}.menu-start.svelte-wg66ol.svelte-wg66ol{margin-top:7px}.menu .button-menu{color:#001aaa;padding-left:8px}.html-editor, .advanced-options{color:#001aaa}textarea.svelte-wg66ol.svelte-wg66ol{margin-top:12px;width:154px;font-size:13px;background:#ffffff;box-shadow:inset 1px 1px 4px rgba(0,0,0,0.3)}");
	}

	function get_each_context$1(ctx, list, i) {
	  var child_ctx = ctx.slice();
	  child_ctx[45] = list[i].name;
	  child_ctx[46] = list[i].left;
	  child_ctx[47] = list[i].action;
	  return child_ctx;
	} // (154:0) {#if renderContextMenu}


	function create_if_block_4$2(ctx) {
	  var button;
	  var t;
	  var mounted;
	  var dispose;
	  return {
	    c: function c() {
	      button = element("button");
	      t = text("...");
	      attr(button, "class", "bar-button svelte-wg66ol");
	      set_style(button, "left",
	      /*menuPos*/
	      ctx[21][0] + "px");
	      set_style(button, "top",
	      /*menuPos*/
	      ctx[21][1] + "px");
	    },
	    m: function m(target, anchor) {
	      insert(target, button, anchor);
	      append(button, t);

	      if (!mounted) {
	        dispose = listen(button, "click",
	        /*showMenu*/
	        ctx[31]);
	        mounted = true;
	      }
	    },
	    p: function p(ctx, dirty) {
	      if (dirty[0] &
	      /*menuPos*/
	      2097152) {
	        set_style(button, "left",
	        /*menuPos*/
	        ctx[21][0] + "px");
	      }

	      if (dirty[0] &
	      /*menuPos*/
	      2097152) {
	        set_style(button, "top",
	        /*menuPos*/
	        ctx[21][1] + "px");
	      }
	    },
	    d: function d(detaching) {
	      if (detaching) detach(button);
	      mounted = false;
	      dispose();
	    }
	  };
	} // (160:0) {#if customActions}


	function create_if_block_3$2(ctx) {
	  var each_1_anchor;
	  var each_value =
	  /*customActions*/
	  ctx[20];
	  var each_blocks = [];

	  for (var i = 0; i < each_value.length; i += 1) {
	    each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
	  }

	  return {
	    c: function c() {
	      for (var _i = 0; _i < each_blocks.length; _i += 1) {
	        each_blocks[_i].c();
	      }

	      each_1_anchor = empty();
	    },
	    m: function m(target, anchor) {
	      for (var _i2 = 0; _i2 < each_blocks.length; _i2 += 1) {
	        each_blocks[_i2].m(target, anchor);
	      }

	      insert(target, each_1_anchor, anchor);
	    },
	    p: function p(ctx, dirty) {
	      if (dirty[0] &
	      /*y, x, customActions, id*/
	      1049024) {
	        each_value =
	        /*customActions*/
	        ctx[20];

	        var _i3;

	        for (_i3 = 0; _i3 < each_value.length; _i3 += 1) {
	          var child_ctx = get_each_context$1(ctx, each_value, _i3);

	          if (each_blocks[_i3]) {
	            each_blocks[_i3].p(child_ctx, dirty);
	          } else {
	            each_blocks[_i3] = create_each_block$1(child_ctx);

	            each_blocks[_i3].c();

	            each_blocks[_i3].m(each_1_anchor.parentNode, each_1_anchor);
	          }
	        }

	        for (; _i3 < each_blocks.length; _i3 += 1) {
	          each_blocks[_i3].d(1);
	        }

	        each_blocks.length = each_value.length;
	      }
	    },
	    d: function d(detaching) {
	      destroy_each(each_blocks, detaching);
	      if (detaching) detach(each_1_anchor);
	    }
	  };
	} // (161:2) {#each customActions as { name, left, action }}


	function create_each_block$1(ctx) {
	  var button;
	  var t0_value =
	  /*name*/
	  ctx[45] + "";
	  var t0;
	  var t1;
	  var mounted;
	  var dispose;

	  function click_handler() {
	    return (
	      /*click_handler*/
	      ctx[38](
	      /*action*/
	      ctx[47])
	    );
	  }

	  return {
	    c: function c() {
	      button = element("button");
	      t0 = text(t0_value);
	      t1 = space();
	      attr(button, "class", "bar-button svelte-wg66ol");
	      set_style(button, "top",
	      /*y*/
	      ctx[8] - 25 + "px");
	      set_style(button, "left",
	      /*x*/
	      ctx[7] +
	      /*left*/
	      ctx[46] + "px");
	    },
	    m: function m(target, anchor) {
	      insert(target, button, anchor);
	      append(button, t0);
	      append(button, t1);

	      if (!mounted) {
	        dispose = listen(button, "click", click_handler);
	        mounted = true;
	      }
	    },
	    p: function p(new_ctx, dirty) {
	      ctx = new_ctx;
	      if (dirty[0] &
	      /*customActions*/
	      1048576 && t0_value !== (t0_value =
	      /*name*/
	      ctx[45] + "")) set_data(t0, t0_value);

	      if (dirty[0] &
	      /*y*/
	      256) {
	        set_style(button, "top",
	        /*y*/
	        ctx[8] - 25 + "px");
	      }

	      if (dirty[0] &
	      /*x, customActions*/
	      1048704) {
	        set_style(button, "left",
	        /*x*/
	        ctx[7] +
	        /*left*/
	        ctx[46] + "px");
	      }
	    },
	    d: function d(detaching) {
	      if (detaching) detach(button);
	      mounted = false;
	      dispose();
	    }
	  };
	} // (172:0) {#if menuVisible}


	function create_if_block_2$2(ctx) {
	  var dialog;
	  var current;
	  dialog = new Dialog({
	    props: {
	      className: "menu",
	      width: "160",
	      x:
	      /*menuPos*/
	      ctx[21][0],
	      y:
	      /*menuPos*/
	      ctx[21][1],
	      onClose:
	      /*onClose*/
	      ctx[9],
	      $$slots: {
	        content: [create_content_slot_2]
	      },
	      $$scope: {
	        ctx: ctx
	      }
	    }
	  });
	  return {
	    c: function c() {
	      create_component(dialog.$$.fragment);
	    },
	    m: function m(target, anchor) {
	      mount_component(dialog, target, anchor);
	      current = true;
	    },
	    p: function p(ctx, dirty) {
	      var dialog_changes = {};
	      if (dirty[0] &
	      /*menuPos*/
	      2097152) dialog_changes.x =
	      /*menuPos*/
	      ctx[21][0];
	      if (dirty[0] &
	      /*menuPos*/
	      2097152) dialog_changes.y =
	      /*menuPos*/
	      ctx[21][1];
	      if (dirty[0] &
	      /*onClose*/
	      512) dialog_changes.onClose =
	      /*onClose*/
	      ctx[9];

	      if (dirty[0] &
	      /*valign, align*/
	      12288 | dirty[1] &
	      /*$$scope*/
	      524288) {
	        dialog_changes.$$scope = {
	          dirty: dirty,
	          ctx: ctx
	        };
	      }

	      dialog.$set(dialog_changes);
	    },
	    i: function i(local) {
	      if (current) return;
	      transition_in(dialog.$$.fragment, local);
	      current = true;
	    },
	    o: function o(local) {
	      transition_out(dialog.$$.fragment, local);
	      current = false;
	    },
	    d: function d(detaching) {
	      destroy_component(dialog, detaching);
	    }
	  };
	} // (179:4) 


	function create_content_slot_2(ctx) {
	  var div3;
	  var editorbuttonmenu0;
	  var t0;
	  var editorbuttonmenu1;
	  var t1;
	  var div0;
	  var button0;
	  var t3;
	  var div1;
	  var button1;
	  var t5;
	  var div2;
	  var button2;
	  var current;
	  var mounted;
	  var dispose;
	  editorbuttonmenu0 = new EditorButtonMenu({
	    props: {
	      label: "Align:",
	      selected:
	      /*align*/
	      ctx[12],
	      onChange:
	      /*setAlign*/
	      ctx[25],
	      buttons: alignButtons
	    }
	  });
	  editorbuttonmenu1 = new EditorButtonMenu({
	    props: {
	      label: "Valign:",
	      selected:
	      /*valign*/
	      ctx[13],
	      onChange:
	      /*setValign*/
	      ctx[26],
	      buttons: valignButtons
	    }
	  });
	  return {
	    c: function c() {
	      div3 = element("div");
	      create_component(editorbuttonmenu0.$$.fragment);
	      t0 = space();
	      create_component(editorbuttonmenu1.$$.fragment);
	      t1 = space();
	      div0 = element("div");
	      button0 = element("button");
	      button0.textContent = "Edit HTML";
	      t3 = space();
	      div1 = element("div");
	      button1 = element("button");
	      button1.textContent = "Advanced Options";
	      t5 = space();
	      div2 = element("div");
	      button2 = element("button");
	      button2.textContent = "Delete";
	      attr(button0, "class", "flat");
	      attr(div0, "class", "menu-row menu-start svelte-wg66ol");
	      attr(button1, "class", "flat");
	      attr(div1, "class", "menu-row svelte-wg66ol");
	      attr(button2, "class", "flat");
	      attr(div2, "class", "menu-row svelte-wg66ol");
	      attr(div3, "slot", "content");
	    },
	    m: function m(target, anchor) {
	      insert(target, div3, anchor);
	      mount_component(editorbuttonmenu0, div3, null);
	      append(div3, t0);
	      mount_component(editorbuttonmenu1, div3, null);
	      append(div3, t1);
	      append(div3, div0);
	      append(div0, button0);
	      append(div3, t3);
	      append(div3, div1);
	      append(div1, button1);
	      append(div3, t5);
	      append(div3, div2);
	      append(div2, button2);
	      current = true;

	      if (!mounted) {
	        dispose = [listen(button0, "click",
	        /*editHtml*/
	        ctx[28]), listen(button1, "click",
	        /*showAdvanced*/
	        ctx[24]), listen(button2, "click",
	        /*onDelete*/
	        ctx[32])];
	        mounted = true;
	      }
	    },
	    p: function p(ctx, dirty) {
	      var editorbuttonmenu0_changes = {};
	      if (dirty[0] &
	      /*align*/
	      4096) editorbuttonmenu0_changes.selected =
	      /*align*/
	      ctx[12];
	      editorbuttonmenu0.$set(editorbuttonmenu0_changes);
	      var editorbuttonmenu1_changes = {};
	      if (dirty[0] &
	      /*valign*/
	      8192) editorbuttonmenu1_changes.selected =
	      /*valign*/
	      ctx[13];
	      editorbuttonmenu1.$set(editorbuttonmenu1_changes);
	    },
	    i: function i(local) {
	      if (current) return;
	      transition_in(editorbuttonmenu0.$$.fragment, local);
	      transition_in(editorbuttonmenu1.$$.fragment, local);
	      current = true;
	    },
	    o: function o(local) {
	      transition_out(editorbuttonmenu0.$$.fragment, local);
	      transition_out(editorbuttonmenu1.$$.fragment, local);
	      current = false;
	    },
	    d: function d(detaching) {
	      if (detaching) detach(div3);
	      destroy_component(editorbuttonmenu0);
	      destroy_component(editorbuttonmenu1);
	      mounted = false;
	      run_all(dispose);
	    }
	  };
	} // (207:0) {#if htmlEditorVisible}


	function create_if_block_1$3(ctx) {
	  var dialog;
	  var current;
	  dialog = new Dialog({
	    props: {
	      className: "html-editor",
	      width: "160",
	      x:
	      /*menuPos*/
	      ctx[21][0],
	      y:
	      /*menuPos*/
	      ctx[21][1],
	      onClose:
	      /*onClose*/
	      ctx[9],
	      $$slots: {
	        content: [create_content_slot_1]
	      },
	      $$scope: {
	        ctx: ctx
	      }
	    }
	  });
	  return {
	    c: function c() {
	      create_component(dialog.$$.fragment);
	    },
	    m: function m(target, anchor) {
	      mount_component(dialog, target, anchor);
	      current = true;
	    },
	    p: function p(ctx, dirty) {
	      var dialog_changes = {};
	      if (dirty[0] &
	      /*menuPos*/
	      2097152) dialog_changes.x =
	      /*menuPos*/
	      ctx[21][0];
	      if (dirty[0] &
	      /*menuPos*/
	      2097152) dialog_changes.y =
	      /*menuPos*/
	      ctx[21][1];
	      if (dirty[0] &
	      /*onClose*/
	      512) dialog_changes.onClose =
	      /*onClose*/
	      ctx[9];

	      if (dirty[0] &
	      /*text, textField*/
	      67584 | dirty[1] &
	      /*$$scope*/
	      524288) {
	        dialog_changes.$$scope = {
	          dirty: dirty,
	          ctx: ctx
	        };
	      }

	      dialog.$set(dialog_changes);
	    },
	    i: function i(local) {
	      if (current) return;
	      transition_in(dialog.$$.fragment, local);
	      current = true;
	    },
	    o: function o(local) {
	      transition_out(dialog.$$.fragment, local);
	      current = false;
	    },
	    d: function d(detaching) {
	      destroy_component(dialog, detaching);
	    }
	  };
	} // (214:4) 


	function create_content_slot_1(ctx) {
	  var div1;
	  var textarea;
	  var t0;
	  var div0;
	  var button0;
	  var t2;
	  var button1;
	  var t4;
	  var button2;
	  var t6;
	  var br0;
	  var t7;
	  var button3;
	  var t9;
	  var button4;
	  var t11;
	  var button5;
	  var t13;
	  var button6;
	  var t15;
	  var button7;
	  var t17;
	  var br1;
	  var t18;
	  var button8;
	  var t20;
	  var button9;
	  var mounted;
	  var dispose;
	  return {
	    c: function c() {
	      div1 = element("div");
	      textarea = element("textarea");
	      t0 = space();
	      div0 = element("div");
	      button0 = element("button");
	      button0.innerHTML = "<b>Bold</b>";
	      t2 = space();
	      button1 = element("button");
	      button1.innerHTML = "<i>italic</i>";
	      t4 = space();
	      button2 = element("button");
	      button2.innerHTML = "<small>small</small>";
	      t6 = space();
	      br0 = element("br");
	      t7 = space();
	      button3 = element("button");
	      button3.innerHTML = "<b>h2</b>";
	      t9 = space();
	      button4 = element("button");
	      button4.innerHTML = "<b>h3</b>";
	      t11 = space();
	      button5 = element("button");
	      button5.innerHTML = "<b>h4</b>";
	      t13 = space();
	      button6 = element("button");
	      button6.innerHTML = "<b>h5</b>";
	      t15 = space();
	      button7 = element("button");
	      button7.innerHTML = "<b>h6</b>";
	      t17 = space();
	      br1 = element("br");
	      t18 = space();
	      button8 = element("button");
	      button8.innerHTML = "<span>&lt;a&gt;</span>";
	      t20 = space();
	      button9 = element("button");
	      button9.innerHTML = "<span>&lt;br&gt;</span>";
	      attr(textarea, "rows", "4");
	      textarea.value =
	      /*text*/
	      ctx[11];
	      attr(textarea, "class", "svelte-wg66ol");
	      attr(button0, "data-tag", "b");
	      attr(button0, "class", "svelte-wg66ol");
	      attr(button1, "data-tag", "i");
	      attr(button1, "class", "svelte-wg66ol");
	      attr(button2, "data-tag", "small");
	      attr(button2, "class", "svelte-wg66ol");
	      attr(button3, "data-tag", "h2");
	      attr(button3, "class", "svelte-wg66ol");
	      attr(button4, "data-tag", "h3");
	      attr(button4, "class", "svelte-wg66ol");
	      attr(button5, "data-tag", "h4");
	      attr(button5, "class", "svelte-wg66ol");
	      attr(button6, "data-tag", "h5");
	      attr(button6, "class", "svelte-wg66ol");
	      attr(button7, "data-tag", "h6");
	      attr(button7, "class", "svelte-wg66ol");
	      attr(button8, "data-tag", "a");
	      attr(button8, "class", "svelte-wg66ol");
	      attr(button9, "data-tag", "br");
	      attr(button9, "class", "svelte-wg66ol");
	      attr(div0, "class", "example-text svelte-wg66ol");
	      attr(div1, "slot", "content");
	    },
	    m: function m(target, anchor) {
	      insert(target, div1, anchor);
	      append(div1, textarea);
	      /*textarea_binding*/

	      ctx[39](textarea);
	      append(div1, t0);
	      append(div1, div0);
	      append(div0, button0);
	      append(div0, t2);
	      append(div0, button1);
	      append(div0, t4);
	      append(div0, button2);
	      append(div0, t6);
	      append(div0, br0);
	      append(div0, t7);
	      append(div0, button3);
	      append(div0, t9);
	      append(div0, button4);
	      append(div0, t11);
	      append(div0, button5);
	      append(div0, t13);
	      append(div0, button6);
	      append(div0, t15);
	      append(div0, button7);
	      append(div0, t17);
	      append(div0, br1);
	      append(div0, t18);
	      append(div0, button8);
	      append(div0, t20);
	      append(div0, button9);

	      if (!mounted) {
	        dispose = [listen(textarea, "keyup",
	        /*onText*/
	        ctx[23]), listen(button0, "click",
	        /*insertHtml*/
	        ctx[27]), listen(button1, "click",
	        /*insertHtml*/
	        ctx[27]), listen(button2, "click",
	        /*insertHtml*/
	        ctx[27]), listen(button3, "click",
	        /*insertHtml*/
	        ctx[27]), listen(button4, "click",
	        /*insertHtml*/
	        ctx[27]), listen(button5, "click",
	        /*insertHtml*/
	        ctx[27]), listen(button6, "click",
	        /*insertHtml*/
	        ctx[27]), listen(button7, "click",
	        /*insertHtml*/
	        ctx[27]), listen(button8, "click",
	        /*insertHtml*/
	        ctx[27]), listen(button9, "click",
	        /*insertHtml*/
	        ctx[27])];
	        mounted = true;
	      }
	    },
	    p: function p(ctx, dirty) {
	      if (dirty[0] &
	      /*text*/
	      2048) {
	        textarea.value =
	        /*text*/
	        ctx[11];
	      }
	    },
	    d: function d(detaching) {
	      if (detaching) detach(div1);
	      /*textarea_binding*/

	      ctx[39](null);
	      mounted = false;
	      run_all(dispose);
	    }
	  };
	} // (235:0) {#if advancedOptionsVisible}


	function create_if_block$5(ctx) {
	  var dialog;
	  var current;
	  dialog = new Dialog({
	    props: {
	      className: "advanced-options",
	      width: "160",
	      x:
	      /*menuPos*/
	      ctx[21][0],
	      y:
	      /*menuPos*/
	      ctx[21][1],
	      onClose:
	      /*onClose*/
	      ctx[9],
	      $$slots: {
	        content: [create_content_slot]
	      },
	      $$scope: {
	        ctx: ctx
	      }
	    }
	  });
	  return {
	    c: function c() {
	      create_component(dialog.$$.fragment);
	    },
	    m: function m(target, anchor) {
	      mount_component(dialog, target, anchor);
	      current = true;
	    },
	    p: function p(ctx, dirty) {
	      var dialog_changes = {};
	      if (dirty[0] &
	      /*menuPos*/
	      2097152) dialog_changes.x =
	      /*menuPos*/
	      ctx[21][0];
	      if (dirty[0] &
	      /*menuPos*/
	      2097152) dialog_changes.y =
	      /*menuPos*/
	      ctx[21][1];
	      if (dirty[0] &
	      /*onClose*/
	      512) dialog_changes.onClose =
	      /*onClose*/
	      ctx[9];

	      if (dirty[0] &
	      /*infoBox, outline, strokeWidth, color, offsetY, offsetX, textWidth*/
	      49207 | dirty[1] &
	      /*$$scope*/
	      524288) {
	        dialog_changes.$$scope = {
	          dirty: dirty,
	          ctx: ctx
	        };
	      }

	      dialog.$set(dialog_changes);
	    },
	    i: function i(local) {
	      if (current) return;
	      transition_in(dialog.$$.fragment, local);
	      current = true;
	    },
	    o: function o(local) {
	      transition_out(dialog.$$.fragment, local);
	      current = false;
	    },
	    d: function d(detaching) {
	      destroy_component(dialog, detaching);
	    }
	  };
	} // (242:4) 


	function create_content_slot(ctx) {
	  var div8;
	  var div0;
	  var t0;
	  var input0;
	  var t1;
	  var div1;
	  var t2;
	  var input1;
	  var t3;
	  var div2;
	  var t4;
	  var input2;
	  var t5;
	  var div3;
	  var t6;
	  var input3;
	  var t7;
	  var div4;
	  var t8;
	  var input4;
	  var t9;
	  var div5;
	  var input5;
	  var t10;
	  var br0;
	  var t11;
	  var div6;
	  var input6;
	  var t12;
	  var br1;
	  var t13;
	  var div7;
	  var button;
	  var mounted;
	  var dispose;
	  return {
	    c: function c() {
	      div8 = element("div");
	      div0 = element("div");
	      t0 = text("Width: ");
	      input0 = element("input");
	      t1 = space();
	      div1 = element("div");
	      t2 = text("OffsetX: ");
	      input1 = element("input");
	      t3 = space();
	      div2 = element("div");
	      t4 = text("OffsetY: ");
	      input2 = element("input");
	      t5 = space();
	      div3 = element("div");
	      t6 = text("Color: ");
	      input3 = element("input");
	      t7 = space();
	      div4 = element("div");
	      t8 = text("Stroke Width: ");
	      input4 = element("input");
	      t9 = space();
	      div5 = element("div");
	      input5 = element("input");
	      t10 = text("Enable text outline");
	      br0 = element("br");
	      t11 = space();
	      div6 = element("div");
	      input6 = element("input");
	      t12 = text("Enable infoBox");
	      br1 = element("br");
	      t13 = space();
	      div7 = element("div");
	      button = element("button");
	      button.textContent = "Export";
	      attr(input0, "type", "number");
	      attr(input0, "variable", "textWidth");
	      attr(input1, "type", "number");
	      attr(input1, "variable", "offsetX");
	      attr(input2, "type", "number");
	      attr(input2, "variable", "offsetY");
	      attr(input3, "variable", "color");
	      attr(input4, "type", "number");
	      attr(input4, "variable", "strokeWidth");
	      attr(input5, "type", "checkbox");
	      attr(input5, "name", "outline");
	      input5.checked =
	      /*outline*/
	      ctx[14];
	      attr(input6, "type", "checkbox");
	      attr(input6, "name", "infoBox");
	      input6.checked =
	      /*infoBox*/
	      ctx[15];
	      attr(button, "class", "export");
	      set_style(div7, "float", "right");
	      attr(div8, "slot", "content");
	    },
	    m: function m(target, anchor) {
	      insert(target, div8, anchor);
	      append(div8, div0);
	      append(div0, t0);
	      append(div0, input0);
	      set_input_value(input0,
	      /*textWidth*/
	      ctx[5]);
	      append(div8, t1);
	      append(div8, div1);
	      append(div1, t2);
	      append(div1, input1);
	      set_input_value(input1,
	      /*offsetX*/
	      ctx[0]);
	      append(div8, t3);
	      append(div8, div2);
	      append(div2, t4);
	      append(div2, input2);
	      set_input_value(input2,
	      /*offsetY*/
	      ctx[1]);
	      append(div8, t5);
	      append(div8, div3);
	      append(div3, t6);
	      append(div3, input3);
	      set_input_value(input3,
	      /*color*/
	      ctx[4]);
	      append(div8, t7);
	      append(div8, div4);
	      append(div4, t8);
	      append(div4, input4);
	      set_input_value(input4,
	      /*strokeWidth*/
	      ctx[2]);
	      append(div8, t9);
	      append(div8, div5);
	      append(div5, input5);
	      append(div5, t10);
	      append(div5, br0);
	      append(div8, t11);
	      append(div8, div6);
	      append(div6, input6);
	      append(div6, t12);
	      append(div6, br1);
	      append(div8, t13);
	      append(div8, div7);
	      append(div7, button);

	      if (!mounted) {
	        dispose = [listen(input0, "input",
	        /*input0_input_handler*/
	        ctx[40]), listen(input0, "keyup",
	        /*changeBound*/
	        ctx[29]), listen(input0, "change",
	        /*changeBound*/
	        ctx[29]), listen(input1, "input",
	        /*input1_input_handler*/
	        ctx[41]), listen(input1, "keyup",
	        /*changeBound*/
	        ctx[29]), listen(input1, "change",
	        /*changeBound*/
	        ctx[29]), listen(input2, "input",
	        /*input2_input_handler*/
	        ctx[42]), listen(input2, "keyup",
	        /*changeBound*/
	        ctx[29]), listen(input2, "change",
	        /*changeBound*/
	        ctx[29]), listen(input3, "input",
	        /*input3_input_handler*/
	        ctx[43]), listen(input3, "keyup",
	        /*changeBound*/
	        ctx[29]), listen(input3, "change",
	        /*changeBound*/
	        ctx[29]), listen(input4, "input",
	        /*input4_input_handler*/
	        ctx[44]), listen(input4, "keyup",
	        /*changeBound*/
	        ctx[29]), listen(input4, "change",
	        /*changeBound*/
	        ctx[29]), listen(input5, "change",
	        /*toggleCheck*/
	        ctx[33]), listen(input6, "change",
	        /*toggleCheck*/
	        ctx[33]), listen(button, "click", onExport)];
	        mounted = true;
	      }
	    },
	    p: function p(ctx, dirty) {
	      if (dirty[0] &
	      /*textWidth*/
	      32 && to_number(input0.value) !==
	      /*textWidth*/
	      ctx[5]) {
	        set_input_value(input0,
	        /*textWidth*/
	        ctx[5]);
	      }

	      if (dirty[0] &
	      /*offsetX*/
	      1 && to_number(input1.value) !==
	      /*offsetX*/
	      ctx[0]) {
	        set_input_value(input1,
	        /*offsetX*/
	        ctx[0]);
	      }

	      if (dirty[0] &
	      /*offsetY*/
	      2 && to_number(input2.value) !==
	      /*offsetY*/
	      ctx[1]) {
	        set_input_value(input2,
	        /*offsetY*/
	        ctx[1]);
	      }

	      if (dirty[0] &
	      /*color*/
	      16 && input3.value !==
	      /*color*/
	      ctx[4]) {
	        set_input_value(input3,
	        /*color*/
	        ctx[4]);
	      }

	      if (dirty[0] &
	      /*strokeWidth*/
	      4 && to_number(input4.value) !==
	      /*strokeWidth*/
	      ctx[2]) {
	        set_input_value(input4,
	        /*strokeWidth*/
	        ctx[2]);
	      }

	      if (dirty[0] &
	      /*outline*/
	      16384) {
	        input5.checked =
	        /*outline*/
	        ctx[14];
	      }

	      if (dirty[0] &
	      /*infoBox*/
	      32768) {
	        input6.checked =
	        /*infoBox*/
	        ctx[15];
	      }
	    },
	    d: function d(detaching) {
	      if (detaching) detach(div8);
	      mounted = false;
	      run_all(dispose);
	    }
	  };
	}

	function create_fragment$7(ctx) {
	  var button;
	  var t0_value = (
	  /*visible*/
	  ctx[3] ? 'Hide' : 'Show') + "";
	  var t0;
	  var t1;
	  var t2;
	  var t3;
	  var t4;
	  var t5;
	  var if_block4_anchor;
	  var current;
	  var mounted;
	  var dispose;
	  var if_block0 =
	  /*renderContextMenu*/
	  ctx[10] && create_if_block_4$2(ctx);
	  var if_block1 =
	  /*customActions*/
	  ctx[20] && create_if_block_3$2(ctx);
	  var if_block2 =
	  /*menuVisible*/
	  ctx[19] && create_if_block_2$2(ctx);
	  var if_block3 =
	  /*htmlEditorVisible*/
	  ctx[17] && create_if_block_1$3(ctx);
	  var if_block4 =
	  /*advancedOptionsVisible*/
	  ctx[18] && create_if_block$5(ctx);
	  return {
	    c: function c() {
	      button = element("button");
	      t0 = text(t0_value);
	      t1 = space();
	      if (if_block0) if_block0.c();
	      t2 = space();
	      if (if_block1) if_block1.c();
	      t3 = space();
	      if (if_block2) if_block2.c();
	      t4 = space();
	      if (if_block3) if_block3.c();
	      t5 = space();
	      if (if_block4) if_block4.c();
	      if_block4_anchor = empty();
	      attr(button, "class", "bar-button svelte-wg66ol");
	      set_style(button, "left",
	      /*showHidePos*/
	      ctx[22][0] + "px");
	      set_style(button, "top",
	      /*showHidePos*/
	      ctx[22][1] + "px");
	    },
	    m: function m(target, anchor) {
	      insert(target, button, anchor);
	      append(button, t0);
	      insert(target, t1, anchor);
	      if (if_block0) if_block0.m(target, anchor);
	      insert(target, t2, anchor);
	      if (if_block1) if_block1.m(target, anchor);
	      insert(target, t3, anchor);
	      if (if_block2) if_block2.m(target, anchor);
	      insert(target, t4, anchor);
	      if (if_block3) if_block3.m(target, anchor);
	      insert(target, t5, anchor);
	      if (if_block4) if_block4.m(target, anchor);
	      insert(target, if_block4_anchor, anchor);
	      current = true;

	      if (!mounted) {
	        dispose = listen(button, "click",
	        /*toggleVisibility*/
	        ctx[30]);
	        mounted = true;
	      }
	    },
	    p: function p(ctx, dirty) {
	      if ((!current || dirty[0] &
	      /*visible*/
	      8) && t0_value !== (t0_value = (
	      /*visible*/
	      ctx[3] ? 'Hide' : 'Show') + "")) set_data(t0, t0_value);

	      if (!current || dirty[0] &
	      /*showHidePos*/
	      4194304) {
	        set_style(button, "left",
	        /*showHidePos*/
	        ctx[22][0] + "px");
	      }

	      if (!current || dirty[0] &
	      /*showHidePos*/
	      4194304) {
	        set_style(button, "top",
	        /*showHidePos*/
	        ctx[22][1] + "px");
	      }

	      if (
	      /*renderContextMenu*/
	      ctx[10]) {
	        if (if_block0) {
	          if_block0.p(ctx, dirty);
	        } else {
	          if_block0 = create_if_block_4$2(ctx);
	          if_block0.c();
	          if_block0.m(t2.parentNode, t2);
	        }
	      } else if (if_block0) {
	        if_block0.d(1);
	        if_block0 = null;
	      }

	      if (
	      /*customActions*/
	      ctx[20]) {
	        if (if_block1) {
	          if_block1.p(ctx, dirty);
	        } else {
	          if_block1 = create_if_block_3$2(ctx);
	          if_block1.c();
	          if_block1.m(t3.parentNode, t3);
	        }
	      } else if (if_block1) {
	        if_block1.d(1);
	        if_block1 = null;
	      }

	      if (
	      /*menuVisible*/
	      ctx[19]) {
	        if (if_block2) {
	          if_block2.p(ctx, dirty);

	          if (dirty[0] &
	          /*menuVisible*/
	          524288) {
	            transition_in(if_block2, 1);
	          }
	        } else {
	          if_block2 = create_if_block_2$2(ctx);
	          if_block2.c();
	          transition_in(if_block2, 1);
	          if_block2.m(t4.parentNode, t4);
	        }
	      } else if (if_block2) {
	        group_outros();
	        transition_out(if_block2, 1, 1, function () {
	          if_block2 = null;
	        });
	        check_outros();
	      }

	      if (
	      /*htmlEditorVisible*/
	      ctx[17]) {
	        if (if_block3) {
	          if_block3.p(ctx, dirty);

	          if (dirty[0] &
	          /*htmlEditorVisible*/
	          131072) {
	            transition_in(if_block3, 1);
	          }
	        } else {
	          if_block3 = create_if_block_1$3(ctx);
	          if_block3.c();
	          transition_in(if_block3, 1);
	          if_block3.m(t5.parentNode, t5);
	        }
	      } else if (if_block3) {
	        group_outros();
	        transition_out(if_block3, 1, 1, function () {
	          if_block3 = null;
	        });
	        check_outros();
	      }

	      if (
	      /*advancedOptionsVisible*/
	      ctx[18]) {
	        if (if_block4) {
	          if_block4.p(ctx, dirty);

	          if (dirty[0] &
	          /*advancedOptionsVisible*/
	          262144) {
	            transition_in(if_block4, 1);
	          }
	        } else {
	          if_block4 = create_if_block$5(ctx);
	          if_block4.c();
	          transition_in(if_block4, 1);
	          if_block4.m(if_block4_anchor.parentNode, if_block4_anchor);
	        }
	      } else if (if_block4) {
	        group_outros();
	        transition_out(if_block4, 1, 1, function () {
	          if_block4 = null;
	        });
	        check_outros();
	      }
	    },
	    i: function i(local) {
	      if (current) return;
	      transition_in(if_block2);
	      transition_in(if_block3);
	      transition_in(if_block4);
	      current = true;
	    },
	    o: function o(local) {
	      transition_out(if_block2);
	      transition_out(if_block3);
	      transition_out(if_block4);
	      current = false;
	    },
	    d: function d(detaching) {
	      if (detaching) detach(button);
	      if (detaching) detach(t1);
	      if (if_block0) if_block0.d(detaching);
	      if (detaching) detach(t2);
	      if (if_block1) if_block1.d(detaching);
	      if (detaching) detach(t3);
	      if (if_block2) if_block2.d(detaching);
	      if (detaching) detach(t4);
	      if (if_block3) if_block3.d(detaching);
	      if (detaching) detach(t5);
	      if (if_block4) if_block4.d(detaching);
	      if (detaching) detach(if_block4_anchor);
	      mounted = false;
	      dispose();
	    }
	  };
	}

	function onExport() {
	  if (window.ANNOTATIONS) {
	    console.log(JSON.stringify(window.ANNOTATIONS.annotations));
	  }
	}

	function instance$7($$self, $$props, $$invalidate) {
	  var showHidePos;
	  var menuPos;
	  var id = $$props.id;
	  var type = $$props.type;
	  var _$$props$x = $$props.x,
	      x = _$$props$x === void 0 ? 0 : _$$props$x;
	  var _$$props$y = $$props.y,
	      y = _$$props$y === void 0 ? 0 : _$$props$y;
	  var _$$props$offsetX = $$props.offsetX,
	      offsetX = _$$props$offsetX === void 0 ? 0 : _$$props$offsetX;
	  var _$$props$offsetY = $$props.offsetY,
	      offsetY = _$$props$offsetY === void 0 ? 0 : _$$props$offsetY;
	  var _$$props$strokeWidth = $$props.strokeWidth,
	      strokeWidth = _$$props$strokeWidth === void 0 ? 1 : _$$props$strokeWidth;
	  var _$$props$visible = $$props.visible,
	      visible = _$$props$visible === void 0 ? true : _$$props$visible;
	  var color = $$props.color;
	  var onClose = $$props.onClose;
	  var onChange = $$props.onChange;
	  var removeDraggable = $$props.removeDraggable;
	  var renderContextMenu = $$props.renderContextMenu;
	  var customTypeActions = $$props.customTypeActions;
	  var text = $$props.text;
	  var align = $$props.align;
	  var valign = $$props.valign;
	  var outline = $$props.outline;
	  var infoBox = $$props.infoBox;
	  var _$$props$textWidth = $$props.textWidth,
	      textWidth = _$$props$textWidth === void 0 ? 160 : _$$props$textWidth;
	  var textField;
	  var htmlEditorVisible = false;
	  var advancedOptionsVisible = false;
	  var menuVisible = false;
	  var customActions;

	  function onText(e) {
	    onChange(id, {
	      text: e.target.value
	    });
	  }

	  function showAdvanced(e) {
	    $$invalidate(18, advancedOptionsVisible = true);
	  }

	  function setAlign(val) {
	    onChange(id, {
	      align: val
	    });
	  }

	  function setValign(val) {
	    onChange(id, {
	      valign: val
	    });
	  }

	  function insertHtml(e) {
	    var tag = e.target.parentElement.dataset.tag;
	    insertAtCursor(textField, "<".concat(tag, ">"), "</".concat(tag, ">"));
	  }

	  function editHtml() {
	    $$invalidate(17, htmlEditorVisible = true);
	  }

	  function changeBound(e) {
	    var props = {};
	    var key = e.target.attributes.variable.value;
	    props[key] = e.target.value;

	    if (e.target.attributes.type && e.target.attributes.type.value === 'number') {
	      props[key] = Number(e.target.value);
	    }

	    onChange(id, props);
	  }

	  function toggleVisibility(e) {
	    $$invalidate(3, visible = !visible);
	    onChange(id, {
	      visible: visible
	    });
	  }

	  function showMenu() {
	    $$invalidate(19, menuVisible = true);
	  }

	  function onDelete() {
	    onClose();
	    removeDraggable(id);
	  }

	  function toggleCheck(e) {
	    var changes = {};
	    var key = e.target.attributes.name.value;
	    changes[key] = e.target.checked;
	    onChange(id, changes);
	  }

	  var click_handler = function click_handler(action) {
	    return action(id);
	  };

	  function textarea_binding($$value) {
	    binding_callbacks[$$value ? 'unshift' : 'push'](function () {
	      textField = $$value;
	      $$invalidate(16, textField);
	    });
	  }

	  function input0_input_handler() {
	    textWidth = to_number(this.value);
	    $$invalidate(5, textWidth);
	  }

	  function input1_input_handler() {
	    offsetX = to_number(this.value);
	    $$invalidate(0, offsetX);
	  }

	  function input2_input_handler() {
	    offsetY = to_number(this.value);
	    $$invalidate(1, offsetY);
	  }

	  function input3_input_handler() {
	    color = this.value;
	    $$invalidate(4, color);
	  }

	  function input4_input_handler() {
	    strokeWidth = to_number(this.value);
	    $$invalidate(2, strokeWidth);
	  }

	  $$self.$$set = function ($$props) {
	    if ('id' in $$props) $$invalidate(6, id = $$props.id);
	    if ('type' in $$props) $$invalidate(34, type = $$props.type);
	    if ('x' in $$props) $$invalidate(7, x = $$props.x);
	    if ('y' in $$props) $$invalidate(8, y = $$props.y);
	    if ('offsetX' in $$props) $$invalidate(0, offsetX = $$props.offsetX);
	    if ('offsetY' in $$props) $$invalidate(1, offsetY = $$props.offsetY);
	    if ('strokeWidth' in $$props) $$invalidate(2, strokeWidth = $$props.strokeWidth);
	    if ('visible' in $$props) $$invalidate(3, visible = $$props.visible);
	    if ('color' in $$props) $$invalidate(4, color = $$props.color);
	    if ('onClose' in $$props) $$invalidate(9, onClose = $$props.onClose);
	    if ('onChange' in $$props) $$invalidate(35, onChange = $$props.onChange);
	    if ('removeDraggable' in $$props) $$invalidate(36, removeDraggable = $$props.removeDraggable);
	    if ('renderContextMenu' in $$props) $$invalidate(10, renderContextMenu = $$props.renderContextMenu);
	    if ('customTypeActions' in $$props) $$invalidate(37, customTypeActions = $$props.customTypeActions);
	    if ('text' in $$props) $$invalidate(11, text = $$props.text);
	    if ('align' in $$props) $$invalidate(12, align = $$props.align);
	    if ('valign' in $$props) $$invalidate(13, valign = $$props.valign);
	    if ('outline' in $$props) $$invalidate(14, outline = $$props.outline);
	    if ('infoBox' in $$props) $$invalidate(15, infoBox = $$props.infoBox);
	    if ('textWidth' in $$props) $$invalidate(5, textWidth = $$props.textWidth);
	  };

	  $$self.$$.update = function () {
	    if ($$self.$$.dirty[0] &
	    /*x, y*/
	    384) {
	      $$invalidate(22, showHidePos = [x, y - 25]);
	    }

	    if ($$self.$$.dirty[0] &
	    /*x, y*/
	    384) {
	      $$invalidate(21, menuPos = [x + 46, y - 25]);
	    }

	    if ($$self.$$.dirty[1] &
	    /*customTypeActions, type*/
	    72) {
	      var _customTypeActions;

	      $$invalidate(20, customActions = (_customTypeActions = customTypeActions) === null || _customTypeActions === void 0 ? void 0 : _customTypeActions[type]);
	    }
	  };

	  return [offsetX, offsetY, strokeWidth, visible, color, textWidth, id, x, y, onClose, renderContextMenu, text, align, valign, outline, infoBox, textField, htmlEditorVisible, advancedOptionsVisible, menuVisible, customActions, menuPos, showHidePos, onText, showAdvanced, setAlign, setValign, insertHtml, editHtml, changeBound, toggleVisibility, showMenu, onDelete, toggleCheck, type, onChange, removeDraggable, customTypeActions, click_handler, textarea_binding, input0_input_handler, input1_input_handler, input2_input_handler, input3_input_handler, input4_input_handler];
	}

	var EditorText = /*#__PURE__*/function (_SvelteComponent) {
	  _inherits(EditorText, _SvelteComponent);

	  var _super = _createSuper(EditorText);

	  function EditorText(options) {
	    var _this;

	    _classCallCheck(this, EditorText);

	    _this = _super.call(this);
	    init(_assertThisInitialized(_this), options, instance$7, create_fragment$7, safe_not_equal, {
	      id: 6,
	      type: 34,
	      x: 7,
	      y: 8,
	      offsetX: 0,
	      offsetY: 1,
	      strokeWidth: 2,
	      visible: 3,
	      color: 4,
	      onClose: 9,
	      onChange: 35,
	      removeDraggable: 36,
	      renderContextMenu: 10,
	      customTypeActions: 37,
	      text: 11,
	      align: 12,
	      valign: 13,
	      outline: 14,
	      infoBox: 15,
	      textWidth: 5
	    }, add_css$6, [-1, -1]);
	    return _this;
	  }

	  _createClass(EditorText, [{
	    key: "id",
	    get: function get() {
	      return this.$$.ctx[6];
	    },
	    set: function set(id) {
	      this.$$set({
	        id: id
	      });
	      flush();
	    }
	  }, {
	    key: "type",
	    get: function get() {
	      return this.$$.ctx[34];
	    },
	    set: function set(type) {
	      this.$$set({
	        type: type
	      });
	      flush();
	    }
	  }, {
	    key: "x",
	    get: function get() {
	      return this.$$.ctx[7];
	    },
	    set: function set(x) {
	      this.$$set({
	        x: x
	      });
	      flush();
	    }
	  }, {
	    key: "y",
	    get: function get() {
	      return this.$$.ctx[8];
	    },
	    set: function set(y) {
	      this.$$set({
	        y: y
	      });
	      flush();
	    }
	  }, {
	    key: "offsetX",
	    get: function get() {
	      return this.$$.ctx[0];
	    },
	    set: function set(offsetX) {
	      this.$$set({
	        offsetX: offsetX
	      });
	      flush();
	    }
	  }, {
	    key: "offsetY",
	    get: function get() {
	      return this.$$.ctx[1];
	    },
	    set: function set(offsetY) {
	      this.$$set({
	        offsetY: offsetY
	      });
	      flush();
	    }
	  }, {
	    key: "strokeWidth",
	    get: function get() {
	      return this.$$.ctx[2];
	    },
	    set: function set(strokeWidth) {
	      this.$$set({
	        strokeWidth: strokeWidth
	      });
	      flush();
	    }
	  }, {
	    key: "visible",
	    get: function get() {
	      return this.$$.ctx[3];
	    },
	    set: function set(visible) {
	      this.$$set({
	        visible: visible
	      });
	      flush();
	    }
	  }, {
	    key: "color",
	    get: function get() {
	      return this.$$.ctx[4];
	    },
	    set: function set(color) {
	      this.$$set({
	        color: color
	      });
	      flush();
	    }
	  }, {
	    key: "onClose",
	    get: function get() {
	      return this.$$.ctx[9];
	    },
	    set: function set(onClose) {
	      this.$$set({
	        onClose: onClose
	      });
	      flush();
	    }
	  }, {
	    key: "onChange",
	    get: function get() {
	      return this.$$.ctx[35];
	    },
	    set: function set(onChange) {
	      this.$$set({
	        onChange: onChange
	      });
	      flush();
	    }
	  }, {
	    key: "removeDraggable",
	    get: function get() {
	      return this.$$.ctx[36];
	    },
	    set: function set(removeDraggable) {
	      this.$$set({
	        removeDraggable: removeDraggable
	      });
	      flush();
	    }
	  }, {
	    key: "renderContextMenu",
	    get: function get() {
	      return this.$$.ctx[10];
	    },
	    set: function set(renderContextMenu) {
	      this.$$set({
	        renderContextMenu: renderContextMenu
	      });
	      flush();
	    }
	  }, {
	    key: "customTypeActions",
	    get: function get() {
	      return this.$$.ctx[37];
	    },
	    set: function set(customTypeActions) {
	      this.$$set({
	        customTypeActions: customTypeActions
	      });
	      flush();
	    }
	  }, {
	    key: "text",
	    get: function get() {
	      return this.$$.ctx[11];
	    },
	    set: function set(text) {
	      this.$$set({
	        text: text
	      });
	      flush();
	    }
	  }, {
	    key: "align",
	    get: function get() {
	      return this.$$.ctx[12];
	    },
	    set: function set(align) {
	      this.$$set({
	        align: align
	      });
	      flush();
	    }
	  }, {
	    key: "valign",
	    get: function get() {
	      return this.$$.ctx[13];
	    },
	    set: function set(valign) {
	      this.$$set({
	        valign: valign
	      });
	      flush();
	    }
	  }, {
	    key: "outline",
	    get: function get() {
	      return this.$$.ctx[14];
	    },
	    set: function set(outline) {
	      this.$$set({
	        outline: outline
	      });
	      flush();
	    }
	  }, {
	    key: "infoBox",
	    get: function get() {
	      return this.$$.ctx[15];
	    },
	    set: function set(infoBox) {
	      this.$$set({
	        infoBox: infoBox
	      });
	      flush();
	    }
	  }, {
	    key: "textWidth",
	    get: function get() {
	      return this.$$.ctx[5];
	    },
	    set: function set(textWidth) {
	      this.$$set({
	        textWidth: textWidth
	      });
	      flush();
	    }
	  }]);

	  return EditorText;
	}(SvelteComponent);

	function add_css$5(target) {
	  append_styles(target, "svelte-1us80jd", ".dialog.svelte-1us80jd{padding-bottom:30px}button.delete.svelte-1us80jd{position:absolute;right:5px;border-color:red;color:red;box-shadow:1px 1px red}button.delete.svelte-1us80jd:hover{background:red;color:white}");
	}

	function get_each_context(ctx, list, i) {
	  var child_ctx = ctx.slice();
	  child_ctx[20] = list[i];
	  return child_ctx;
	}

	function get_each_context_1(ctx, list, i) {
	  var child_ctx = ctx.slice();
	  child_ctx[23] = list[i].name;
	  child_ctx[24] = list[i].left;
	  child_ctx[25] = list[i].action;
	  return child_ctx;
	} // (93:0) {:else}


	function create_else_block(ctx) {
	  var button;
	  var t;
	  var mounted;
	  var dispose;
	  return {
	    c: function c() {
	      button = element("button");
	      t = text("...");
	      attr(button, "class", "bar-button");
	      set_style(button, "top",
	      /*y*/
	      ctx[4] - 25 + "px");
	      set_style(button, "left",
	      /*x*/
	      ctx[3] + 44 + "px");
	    },
	    m: function m(target, anchor) {
	      insert(target, button, anchor);
	      append(button, t);

	      if (!mounted) {
	        dispose = listen(button, "click",
	        /*showEditor*/
	        ctx[12]);
	        mounted = true;
	      }
	    },
	    p: function p(ctx, dirty) {
	      if (dirty &
	      /*y*/
	      16) {
	        set_style(button, "top",
	        /*y*/
	        ctx[4] - 25 + "px");
	      }

	      if (dirty &
	      /*x*/
	      8) {
	        set_style(button, "left",
	        /*x*/
	        ctx[3] + 44 + "px");
	      }
	    },
	    d: function d(detaching) {
	      if (detaching) detach(button);
	      mounted = false;
	      dispose();
	    }
	  };
	} // (83:0) {#if customActions}


	function create_if_block_1$2(ctx) {
	  var each_1_anchor;
	  var each_value_1 =
	  /*customActions*/
	  ctx[9];
	  var each_blocks = [];

	  for (var i = 0; i < each_value_1.length; i += 1) {
	    each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	  }

	  return {
	    c: function c() {
	      for (var _i = 0; _i < each_blocks.length; _i += 1) {
	        each_blocks[_i].c();
	      }

	      each_1_anchor = empty();
	    },
	    m: function m(target, anchor) {
	      for (var _i2 = 0; _i2 < each_blocks.length; _i2 += 1) {
	        each_blocks[_i2].m(target, anchor);
	      }

	      insert(target, each_1_anchor, anchor);
	    },
	    p: function p(ctx, dirty) {
	      if (dirty &
	      /*y, x, customActions, id*/
	      540) {
	        each_value_1 =
	        /*customActions*/
	        ctx[9];

	        var _i3;

	        for (_i3 = 0; _i3 < each_value_1.length; _i3 += 1) {
	          var child_ctx = get_each_context_1(ctx, each_value_1, _i3);

	          if (each_blocks[_i3]) {
	            each_blocks[_i3].p(child_ctx, dirty);
	          } else {
	            each_blocks[_i3] = create_each_block_1(child_ctx);

	            each_blocks[_i3].c();

	            each_blocks[_i3].m(each_1_anchor.parentNode, each_1_anchor);
	          }
	        }

	        for (; _i3 < each_blocks.length; _i3 += 1) {
	          each_blocks[_i3].d(1);
	        }

	        each_blocks.length = each_value_1.length;
	      }
	    },
	    d: function d(detaching) {
	      destroy_each(each_blocks, detaching);
	      if (detaching) detach(each_1_anchor);
	    }
	  };
	} // (84:2) {#each customActions as { name, left, action }}


	function create_each_block_1(ctx) {
	  var button;
	  var t0_value =
	  /*name*/
	  ctx[23] + "";
	  var t0;
	  var t1;
	  var mounted;
	  var dispose;

	  function click_handler() {
	    return (
	      /*click_handler*/
	      ctx[19](
	      /*action*/
	      ctx[25])
	    );
	  }

	  return {
	    c: function c() {
	      button = element("button");
	      t0 = text(t0_value);
	      t1 = space();
	      attr(button, "class", "bar-button");
	      set_style(button, "top",
	      /*y*/
	      ctx[4] - 25 + "px");
	      set_style(button, "left",
	      /*x*/
	      ctx[3] +
	      /*left*/
	      ctx[24] + "px");
	    },
	    m: function m(target, anchor) {
	      insert(target, button, anchor);
	      append(button, t0);
	      append(button, t1);

	      if (!mounted) {
	        dispose = listen(button, "click", click_handler);
	        mounted = true;
	      }
	    },
	    p: function p(new_ctx, dirty) {
	      ctx = new_ctx;
	      if (dirty &
	      /*customActions*/
	      512 && t0_value !== (t0_value =
	      /*name*/
	      ctx[23] + "")) set_data(t0, t0_value);

	      if (dirty &
	      /*y*/
	      16) {
	        set_style(button, "top",
	        /*y*/
	        ctx[4] - 25 + "px");
	      }

	      if (dirty &
	      /*x, customActions*/
	      520) {
	        set_style(button, "left",
	        /*x*/
	        ctx[3] +
	        /*left*/
	        ctx[24] + "px");
	      }
	    },
	    d: function d(detaching) {
	      if (detaching) detach(button);
	      mounted = false;
	      dispose();
	    }
	  };
	} // (103:0) {#if dialogVisible}


	function create_if_block$4(ctx) {
	  var div1;
	  var button0;
	  var t1;
	  var draghandle;
	  var t2;
	  var t3;
	  var div0;
	  var button1;
	  var current;
	  var mounted;
	  var dispose;
	  draghandle = new DragHandle({
	    props: {
	      id:
	      /*id*/
	      ctx[2],
	      handleClass: "dialog",
	      color: "transparent",
	      handleHeight: 8,
	      handleWidth: 200,
	      x: 100,
	      y: -6,
	      active: true,
	      onChange:
	      /*handleReposition*/
	      ctx[14]
	    }
	  });
	  var each_value =
	  /*editProperties*/
	  ctx[5];
	  var each_blocks = [];

	  for (var i = 0; i < each_value.length; i += 1) {
	    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	  }

	  return {
	    c: function c() {
	      div1 = element("div");
	      button0 = element("button");
	      button0.textContent = "X";
	      t1 = space();
	      create_component(draghandle.$$.fragment);
	      t2 = space();

	      for (var _i4 = 0; _i4 < each_blocks.length; _i4 += 1) {
	        each_blocks[_i4].c();
	      }

	      t3 = space();
	      div0 = element("div");
	      button1 = element("button");
	      button1.textContent = "Delete";
	      attr(button0, "class", "closer");
	      attr(button1, "class", "delete svelte-1us80jd");
	      attr(div1, "class", "dialog svelte-1us80jd");
	      set_style(div1, "top",
	      /*dialogPosition*/
	      ctx[0][1] + "px");
	      set_style(div1, "left",
	      /*dialogPosition*/
	      ctx[0][0] + "px");
	    },
	    m: function m(target, anchor) {
	      insert(target, div1, anchor);
	      append(div1, button0);
	      append(div1, t1);
	      mount_component(draghandle, div1, null);
	      append(div1, t2);

	      for (var _i5 = 0; _i5 < each_blocks.length; _i5 += 1) {
	        each_blocks[_i5].m(div1, null);
	      }

	      append(div1, t3);
	      append(div1, div0);
	      append(div0, button1);
	      current = true;

	      if (!mounted) {
	        dispose = [listen(button0, "click", function () {
	          if (is_function(
	          /*onClose*/
	          ctx[7]))
	            /*onClose*/
	            ctx[7].apply(this, arguments);
	        }), listen(button1, "click",
	        /*onDelete*/
	        ctx[13])];
	        mounted = true;
	      }
	    },
	    p: function p(new_ctx, dirty) {
	      ctx = new_ctx;
	      var draghandle_changes = {};
	      if (dirty &
	      /*id*/
	      4) draghandle_changes.id =
	      /*id*/
	      ctx[2];
	      draghandle.$set(draghandle_changes);

	      if (dirty &
	      /*editProperties, editFields, changeBound*/
	      1120) {
	        each_value =
	        /*editProperties*/
	        ctx[5];

	        var _i6;

	        for (_i6 = 0; _i6 < each_value.length; _i6 += 1) {
	          var child_ctx = get_each_context(ctx, each_value, _i6);

	          if (each_blocks[_i6]) {
	            each_blocks[_i6].p(child_ctx, dirty);
	          } else {
	            each_blocks[_i6] = create_each_block(child_ctx);

	            each_blocks[_i6].c();

	            each_blocks[_i6].m(div1, t3);
	          }
	        }

	        for (; _i6 < each_blocks.length; _i6 += 1) {
	          each_blocks[_i6].d(1);
	        }

	        each_blocks.length = each_value.length;
	      }

	      if (!current || dirty &
	      /*dialogPosition*/
	      1) {
	        set_style(div1, "top",
	        /*dialogPosition*/
	        ctx[0][1] + "px");
	      }

	      if (!current || dirty &
	      /*dialogPosition*/
	      1) {
	        set_style(div1, "left",
	        /*dialogPosition*/
	        ctx[0][0] + "px");
	      }
	    },
	    i: function i(local) {
	      if (current) return;
	      transition_in(draghandle.$$.fragment, local);
	      current = true;
	    },
	    o: function o(local) {
	      transition_out(draghandle.$$.fragment, local);
	      current = false;
	    },
	    d: function d(detaching) {
	      if (detaching) detach(div1);
	      destroy_component(draghandle);
	      destroy_each(each_blocks, detaching);
	      mounted = false;
	      run_all(dispose);
	    }
	  };
	} // (119:4) {#each editProperties as prop}


	function create_each_block(ctx) {
	  var div;
	  var t0_value =
	  /*prop*/
	  ctx[20].name + "";
	  var t0;
	  var t1;
	  var input;
	  var input_type_value;
	  var input_value_value;
	  var input_variable_value;
	  var mounted;
	  var dispose;
	  return {
	    c: function c() {
	      div = element("div");
	      t0 = text(t0_value);
	      t1 = text(":\n        ");
	      input = element("input");
	      attr(input, "type", input_type_value =
	      /*prop*/
	      ctx[20].type);
	      input.value = input_value_value =
	      /*editFields*/
	      ctx[6][
	      /*prop*/
	      ctx[20].name];
	      attr(input, "variable", input_variable_value =
	      /*prop*/
	      ctx[20].name);
	    },
	    m: function m(target, anchor) {
	      insert(target, div, anchor);
	      append(div, t0);
	      append(div, t1);
	      append(div, input);

	      if (!mounted) {
	        dispose = [listen(input, "keyup",
	        /*changeBound*/
	        ctx[10]), listen(input, "change",
	        /*changeBound*/
	        ctx[10])];
	        mounted = true;
	      }
	    },
	    p: function p(ctx, dirty) {
	      if (dirty &
	      /*editProperties*/
	      32 && t0_value !== (t0_value =
	      /*prop*/
	      ctx[20].name + "")) set_data(t0, t0_value);

	      if (dirty &
	      /*editProperties*/
	      32 && input_type_value !== (input_type_value =
	      /*prop*/
	      ctx[20].type)) {
	        attr(input, "type", input_type_value);
	      }

	      if (dirty &
	      /*editFields, editProperties*/
	      96 && input_value_value !== (input_value_value =
	      /*editFields*/
	      ctx[6][
	      /*prop*/
	      ctx[20].name]) && input.value !== input_value_value) {
	        input.value = input_value_value;
	      }

	      if (dirty &
	      /*editProperties*/
	      32 && input_variable_value !== (input_variable_value =
	      /*prop*/
	      ctx[20].name)) {
	        attr(input, "variable", input_variable_value);
	      }
	    },
	    d: function d(detaching) {
	      if (detaching) detach(div);
	      mounted = false;
	      run_all(dispose);
	    }
	  };
	}

	function create_fragment$6(ctx) {
	  var button;
	  var t0_value = (
	  /*visible*/
	  ctx[1] ? 'Hide' : 'Show') + "";
	  var t0;
	  var t1;
	  var t2;
	  var if_block1_anchor;
	  var current;
	  var mounted;
	  var dispose;

	  function select_block_type(ctx, dirty) {
	    if (
	    /*customActions*/
	    ctx[9]) return create_if_block_1$2;
	    return create_else_block;
	  }

	  var current_block_type = select_block_type(ctx);
	  var if_block0 = current_block_type(ctx);
	  var if_block1 =
	  /*dialogVisible*/
	  ctx[8] && create_if_block$4(ctx);
	  return {
	    c: function c() {
	      button = element("button");
	      t0 = text(t0_value);
	      t1 = space();
	      if_block0.c();
	      t2 = space();
	      if (if_block1) if_block1.c();
	      if_block1_anchor = empty();
	      attr(button, "class", "bar-button");
	      set_style(button, "top",
	      /*y*/
	      ctx[4] - 25 + "px");
	      set_style(button, "left",
	      /*x*/
	      ctx[3] + "px");
	    },
	    m: function m(target, anchor) {
	      insert(target, button, anchor);
	      append(button, t0);
	      insert(target, t1, anchor);
	      if_block0.m(target, anchor);
	      insert(target, t2, anchor);
	      if (if_block1) if_block1.m(target, anchor);
	      insert(target, if_block1_anchor, anchor);
	      current = true;

	      if (!mounted) {
	        dispose = listen(button, "click",
	        /*toggleVisibility*/
	        ctx[11]);
	        mounted = true;
	      }
	    },
	    p: function p(ctx, _ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	          dirty = _ref2[0];

	      if ((!current || dirty &
	      /*visible*/
	      2) && t0_value !== (t0_value = (
	      /*visible*/
	      ctx[1] ? 'Hide' : 'Show') + "")) set_data(t0, t0_value);

	      if (!current || dirty &
	      /*y*/
	      16) {
	        set_style(button, "top",
	        /*y*/
	        ctx[4] - 25 + "px");
	      }

	      if (!current || dirty &
	      /*x*/
	      8) {
	        set_style(button, "left",
	        /*x*/
	        ctx[3] + "px");
	      }

	      if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block0) {
	        if_block0.p(ctx, dirty);
	      } else {
	        if_block0.d(1);
	        if_block0 = current_block_type(ctx);

	        if (if_block0) {
	          if_block0.c();
	          if_block0.m(t2.parentNode, t2);
	        }
	      }

	      if (
	      /*dialogVisible*/
	      ctx[8]) {
	        if (if_block1) {
	          if_block1.p(ctx, dirty);

	          if (dirty &
	          /*dialogVisible*/
	          256) {
	            transition_in(if_block1, 1);
	          }
	        } else {
	          if_block1 = create_if_block$4(ctx);
	          if_block1.c();
	          transition_in(if_block1, 1);
	          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
	        }
	      } else if (if_block1) {
	        group_outros();
	        transition_out(if_block1, 1, 1, function () {
	          if_block1 = null;
	        });
	        check_outros();
	      }
	    },
	    i: function i(local) {
	      if (current) return;
	      transition_in(if_block1);
	      current = true;
	    },
	    o: function o(local) {
	      transition_out(if_block1);
	      current = false;
	    },
	    d: function d(detaching) {
	      if (detaching) detach(button);
	      if (detaching) detach(t1);
	      if_block0.d(detaching);
	      if (detaching) detach(t2);
	      if (if_block1) if_block1.d(detaching);
	      if (detaching) detach(if_block1_anchor);
	      mounted = false;
	      dispose();
	    }
	  };
	}

	function instance$6($$self, $$props, $$invalidate) {
	  var id = $$props.id;
	  var type = $$props.type;
	  var _$$props$x = $$props.x,
	      x = _$$props$x === void 0 ? 0 : _$$props$x;
	  var _$$props$y = $$props.y,
	      y = _$$props$y === void 0 ? 0 : _$$props$y;
	  var _$$props$editProperti = $$props.editProperties,
	      editProperties = _$$props$editProperti === void 0 ? [] : _$$props$editProperti;
	  var _$$props$editFields = $$props.editFields,
	      editFields = _$$props$editFields === void 0 ? {} : _$$props$editFields;
	  var onClose = $$props.onClose;
	  var onChange = $$props.onChange;
	  var removeDraggable = $$props.removeDraggable;
	  var dialogPosition = $$props.dialogPosition;
	  var customTypeActions = $$props.customTypeActions;
	  var _$$props$visible = $$props.visible,
	      visible = _$$props$visible === void 0 ? true : _$$props$visible;
	  var dialogVisible = false;
	  var customActions;

	  function changeBound(e) {
	    var props = {};
	    var key = e.target.attributes.variable.value;
	    props[key] = e.target.value;

	    if (e.target.attributes.type && e.target.attributes.type.value === 'number') {
	      props[key] = Number(e.target.value);
	    }

	    onChange(id, props);
	  }

	  function toggleVisibility(e) {
	    $$invalidate(1, visible = !visible);
	    onChange(id, {
	      visible: visible
	    });
	  }

	  function showEditor() {
	    $$invalidate(8, dialogVisible = true);
	  }

	  function onDelete() {
	    onClose();
	    removeDraggable(id);
	  }

	  function handleReposition(props) {
	    $$invalidate(0, dialogPosition = [dialogPosition[0] + props.x - 100, dialogPosition[1] + props.y]); // 200 width handle / 2
	  }

	  var click_handler = function click_handler(action) {
	    return action(id);
	  };

	  $$self.$$set = function ($$props) {
	    if ('id' in $$props) $$invalidate(2, id = $$props.id);
	    if ('type' in $$props) $$invalidate(15, type = $$props.type);
	    if ('x' in $$props) $$invalidate(3, x = $$props.x);
	    if ('y' in $$props) $$invalidate(4, y = $$props.y);
	    if ('editProperties' in $$props) $$invalidate(5, editProperties = $$props.editProperties);
	    if ('editFields' in $$props) $$invalidate(6, editFields = $$props.editFields);
	    if ('onClose' in $$props) $$invalidate(7, onClose = $$props.onClose);
	    if ('onChange' in $$props) $$invalidate(16, onChange = $$props.onChange);
	    if ('removeDraggable' in $$props) $$invalidate(17, removeDraggable = $$props.removeDraggable);
	    if ('dialogPosition' in $$props) $$invalidate(0, dialogPosition = $$props.dialogPosition);
	    if ('customTypeActions' in $$props) $$invalidate(18, customTypeActions = $$props.customTypeActions);
	    if ('visible' in $$props) $$invalidate(1, visible = $$props.visible);
	  };

	  $$self.$$.update = function () {
	    if ($$self.$$.dirty &
	    /*customTypeActions, type*/
	    294912) {
	      var _customTypeActions;

	      $$invalidate(9, customActions = (_customTypeActions = customTypeActions) === null || _customTypeActions === void 0 ? void 0 : _customTypeActions[type]);
	    }
	  };

	  return [dialogPosition, visible, id, x, y, editProperties, editFields, onClose, dialogVisible, customActions, changeBound, toggleVisibility, showEditor, onDelete, handleReposition, type, onChange, removeDraggable, customTypeActions, click_handler];
	}

	var EditorGeneric = /*#__PURE__*/function (_SvelteComponent) {
	  _inherits(EditorGeneric, _SvelteComponent);

	  var _super = _createSuper(EditorGeneric);

	  function EditorGeneric(options) {
	    var _this;

	    _classCallCheck(this, EditorGeneric);

	    _this = _super.call(this);
	    init(_assertThisInitialized(_this), options, instance$6, create_fragment$6, safe_not_equal, {
	      id: 2,
	      type: 15,
	      x: 3,
	      y: 4,
	      editProperties: 5,
	      editFields: 6,
	      onClose: 7,
	      onChange: 16,
	      removeDraggable: 17,
	      dialogPosition: 0,
	      customTypeActions: 18,
	      visible: 1
	    }, add_css$5);
	    return _this;
	  }

	  _createClass(EditorGeneric, [{
	    key: "id",
	    get: function get() {
	      return this.$$.ctx[2];
	    },
	    set: function set(id) {
	      this.$$set({
	        id: id
	      });
	      flush();
	    }
	  }, {
	    key: "type",
	    get: function get() {
	      return this.$$.ctx[15];
	    },
	    set: function set(type) {
	      this.$$set({
	        type: type
	      });
	      flush();
	    }
	  }, {
	    key: "x",
	    get: function get() {
	      return this.$$.ctx[3];
	    },
	    set: function set(x) {
	      this.$$set({
	        x: x
	      });
	      flush();
	    }
	  }, {
	    key: "y",
	    get: function get() {
	      return this.$$.ctx[4];
	    },
	    set: function set(y) {
	      this.$$set({
	        y: y
	      });
	      flush();
	    }
	  }, {
	    key: "editProperties",
	    get: function get() {
	      return this.$$.ctx[5];
	    },
	    set: function set(editProperties) {
	      this.$$set({
	        editProperties: editProperties
	      });
	      flush();
	    }
	  }, {
	    key: "editFields",
	    get: function get() {
	      return this.$$.ctx[6];
	    },
	    set: function set(editFields) {
	      this.$$set({
	        editFields: editFields
	      });
	      flush();
	    }
	  }, {
	    key: "onClose",
	    get: function get() {
	      return this.$$.ctx[7];
	    },
	    set: function set(onClose) {
	      this.$$set({
	        onClose: onClose
	      });
	      flush();
	    }
	  }, {
	    key: "onChange",
	    get: function get() {
	      return this.$$.ctx[16];
	    },
	    set: function set(onChange) {
	      this.$$set({
	        onChange: onChange
	      });
	      flush();
	    }
	  }, {
	    key: "removeDraggable",
	    get: function get() {
	      return this.$$.ctx[17];
	    },
	    set: function set(removeDraggable) {
	      this.$$set({
	        removeDraggable: removeDraggable
	      });
	      flush();
	    }
	  }, {
	    key: "dialogPosition",
	    get: function get() {
	      return this.$$.ctx[0];
	    },
	    set: function set(dialogPosition) {
	      this.$$set({
	        dialogPosition: dialogPosition
	      });
	      flush();
	    }
	  }, {
	    key: "customTypeActions",
	    get: function get() {
	      return this.$$.ctx[18];
	    },
	    set: function set(customTypeActions) {
	      this.$$set({
	        customTypeActions: customTypeActions
	      });
	      flush();
	    }
	  }, {
	    key: "visible",
	    get: function get() {
	      return this.$$.ctx[1];
	    },
	    set: function set(visible) {
	      this.$$set({
	        visible: visible
	      });
	      flush();
	    }
	  }]);

	  return EditorGeneric;
	}(SvelteComponent);

	// singleSelection type will avoid any sub
	var iconCollection = {
	  type: 'collection',
	  title: 'Icons and Icon Labels',
	  description: 'Add an icon to represent a map feature or a labeled place. You can choose icon types and colors.',
	  warning: '<b><i>Please adhere to the style guide:</i></b> <br><b>Only</b> use colors when you need to separate groups of icons into discrete buckets.<br> <b>Only</b> use a larger icon size when you need to highlight one feature out of many.',
	  variations: {
	    iconColor: true,
	    iconSize: true
	  },
	  previewItem: {
	    type: 'icon',
	    text: 'Feature Label',
	    iconText: 'â',
	    outline: true,
	    align: 'center',
	    offsetX: 0,
	    x: 0.5,
	    y: 0.4
	  },
	  items: [{
	    preset: 'dot',
	    type: 'icon',
	    iconText: 'â',
	    align: 'left',
	    valign: 'top',
	    offsetX: 0,
	    iconSize: 14,
	    x: 0.5,
	    y: 0.4,
	    _info: 'Base circle icon'
	  }, {
	    preset: 'square',
	    type: 'icon',
	    iconText: 'â ',
	    align: 'left',
	    valign: 'top',
	    offsetX: 0,
	    iconSize: 14,
	    x: 0.5,
	    y: 0.4,
	    _info: 'Alternate square icon'
	  }, {
	    preset: 'dot',
	    type: 'icon',
	    text: 'Cityname',
	    iconText: 'â',
	    align: 'center',
	    valign: 'top',
	    offsetX: 0,
	    iconSize: 14,
	    outline: true,
	    x: 0.5,
	    y: 0.4,
	    _info: 'Base circle icon with label',
	    _typeVariations: 'icon'
	  }, {
	    preset: 'square',
	    type: 'icon',
	    text: 'Cityname',
	    iconText: 'â ',
	    align: 'center',
	    valign: 'top',
	    offsetX: 0,
	    iconSize: 14,
	    outline: true,
	    x: 0.5,
	    y: 0.4,
	    _info: 'Alternate square icon with label',
	    _typeVariations: 'icon'
	  }, {
	    preset: 'star',
	    type: 'icon',
	    text: 'Cityname',
	    iconText: 'â',
	    align: 'center',
	    valign: 'top',
	    offsetX: 0,
	    iconSize: 14,
	    outline: true,
	    x: 0.5,
	    y: 0.4,
	    _info: 'Alternate star icon with label',
	    _typeVariations: 'icon'
	  }, {
	    preset: 'city',
	    type: 'icon',
	    text: '<b>Albany</b>',
	    // iconText: 'â',
	    iconNamedSVG: 'capitol',
	    align: 'center',
	    valign: 'top',
	    outline: true,
	    offsetX: 0,
	    iconSize: 14,
	    x: 0.5,
	    y: 0.4,
	    _info: 'Capitol City Label',
	    _warn: 'Please only use to denote a capitol city - please use bold text for capitol cities.',
	    _typeVariations: 'bold'
	  }, {
	    preset: 'explosion',
	    type: 'icon',
	    iconText: 'ð¥',
	    align: 'left',
	    valign: 'top',
	    offsetX: 0,
	    iconSize: 20,
	    x: 0.5,
	    y: 0.4,
	    _info: 'Explosion Icon',
	    _warn: 'Please only use to denote an explosion'
	  }, {
	    preset: 'explosion',
	    type: 'icon',
	    iconText: 'ð¥',
	    text: 'Location',
	    align: 'center',
	    valign: 'top',
	    outline: true,
	    offsetX: 0,
	    iconSize: 20,
	    x: 0.5,
	    y: 0.4,
	    _info: 'Explosion Icon With Label',
	    _warn: 'Please only use to denote an explosion',
	    _typeVariations: 'icon'
	  }, {
	    preset: 'fire',
	    type: 'icon',
	    iconText: 'ð¥',
	    align: 'center',
	    valign: 'top',
	    offsetX: 0,
	    iconSize: 20,
	    x: 0.5,
	    y: 0.4,
	    _info: 'Fire Icon',
	    _warn: 'Please only use to denote a fire'
	  }, {
	    preset: 'fire',
	    type: 'icon',
	    iconText: 'ð¥',
	    align: 'center',
	    valign: 'top',
	    text: 'Location',
	    outline: true,
	    offsetX: 0,
	    iconSize: 20,
	    x: 0.5,
	    y: 0.4,
	    _info: 'Fire Icon With Label',
	    _warn: 'Please only use to denote a fire',
	    _typeVariations: 'icon'
	  }, {
	    preset: 'epicenter',
	    type: 'icon',
	    iconNamedSVG: 'earthquake',
	    align: 'left',
	    valign: 'top',
	    offsetX: 0,
	    iconSize: 14,
	    x: 0.5,
	    y: 0.4,
	    _info: 'Epicenter Icon',
	    _warn: 'Please only use to denote an epicenter'
	  }, {
	    preset: 'epicenter',
	    type: 'icon',
	    iconNamedSVG: 'earthquake',
	    align: 'center',
	    valign: 'top',
	    text: 'Location',
	    outline: true,
	    offsetX: 0,
	    iconSize: 14,
	    x: 0.5,
	    y: 0.4,
	    _info: 'Epicenter Icon With Label',
	    _warn: 'Please only use to denote an epicenter',
	    _typeVariations: 'icon'
	  }]
	};

	// singleSelection type will avoid any sub
	// variation object (for example with icons)

	var lineCollection = {
	  id: 'lineCollection',
	  type: 'collection',
	  title: 'Callout Lines',
	  description: 'A collection of lines and angled lines for regions that are too small to enclose text or to provide underlying detail or numbers.',
	  warning: '<b><i>Please adhere to the style guide:</i></b> <br><b>Only</b> use these callout lines to display facts or locations, any commentary should be reserved for swoopy arrow labels.',
	  previewItem: {
	    type: 'line',
	    text: 'Nova<br>Scotia',
	    outline: true,
	    align: 'left',
	    x: 0.1,
	    y: 0.2,
	    x2: 30,
	    y2: 0
	  },
	  items: [{
	    preset: 'line-left',
	    type: 'line',
	    text: 'Nova<br>Scotia',
	    outline: true,
	    align: 'left',
	    valign: 'top',
	    lineStyle: 'horizontal',
	    x: 0.1,
	    y: 0.2,
	    x2: 30,
	    y2: 0,
	    _info: 'Basic line to the left',
	    _typeVariations: 'line',
	    _variations: {
	      valign: true
	    }
	  }, {
	    preset: 'line-right',
	    type: 'line',
	    text: 'Nova<br>Scotia',
	    outline: true,
	    align: 'right',
	    valign: 'top',
	    lineStyle: 'horizontal',
	    x: 0.8,
	    y: 0.2,
	    x2: -30,
	    y2: 0,
	    _info: 'Basic line to the right',
	    _typeVariations: 'line',
	    _variations: {
	      valign: true
	    }
	  }, {
	    preset: 'line-top',
	    type: 'line',
	    text: 'Nova<br>Scotia',
	    outline: true,
	    align: 'left',
	    valign: 'top',
	    lineStyle: 'vertical',
	    x: 0.4,
	    y: 0.1,
	    x2: 0,
	    y2: 30,
	    _info: 'Basic line above',
	    _typeVariations: 'line',
	    _variations: {
	      align: true
	    }
	  }, {
	    preset: 'line-bottom',
	    type: 'line',
	    text: 'Nova<br>Scotia',
	    outline: true,
	    align: 'right',
	    valign: 'bottom',
	    lineStyle: 'vertical',
	    x: 0.8,
	    y: 0.8,
	    x2: 0,
	    y2: -30,
	    _info: 'Basic line below',
	    _typeVariations: 'line',
	    _variations: {
	      align: true
	    }
	  }, {
	    preset: 'line-top-left',
	    type: 'linebend',
	    text: 'Nova<br>Scotia',
	    outline: true,
	    align: 'left',
	    lineStyle: 'vertical',
	    x: 0.2,
	    y: 0.1,
	    x2: 20,
	    y2: 0,
	    x3: 20,
	    y3: 30,
	    _info: 'Angled Line Top Left',
	    _typeVariations: 'line',
	    _variations: {
	      align: true
	    }
	  }, {
	    preset: 'line-left-up',
	    type: 'linebend',
	    text: 'Nova<br>Scotia',
	    outline: true,
	    align: 'left',
	    lineStyle: 'horizontal',
	    x: 0.2,
	    y: 0.1,
	    x2: 0,
	    y2: 20,
	    x3: 30,
	    y3: 20,
	    _info: 'Angled Line Left Top',
	    _typeVariations: 'line',
	    _variations: {
	      valign: true
	    }
	  }, {
	    preset: 'line-top-right',
	    type: 'linebend',
	    text: 'Nova<br>Scotia',
	    outline: true,
	    align: 'right',
	    lineStyle: 'vertical',
	    x: 0.8,
	    y: 0.1,
	    x2: -20,
	    y2: 0,
	    x3: -20,
	    y3: 30,
	    _info: 'Angled Line Top Right',
	    _typeVariations: 'line',
	    _variations: {
	      align: true
	    }
	  }, {
	    preset: 'line-right-up',
	    type: 'linebend',
	    text: 'Nova<br>Scotia',
	    outline: true,
	    align: 'right',
	    lineStyle: 'horizontal',
	    x: 0.8,
	    y: 0.1,
	    x2: 0,
	    y2: 20,
	    x3: -30,
	    y3: 20,
	    _info: 'Angled Line Right Top',
	    _typeVariations: 'line',
	    _variations: {
	      valign: true
	    }
	  }, {
	    preset: 'line-bottom-left',
	    type: 'linebend',
	    text: 'Nova<br>Scotia',
	    outline: true,
	    align: 'left',
	    valign: 'bottom',
	    lineStyle: 'vertical',
	    x: 0.1,
	    y: 0.7,
	    x2: 20,
	    y2: 0,
	    x3: 20,
	    y3: -30,
	    _info: 'Angled Line Bottom Left',
	    _typeVariations: 'line',
	    _variations: {
	      align: true
	    }
	  }, {
	    preset: 'line-left-down',
	    type: 'linebend',
	    text: 'Nova<br>Scotia',
	    outline: true,
	    align: 'left',
	    valign: 'bottom',
	    lineStyle: 'horizontal',
	    x: 0.1,
	    y: 0.7,
	    x2: 0,
	    y2: -20,
	    x3: 30,
	    y3: -20,
	    _info: 'Angled Line Left Bottom',
	    _typeVariations: 'line',
	    _variations: {
	      valign: true
	    }
	  }, {
	    preset: 'line-bottom-right',
	    type: 'linebend',
	    text: 'Nova<br>Scotia',
	    outline: true,
	    align: 'right',
	    valign: 'bottom',
	    lineStyle: 'vertical',
	    x: 0.8,
	    y: 0.6,
	    x2: -20,
	    y2: 0,
	    x3: -20,
	    y3: -30,
	    _info: 'Angled Line Bottom Right',
	    _typeVariations: 'line',
	    _variations: {
	      align: true
	    }
	  }, {
	    preset: 'line-right-down',
	    type: 'linebend',
	    text: 'Nova<br>Scotia',
	    outline: true,
	    align: 'right',
	    valign: 'bottom',
	    lineStyle: 'horizontal',
	    x: 0.8,
	    y: 0.6,
	    x2: 0,
	    y2: -20,
	    x3: -30,
	    y3: -20,
	    _info: 'Angled Line Right Bottom',
	    _typeVariations: 'line',
	    _variations: {
	      valign: true
	    }
	  }, {
	    preset: 'line-diagonal-left-top',
	    type: 'line',
	    text: 'Nova<br>Scotia',
	    outline: true,
	    align: 'left',
	    lineStyle: 'diagonal',
	    x: 0.1,
	    y: 0.1,
	    x2: 20,
	    y2: 20,
	    _info: 'Diagonal Line Left Top',
	    _typeVariations: 'line',
	    _variations: {}
	  }, {
	    preset: 'line-diagonal-right-top',
	    type: 'line',
	    text: 'Nova<br>Scotia',
	    outline: true,
	    align: 'right',
	    valign: 'top',
	    lineStyle: 'diagonal',
	    x: 0.8,
	    y: 0.1,
	    x2: -20,
	    y2: 20,
	    _info: 'Diagonal Line Right Top',
	    _typeVariations: 'line',
	    _variations: {}
	  }, {
	    preset: 'line-diagonal-left-bottom',
	    type: 'line',
	    text: 'Nova<br>Scotia',
	    outline: true,
	    align: 'left',
	    valign: 'bottom',
	    lineStyle: 'diagonal',
	    x: 0.1,
	    y: 0.8,
	    x2: 20,
	    y2: -20,
	    _info: 'Diagonal Line Left Bottom',
	    _typeVariations: 'line',
	    _variations: {}
	  }, {
	    preset: 'line-diagonal-right-bottom',
	    type: 'line',
	    text: 'Nova<br>Scotia',
	    outline: true,
	    align: 'right',
	    valign: 'bottom',
	    lineStyle: 'diagonal',
	    x: 0.8,
	    y: 0.6,
	    x2: -20,
	    y2: -20,
	    _info: 'Diagonal Line Right Bottom',
	    _typeVariations: 'line',
	    _variations: {}
	  }]
	};

	// singleSelection type will avoid any sub
	// variation object (for example with icons)

	var arrowCollection = {
	  id: 'arrowCollection',
	  type: 'collection',
	  title: 'Context Arrows',
	  description: 'A collection of arrows for adding contextual information to a feature or region. Use lines for details and names, and leave the arrows for additional commentary.',
	  warning: '<b><i>Please adhere to the style guide:</i></b> <br><b>Only</b> use these callout lines to display facts or locations, any commentary should be reserved for swoopy arrow labels.',
	  previewItem: {
	    type: 'arrow',
	    text: 'Honda\'s Swindon plant will fully close in 2021',
	    outline: true,
	    textWidth: 125,
	    align: 'center',
	    valign: 'top',
	    arrowStyle: 'twoHandle',
	    lineStyle: 'vertical',
	    offsetX: 0,
	    offsetY: 0,
	    x: 0.7,
	    y: 0.1,
	    x2: -10,
	    y2: 4,
	    x3: -20,
	    y3: 20
	  },
	  items: [{
	    preset: 'arrow-top-left',
	    type: 'arrow',
	    text: 'Honda\'s Swindon plant will fully close in 2021',
	    outline: true,
	    align: 'center',
	    valign: 'top',
	    lineStyle: 'vertical',
	    arrowStyle: 'twoHandle',
	    textWidth: 125,
	    offsetX: 0,
	    offsetY: 0,
	    x: 0.3,
	    y: 0.1,
	    x2: 18,
	    y2: 10,
	    x3: 20,
	    y3: 20,
	    _info: 'Arrow Top Left'
	  }, {
	    preset: 'arrow-top-right',
	    type: 'arrow',
	    text: 'Honda\'s Swindon plant will fully close in 2021',
	    outline: true,
	    align: 'center',
	    valign: 'top',
	    arrowStyle: 'twoHandle',
	    lineStyle: 'vertical',
	    textWidth: 125,
	    offsetX: 0,
	    offsetY: 0,
	    x: 0.7,
	    y: 0.1,
	    x2: -10,
	    y2: 4,
	    x3: -20,
	    y3: 20,
	    _info: 'Arrow Top Right'
	  }, {
	    preset: 'arrow-bottom-left',
	    type: 'arrow',
	    text: 'Honda\'s Swindon plant will fully close in 2021',
	    outline: true,
	    align: 'center',
	    valign: 'bottom',
	    arrowStyle: 'twoHandle',
	    lineStyle: 'vertical',
	    textWidth: 125,
	    offsetX: 0,
	    offsetY: 0,
	    x: 0.3,
	    y: 0.8,
	    x2: 10,
	    y2: -4,
	    x3: 20,
	    y3: -20,
	    _info: 'Arrow Bottom Left'
	  }, {
	    preset: 'arrow-bottom-right',
	    type: 'arrow',
	    text: 'Honda\'s Swindon plant will fully close in 2021',
	    outline: true,
	    align: 'center',
	    valign: 'bottom',
	    arrowStyle: 'twoHandle',
	    lineStyle: 'vertical',
	    textWidth: 125,
	    offsetX: 0,
	    offsetY: 0,
	    x: 0.7,
	    y: 0.8,
	    x2: -10,
	    y2: -4,
	    x3: -20,
	    y3: -20,
	    _info: 'Arrow Bottom Right'
	  }, {
	    preset: 'arrow-left',
	    type: 'arrow',
	    text: 'Honda\'s Swindon plant will fully close in 2021',
	    outline: true,
	    align: 'center',
	    valign: 'center',
	    arrowStyle: 'twoHandle',
	    lineStyle: 'horizontal',
	    textWidth: 100,
	    offsetX: 48,
	    offsetY: -5,
	    x: 0.1,
	    y: 0.3,
	    x2: 20,
	    y2: 14,
	    x3: 30,
	    y3: 16,
	    _info: 'Arrow Left Side',
	    _warn: 'If using a side arrow manually position so that it is close to the text edge'
	  }, {
	    preset: 'arrow-right',
	    type: 'arrow',
	    text: 'Honda\'s Swindon plant will fully close in 2021',
	    outline: true,
	    align: 'center',
	    valign: 'center',
	    textWidth: 100,
	    arrowStyle: 'twoHandle',
	    lineStyle: 'horizontal',
	    offsetX: -48,
	    offsetY: -5,
	    x: 0.9,
	    y: 0.3,
	    x2: -20,
	    y2: 14,
	    x3: -30,
	    y3: 16,
	    _info: 'Arrow Right Side',
	    _warn: 'If using a side arrow manually position so that it is close to the text edge'
	  }]
	};

	// Pulled shapes out of locatormap collection -- may include these
	// again at a later date
	var shapeCollection = {
	  type: 'collection',
	  title: 'Shapes',
	  description: 'A collection of arrows for adding contextual information to a feature or region. Use lines for details and names, and leave the arrows for additional commentary.',
	  roles: ['advanced'],
	  previewItem: {
	    type: 'circle',
	    color: '#000000',
	    fill: 'blue',
	    radius: 15,
	    x: 0.5,
	    y: 0.4
	  },
	  items: [{
	    type: 'circle',
	    radius: 25,
	    x: 0.5,
	    y: 0.4,
	    _info: 'Basic Circle'
	  }, {
	    type: 'circle',
	    text: 'Circle With Text',
	    radius: 20,
	    align: 'center',
	    valign: 'bottom',
	    stroke: 'black',
	    x: 0.5,
	    y: 0.4,
	    _info: 'Circle With Text'
	  }]
	}; // Pulled svg items out of locatormap collection -- may include these
	// again at a later date

	var svgCollection = {
	  type: 'collection',
	  title: 'Custom Media: Images, SVG',
	  description: 'A collection of arrows for adding contextual information to a feature or region. Use lines for details and names, and leave the arrows for additional commentary.',
	  roles: ['advanced'],
	  previewItem: {
	    type: 'circle',
	    color: '#000000',
	    radius: 15,
	    x: 0.5,
	    y: 0.4
	  },
	  items: [{
	    type: 'text',
	    text: 'Single Line label',
	    align: 'left',
	    outline: true,
	    x: 0,
	    y: 0,
	    _type: 'text'
	  }]
	};

	var advancedCollection = {
	  id: 'advancedCollection',
	  type: 'collection',
	  title: 'Select a Draggable Label Type to Add .',
	  items: [labelCollectionMaps, iconCollection, lineCollection, arrowCollection, shapeCollection, svgCollection]
	};

	function add_css$4(target) {
	  append_styles(target, "svelte-1ixuhkx", ".editor-wrapper, .editor-wrapper div, .editor-wrapper button, .editor-wrapper textarea{font-family:\"BWHaasDingbat\", \"BWHaasText\", \"Helvetica Neue\", Helvetica, Arial, sans-serif;font-size:12px}.editor-wrapper button{display:inline-block;border:1px solid rgba(41, 32, 226, .13);cursor:pointer;background:#ffffff;border-radius:3px;box-shadow:1px 1px 3px rgba(41, 32, 226, .13)}.editor-wrapper button.flat{color:#001aaa;box-shadow:none;border-color:transparent;background:#eeeeee}.editor-wrapper button.icon svg{width:16px;height:16px}.editor-wrapper button:hover, .editor-wrapper button.bar-button:hover{background:#001aaa;border-color:#001aaa;color:white}.menu-bar.svelte-1ixuhkx.svelte-1ixuhkx{font-size:12px;position:absolute;right:5px;top:5px}.editor-wrapper.svelte-1ixuhkx.svelte-1ixuhkx{position:absolute;top:0;left:0;z-index:100;width:100%}div.svelte-1ixuhkx button.svelte-1ixuhkx{display:inline-block;font-size:12px}.editor-wrapper button.bar-button{background:#ffffff;border-color:#001aaa;color:#001aaa}");
	}

	var get_content_slot_changes = function get_content_slot_changes(dirty) {
	  return {};
	};

	var get_content_slot_context = function get_content_slot_context(ctx) {
	  return {};
	}; // (294:2) {#if renderEditorBar}


	function create_if_block_5$1(ctx) {
	  var div;
	  var button0;
	  var t1;
	  var button1;
	  var mounted;
	  var dispose;
	  return {
	    c: function c() {
	      div = element("div");
	      button0 = element("button");
	      button0.textContent = "Add Draggable";
	      t1 = space();
	      button1 = element("button");
	      button1.textContent = "...";
	      attr(button0, "class", "bar-button svelte-1ixuhkx");
	      attr(button1, "class", "bar-button svelte-1ixuhkx");
	      attr(div, "class", "menu-bar svelte-1ixuhkx");
	    },
	    m: function m(target, anchor) {
	      insert(target, div, anchor);
	      append(div, button0);
	      append(div, t1);
	      append(div, button1);

	      if (!mounted) {
	        dispose = [listen(button0, "click",
	        /*showAddMenu*/
	        ctx[13]), listen(button1, "click",
	        /*showOptions*/
	        ctx[30])];
	        mounted = true;
	      }
	    },
	    p: noop,
	    d: function d(detaching) {
	      if (detaching) detach(div);
	      mounted = false;
	      run_all(dispose);
	    }
	  };
	} // (301:2) {#if addDialogVisible}


	function create_if_block_4$1(ctx) {
	  var editoradddialog;
	  var current;
	  editoradddialog = new EditorAddDialog({
	    props: {
	      onComplete:
	      /*addCompleteHandler*/
	      ctx[29],
	      scale:
	      /*scale*/
	      ctx[6],
	      containerWidth:
	      /*containerWidth*/
	      ctx[1],
	      collection:
	      /*collection*/
	      ctx[9],
	      options:
	      /*options*/
	      ctx[2]
	    }
	  });
	  return {
	    c: function c() {
	      create_component(editoradddialog.$$.fragment);
	    },
	    m: function m(target, anchor) {
	      mount_component(editoradddialog, target, anchor);
	      current = true;
	    },
	    p: function p(ctx, dirty) {
	      var editoradddialog_changes = {};
	      if (dirty[0] &
	      /*addCompleteHandler*/
	      536870912) editoradddialog_changes.onComplete =
	      /*addCompleteHandler*/
	      ctx[29];
	      if (dirty[0] &
	      /*scale*/
	      64) editoradddialog_changes.scale =
	      /*scale*/
	      ctx[6];
	      if (dirty[0] &
	      /*containerWidth*/
	      2) editoradddialog_changes.containerWidth =
	      /*containerWidth*/
	      ctx[1];
	      if (dirty[0] &
	      /*collection*/
	      512) editoradddialog_changes.collection =
	      /*collection*/
	      ctx[9];
	      if (dirty[0] &
	      /*options*/
	      4) editoradddialog_changes.options =
	      /*options*/
	      ctx[2];
	      editoradddialog.$set(editoradddialog_changes);
	    },
	    i: function i(local) {
	      if (current) return;
	      transition_in(editoradddialog.$$.fragment, local);
	      current = true;
	    },
	    o: function o(local) {
	      transition_out(editoradddialog.$$.fragment, local);
	      current = false;
	    },
	    d: function d(detaching) {
	      destroy_component(editoradddialog, detaching);
	    }
	  };
	} // (311:2) {#if placementModeVisible}


	function create_if_block_3$1(ctx) {
	  var editorplacement;
	  var current;
	  editorplacement = new EditorPlacement({
	    props: {
	      draggable:
	      /*placementDraggable*/
	      ctx[25],
	      placementMode:
	      /*placementModeVisible*/
	      ctx[16],
	      editorTarget:
	      /*placementNode*/
	      ctx[27],
	      draggablesTarget:
	      /*draggablesTarget*/
	      ctx[4],
	      onComplete:
	      /*placementCompleteHandler*/
	      ctx[28],
	      scale:
	      /*scale*/
	      ctx[6],
	      containerWidth:
	      /*containerWidth*/
	      ctx[1],
	      placementMessage:
	      /*placementMessage*/
	      ctx[7],
	      collection:
	      /*collection*/
	      ctx[9],
	      addDraggable:
	      /*addDraggable*/
	      ctx[3],
	      options:
	      /*options*/
	      ctx[2]
	    }
	  });
	  return {
	    c: function c() {
	      create_component(editorplacement.$$.fragment);
	    },
	    m: function m(target, anchor) {
	      mount_component(editorplacement, target, anchor);
	      current = true;
	    },
	    p: function p(ctx, dirty) {
	      var editorplacement_changes = {};
	      if (dirty[0] &
	      /*placementDraggable*/
	      33554432) editorplacement_changes.draggable =
	      /*placementDraggable*/
	      ctx[25];
	      if (dirty[0] &
	      /*placementModeVisible*/
	      65536) editorplacement_changes.placementMode =
	      /*placementModeVisible*/
	      ctx[16];
	      if (dirty[0] &
	      /*placementNode*/
	      134217728) editorplacement_changes.editorTarget =
	      /*placementNode*/
	      ctx[27];
	      if (dirty[0] &
	      /*draggablesTarget*/
	      16) editorplacement_changes.draggablesTarget =
	      /*draggablesTarget*/
	      ctx[4];
	      if (dirty[0] &
	      /*placementCompleteHandler*/
	      268435456) editorplacement_changes.onComplete =
	      /*placementCompleteHandler*/
	      ctx[28];
	      if (dirty[0] &
	      /*scale*/
	      64) editorplacement_changes.scale =
	      /*scale*/
	      ctx[6];
	      if (dirty[0] &
	      /*containerWidth*/
	      2) editorplacement_changes.containerWidth =
	      /*containerWidth*/
	      ctx[1];
	      if (dirty[0] &
	      /*placementMessage*/
	      128) editorplacement_changes.placementMessage =
	      /*placementMessage*/
	      ctx[7];
	      if (dirty[0] &
	      /*collection*/
	      512) editorplacement_changes.collection =
	      /*collection*/
	      ctx[9];
	      if (dirty[0] &
	      /*addDraggable*/
	      8) editorplacement_changes.addDraggable =
	      /*addDraggable*/
	      ctx[3];
	      if (dirty[0] &
	      /*options*/
	      4) editorplacement_changes.options =
	      /*options*/
	      ctx[2];
	      editorplacement.$set(editorplacement_changes);
	    },
	    i: function i(local) {
	      if (current) return;
	      transition_in(editorplacement.$$.fragment, local);
	      current = true;
	    },
	    o: function o(local) {
	      transition_out(editorplacement.$$.fragment, local);
	      current = false;
	    },
	    d: function d(detaching) {
	      destroy_component(editorplacement, detaching);
	    }
	  };
	} // (327:2) {#if showEditorOptions}


	function create_if_block_2$1(ctx) {
	  var editoroptions;
	  var current;
	  editoroptions = new EditorOptions({
	    props: {
	      draggablesComponent:
	      /*draggablesComponent*/
	      ctx[5],
	      closeOptions:
	      /*closeOptions*/
	      ctx[31],
	      options:
	      /*options*/
	      ctx[2]
	    }
	  });
	  return {
	    c: function c() {
	      create_component(editoroptions.$$.fragment);
	    },
	    m: function m(target, anchor) {
	      mount_component(editoroptions, target, anchor);
	      current = true;
	    },
	    p: function p(ctx, dirty) {
	      var editoroptions_changes = {};
	      if (dirty[0] &
	      /*draggablesComponent*/
	      32) editoroptions_changes.draggablesComponent =
	      /*draggablesComponent*/
	      ctx[5];
	      if (dirty[0] &
	      /*options*/
	      4) editoroptions_changes.options =
	      /*options*/
	      ctx[2];
	      editoroptions.$set(editoroptions_changes);
	    },
	    i: function i(local) {
	      if (current) return;
	      transition_in(editoroptions.$$.fragment, local);
	      current = true;
	    },
	    o: function o(local) {
	      transition_out(editoroptions.$$.fragment, local);
	      current = false;
	    },
	    d: function d(detaching) {
	      destroy_component(editoroptions, detaching);
	    }
	  };
	} // (335:2) {#if genericEditorMounted}


	function create_if_block_1$1(ctx) {
	  var editorgeneric;
	  var current;
	  editorgeneric = new EditorGeneric({
	    props: {
	      id:
	      /*editFields*/
	      ctx[19].id,
	      type:
	      /*editFields*/
	      ctx[19].type,
	      x:
	      /*editPosition*/
	      ctx[20][0],
	      y:
	      /*editPosition*/
	      ctx[20][1],
	      dialogPosition:
	      /*dialogPosition*/
	      ctx[22],
	      visible:
	      /*editFields*/
	      ctx[19].visible,
	      onChange:
	      /*updateDraggable*/
	      ctx[23],
	      onClose:
	      /*closeEditorWindow*/
	      ctx[26],
	      active: "true",
	      editProperties:
	      /*editProperties*/
	      ctx[21],
	      editFields:
	      /*editFields*/
	      ctx[19],
	      removeDraggable:
	      /*removeDraggable*/
	      ctx[24],
	      showAdvancedFields:
	      /*showAdvancedFields*/
	      ctx[10],
	      customTypeActions:
	      /*customTypeActions*/
	      ctx[8]
	    }
	  });
	  return {
	    c: function c() {
	      create_component(editorgeneric.$$.fragment);
	    },
	    m: function m(target, anchor) {
	      mount_component(editorgeneric, target, anchor);
	      current = true;
	    },
	    p: function p(ctx, dirty) {
	      var editorgeneric_changes = {};
	      if (dirty[0] &
	      /*editFields*/
	      524288) editorgeneric_changes.id =
	      /*editFields*/
	      ctx[19].id;
	      if (dirty[0] &
	      /*editFields*/
	      524288) editorgeneric_changes.type =
	      /*editFields*/
	      ctx[19].type;
	      if (dirty[0] &
	      /*editPosition*/
	      1048576) editorgeneric_changes.x =
	      /*editPosition*/
	      ctx[20][0];
	      if (dirty[0] &
	      /*editPosition*/
	      1048576) editorgeneric_changes.y =
	      /*editPosition*/
	      ctx[20][1];
	      if (dirty[0] &
	      /*dialogPosition*/
	      4194304) editorgeneric_changes.dialogPosition =
	      /*dialogPosition*/
	      ctx[22];
	      if (dirty[0] &
	      /*editFields*/
	      524288) editorgeneric_changes.visible =
	      /*editFields*/
	      ctx[19].visible;
	      if (dirty[0] &
	      /*updateDraggable*/
	      8388608) editorgeneric_changes.onChange =
	      /*updateDraggable*/
	      ctx[23];
	      if (dirty[0] &
	      /*closeEditorWindow*/
	      67108864) editorgeneric_changes.onClose =
	      /*closeEditorWindow*/
	      ctx[26];
	      if (dirty[0] &
	      /*editProperties*/
	      2097152) editorgeneric_changes.editProperties =
	      /*editProperties*/
	      ctx[21];
	      if (dirty[0] &
	      /*editFields*/
	      524288) editorgeneric_changes.editFields =
	      /*editFields*/
	      ctx[19];
	      if (dirty[0] &
	      /*removeDraggable*/
	      16777216) editorgeneric_changes.removeDraggable =
	      /*removeDraggable*/
	      ctx[24];
	      if (dirty[0] &
	      /*showAdvancedFields*/
	      1024) editorgeneric_changes.showAdvancedFields =
	      /*showAdvancedFields*/
	      ctx[10];
	      if (dirty[0] &
	      /*customTypeActions*/
	      256) editorgeneric_changes.customTypeActions =
	      /*customTypeActions*/
	      ctx[8];
	      editorgeneric.$set(editorgeneric_changes);
	    },
	    i: function i(local) {
	      if (current) return;
	      transition_in(editorgeneric.$$.fragment, local);
	      current = true;
	    },
	    o: function o(local) {
	      transition_out(editorgeneric.$$.fragment, local);
	      current = false;
	    },
	    d: function d(detaching) {
	      destroy_component(editorgeneric, detaching);
	    }
	  };
	} // (354:2) {#if textEditorMounted}


	function create_if_block$3(ctx) {
	  var editortext;
	  var current;
	  editortext = new EditorText({
	    props: {
	      id:
	      /*editFields*/
	      ctx[19].id,
	      type:
	      /*editFields*/
	      ctx[19].type,
	      x:
	      /*editPosition*/
	      ctx[20][0],
	      y:
	      /*editPosition*/
	      ctx[20][1],
	      dialogPosition:
	      /*dialogPosition*/
	      ctx[22],
	      visible:
	      /*editFields*/
	      ctx[19].visible,
	      text:
	      /*editFields*/
	      ctx[19].text,
	      align:
	      /*editFields*/
	      ctx[19].align,
	      valign:
	      /*editFields*/
	      ctx[19].valign,
	      color:
	      /*editFields*/
	      ctx[19].color,
	      outline:
	      /*editFields*/
	      ctx[19].outline,
	      infoBox:
	      /*editFields*/
	      ctx[19].infoBox,
	      textWidth:
	      /*editFields*/
	      ctx[19].textWidth,
	      onChange:
	      /*updateDraggable*/
	      ctx[23],
	      onClose:
	      /*closeEditorWindow*/
	      ctx[26],
	      active: "true",
	      customTypeActions:
	      /*customTypeActions*/
	      ctx[8],
	      renderContextMenu:
	      /*renderContextMenu*/
	      ctx[12],
	      removeDraggable:
	      /*removeDraggable*/
	      ctx[24],
	      showAdvancedFields:
	      /*showAdvancedFields*/
	      ctx[10]
	    }
	  });
	  return {
	    c: function c() {
	      create_component(editortext.$$.fragment);
	    },
	    m: function m(target, anchor) {
	      mount_component(editortext, target, anchor);
	      current = true;
	    },
	    p: function p(ctx, dirty) {
	      var editortext_changes = {};
	      if (dirty[0] &
	      /*editFields*/
	      524288) editortext_changes.id =
	      /*editFields*/
	      ctx[19].id;
	      if (dirty[0] &
	      /*editFields*/
	      524288) editortext_changes.type =
	      /*editFields*/
	      ctx[19].type;
	      if (dirty[0] &
	      /*editPosition*/
	      1048576) editortext_changes.x =
	      /*editPosition*/
	      ctx[20][0];
	      if (dirty[0] &
	      /*editPosition*/
	      1048576) editortext_changes.y =
	      /*editPosition*/
	      ctx[20][1];
	      if (dirty[0] &
	      /*dialogPosition*/
	      4194304) editortext_changes.dialogPosition =
	      /*dialogPosition*/
	      ctx[22];
	      if (dirty[0] &
	      /*editFields*/
	      524288) editortext_changes.visible =
	      /*editFields*/
	      ctx[19].visible;
	      if (dirty[0] &
	      /*editFields*/
	      524288) editortext_changes.text =
	      /*editFields*/
	      ctx[19].text;
	      if (dirty[0] &
	      /*editFields*/
	      524288) editortext_changes.align =
	      /*editFields*/
	      ctx[19].align;
	      if (dirty[0] &
	      /*editFields*/
	      524288) editortext_changes.valign =
	      /*editFields*/
	      ctx[19].valign;
	      if (dirty[0] &
	      /*editFields*/
	      524288) editortext_changes.color =
	      /*editFields*/
	      ctx[19].color;
	      if (dirty[0] &
	      /*editFields*/
	      524288) editortext_changes.outline =
	      /*editFields*/
	      ctx[19].outline;
	      if (dirty[0] &
	      /*editFields*/
	      524288) editortext_changes.infoBox =
	      /*editFields*/
	      ctx[19].infoBox;
	      if (dirty[0] &
	      /*editFields*/
	      524288) editortext_changes.textWidth =
	      /*editFields*/
	      ctx[19].textWidth;
	      if (dirty[0] &
	      /*updateDraggable*/
	      8388608) editortext_changes.onChange =
	      /*updateDraggable*/
	      ctx[23];
	      if (dirty[0] &
	      /*closeEditorWindow*/
	      67108864) editortext_changes.onClose =
	      /*closeEditorWindow*/
	      ctx[26];
	      if (dirty[0] &
	      /*customTypeActions*/
	      256) editortext_changes.customTypeActions =
	      /*customTypeActions*/
	      ctx[8];
	      if (dirty[0] &
	      /*renderContextMenu*/
	      4096) editortext_changes.renderContextMenu =
	      /*renderContextMenu*/
	      ctx[12];
	      if (dirty[0] &
	      /*removeDraggable*/
	      16777216) editortext_changes.removeDraggable =
	      /*removeDraggable*/
	      ctx[24];
	      if (dirty[0] &
	      /*showAdvancedFields*/
	      1024) editortext_changes.showAdvancedFields =
	      /*showAdvancedFields*/
	      ctx[10];
	      editortext.$set(editortext_changes);
	    },
	    i: function i(local) {
	      if (current) return;
	      transition_in(editortext.$$.fragment, local);
	      current = true;
	    },
	    o: function o(local) {
	      transition_out(editortext.$$.fragment, local);
	      current = false;
	    },
	    d: function d(detaching) {
	      destroy_component(editortext, detaching);
	    }
	  };
	}

	function create_fragment$5(ctx) {
	  var div;
	  var t0;
	  var t1;
	  var t2;
	  var t3;
	  var t4;
	  var t5;
	  var current;
	  var if_block0 =
	  /*renderEditorBar*/
	  ctx[11] && create_if_block_5$1(ctx);
	  var if_block1 =
	  /*addDialogVisible*/
	  ctx[15] && create_if_block_4$1(ctx);
	  var if_block2 =
	  /*placementModeVisible*/
	  ctx[16] && create_if_block_3$1(ctx);
	  var if_block3 =
	  /*showEditorOptions*/
	  ctx[14] && create_if_block_2$1(ctx);
	  var if_block4 =
	  /*genericEditorMounted*/
	  ctx[18] && create_if_block_1$1(ctx);
	  var if_block5 =
	  /*textEditorMounted*/
	  ctx[17] && create_if_block$3(ctx);
	  var content_slot_template =
	  /*#slots*/
	  ctx[44].content;
	  var content_slot = create_slot(content_slot_template, ctx,
	  /*$$scope*/
	  ctx[43], get_content_slot_context);
	  return {
	    c: function c() {
	      div = element("div");
	      if (if_block0) if_block0.c();
	      t0 = space();
	      if (if_block1) if_block1.c();
	      t1 = space();
	      if (if_block2) if_block2.c();
	      t2 = space();
	      if (if_block3) if_block3.c();
	      t3 = space();
	      if (if_block4) if_block4.c();
	      t4 = space();
	      if (if_block5) if_block5.c();
	      t5 = space();
	      if (content_slot) content_slot.c();
	      attr(div, "class", "editor-wrapper svelte-1ixuhkx");
	    },
	    m: function m(target, anchor) {
	      insert(target, div, anchor);
	      if (if_block0) if_block0.m(div, null);
	      append(div, t0);
	      if (if_block1) if_block1.m(div, null);
	      append(div, t1);
	      if (if_block2) if_block2.m(div, null);
	      append(div, t2);
	      if (if_block3) if_block3.m(div, null);
	      append(div, t3);
	      if (if_block4) if_block4.m(div, null);
	      append(div, t4);
	      if (if_block5) if_block5.m(div, null);
	      append(div, t5);

	      if (content_slot) {
	        content_slot.m(div, null);
	      }
	      /*div_binding*/


	      ctx[45](div);
	      current = true;
	    },
	    p: function p(ctx, dirty) {
	      if (
	      /*renderEditorBar*/
	      ctx[11]) {
	        if (if_block0) {
	          if_block0.p(ctx, dirty);
	        } else {
	          if_block0 = create_if_block_5$1(ctx);
	          if_block0.c();
	          if_block0.m(div, t0);
	        }
	      } else if (if_block0) {
	        if_block0.d(1);
	        if_block0 = null;
	      }

	      if (
	      /*addDialogVisible*/
	      ctx[15]) {
	        if (if_block1) {
	          if_block1.p(ctx, dirty);

	          if (dirty[0] &
	          /*addDialogVisible*/
	          32768) {
	            transition_in(if_block1, 1);
	          }
	        } else {
	          if_block1 = create_if_block_4$1(ctx);
	          if_block1.c();
	          transition_in(if_block1, 1);
	          if_block1.m(div, t1);
	        }
	      } else if (if_block1) {
	        group_outros();
	        transition_out(if_block1, 1, 1, function () {
	          if_block1 = null;
	        });
	        check_outros();
	      }

	      if (
	      /*placementModeVisible*/
	      ctx[16]) {
	        if (if_block2) {
	          if_block2.p(ctx, dirty);

	          if (dirty[0] &
	          /*placementModeVisible*/
	          65536) {
	            transition_in(if_block2, 1);
	          }
	        } else {
	          if_block2 = create_if_block_3$1(ctx);
	          if_block2.c();
	          transition_in(if_block2, 1);
	          if_block2.m(div, t2);
	        }
	      } else if (if_block2) {
	        group_outros();
	        transition_out(if_block2, 1, 1, function () {
	          if_block2 = null;
	        });
	        check_outros();
	      }

	      if (
	      /*showEditorOptions*/
	      ctx[14]) {
	        if (if_block3) {
	          if_block3.p(ctx, dirty);

	          if (dirty[0] &
	          /*showEditorOptions*/
	          16384) {
	            transition_in(if_block3, 1);
	          }
	        } else {
	          if_block3 = create_if_block_2$1(ctx);
	          if_block3.c();
	          transition_in(if_block3, 1);
	          if_block3.m(div, t3);
	        }
	      } else if (if_block3) {
	        group_outros();
	        transition_out(if_block3, 1, 1, function () {
	          if_block3 = null;
	        });
	        check_outros();
	      }

	      if (
	      /*genericEditorMounted*/
	      ctx[18]) {
	        if (if_block4) {
	          if_block4.p(ctx, dirty);

	          if (dirty[0] &
	          /*genericEditorMounted*/
	          262144) {
	            transition_in(if_block4, 1);
	          }
	        } else {
	          if_block4 = create_if_block_1$1(ctx);
	          if_block4.c();
	          transition_in(if_block4, 1);
	          if_block4.m(div, t4);
	        }
	      } else if (if_block4) {
	        group_outros();
	        transition_out(if_block4, 1, 1, function () {
	          if_block4 = null;
	        });
	        check_outros();
	      }

	      if (
	      /*textEditorMounted*/
	      ctx[17]) {
	        if (if_block5) {
	          if_block5.p(ctx, dirty);

	          if (dirty[0] &
	          /*textEditorMounted*/
	          131072) {
	            transition_in(if_block5, 1);
	          }
	        } else {
	          if_block5 = create_if_block$3(ctx);
	          if_block5.c();
	          transition_in(if_block5, 1);
	          if_block5.m(div, t5);
	        }
	      } else if (if_block5) {
	        group_outros();
	        transition_out(if_block5, 1, 1, function () {
	          if_block5 = null;
	        });
	        check_outros();
	      }

	      if (content_slot) {
	        if (content_slot.p && (!current || dirty[1] &
	        /*$$scope*/
	        4096)) {
	          update_slot_base(content_slot, content_slot_template, ctx,
	          /*$$scope*/
	          ctx[43], !current ? get_all_dirty_from_scope(
	          /*$$scope*/
	          ctx[43]) : get_slot_changes(content_slot_template,
	          /*$$scope*/
	          ctx[43], dirty, get_content_slot_changes), get_content_slot_context);
	        }
	      }
	    },
	    i: function i(local) {
	      if (current) return;
	      transition_in(if_block1);
	      transition_in(if_block2);
	      transition_in(if_block3);
	      transition_in(if_block4);
	      transition_in(if_block5);
	      transition_in(content_slot, local);
	      current = true;
	    },
	    o: function o(local) {
	      transition_out(if_block1);
	      transition_out(if_block2);
	      transition_out(if_block3);
	      transition_out(if_block4);
	      transition_out(if_block5);
	      transition_out(content_slot, local);
	      current = false;
	    },
	    d: function d(detaching) {
	      if (detaching) detach(div);
	      if (if_block0) if_block0.d();
	      if (if_block1) if_block1.d();
	      if (if_block2) if_block2.d();
	      if (if_block3) if_block3.d();
	      if (if_block4) if_block4.d();
	      if (if_block5) if_block5.d();
	      if (content_slot) content_slot.d(detaching);
	      /*div_binding*/

	      ctx[45](null);
	    }
	  };
	}

	function instance$5($$self, $$props, $$invalidate) {
	  var _addCompleteHandler;

	  var _placementCompleteHandler;

	  var placementNode;
	  var _$$props$$$slots = $$props.$$slots,
	      slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots,
	      $$scope = $$props.$$scope;
	  var addDraggable = $$props.addDraggable;
	  var updateOptions = $$props.updateOptions;
	  var draggablesTarget = $$props.draggablesTarget;
	  var draggablesComponent = $$props.draggablesComponent;
	  var domNode = $$props.domNode;
	  var placementTarget = $$props.placementTarget;
	  var scale = $$props.scale;
	  var containerWidth = $$props.containerWidth;
	  var placementMessage = $$props.placementMessage;
	  var customTypeActions = $$props.customTypeActions;
	  var _$$props$collection = $$props.collection,
	      collection = _$$props$collection === void 0 ? advancedCollection : _$$props$collection;
	  var _$$props$showAdvanced = $$props.showAdvancedFields,
	      showAdvancedFields = _$$props$showAdvanced === void 0 ? false : _$$props$showAdvanced;
	  var _$$props$placementAft = $$props.placementAfterSelect,
	      placementAfterSelect = _$$props$placementAft === void 0 ? true : _$$props$placementAft;
	  var _$$props$renderEditor = $$props.renderEditorBar,
	      renderEditorBar = _$$props$renderEditor === void 0 ? true : _$$props$renderEditor;
	  var _$$props$renderContex = $$props.renderContextMenu,
	      renderContextMenu = _$$props$renderContex === void 0 ? true : _$$props$renderContex;
	  var _$$props$options = $$props.options,
	      options = _$$props$options === void 0 ? {} : _$$props$options;
	  var showEditorOptions = false;
	  var addDialogVisible = false;
	  var placementModeVisible = false;
	  var textEditorMounted = false;
	  var genericEditorMounted = false;
	  var editFields;
	  var editPosition;
	  var editProperties;
	  var dialogPosition;
	  var updateDraggable;
	  var removeDraggable;
	  var placementDraggable;

	  var closeEditorWindow = function closeEditorWindow() {
	    return 'yo';
	  };

	  function showAddMenu(placementCallback) {
	    $$invalidate(15, addDialogVisible = true);

	    if (placementCallback) {
	      bindPlacementCallback(placementCallback);
	    }
	  }

	  function showPlacementMode(draggable, callback) {
	    $$invalidate(15, addDialogVisible = false);
	    $$invalidate(16, placementModeVisible = true);
	    $$invalidate(25, placementDraggable = draggable);

	    if (callback) {
	      bindPlacementCallback(callback);
	    }
	  }

	  function hidePlacementMode() {
	    $$invalidate(16, placementModeVisible = false);
	  }

	  function showTypeVariants(draggable, callback) {
	    $$invalidate(15, addDialogVisible = true); // callback required

	    bindAddCallback(callback);
	  }

	  function mountTextEditor(fields, update, remove, closeCallback, pos) {
	    if (textEditorMounted) closeEditorWindow();
	    if (genericEditorMounted) closeEditorWindow();
	    $$invalidate(19, editFields = fields);
	    $$invalidate(23, updateDraggable = update);
	    $$invalidate(24, removeDraggable = remove);
	    $$invalidate(17, textEditorMounted = true);
	    $$invalidate(20, editPosition = pos);
	    $$invalidate(22, dialogPosition = pos);

	    if (dialogPosition[1] > window.innerHeight - 300) {
	      $$invalidate(22, dialogPosition = [0, 0]);
	    }

	    $$invalidate(26, closeEditorWindow = function closeEditorWindow() {
	      $$invalidate(17, textEditorMounted = false);
	      closeCallback();
	    });
	  }

	  function mountGenericEditor(properties, fields, update, remove, closeCallback, pos) {
	    if (textEditorMounted) closeEditorWindow();
	    if (genericEditorMounted) closeEditorWindow();
	    $$invalidate(21, editProperties = properties);
	    $$invalidate(19, editFields = fields);
	    $$invalidate(23, updateDraggable = update);
	    $$invalidate(24, removeDraggable = remove);
	    $$invalidate(18, genericEditorMounted = true);
	    $$invalidate(20, editPosition = pos);
	    $$invalidate(22, dialogPosition = pos);

	    if (dialogPosition[1] > window.innerHeight - 300) {
	      $$invalidate(22, dialogPosition = [0, 0]);
	    }

	    $$invalidate(26, closeEditorWindow = function closeEditorWindow() {
	      $$invalidate(18, genericEditorMounted = false);
	      closeCallback();
	    });
	  }

	  function updateFields(fields) {
	    Object.keys(fields).forEach(function (key) {
	      $$invalidate(19, editFields[key] = fields[key], editFields);
	    });
	  }

	  var documentCloseListener;

	  function bindDocumentCloseHandler(draggableNode, closeCallback) {
	    document.removeEventListener('click', documentCloseListener);

	    documentCloseListener = function documentCloseListener(e) {
	      if (!(e.path && e.path.filter)) return;
	      var filtered = e.path.filter(function (item) {
	        return item === domNode || item === draggableNode;
	      });

	      if (filtered.length === 0 && closeEditorWindow) {
	        closeEditorWindow();
	      }
	    };

	    document.addEventListener('click', documentCloseListener);
	  }

	  function calculateBounds() {
	    setTimeout(function () {
	      $$invalidate(1, containerWidth = draggablesTarget.offsetWidth);
	      var aBounds = draggablesTarget.getBoundingClientRect();
	      var bounds = {
	        top: 0,
	        left: 0,
	        right: 0,
	        bottom: 0
	      };
	      draggablesTarget.querySelectorAll('.draggable .text').forEach(function (node) {
	        var textBounds = node.getBoundingClientRect();
	        bounds.top = Math.min(bounds.top, textBounds.top - aBounds.top);
	        bounds.left = Math.min(bounds.left, textBounds.left - aBounds.left);
	        bounds.right = Math.max(bounds.right, textBounds.right - aBounds.left);
	        bounds.bottom = Math.max(bounds.bottom, textBounds.bottom - aBounds.top);
	      });
	      var activeBreakpoint = getBreakpoint(containerWidth, options.breakpoints, false);

	      if (activeBreakpoint) {
	        activeBreakpoint.bounds = bounds;
	      }

	      updateOptions(options);
	    }, 50);
	  }

	  function onAddComplete(draggable) {
	    $$invalidate(15, addDialogVisible = false);

	    if (draggable && placementAfterSelect) {
	      $$invalidate(16, placementModeVisible = true);
	      $$invalidate(25, placementDraggable = draggable);
	    }
	  }

	  function onPlacementComplete(draggable) {
	    $$invalidate(16, placementModeVisible = false);
	  }

	  function bindAddCallback(callback) {
	    $$invalidate(29, _addCompleteHandler = function addCompleteHandler(draggable) {
	      onAddComplete(draggable);

	      if (callback) {
	        callback(draggable);
	      } // now reset because we only want it used once


	      $$invalidate(29, _addCompleteHandler = onAddComplete);
	    });
	  }

	  function bindPlacementCallback(callback) {
	    $$invalidate(28, _placementCompleteHandler = function placementCompleteHandler(draggable) {
	      onPlacementComplete();

	      if (callback) {
	        callback(draggable);
	      } // now reset because we only want it used once


	      $$invalidate(28, _placementCompleteHandler = onPlacementComplete);
	    });
	  }

	  function showOptions() {
	    $$invalidate(14, showEditorOptions = true);
	  }

	  function closeOptions(_options) {
	    Object.keys(_options).forEach(function (key) {
	      $$invalidate(2, options[key] = _options[key], options);
	    });
	    $$invalidate(14, showEditorOptions = false);
	    updateOptions(options);
	  }

	  function div_binding($$value) {
	    binding_callbacks[$$value ? 'unshift' : 'push'](function () {
	      domNode = $$value;
	      $$invalidate(0, domNode);
	    });
	  }

	  $$self.$$set = function ($$props) {
	    if ('addDraggable' in $$props) $$invalidate(3, addDraggable = $$props.addDraggable);
	    if ('updateOptions' in $$props) $$invalidate(32, updateOptions = $$props.updateOptions);
	    if ('draggablesTarget' in $$props) $$invalidate(4, draggablesTarget = $$props.draggablesTarget);
	    if ('draggablesComponent' in $$props) $$invalidate(5, draggablesComponent = $$props.draggablesComponent);
	    if ('domNode' in $$props) $$invalidate(0, domNode = $$props.domNode);
	    if ('placementTarget' in $$props) $$invalidate(33, placementTarget = $$props.placementTarget);
	    if ('scale' in $$props) $$invalidate(6, scale = $$props.scale);
	    if ('containerWidth' in $$props) $$invalidate(1, containerWidth = $$props.containerWidth);
	    if ('placementMessage' in $$props) $$invalidate(7, placementMessage = $$props.placementMessage);
	    if ('customTypeActions' in $$props) $$invalidate(8, customTypeActions = $$props.customTypeActions);
	    if ('collection' in $$props) $$invalidate(9, collection = $$props.collection);
	    if ('showAdvancedFields' in $$props) $$invalidate(10, showAdvancedFields = $$props.showAdvancedFields);
	    if ('placementAfterSelect' in $$props) $$invalidate(34, placementAfterSelect = $$props.placementAfterSelect);
	    if ('renderEditorBar' in $$props) $$invalidate(11, renderEditorBar = $$props.renderEditorBar);
	    if ('renderContextMenu' in $$props) $$invalidate(12, renderContextMenu = $$props.renderContextMenu);
	    if ('options' in $$props) $$invalidate(2, options = $$props.options);
	    if ('$$scope' in $$props) $$invalidate(43, $$scope = $$props.$$scope);
	  };

	  $$self.$$.update = function () {
	    if ($$self.$$.dirty[0] &
	    /*domNode*/
	    1 | $$self.$$.dirty[1] &
	    /*placementTarget*/
	    4) {
	      $$invalidate(27, placementNode = placementTarget || domNode);
	    }
	  };

	  $$invalidate(29, _addCompleteHandler = onAddComplete);

	  $$invalidate(28, _placementCompleteHandler = onPlacementComplete);

	  return [domNode, containerWidth, options, addDraggable, draggablesTarget, draggablesComponent, scale, placementMessage, customTypeActions, collection, showAdvancedFields, renderEditorBar, renderContextMenu, showAddMenu, showEditorOptions, addDialogVisible, placementModeVisible, textEditorMounted, genericEditorMounted, editFields, editPosition, editProperties, dialogPosition, updateDraggable, removeDraggable, placementDraggable, closeEditorWindow, placementNode, _placementCompleteHandler, _addCompleteHandler, showOptions, closeOptions, updateOptions, placementTarget, placementAfterSelect, showPlacementMode, hidePlacementMode, showTypeVariants, mountTextEditor, mountGenericEditor, updateFields, bindDocumentCloseHandler, calculateBounds, $$scope, slots, div_binding];
	}

	var Editor = /*#__PURE__*/function (_SvelteComponent) {
	  _inherits(Editor, _SvelteComponent);

	  var _super = _createSuper(Editor);

	  function Editor(options) {
	    var _this;

	    _classCallCheck(this, Editor);

	    _this = _super.call(this);
	    init(_assertThisInitialized(_this), options, instance$5, create_fragment$5, safe_not_equal, {
	      addDraggable: 3,
	      updateOptions: 32,
	      draggablesTarget: 4,
	      draggablesComponent: 5,
	      domNode: 0,
	      placementTarget: 33,
	      scale: 6,
	      containerWidth: 1,
	      placementMessage: 7,
	      customTypeActions: 8,
	      collection: 9,
	      showAdvancedFields: 10,
	      placementAfterSelect: 34,
	      renderEditorBar: 11,
	      renderContextMenu: 12,
	      options: 2,
	      showAddMenu: 13,
	      showPlacementMode: 35,
	      hidePlacementMode: 36,
	      showTypeVariants: 37,
	      mountTextEditor: 38,
	      mountGenericEditor: 39,
	      updateFields: 40,
	      bindDocumentCloseHandler: 41,
	      calculateBounds: 42
	    }, add_css$4, [-1, -1]);
	    return _this;
	  }

	  _createClass(Editor, [{
	    key: "addDraggable",
	    get: function get() {
	      return this.$$.ctx[3];
	    },
	    set: function set(addDraggable) {
	      this.$$set({
	        addDraggable: addDraggable
	      });
	      flush();
	    }
	  }, {
	    key: "updateOptions",
	    get: function get() {
	      return this.$$.ctx[32];
	    },
	    set: function set(updateOptions) {
	      this.$$set({
	        updateOptions: updateOptions
	      });
	      flush();
	    }
	  }, {
	    key: "draggablesTarget",
	    get: function get() {
	      return this.$$.ctx[4];
	    },
	    set: function set(draggablesTarget) {
	      this.$$set({
	        draggablesTarget: draggablesTarget
	      });
	      flush();
	    }
	  }, {
	    key: "draggablesComponent",
	    get: function get() {
	      return this.$$.ctx[5];
	    },
	    set: function set(draggablesComponent) {
	      this.$$set({
	        draggablesComponent: draggablesComponent
	      });
	      flush();
	    }
	  }, {
	    key: "domNode",
	    get: function get() {
	      return this.$$.ctx[0];
	    },
	    set: function set(domNode) {
	      this.$$set({
	        domNode: domNode
	      });
	      flush();
	    }
	  }, {
	    key: "placementTarget",
	    get: function get() {
	      return this.$$.ctx[33];
	    },
	    set: function set(placementTarget) {
	      this.$$set({
	        placementTarget: placementTarget
	      });
	      flush();
	    }
	  }, {
	    key: "scale",
	    get: function get() {
	      return this.$$.ctx[6];
	    },
	    set: function set(scale) {
	      this.$$set({
	        scale: scale
	      });
	      flush();
	    }
	  }, {
	    key: "containerWidth",
	    get: function get() {
	      return this.$$.ctx[1];
	    },
	    set: function set(containerWidth) {
	      this.$$set({
	        containerWidth: containerWidth
	      });
	      flush();
	    }
	  }, {
	    key: "placementMessage",
	    get: function get() {
	      return this.$$.ctx[7];
	    },
	    set: function set(placementMessage) {
	      this.$$set({
	        placementMessage: placementMessage
	      });
	      flush();
	    }
	  }, {
	    key: "customTypeActions",
	    get: function get() {
	      return this.$$.ctx[8];
	    },
	    set: function set(customTypeActions) {
	      this.$$set({
	        customTypeActions: customTypeActions
	      });
	      flush();
	    }
	  }, {
	    key: "collection",
	    get: function get() {
	      return this.$$.ctx[9];
	    },
	    set: function set(collection) {
	      this.$$set({
	        collection: collection
	      });
	      flush();
	    }
	  }, {
	    key: "showAdvancedFields",
	    get: function get() {
	      return this.$$.ctx[10];
	    },
	    set: function set(showAdvancedFields) {
	      this.$$set({
	        showAdvancedFields: showAdvancedFields
	      });
	      flush();
	    }
	  }, {
	    key: "placementAfterSelect",
	    get: function get() {
	      return this.$$.ctx[34];
	    },
	    set: function set(placementAfterSelect) {
	      this.$$set({
	        placementAfterSelect: placementAfterSelect
	      });
	      flush();
	    }
	  }, {
	    key: "renderEditorBar",
	    get: function get() {
	      return this.$$.ctx[11];
	    },
	    set: function set(renderEditorBar) {
	      this.$$set({
	        renderEditorBar: renderEditorBar
	      });
	      flush();
	    }
	  }, {
	    key: "renderContextMenu",
	    get: function get() {
	      return this.$$.ctx[12];
	    },
	    set: function set(renderContextMenu) {
	      this.$$set({
	        renderContextMenu: renderContextMenu
	      });
	      flush();
	    }
	  }, {
	    key: "options",
	    get: function get() {
	      return this.$$.ctx[2];
	    },
	    set: function set(options) {
	      this.$$set({
	        options: options
	      });
	      flush();
	    }
	  }, {
	    key: "showAddMenu",
	    get: function get() {
	      return this.$$.ctx[13];
	    }
	  }, {
	    key: "showPlacementMode",
	    get: function get() {
	      return this.$$.ctx[35];
	    }
	  }, {
	    key: "hidePlacementMode",
	    get: function get() {
	      return this.$$.ctx[36];
	    }
	  }, {
	    key: "showTypeVariants",
	    get: function get() {
	      return this.$$.ctx[37];
	    }
	  }, {
	    key: "mountTextEditor",
	    get: function get() {
	      return this.$$.ctx[38];
	    }
	  }, {
	    key: "mountGenericEditor",
	    get: function get() {
	      return this.$$.ctx[39];
	    }
	  }, {
	    key: "updateFields",
	    get: function get() {
	      return this.$$.ctx[40];
	    }
	  }, {
	    key: "bindDocumentCloseHandler",
	    get: function get() {
	      return this.$$.ctx[41];
	    }
	  }, {
	    key: "calculateBounds",
	    get: function get() {
	      return this.$$.ctx[42];
	    }
	  }]);

	  return Editor;
	}(SvelteComponent);

	// a square to preview it - we can use this to abstract
	// away the preview frames inside the add draggable dialog

	function preview(target, draggable) {
	  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
	  var _options$containerWid = options.containerWidth,
	      containerWidth = _options$containerWid === void 0 ? 120 : _options$containerWid;
	  var scale = options.scale ? getScale({}, options.scale) : scaleLinear();
	  return new Container({
	    target: target,
	    props: {
	      draggable: draggable,
	      isEditor: false,
	      breakpoint: null,
	      updateDraggable: nullHandler,
	      finalizeDraggable: nullHandler,
	      removeDraggable: nullHandler,
	      scale: scale,
	      containerWidth: containerWidth
	    }
	  });
	}

	// full editor context - simply pass in an onComplete
	// callback and the collection you want to render

	function selectView(target, collection) {
	  var params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
	  var onComplete = params.onComplete;
	  return new EditorSelect({
	    target: target,
	    props: {
	      collection: collection,
	      onComplete: onComplete,
	      options: {}
	    }
	  });
	}

	// main.js would be for client side rendering only - we no longer pass in
	// isEditor - and editor.js wraps draggables in an editing frame

	function draggables(target, draggablesState) {
	  var params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
	  var _params$isEditor = params.isEditor,
	      isEditor = _params$isEditor === void 0 ? true : _params$isEditor,
	      onChange = params.onChange,
	      onChangeComplete = params.onChangeComplete,
	      onShowEditor = params.onShowEditor,
	      onHideEditor = params.onHideEditor,
	      resizeFrame = params.resizeFrame,
	      scale = params.scale,
	      editorTarget = params.editorTarget,
	      editorAnchor = params.editorAnchor,
	      renderEditorBar = params.renderEditorBar,
	      renderContextMenu = params.renderContextMenu,
	      collection = params.collection,
	      showAdvancedFields = params.showAdvancedFields,
	      staticPreview = params.staticPreview,
	      renderSelectView = params.renderSelectView,
	      placementMessage = params.placementMessage,
	      darkMode = params.darkMode; // if staticPreview return simple view

	  if (staticPreview) {
	    return preview(target, draggablesState, params);
	  } // if renderSelectView render the selection screen into provided target


	  if (renderSelectView) {
	    return selectView(target, draggablesState, params);
	  } // build in support for either annotations or draggables


	  var items = readDraggablesWithIds(draggablesState);

	  var options = _objectSpread2({
	    defaultOptions: defaultOptions
	  }, draggablesState.options);

	  var component = new Draggables({
	    target: target,
	    props: {
	      isEditor: isEditor,
	      items: items,
	      options: options,
	      darkMode: darkMode,
	      containerWidth: target.offsetWidth,
	      onChange: onChange || nullHandler,
	      onChangeComplete: onChangeComplete || nullHandler,
	      onShowEditor: onShowEditor || nullHandler,
	      onHideEditor: onHideEditor || nullHandler,
	      scale: getScale(draggablesState.options, scale),
	      resizeFrame: resizeFrame || defaultResizeFrame(target)
	    }
	  }); // The Editor layer sits on top of an existing draggables component
	  // to provide draggable states

	  var editor = null;

	  if (isEditor) {
	    var editorDiv = editorTarget;

	    if (!editorDiv) {
	      editorDiv = document.createElement('div');
	      target.appendChild(editorDiv);
	    }

	    editor = new Editor({
	      target: editorDiv,
	      anchor: editorAnchor,
	      props: {
	        options: component.options,
	        draggablesTarget: target,
	        draggablesComponent: component,
	        addDraggable: component.addDraggable,
	        updateOptions: component.updateOptions,
	        containerWidth: component.containerWidth,
	        scale: component.scale,
	        renderEditorBar: renderEditorBar,
	        renderContextMenu: renderContextMenu,
	        collection: collection,
	        showAdvancedFields: showAdvancedFields,
	        placementMessage: placementMessage,
	        darkMode: darkMode
	      }
	    }); // set component editor !!

	    component.editor = editor; // also set this to allow for better drag/drop events

	    document.addEventListener('dragover', function (event) {
	      event.preventDefault();
	    });
	  }

	  var cleanup = bindResizeEvents(component, target); // destroys this component for re-creation

	  var destroy = function destroy() {
	    if (component) {
	      component.$destroy();
	      cleanup();
	    }
	  }; // returned so that external apps can force a resize


	  var resize = function resize() {
	    component.containerWidth = target.offsetWidth;
	  };

	  return {
	    annotations: component.items,
	    draggables: component.items,
	    component: component,
	    cleanup: cleanup,
	    destroy: destroy,
	    resize: resize,
	    editor: editor,
	    getBounds: boundsHandler(draggablesState)
	  };
	}

	var util = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.isNode = exports.PROMISE_RESOLVED_VOID = exports.PROMISE_RESOLVED_TRUE = exports.PROMISE_RESOLVED_FALSE = void 0;
	exports.isPromise = isPromise;
	exports.microSeconds = microSeconds;
	exports.randomInt = randomInt;
	exports.randomToken = randomToken;
	exports.sleep = sleep;

	/**
	 * returns true if the given object is a promise
	 */
	function isPromise(obj) {
	  if (obj && typeof obj.then === 'function') {
	    return true;
	  } else {
	    return false;
	  }
	}

	var PROMISE_RESOLVED_FALSE = Promise.resolve(false);
	exports.PROMISE_RESOLVED_FALSE = PROMISE_RESOLVED_FALSE;
	var PROMISE_RESOLVED_TRUE = Promise.resolve(true);
	exports.PROMISE_RESOLVED_TRUE = PROMISE_RESOLVED_TRUE;
	var PROMISE_RESOLVED_VOID = Promise.resolve();
	exports.PROMISE_RESOLVED_VOID = PROMISE_RESOLVED_VOID;

	function sleep(time, resolveWith) {
	  if (!time) time = 0;
	  return new Promise(function (res) {
	    return setTimeout(function () {
	      return res(resolveWith);
	    }, time);
	  });
	}

	function randomInt(min, max) {
	  return Math.floor(Math.random() * (max - min + 1) + min);
	}
	/**
	 * https://stackoverflow.com/a/8084248
	 */


	function randomToken() {
	  return Math.random().toString(36).substring(2);
	}

	var lastMs = 0;
	var additional = 0;
	/**
	 * returns the current time in micro-seconds,
	 * WARNING: This is a pseudo-function
	 * Performance.now is not reliable in webworkers, so we just make sure to never return the same time.
	 * This is enough in browsers, and this function will not be used in nodejs.
	 * The main reason for this hack is to ensure that BroadcastChannel behaves equal to production when it is used in fast-running unit tests.
	 */

	function microSeconds() {
	  var ms = new Date().getTime();

	  if (ms === lastMs) {
	    additional++;
	    return ms * 1000 + additional;
	  } else {
	    lastMs = ms;
	    additional = 0;
	    return ms * 1000;
	  }
	}
	/**
	 * copied from the 'detect-node' npm module
	 * We cannot use the module directly because it causes problems with rollup
	 * @link https://github.com/iliakan/detect-node/blob/master/index.js
	 */


	var isNode = Object.prototype.toString.call(typeof process !== 'undefined' ? process : 0) === '[object process]';
	exports.isNode = isNode;
	});

	unwrapExports(util);
	util.isNode;
	util.PROMISE_RESOLVED_VOID;
	util.PROMISE_RESOLVED_TRUE;
	util.PROMISE_RESOLVED_FALSE;
	util.isPromise;
	util.microSeconds;
	util.randomInt;
	util.randomToken;
	util.sleep;

	var interopRequireDefault = createCommonjsModule(function (module) {
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : {
	    "default": obj
	  };
	}

	module.exports = _interopRequireDefault, module.exports.__esModule = true, module.exports["default"] = module.exports;
	});

	unwrapExports(interopRequireDefault);

	var _typeof_1 = createCommonjsModule(function (module) {
	function _typeof(obj) {
	  "@babel/helpers - typeof";

	  return (module.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
	    return typeof obj;
	  } : function (obj) {
	    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
	  }, module.exports.__esModule = true, module.exports["default"] = module.exports), _typeof(obj);
	}

	module.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports;
	});

	unwrapExports(_typeof_1);

	var _util = util;

	var native_1 = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.averageResponseTime = averageResponseTime;
	exports.canBeUsed = canBeUsed;
	exports.close = close;
	exports.create = create;
	exports.microSeconds = exports["default"] = void 0;
	exports.onMessage = onMessage;
	exports.postMessage = postMessage;
	exports.type = void 0;



	var microSeconds = _util.microSeconds;
	exports.microSeconds = microSeconds;
	var type = 'native';
	exports.type = type;

	function create(channelName) {
	  var state = {
	    messagesCallback: null,
	    bc: new BroadcastChannel(channelName),
	    subFns: [] // subscriberFunctions

	  };

	  state.bc.onmessage = function (msg) {
	    if (state.messagesCallback) {
	      state.messagesCallback(msg.data);
	    }
	  };

	  return state;
	}

	function close(channelState) {
	  channelState.bc.close();
	  channelState.subFns = [];
	}

	function postMessage(channelState, messageJson) {
	  try {
	    channelState.bc.postMessage(messageJson, false);
	    return _util.PROMISE_RESOLVED_VOID;
	  } catch (err) {
	    return Promise.reject(err);
	  }
	}

	function onMessage(channelState, fn) {
	  channelState.messagesCallback = fn;
	}

	function canBeUsed() {
	  /**
	   * in the electron-renderer, isNode will be true even if we are in browser-context
	   * so we also check if window is undefined
	   */
	  if (_util.isNode && typeof window === 'undefined') return false;

	  if (typeof BroadcastChannel === 'function') {
	    if (BroadcastChannel._pubkey) {
	      throw new Error('BroadcastChannel: Do not overwrite window.BroadcastChannel with this module, this is not a polyfill');
	    }

	    return true;
	  } else return false;
	}

	function averageResponseTime() {
	  return 150;
	}

	var _default = {
	  create: create,
	  close: close,
	  onMessage: onMessage,
	  postMessage: postMessage,
	  canBeUsed: canBeUsed,
	  type: type,
	  averageResponseTime: averageResponseTime,
	  microSeconds: microSeconds
	};
	exports["default"] = _default;
	});

	unwrapExports(native_1);
	native_1.averageResponseTime;
	native_1.canBeUsed;
	native_1.close;
	native_1.create;
	native_1.microSeconds;
	native_1.onMessage;
	native_1.postMessage;
	native_1.type;

	/**
	 * this is a set which automatically forgets
	 * a given entry when a new entry is set and the ttl
	 * of the old one is over
	 */
	var ObliviousSet = /** @class */ (function () {
	    function ObliviousSet(ttl) {
	        this.ttl = ttl;
	        this.set = new Set();
	        this.timeMap = new Map();
	    }
	    ObliviousSet.prototype.has = function (value) {
	        return this.set.has(value);
	    };
	    ObliviousSet.prototype.add = function (value) {
	        var _this = this;
	        this.timeMap.set(value, now$2());
	        this.set.add(value);
	        /**
	         * When a new value is added,
	         * start the cleanup at the next tick
	         * to not block the cpu for more important stuff
	         * that might happen.
	         */
	        setTimeout(function () {
	            removeTooOldValues(_this);
	        }, 0);
	    };
	    ObliviousSet.prototype.clear = function () {
	        this.set.clear();
	        this.timeMap.clear();
	    };
	    return ObliviousSet;
	}());
	/**
	 * Removes all entries from the set
	 * where the TTL has expired
	 */
	function removeTooOldValues(obliviousSet) {
	    var olderThen = now$2() - obliviousSet.ttl;
	    var iterator = obliviousSet.set[Symbol.iterator]();
	    /**
	     * Because we can assume the new values are added at the bottom,
	     * we start from the top and stop as soon as we reach a non-too-old value.
	     */
	    while (true) {
	        var value = iterator.next().value;
	        if (!value) {
	            return; // no more elements
	        }
	        var time = obliviousSet.timeMap.get(value);
	        if (time < olderThen) {
	            obliviousSet.timeMap.delete(value);
	            obliviousSet.set.delete(value);
	        }
	        else {
	            // We reached a value that is not old enough
	            return;
	        }
	    }
	}
	function now$2() {
	    return new Date().getTime();
	}

	var es$1 = {
		__proto__: null,
		ObliviousSet: ObliviousSet,
		removeTooOldValues: removeTooOldValues,
		now: now$2
	};

	var options = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.fillOptionsWithDefaults = fillOptionsWithDefaults;

	function fillOptionsWithDefaults() {
	  var originalOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	  var options = JSON.parse(JSON.stringify(originalOptions)); // main

	  if (typeof options.webWorkerSupport === 'undefined') options.webWorkerSupport = true; // indexed-db

	  if (!options.idb) options.idb = {}; //  after this time the messages get deleted

	  if (!options.idb.ttl) options.idb.ttl = 1000 * 45;
	  if (!options.idb.fallbackInterval) options.idb.fallbackInterval = 150; //  handles abrupt db onclose events.

	  if (originalOptions.idb && typeof originalOptions.idb.onclose === 'function') options.idb.onclose = originalOptions.idb.onclose; // localstorage

	  if (!options.localstorage) options.localstorage = {};
	  if (!options.localstorage.removeTimeout) options.localstorage.removeTimeout = 1000 * 60; // custom methods

	  if (originalOptions.methods) options.methods = originalOptions.methods; // node

	  if (!options.node) options.node = {};
	  if (!options.node.ttl) options.node.ttl = 1000 * 60 * 2; // 2 minutes;

	  /**
	   * On linux use 'ulimit -Hn' to get the limit of open files.
	   * On ubuntu this was 4096 for me, so we use half of that as maxParallelWrites default.
	   */

	  if (!options.node.maxParallelWrites) options.node.maxParallelWrites = 2048;
	  if (typeof options.node.useFastPath === 'undefined') options.node.useFastPath = true;
	  return options;
	}
	});

	unwrapExports(options);
	options.fillOptionsWithDefaults;

	var _options = options;

	var indexedDb = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.averageResponseTime = averageResponseTime;
	exports.canBeUsed = canBeUsed;
	exports.cleanOldMessages = cleanOldMessages;
	exports.close = close;
	exports.create = create;
	exports.createDatabase = createDatabase;
	exports["default"] = void 0;
	exports.getAllMessages = getAllMessages;
	exports.getIdb = getIdb;
	exports.getMessagesHigherThan = getMessagesHigherThan;
	exports.getOldMessages = getOldMessages;
	exports.microSeconds = void 0;
	exports.onMessage = onMessage;
	exports.postMessage = postMessage;
	exports.removeMessageById = removeMessageById;
	exports.type = void 0;
	exports.writeMessage = writeMessage;







	/**
	 * this method uses indexeddb to store the messages
	 * There is currently no observerAPI for idb
	 * @link https://github.com/w3c/IndexedDB/issues/51
	 */
	var microSeconds = _util.microSeconds;
	exports.microSeconds = microSeconds;
	var DB_PREFIX = 'pubkey.broadcast-channel-0-';
	var OBJECT_STORE_ID = 'messages';
	var type = 'idb';
	exports.type = type;

	function getIdb() {
	  if (typeof indexedDB !== 'undefined') return indexedDB;

	  if (typeof window !== 'undefined') {
	    if (typeof window.mozIndexedDB !== 'undefined') return window.mozIndexedDB;
	    if (typeof window.webkitIndexedDB !== 'undefined') return window.webkitIndexedDB;
	    if (typeof window.msIndexedDB !== 'undefined') return window.msIndexedDB;
	  }

	  return false;
	}

	function createDatabase(channelName) {
	  var IndexedDB = getIdb(); // create table

	  var dbName = DB_PREFIX + channelName;
	  var openRequest = IndexedDB.open(dbName, 1);

	  openRequest.onupgradeneeded = function (ev) {
	    var db = ev.target.result;
	    db.createObjectStore(OBJECT_STORE_ID, {
	      keyPath: 'id',
	      autoIncrement: true
	    });
	  };

	  var dbPromise = new Promise(function (res, rej) {
	    openRequest.onerror = function (ev) {
	      return rej(ev);
	    };

	    openRequest.onsuccess = function () {
	      res(openRequest.result);
	    };
	  });
	  return dbPromise;
	}
	/**
	 * writes the new message to the database
	 * so other readers can find it
	 */


	function writeMessage(db, readerUuid, messageJson) {
	  var time = new Date().getTime();
	  var writeObject = {
	    uuid: readerUuid,
	    time: time,
	    data: messageJson
	  };
	  var transaction = db.transaction([OBJECT_STORE_ID], 'readwrite');
	  return new Promise(function (res, rej) {
	    transaction.oncomplete = function () {
	      return res();
	    };

	    transaction.onerror = function (ev) {
	      return rej(ev);
	    };

	    var objectStore = transaction.objectStore(OBJECT_STORE_ID);
	    objectStore.add(writeObject);
	  });
	}

	function getAllMessages(db) {
	  var objectStore = db.transaction(OBJECT_STORE_ID).objectStore(OBJECT_STORE_ID);
	  var ret = [];
	  return new Promise(function (res) {
	    objectStore.openCursor().onsuccess = function (ev) {
	      var cursor = ev.target.result;

	      if (cursor) {
	        ret.push(cursor.value); //alert("Name for SSN " + cursor.key + " is " + cursor.value.name);

	        cursor["continue"]();
	      } else {
	        res(ret);
	      }
	    };
	  });
	}

	function getMessagesHigherThan(db, lastCursorId) {
	  var objectStore = db.transaction(OBJECT_STORE_ID).objectStore(OBJECT_STORE_ID);
	  var ret = [];

	  function openCursor() {
	    // Occasionally Safari will fail on IDBKeyRange.bound, this
	    // catches that error, having it open the cursor to the first
	    // item. When it gets data it will advance to the desired key.
	    try {
	      var keyRangeValue = IDBKeyRange.bound(lastCursorId + 1, Infinity);
	      return objectStore.openCursor(keyRangeValue);
	    } catch (e) {
	      return objectStore.openCursor();
	    }
	  }

	  return new Promise(function (res) {
	    openCursor().onsuccess = function (ev) {
	      var cursor = ev.target.result;

	      if (cursor) {
	        if (cursor.value.id < lastCursorId + 1) {
	          cursor["continue"](lastCursorId + 1);
	        } else {
	          ret.push(cursor.value);
	          cursor["continue"]();
	        }
	      } else {
	        res(ret);
	      }
	    };
	  });
	}

	function removeMessageById(db, id) {
	  var request = db.transaction([OBJECT_STORE_ID], 'readwrite').objectStore(OBJECT_STORE_ID)["delete"](id);
	  return new Promise(function (res) {
	    request.onsuccess = function () {
	      return res();
	    };
	  });
	}

	function getOldMessages(db, ttl) {
	  var olderThen = new Date().getTime() - ttl;
	  var objectStore = db.transaction(OBJECT_STORE_ID).objectStore(OBJECT_STORE_ID);
	  var ret = [];
	  return new Promise(function (res) {
	    objectStore.openCursor().onsuccess = function (ev) {
	      var cursor = ev.target.result;

	      if (cursor) {
	        var msgObk = cursor.value;

	        if (msgObk.time < olderThen) {
	          ret.push(msgObk); //alert("Name for SSN " + cursor.key + " is " + cursor.value.name);

	          cursor["continue"]();
	        } else {
	          // no more old messages,
	          res(ret);
	          return;
	        }
	      } else {
	        res(ret);
	      }
	    };
	  });
	}

	function cleanOldMessages(db, ttl) {
	  return getOldMessages(db, ttl).then(function (tooOld) {
	    return Promise.all(tooOld.map(function (msgObj) {
	      return removeMessageById(db, msgObj.id);
	    }));
	  });
	}

	function create(channelName, options) {
	  options = (0, _options.fillOptionsWithDefaults)(options);
	  return createDatabase(channelName).then(function (db) {
	    var state = {
	      closed: false,
	      lastCursorId: 0,
	      channelName: channelName,
	      options: options,
	      uuid: (0, _util.randomToken)(),

	      /**
	       * emittedMessagesIds
	       * contains all messages that have been emitted before
	       * @type {ObliviousSet}
	       */
	      eMIs: new es$1.ObliviousSet(options.idb.ttl * 2),
	      // ensures we do not read messages in parrallel
	      writeBlockPromise: _util.PROMISE_RESOLVED_VOID,
	      messagesCallback: null,
	      readQueuePromises: [],
	      db: db
	    };
	    /**
	     * Handle abrupt closes that do not originate from db.close().
	     * This could happen, for example, if the underlying storage is
	     * removed or if the user clears the database in the browser's
	     * history preferences.
	     */

	    db.onclose = function () {
	      state.closed = true;
	      if (options.idb.onclose) options.idb.onclose();
	    };
	    /**
	     * if service-workers are used,
	     * we have no 'storage'-event if they post a message,
	     * therefore we also have to set an interval
	     */


	    _readLoop(state);

	    return state;
	  });
	}

	function _readLoop(state) {
	  if (state.closed) return;
	  readNewMessages(state).then(function () {
	    return (0, _util.sleep)(state.options.idb.fallbackInterval);
	  }).then(function () {
	    return _readLoop(state);
	  });
	}

	function _filterMessage(msgObj, state) {
	  if (msgObj.uuid === state.uuid) return false; // send by own

	  if (state.eMIs.has(msgObj.id)) return false; // already emitted

	  if (msgObj.data.time < state.messagesCallbackTime) return false; // older then onMessageCallback

	  return true;
	}
	/**
	 * reads all new messages from the database and emits them
	 */


	function readNewMessages(state) {
	  // channel already closed
	  if (state.closed) return _util.PROMISE_RESOLVED_VOID; // if no one is listening, we do not need to scan for new messages

	  if (!state.messagesCallback) return _util.PROMISE_RESOLVED_VOID;
	  return getMessagesHigherThan(state.db, state.lastCursorId).then(function (newerMessages) {
	    var useMessages = newerMessages
	    /**
	     * there is a bug in iOS where the msgObj can be undefined some times
	     * so we filter them out
	     * @link https://github.com/pubkey/broadcast-channel/issues/19
	     */
	    .filter(function (msgObj) {
	      return !!msgObj;
	    }).map(function (msgObj) {
	      if (msgObj.id > state.lastCursorId) {
	        state.lastCursorId = msgObj.id;
	      }

	      return msgObj;
	    }).filter(function (msgObj) {
	      return _filterMessage(msgObj, state);
	    }).sort(function (msgObjA, msgObjB) {
	      return msgObjA.time - msgObjB.time;
	    }); // sort by time

	    useMessages.forEach(function (msgObj) {
	      if (state.messagesCallback) {
	        state.eMIs.add(msgObj.id);
	        state.messagesCallback(msgObj.data);
	      }
	    });
	    return _util.PROMISE_RESOLVED_VOID;
	  });
	}

	function close(channelState) {
	  channelState.closed = true;
	  channelState.db.close();
	}

	function postMessage(channelState, messageJson) {
	  channelState.writeBlockPromise = channelState.writeBlockPromise.then(function () {
	    return writeMessage(channelState.db, channelState.uuid, messageJson);
	  }).then(function () {
	    if ((0, _util.randomInt)(0, 10) === 0) {
	      /* await (do not await) */
	      cleanOldMessages(channelState.db, channelState.options.idb.ttl);
	    }
	  });
	  return channelState.writeBlockPromise;
	}

	function onMessage(channelState, fn, time) {
	  channelState.messagesCallbackTime = time;
	  channelState.messagesCallback = fn;
	  readNewMessages(channelState);
	}

	function canBeUsed() {
	  if (_util.isNode) return false;
	  var idb = getIdb();
	  if (!idb) return false;
	  return true;
	}

	function averageResponseTime(options) {
	  return options.idb.fallbackInterval * 2;
	}

	var _default = {
	  create: create,
	  close: close,
	  onMessage: onMessage,
	  postMessage: postMessage,
	  canBeUsed: canBeUsed,
	  type: type,
	  averageResponseTime: averageResponseTime,
	  microSeconds: microSeconds
	};
	exports["default"] = _default;
	});

	unwrapExports(indexedDb);
	indexedDb.averageResponseTime;
	indexedDb.canBeUsed;
	indexedDb.cleanOldMessages;
	indexedDb.close;
	indexedDb.create;
	indexedDb.createDatabase;
	indexedDb.getAllMessages;
	indexedDb.getIdb;
	indexedDb.getMessagesHigherThan;
	indexedDb.getOldMessages;
	indexedDb.microSeconds;
	indexedDb.onMessage;
	indexedDb.postMessage;
	indexedDb.removeMessageById;
	indexedDb.type;
	indexedDb.writeMessage;

	var localstorage = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.addStorageEventListener = addStorageEventListener;
	exports.averageResponseTime = averageResponseTime;
	exports.canBeUsed = canBeUsed;
	exports.close = close;
	exports.create = create;
	exports["default"] = void 0;
	exports.getLocalStorage = getLocalStorage;
	exports.microSeconds = void 0;
	exports.onMessage = onMessage;
	exports.postMessage = postMessage;
	exports.removeStorageEventListener = removeStorageEventListener;
	exports.storageKey = storageKey;
	exports.type = void 0;







	/**
	 * A localStorage-only method which uses localstorage and its 'storage'-event
	 * This does not work inside of webworkers because they have no access to locastorage
	 * This is basically implemented to support IE9 or your grandmothers toaster.
	 * @link https://caniuse.com/#feat=namevalue-storage
	 * @link https://caniuse.com/#feat=indexeddb
	 */
	var microSeconds = _util.microSeconds;
	exports.microSeconds = microSeconds;
	var KEY_PREFIX = 'pubkey.broadcastChannel-';
	var type = 'localstorage';
	/**
	 * copied from crosstab
	 * @link https://github.com/tejacques/crosstab/blob/master/src/crosstab.js#L32
	 */

	exports.type = type;

	function getLocalStorage() {
	  var localStorage;
	  if (typeof window === 'undefined') return null;

	  try {
	    localStorage = window.localStorage;
	    localStorage = window['ie8-eventlistener/storage'] || window.localStorage;
	  } catch (e) {// New versions of Firefox throw a Security exception
	    // if cookies are disabled. See
	    // https://bugzilla.mozilla.org/show_bug.cgi?id=1028153
	  }

	  return localStorage;
	}

	function storageKey(channelName) {
	  return KEY_PREFIX + channelName;
	}
	/**
	* writes the new message to the storage
	* and fires the storage-event so other readers can find it
	*/


	function postMessage(channelState, messageJson) {
	  return new Promise(function (res) {
	    (0, _util.sleep)().then(function () {
	      var key = storageKey(channelState.channelName);
	      var writeObj = {
	        token: (0, _util.randomToken)(),
	        time: new Date().getTime(),
	        data: messageJson,
	        uuid: channelState.uuid
	      };
	      var value = JSON.stringify(writeObj);
	      getLocalStorage().setItem(key, value);
	      /**
	       * StorageEvent does not fire the 'storage' event
	       * in the window that changes the state of the local storage.
	       * So we fire it manually
	       */

	      var ev = document.createEvent('Event');
	      ev.initEvent('storage', true, true);
	      ev.key = key;
	      ev.newValue = value;
	      window.dispatchEvent(ev);
	      res();
	    });
	  });
	}

	function addStorageEventListener(channelName, fn) {
	  var key = storageKey(channelName);

	  var listener = function listener(ev) {
	    if (ev.key === key) {
	      fn(JSON.parse(ev.newValue));
	    }
	  };

	  window.addEventListener('storage', listener);
	  return listener;
	}

	function removeStorageEventListener(listener) {
	  window.removeEventListener('storage', listener);
	}

	function create(channelName, options) {
	  options = (0, _options.fillOptionsWithDefaults)(options);

	  if (!canBeUsed()) {
	    throw new Error('BroadcastChannel: localstorage cannot be used');
	  }

	  var uuid = (0, _util.randomToken)();
	  /**
	   * eMIs
	   * contains all messages that have been emitted before
	   * @type {ObliviousSet}
	   */

	  var eMIs = new es$1.ObliviousSet(options.localstorage.removeTimeout);
	  var state = {
	    channelName: channelName,
	    uuid: uuid,
	    eMIs: eMIs // emittedMessagesIds

	  };
	  state.listener = addStorageEventListener(channelName, function (msgObj) {
	    if (!state.messagesCallback) return; // no listener

	    if (msgObj.uuid === uuid) return; // own message

	    if (!msgObj.token || eMIs.has(msgObj.token)) return; // already emitted

	    if (msgObj.data.time && msgObj.data.time < state.messagesCallbackTime) return; // too old

	    eMIs.add(msgObj.token);
	    state.messagesCallback(msgObj.data);
	  });
	  return state;
	}

	function close(channelState) {
	  removeStorageEventListener(channelState.listener);
	}

	function onMessage(channelState, fn, time) {
	  channelState.messagesCallbackTime = time;
	  channelState.messagesCallback = fn;
	}

	function canBeUsed() {
	  if (_util.isNode) return false;
	  var ls = getLocalStorage();
	  if (!ls) return false;

	  try {
	    var key = '__broadcastchannel_check';
	    ls.setItem(key, 'works');
	    ls.removeItem(key);
	  } catch (e) {
	    // Safari 10 in private mode will not allow write access to local
	    // storage and fail with a QuotaExceededError. See
	    // https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API#Private_Browsing_Incognito_modes
	    return false;
	  }

	  return true;
	}

	function averageResponseTime() {
	  var defaultTime = 120;
	  var userAgent = navigator.userAgent.toLowerCase();

	  if (userAgent.includes('safari') && !userAgent.includes('chrome')) {
	    // safari is much slower so this time is higher
	    return defaultTime * 2;
	  }

	  return defaultTime;
	}

	var _default = {
	  create: create,
	  close: close,
	  onMessage: onMessage,
	  postMessage: postMessage,
	  canBeUsed: canBeUsed,
	  type: type,
	  averageResponseTime: averageResponseTime,
	  microSeconds: microSeconds
	};
	exports["default"] = _default;
	});

	unwrapExports(localstorage);
	localstorage.addStorageEventListener;
	localstorage.averageResponseTime;
	localstorage.canBeUsed;
	localstorage.close;
	localstorage.create;
	localstorage.getLocalStorage;
	localstorage.microSeconds;
	localstorage.onMessage;
	localstorage.postMessage;
	localstorage.removeStorageEventListener;
	localstorage.storageKey;
	localstorage.type;

	var simulate = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.averageResponseTime = averageResponseTime;
	exports.canBeUsed = canBeUsed;
	exports.close = close;
	exports.create = create;
	exports.microSeconds = exports["default"] = void 0;
	exports.onMessage = onMessage;
	exports.postMessage = postMessage;
	exports.type = void 0;



	var microSeconds = _util.microSeconds;
	exports.microSeconds = microSeconds;
	var type = 'simulate';
	exports.type = type;
	var SIMULATE_CHANNELS = new Set();

	function create(channelName) {
	  var state = {
	    name: channelName,
	    messagesCallback: null
	  };
	  SIMULATE_CHANNELS.add(state);
	  return state;
	}

	function close(channelState) {
	  SIMULATE_CHANNELS["delete"](channelState);
	}

	function postMessage(channelState, messageJson) {
	  return new Promise(function (res) {
	    return setTimeout(function () {
	      var channelArray = Array.from(SIMULATE_CHANNELS);
	      channelArray.filter(function (channel) {
	        return channel.name === channelState.name;
	      }).filter(function (channel) {
	        return channel !== channelState;
	      }).filter(function (channel) {
	        return !!channel.messagesCallback;
	      }).forEach(function (channel) {
	        return channel.messagesCallback(messageJson);
	      });
	      res();
	    }, 5);
	  });
	}

	function onMessage(channelState, fn) {
	  channelState.messagesCallback = fn;
	}

	function canBeUsed() {
	  return true;
	}

	function averageResponseTime() {
	  return 5;
	}

	var _default = {
	  create: create,
	  close: close,
	  onMessage: onMessage,
	  postMessage: postMessage,
	  canBeUsed: canBeUsed,
	  type: type,
	  averageResponseTime: averageResponseTime,
	  microSeconds: microSeconds
	};
	exports["default"] = _default;
	});

	unwrapExports(simulate);
	simulate.averageResponseTime;
	simulate.canBeUsed;
	simulate.close;
	simulate.create;
	simulate.microSeconds;
	simulate.onMessage;
	simulate.postMessage;
	simulate.type;

	var require$$0 = native_1;

	var require$$1 = indexedDb;

	var require$$2 = localstorage;

	var require$$3 = simulate;

	var methodChooser = createCommonjsModule(function (module, exports) {





	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.chooseMethod = chooseMethod;

	var _native = interopRequireDefault(require$$0);

	var _indexedDb = interopRequireDefault(require$$1);

	var _localstorage = interopRequireDefault(require$$2);

	var _simulate = interopRequireDefault(require$$3);

	// the line below will be removed from es5/browser builds
	// order is important
	var METHODS = [_native["default"], // fastest
	_indexedDb["default"], _localstorage["default"]];

	function chooseMethod(options) {
	  var chooseMethods = [].concat(options.methods, METHODS).filter(Boolean); // the line below will be removed from es5/browser builds



	  if (options.type) {
	    if (options.type === 'simulate') {
	      // only use simulate-method if directly chosen
	      return _simulate["default"];
	    }

	    var ret = chooseMethods.find(function (m) {
	      return m.type === options.type;
	    });
	    if (!ret) throw new Error('method-type ' + options.type + ' not found');else return ret;
	  }
	  /**
	   * if no webworker support is needed,
	   * remove idb from the list so that localstorage is been chosen
	   */


	  if (!options.webWorkerSupport && !_util.isNode) {
	    chooseMethods = chooseMethods.filter(function (m) {
	      return m.type !== 'idb';
	    });
	  }

	  var useMethod = chooseMethods.find(function (method) {
	    return method.canBeUsed();
	  });
	  if (!useMethod) throw new Error("No useable method found in " + JSON.stringify(METHODS.map(function (m) {
	    return m.type;
	  })));else return useMethod;
	}
	});

	unwrapExports(methodChooser);
	methodChooser.chooseMethod;

	var _methodChooser = methodChooser;

	var broadcastChannel = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.OPEN_BROADCAST_CHANNELS = exports.BroadcastChannel = void 0;
	exports.clearNodeFolder = clearNodeFolder;
	exports.enforceOptions = enforceOptions;







	/**
	 * Contains all open channels,
	 * used in tests to ensure everything is closed.
	 */
	var OPEN_BROADCAST_CHANNELS = new Set();
	exports.OPEN_BROADCAST_CHANNELS = OPEN_BROADCAST_CHANNELS;
	var lastId = 0;

	var BroadcastChannel = function BroadcastChannel(name, options) {
	  // identifier of the channel to debug stuff
	  this.id = lastId++;
	  OPEN_BROADCAST_CHANNELS.add(this);
	  this.name = name;

	  if (ENFORCED_OPTIONS) {
	    options = ENFORCED_OPTIONS;
	  }

	  this.options = (0, _options.fillOptionsWithDefaults)(options);
	  this.method = (0, _methodChooser.chooseMethod)(this.options); // isListening

	  this._iL = false;
	  /**
	   * _onMessageListener
	   * setting onmessage twice,
	   * will overwrite the first listener
	   */

	  this._onML = null;
	  /**
	   * _addEventListeners
	   */

	  this._addEL = {
	    message: [],
	    internal: []
	  };
	  /**
	   * Unsend message promises
	   * where the sending is still in progress
	   * @type {Set<Promise>}
	   */

	  this._uMP = new Set();
	  /**
	   * _beforeClose
	   * array of promises that will be awaited
	   * before the channel is closed
	   */

	  this._befC = [];
	  /**
	   * _preparePromise
	   */

	  this._prepP = null;

	  _prepareChannel(this);
	}; // STATICS

	/**
	 * used to identify if someone overwrites
	 * window.BroadcastChannel with this
	 * See methods/native.js
	 */


	exports.BroadcastChannel = BroadcastChannel;
	BroadcastChannel._pubkey = true;
	/**
	 * clears the tmp-folder if is node
	 * @return {Promise<boolean>} true if has run, false if not node
	 */

	function clearNodeFolder(options) {
	  options = (0, _options.fillOptionsWithDefaults)(options);
	  var method = (0, _methodChooser.chooseMethod)(options);

	  if (method.type === 'node') {
	    return method.clearNodeFolder().then(function () {
	      return true;
	    });
	  } else {
	    return _util.PROMISE_RESOLVED_FALSE;
	  }
	}
	/**
	 * if set, this method is enforced,
	 * no mather what the options are
	 */


	var ENFORCED_OPTIONS;

	function enforceOptions(options) {
	  ENFORCED_OPTIONS = options;
	} // PROTOTYPE


	BroadcastChannel.prototype = {
	  postMessage: function postMessage(msg) {
	    if (this.closed) {
	      throw new Error('BroadcastChannel.postMessage(): ' + 'Cannot post message after channel has closed ' +
	      /**
	       * In the past when this error appeared, it was realy hard to debug.
	       * So now we log the msg together with the error so it at least
	       * gives some clue about where in your application this happens.
	       */
	      JSON.stringify(msg));
	    }

	    return _post(this, 'message', msg);
	  },
	  postInternal: function postInternal(msg) {
	    return _post(this, 'internal', msg);
	  },

	  set onmessage(fn) {
	    var time = this.method.microSeconds();
	    var listenObj = {
	      time: time,
	      fn: fn
	    };

	    _removeListenerObject(this, 'message', this._onML);

	    if (fn && typeof fn === 'function') {
	      this._onML = listenObj;

	      _addListenerObject(this, 'message', listenObj);
	    } else {
	      this._onML = null;
	    }
	  },

	  addEventListener: function addEventListener(type, fn) {
	    var time = this.method.microSeconds();
	    var listenObj = {
	      time: time,
	      fn: fn
	    };

	    _addListenerObject(this, type, listenObj);
	  },
	  removeEventListener: function removeEventListener(type, fn) {
	    var obj = this._addEL[type].find(function (obj) {
	      return obj.fn === fn;
	    });

	    _removeListenerObject(this, type, obj);
	  },
	  close: function close() {
	    var _this = this;

	    if (this.closed) {
	      return;
	    }

	    OPEN_BROADCAST_CHANNELS["delete"](this);
	    this.closed = true;
	    var awaitPrepare = this._prepP ? this._prepP : _util.PROMISE_RESOLVED_VOID;
	    this._onML = null;
	    this._addEL.message = [];
	    return awaitPrepare // wait until all current sending are processed
	    .then(function () {
	      return Promise.all(Array.from(_this._uMP));
	    }) // run before-close hooks
	    .then(function () {
	      return Promise.all(_this._befC.map(function (fn) {
	        return fn();
	      }));
	    }) // close the channel
	    .then(function () {
	      return _this.method.close(_this._state);
	    });
	  },

	  get type() {
	    return this.method.type;
	  },

	  get isClosed() {
	    return this.closed;
	  }

	};
	/**
	 * Post a message over the channel
	 * @returns {Promise} that resolved when the message sending is done
	 */

	function _post(broadcastChannel, type, msg) {
	  var time = broadcastChannel.method.microSeconds();
	  var msgObj = {
	    time: time,
	    type: type,
	    data: msg
	  };
	  var awaitPrepare = broadcastChannel._prepP ? broadcastChannel._prepP : _util.PROMISE_RESOLVED_VOID;
	  return awaitPrepare.then(function () {
	    var sendPromise = broadcastChannel.method.postMessage(broadcastChannel._state, msgObj); // add/remove to unsend messages list

	    broadcastChannel._uMP.add(sendPromise);

	    sendPromise["catch"]().then(function () {
	      return broadcastChannel._uMP["delete"](sendPromise);
	    });
	    return sendPromise;
	  });
	}

	function _prepareChannel(channel) {
	  var maybePromise = channel.method.create(channel.name, channel.options);

	  if ((0, _util.isPromise)(maybePromise)) {
	    channel._prepP = maybePromise;
	    maybePromise.then(function (s) {
	      // used in tests to simulate slow runtime

	      /*if (channel.options.prepareDelay) {
	           await new Promise(res => setTimeout(res, this.options.prepareDelay));
	      }*/
	      channel._state = s;
	    });
	  } else {
	    channel._state = maybePromise;
	  }
	}

	function _hasMessageListeners(channel) {
	  if (channel._addEL.message.length > 0) return true;
	  if (channel._addEL.internal.length > 0) return true;
	  return false;
	}

	function _addListenerObject(channel, type, obj) {
	  channel._addEL[type].push(obj);

	  _startListening(channel);
	}

	function _removeListenerObject(channel, type, obj) {
	  channel._addEL[type] = channel._addEL[type].filter(function (o) {
	    return o !== obj;
	  });

	  _stopListening(channel);
	}

	function _startListening(channel) {
	  if (!channel._iL && _hasMessageListeners(channel)) {
	    // someone is listening, start subscribing
	    var listenerFn = function listenerFn(msgObj) {
	      channel._addEL[msgObj.type].forEach(function (listenerObject) {
	        /**
	         * Getting the current time in JavaScript has no good precision.
	         * So instead of only listening to events that happend 'after' the listener
	         * was added, we also listen to events that happended 100ms before it.
	         * This ensures that when another process, like a WebWorker, sends events
	         * we do not miss them out because their timestamp is a bit off compared to the main process.
	         * Not doing this would make messages missing when we send data directly after subscribing and awaiting a response.
	         * @link https://johnresig.com/blog/accuracy-of-javascript-time/
	         */
	        var hundredMsInMicro = 100 * 1000;
	        var minMessageTime = listenerObject.time - hundredMsInMicro;

	        if (msgObj.time >= minMessageTime) {
	          listenerObject.fn(msgObj.data);
	        }
	      });
	    };

	    var time = channel.method.microSeconds();

	    if (channel._prepP) {
	      channel._prepP.then(function () {
	        channel._iL = true;
	        channel.method.onMessage(channel._state, listenerFn, time);
	      });
	    } else {
	      channel._iL = true;
	      channel.method.onMessage(channel._state, listenerFn, time);
	    }
	  }
	}

	function _stopListening(channel) {
	  if (channel._iL && !_hasMessageListeners(channel)) {
	    // noone is listening, stop subscribing
	    channel._iL = false;
	    var time = channel.method.microSeconds();
	    channel.method.onMessage(channel._state, null, time);
	  }
	}
	});

	unwrapExports(broadcastChannel);
	broadcastChannel.OPEN_BROADCAST_CHANNELS;
	broadcastChannel.BroadcastChannel;
	broadcastChannel.clearNodeFolder;
	broadcastChannel.enforceOptions;

	/* global WorkerGlobalScope */
	function add$1(fn) {
	  if (typeof WorkerGlobalScope === 'function' && self instanceof WorkerGlobalScope) ; else {
	    /**
	     * if we are on react-native, there is no window.addEventListener
	     * @link https://github.com/pubkey/unload/issues/6
	     */
	    if (typeof window.addEventListener !== 'function') return;
	    /**
	     * for normal browser-windows, we use the beforeunload-event
	     */

	    window.addEventListener('beforeunload', function () {
	      fn();
	    }, true);
	    /**
	     * for iframes, we have to use the unload-event
	     * @link https://stackoverflow.com/q/47533670/3443137
	     */

	    window.addEventListener('unload', function () {
	      fn();
	    }, true);
	  }
	  /**
	   * TODO add fallback for safari-mobile
	   * @link https://stackoverflow.com/a/26193516/3443137
	   */

	}

	var BrowserMethod = {
	  add: add$1
	};

	var USE_METHOD = BrowserMethod;
	var LISTENERS = new Set();
	var startedListening = false;

	function startListening() {
	  if (startedListening) return;
	  startedListening = true;
	  USE_METHOD.add(runAll);
	}

	function add(fn) {
	  startListening();
	  if (typeof fn !== 'function') throw new Error('Listener is no function');
	  LISTENERS.add(fn);
	  var addReturn = {
	    remove: function remove() {
	      return LISTENERS["delete"](fn);
	    },
	    run: function run() {
	      LISTENERS["delete"](fn);
	      return fn();
	    }
	  };
	  return addReturn;
	}
	function runAll() {
	  var promises = [];
	  LISTENERS.forEach(function (fn) {
	    promises.push(fn());
	    LISTENERS["delete"](fn);
	  });
	  return Promise.all(promises);
	}
	function removeAll() {
	  LISTENERS.clear();
	}
	function getSize() {
	  return LISTENERS.size;
	}

	var es = {
		__proto__: null,
		add: add,
		runAll: runAll,
		removeAll: removeAll,
		getSize: getSize
	};

	var leaderElection = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.beLeader = beLeader;
	exports.createLeaderElection = createLeaderElection;





	var LeaderElection = function LeaderElection(broadcastChannel, options) {
	  var _this = this;

	  this.broadcastChannel = broadcastChannel;
	  this._options = options;
	  this.isLeader = false;
	  this.hasLeader = false;
	  this.isDead = false;
	  this.token = (0, _util.randomToken)();
	  /**
	   * Apply Queue,
	   * used to ensure we do not run applyOnce()
	   * in parallel.
	   */

	  this._aplQ = _util.PROMISE_RESOLVED_VOID; // amount of unfinished applyOnce() calls

	  this._aplQC = 0; // things to clean up

	  this._unl = []; // _unloads

	  this._lstns = []; // _listeners

	  this._dpL = function () {}; // onduplicate listener


	  this._dpLC = false; // true when onduplicate called

	  /**
	   * Even when the own instance is not applying,
	   * we still listen to messages to ensure the hasLeader flag
	   * is set correctly.
	   */

	  var hasLeaderListener = function hasLeaderListener(msg) {
	    if (msg.context === 'leader') {
	      if (msg.action === 'death') {
	        _this.hasLeader = false;
	      }

	      if (msg.action === 'tell') {
	        _this.hasLeader = true;
	      }
	    }
	  };

	  this.broadcastChannel.addEventListener('internal', hasLeaderListener);

	  this._lstns.push(hasLeaderListener);
	};

	LeaderElection.prototype = {
	  /**
	   * Returns true if the instance is leader,
	   * false if not.
	   * @async
	   */
	  applyOnce: function applyOnce( // true if the applyOnce() call came from the fallbackInterval cycle
	  isFromFallbackInterval) {
	    var _this2 = this;

	    if (this.isLeader) {
	      return (0, _util.sleep)(0, true);
	    }

	    if (this.isDead) {
	      return (0, _util.sleep)(0, false);
	    }
	    /**
	     * Already applying more then once,
	     * -> wait for the apply queue to be finished.
	     */


	    if (this._aplQC > 1) {
	      return this._aplQ;
	    }
	    /**
	     * Add a new apply-run
	     */


	    var applyRun = function applyRun() {
	      /**
	       * Optimization shortcuts.
	       * Directly return if a previous run
	       * has already elected a leader.
	       */
	      if (_this2.isLeader) {
	        return _util.PROMISE_RESOLVED_TRUE;
	      }

	      var stopCriteria = false;
	      var stopCriteriaPromiseResolve;
	      /**
	       * Resolves when a stop criteria is reached.
	       * Uses as a performance shortcut so we do not
	       * have to await the responseTime when it is already clear
	       * that the election failed.
	       */

	      var stopCriteriaPromise = new Promise(function (res) {
	        stopCriteriaPromiseResolve = function stopCriteriaPromiseResolve() {
	          stopCriteria = true;
	          res();
	        };
	      });

	      var handleMessage = function handleMessage(msg) {
	        if (msg.context === 'leader' && msg.token != _this2.token) {

	          if (msg.action === 'apply') {
	            // other is applying
	            if (msg.token > _this2.token) {
	              /**
	               * other has higher token
	               * -> stop applying and let other become leader.
	               */
	              stopCriteriaPromiseResolve();
	            }
	          }

	          if (msg.action === 'tell') {
	            // other is already leader
	            stopCriteriaPromiseResolve();
	            _this2.hasLeader = true;
	          }
	        }
	      };

	      _this2.broadcastChannel.addEventListener('internal', handleMessage);
	      /**
	       * If the applyOnce() call came from the fallbackInterval,
	       * we can assume that the election runs in the background and
	       * not critical process is waiting for it.
	       * When this is true, we give the other intances
	       * more time to answer to messages in the election cycle.
	       * This makes it less likely to elect duplicate leaders.
	       * But also it takes longer which is not a problem because we anyway
	       * run in the background.
	       */


	      var waitForAnswerTime = isFromFallbackInterval ? _this2._options.responseTime * 4 : _this2._options.responseTime;

	      var applyPromise = _sendMessage(_this2, 'apply') // send out that this one is applying
	      .then(function () {
	        return Promise.race([(0, _util.sleep)(waitForAnswerTime), stopCriteriaPromise.then(function () {
	          return Promise.reject(new Error());
	        })]);
	      }) // send again in case another instance was just created
	      .then(function () {
	        return _sendMessage(_this2, 'apply');
	      }) // let others time to respond
	      .then(function () {
	        return Promise.race([(0, _util.sleep)(waitForAnswerTime), stopCriteriaPromise.then(function () {
	          return Promise.reject(new Error());
	        })]);
	      })["catch"](function () {}).then(function () {
	        _this2.broadcastChannel.removeEventListener('internal', handleMessage);

	        if (!stopCriteria) {
	          // no stop criteria -> own is leader
	          return beLeader(_this2).then(function () {
	            return true;
	          });
	        } else {
	          // other is leader
	          return false;
	        }
	      });

	      return applyPromise;
	    };

	    this._aplQC = this._aplQC + 1;
	    this._aplQ = this._aplQ.then(function () {
	      return applyRun();
	    }).then(function () {
	      _this2._aplQC = _this2._aplQC - 1;
	    });
	    return this._aplQ.then(function () {
	      return _this2.isLeader;
	    });
	  },
	  awaitLeadership: function awaitLeadership() {
	    if (
	    /* _awaitLeadershipPromise */
	    !this._aLP) {
	      this._aLP = _awaitLeadershipOnce(this);
	    }

	    return this._aLP;
	  },

	  set onduplicate(fn) {
	    this._dpL = fn;
	  },

	  die: function die() {
	    var _this3 = this;

	    this._lstns.forEach(function (listener) {
	      return _this3.broadcastChannel.removeEventListener('internal', listener);
	    });

	    this._lstns = [];

	    this._unl.forEach(function (uFn) {
	      return uFn.remove();
	    });

	    this._unl = [];

	    if (this.isLeader) {
	      this.hasLeader = false;
	      this.isLeader = false;
	    }

	    this.isDead = true;
	    return _sendMessage(this, 'death');
	  }
	};
	/**
	 * @param leaderElector {LeaderElector}
	 */

	function _awaitLeadershipOnce(leaderElector) {
	  if (leaderElector.isLeader) {
	    return _util.PROMISE_RESOLVED_VOID;
	  }

	  return new Promise(function (res) {
	    var resolved = false;

	    function finish() {
	      if (resolved) {
	        return;
	      }

	      resolved = true;
	      leaderElector.broadcastChannel.removeEventListener('internal', whenDeathListener);
	      res(true);
	    } // try once now


	    leaderElector.applyOnce().then(function () {
	      if (leaderElector.isLeader) {
	        finish();
	      }
	    });
	    /**
	     * Try on fallbackInterval
	     * @recursive
	     */

	    var tryOnFallBack = function tryOnFallBack() {
	      return (0, _util.sleep)(leaderElector._options.fallbackInterval).then(function () {
	        if (leaderElector.isDead || resolved) {
	          return;
	        }

	        if (leaderElector.isLeader) {
	          finish();
	        } else {
	          return leaderElector.applyOnce(true).then(function () {
	            if (leaderElector.isLeader) {
	              finish();
	            } else {
	              tryOnFallBack();
	            }
	          });
	        }
	      });
	    };

	    tryOnFallBack(); // try when other leader dies

	    var whenDeathListener = function whenDeathListener(msg) {
	      if (msg.context === 'leader' && msg.action === 'death') {
	        leaderElector.hasLeader = false;
	        leaderElector.applyOnce().then(function () {
	          if (leaderElector.isLeader) {
	            finish();
	          }
	        });
	      }
	    };

	    leaderElector.broadcastChannel.addEventListener('internal', whenDeathListener);

	    leaderElector._lstns.push(whenDeathListener);
	  });
	}
	/**
	 * sends and internal message over the broadcast-channel
	 */


	function _sendMessage(leaderElector, action) {
	  var msgJson = {
	    context: 'leader',
	    action: action,
	    token: leaderElector.token
	  };
	  return leaderElector.broadcastChannel.postInternal(msgJson);
	}

	function beLeader(leaderElector) {
	  leaderElector.isLeader = true;
	  leaderElector.hasLeader = true;
	  var unloadFn = (0, es.add)(function () {
	    return leaderElector.die();
	  });

	  leaderElector._unl.push(unloadFn);

	  var isLeaderListener = function isLeaderListener(msg) {
	    if (msg.context === 'leader' && msg.action === 'apply') {
	      _sendMessage(leaderElector, 'tell');
	    }

	    if (msg.context === 'leader' && msg.action === 'tell' && !leaderElector._dpLC) {
	      /**
	       * another instance is also leader!
	       * This can happen on rare events
	       * like when the CPU is at 100% for long time
	       * or the tabs are open very long and the browser throttles them.
	       * @link https://github.com/pubkey/broadcast-channel/issues/414
	       * @link https://github.com/pubkey/broadcast-channel/issues/385
	       */
	      leaderElector._dpLC = true;

	      leaderElector._dpL(); // message the lib user so the app can handle the problem


	      _sendMessage(leaderElector, 'tell'); // ensure other leader also knows the problem

	    }
	  };

	  leaderElector.broadcastChannel.addEventListener('internal', isLeaderListener);

	  leaderElector._lstns.push(isLeaderListener);

	  return _sendMessage(leaderElector, 'tell');
	}

	function fillOptionsWithDefaults(options, channel) {
	  if (!options) options = {};
	  options = JSON.parse(JSON.stringify(options));

	  if (!options.fallbackInterval) {
	    options.fallbackInterval = 3000;
	  }

	  if (!options.responseTime) {
	    options.responseTime = channel.method.averageResponseTime(channel.options);
	  }

	  return options;
	}

	function createLeaderElection(channel, options) {
	  if (channel._leaderElector) {
	    throw new Error('BroadcastChannel already has a leader-elector');
	  }

	  options = fillOptionsWithDefaults(options, channel);
	  var elector = new LeaderElection(channel, options);

	  channel._befC.push(function () {
	    return elector.die();
	  });

	  channel._leaderElector = elector;
	  return elector;
	}
	});

	unwrapExports(leaderElection);
	leaderElection.beLeader;
	leaderElection.createLeaderElection;

	var _broadcastChannel = broadcastChannel;

	var _leaderElection = leaderElection;

	var lib = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	Object.defineProperty(exports, "BroadcastChannel", {
	  enumerable: true,
	  get: function get() {
	    return _broadcastChannel.BroadcastChannel;
	  }
	});
	Object.defineProperty(exports, "OPEN_BROADCAST_CHANNELS", {
	  enumerable: true,
	  get: function get() {
	    return _broadcastChannel.OPEN_BROADCAST_CHANNELS;
	  }
	});
	Object.defineProperty(exports, "beLeader", {
	  enumerable: true,
	  get: function get() {
	    return _leaderElection.beLeader;
	  }
	});
	Object.defineProperty(exports, "clearNodeFolder", {
	  enumerable: true,
	  get: function get() {
	    return _broadcastChannel.clearNodeFolder;
	  }
	});
	Object.defineProperty(exports, "createLeaderElection", {
	  enumerable: true,
	  get: function get() {
	    return _leaderElection.createLeaderElection;
	  }
	});
	Object.defineProperty(exports, "enforceOptions", {
	  enumerable: true,
	  get: function get() {
	    return _broadcastChannel.enforceOptions;
	  }
	});
	});

	unwrapExports(lib);

	var _index = lib;

	/**
	 * because babel can only export on default-attribute,
	 * we use this for the non-module-build
	 * this ensures that users do not have to use
	 * var BroadcastChannel = require('broadcast-channel').default;
	 * but
	 * var BroadcastChannel = require('broadcast-channel');
	 */
	var index_es5 = {
	  BroadcastChannel: _index.BroadcastChannel,
	  createLeaderElection: _index.createLeaderElection,
	  clearNodeFolder: _index.clearNodeFolder,
	  enforceOptions: _index.enforceOptions,
	  beLeader: _index.beLeader
	};
	var index_es5_1 = index_es5.BroadcastChannel;

	function Multicast(_ref) {
	  var _ref$channel = _ref.channel,
	      channel = _ref$channel === void 0 ? 'default' : _ref$channel,
	      _ref$isRoot = _ref.isRoot,
	      isRoot = _ref$isRoot === void 0 ? false : _ref$isRoot;
	  var channelRoot = new index_es5_1("".concat(channel, "-root"));
	  var channelChildren = new index_es5_1("".concat(channel, "-children"));

	  var send = function send(message) {
	    if (isRoot) {
	      // root? send message down to children
	      channelChildren.postMessage(message);
	    } else {
	      // child? send message up to root
	      channelRoot.postMessage(message);
	    }
	  };

	  var receive = function receive(callbk) {
	    if (isRoot) {
	      channelRoot.onmessage = callbk;
	    } else {
	      channelChildren.onmessage = callbk;
	    }
	  };

	  var close = function close() {
	    channelRoot.close();
	    channelChildren.close();
	  };

	  return {
	    send: send,
	    receive: receive,
	    close: close
	  };
	}

	function add_css$3(target) {
	  append_styles(target, "svelte-1nz5vsj", ".draggable-annotations .draggable .text{font-size:14px}.draggable-annotations.mobile .draggable .text{font-size:12px}");
	}

	function create_fragment$4(ctx) {
	  var div;
	  var div_class_value;
	  var div_resize_listener;
	  return {
	    c: function c() {
	      div = element("div");
	      attr(div, "class", div_class_value = "draggable-annotations " + (
	      /*isMobile*/
	      ctx[2] ? 'mobile' : ''));
	      add_render_callback(function () {
	        return (
	          /*div_elementresize_handler*/
	          ctx[9].call(div)
	        );
	      });
	    },
	    m: function m(target, anchor) {
	      insert(target, div, anchor);
	      div_resize_listener = add_resize_listener(div,
	      /*div_elementresize_handler*/
	      ctx[9].bind(div));
	      /*div_binding*/

	      ctx[10](div);
	    },
	    p: function p(ctx, _ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	          dirty = _ref2[0];

	      if (dirty &
	      /*isMobile*/
	      4 && div_class_value !== (div_class_value = "draggable-annotations " + (
	      /*isMobile*/
	      ctx[2] ? 'mobile' : ''))) {
	        attr(div, "class", div_class_value);
	      }
	    },
	    i: noop,
	    o: noop,
	    d: function d(detaching) {
	      if (detaching) detach(div);
	      div_resize_listener();
	      /*div_binding*/

	      ctx[10](null);
	    }
	  };
	}

	function instance$4($$self, $$props, $$invalidate) {
	  var isMobile;
	  var $yAxis;
	  var $xAxis;
	  component_subscribe($$self, yAxis, function ($$value) {
	    return $$invalidate(7, $yAxis = $$value);
	  });
	  component_subscribe($$self, xAxis, function ($$value) {
	    return $$invalidate(8, $xAxis = $$value);
	  });
	  var env = $$props.env;
	  var annotations = $$props.annotations;
	  var _$$props$options = $$props.options,
	      options = _$$props$options === void 0 ? {} : _$$props$options;
	  var clientWidth;
	  var targetEl;
	  var instanceCreated = false;

	  function div_elementresize_handler() {
	    clientWidth = this.offsetWidth;
	    $$invalidate(0, clientWidth);
	  }

	  function div_binding($$value) {
	    binding_callbacks[$$value ? 'unshift' : 'push'](function () {
	      targetEl = $$value;
	      $$invalidate(1, targetEl);
	    });
	  }

	  $$self.$$set = function ($$props) {
	    if ('env' in $$props) $$invalidate(3, env = $$props.env);
	    if ('annotations' in $$props) $$invalidate(4, annotations = $$props.annotations);
	    if ('options' in $$props) $$invalidate(5, options = $$props.options);
	  };

	  $$self.$$.update = function () {
	    if ($$self.$$.dirty &
	    /*clientWidth, options*/
	    33) {
	      $$invalidate(2, isMobile = isMobileWidth(clientWidth, options));
	    }

	    if ($$self.$$.dirty &
	    /*targetEl, clientWidth, instanceCreated, env, $xAxis, $yAxis, options, isMobile, annotations*/
	    511) {
	      {
	        if (targetEl && clientWidth && !instanceCreated) {
	          var instanceStore = annotationState(env.data.id || 'new'); // customScale allows us to store x, y as actual values
	          // input [x, y], return [xScale(x), yScale(y)]

	          var customScale = function customScale(pos) {
	            return [$xAxis.scale(pos[0]), $yAxis.scale(pos[1])];
	          };

	          customScale.invert = function (pos) {
	            return [$xAxis.scale.invert(pos[0]), $yAxis.scale.invert(pos[1])];
	          };

	          var defaultAnnotations = {
	            draggables: [],
	            options: {
	              breakpoints: [{
	                name: 'default',
	                size: 620
	              }, {
	                name: 'mobile',
	                size: 375
	              }]
	            }
	          }; // inter-frame communication (children)

	          var sendChanges = function sendChanges() {
	            return null;
	          };

	          if (isEditor()) {
	            var multicast = new Multicast({
	              channel: 'draggables',
	              isRoot: false
	            }); // parse messages from our parent (to show placement, hide, etc.)

	            multicast.receive(function (_ref3) {
	              var type = _ref3.type,
	                  props = _ref3.props;
	              var currentInstance = instanceStore();

	              if (currentInstance) {
	                var editor = currentInstance.editor;

	                switch (type) {
	                  case 'showPlacement':
	                    editor.showPlacementMode(props);
	                    break;

	                  case 'hidePlacement':
	                    editor.hidePlacementMode();
	                    break;
	                }
	              }
	            }); // tell the root about the annotation change

	            sendChanges = function sendChanges(changes) {
	              var type = Object.keys(changes)[0]; // use the first key as the type, e.g., 'add', etc.
	              // this is a special type, it means modify the annotation

	              if (type === 'id') {
	                var _config$draggableAnno2;

	                // do we need a breakpoint?
	                var _env$data$config = env.data.config,
	                    config = _env$data$config === void 0 ? {} : _env$data$config;

	                var _config$draggableAnno = (_config$draggableAnno2 = config.draggableAnnotations) === null || _config$draggableAnno2 === void 0 ? void 0 : _config$draggableAnno2.options,
	                    breakpoints = _config$draggableAnno.breakpoints;

	                if (breakpoints) {
	                  var breakpoint = _toConsumableArray(breakpoints).reverse().filter(function (_ref4) {
	                    var name = _ref4.name;
	                    return name !== 'default';
	                  }).find(function (_ref5) {
	                    var size = _ref5.size;
	                    return clientWidth <= size;
	                  });

	                  if (breakpoint) {
	                    changes = {
	                      id: changes.id,
	                      props: {
	                        breakpoints: _defineProperty({}, breakpoint.name, changes.props)
	                      }
	                    };
	                  }
	                }
	              }

	              multicast.send({
	                type: type,
	                changes: changes
	              });
	            };
	          }

	          var customUpdateHandler = function customUpdateHandler(changes) {
	            sendChanges(changes);

	            if (options.handleAnnotationChanges) {
	              options.handleAnnotationChanges(changes);
	            }
	          };

	          var customUpdateCompleteHandler = function customUpdateCompleteHandler(changes) {
	            sendChanges(changes);

	            if (options.handleAnnotationChangesComplete) {
	              options.handleAnnotationChangesComplete(changes);
	            }
	          }; // strip out all of the fontSize params so we can set via css


	          var defaultTextWidth = isMobile ? 107 : 125;
	          var annotationConfig = annotations || defaultAnnotations;

	          if (annotationConfig.draggables) {
	            annotationConfig.draggables = annotationConfig.draggables.map(function (item) {
	              return _objectSpread2(_objectSpread2({}, item), {}, {
	                fontSize: undefined,
	                // iconSize: undefined, not sure about iconSize
	                textWidth: item.textWidth ? item.textWidth : defaultTextWidth
	              });
	            }); // this will set the instance as a reference for any

	            instanceStore(draggables(targetEl, annotationConfig, {
	              editorTarget: targetEl,
	              containerWidth: clientWidth,
	              isEditor: isEditor(),
	              // resizeFrame: options.annotationResizeHandler,
	              onChange: customUpdateHandler,
	              onChangeComplete: customUpdateCompleteHandler,
	              renderEditorBar: false,
	              renderContextMenu: false,
	              // this hides the ... menu
	              scale: customScale,
	              darkMode: isDarkTheme(env.data, env.options)
	            }));
	          } // prevent double call


	          $$invalidate(6, instanceCreated = true);
	        }
	      }
	    }
	  };

	  return [clientWidth, targetEl, isMobile, env, annotations, options, instanceCreated, $yAxis, $xAxis, div_elementresize_handler, div_binding];
	}

	var DraggablesWrapper = /*#__PURE__*/function (_SvelteComponent) {
	  _inherits(DraggablesWrapper, _SvelteComponent);

	  var _super = _createSuper(DraggablesWrapper);

	  function DraggablesWrapper(options) {
	    var _this;

	    _classCallCheck(this, DraggablesWrapper);

	    _this = _super.call(this);
	    init(_assertThisInitialized(_this), options, instance$4, create_fragment$4, safe_not_equal, {
	      env: 3,
	      annotations: 4,
	      options: 5
	    }, add_css$3);
	    return _this;
	  }

	  _createClass(DraggablesWrapper, [{
	    key: "env",
	    get: function get() {
	      return this.$$.ctx[3];
	    },
	    set: function set(env) {
	      this.$$set({
	        env: env
	      });
	      flush();
	    }
	  }, {
	    key: "annotations",
	    get: function get() {
	      return this.$$.ctx[4];
	    },
	    set: function set(annotations) {
	      this.$$set({
	        annotations: annotations
	      });
	      flush();
	    }
	  }, {
	    key: "options",
	    get: function get() {
	      return this.$$.ctx[5];
	    },
	    set: function set(options) {
	      this.$$set({
	        options: options
	      });
	      flush();
	    }
	  }]);

	  return DraggablesWrapper;
	}(SvelteComponent);

	var globalIsFinite = global_1.isFinite;

	// `Number.isFinite` method
	// https://tc39.github.io/ecma262/#sec-number.isfinite
	var numberIsFinite = Number.isFinite || function isFinite(it) {
	  return typeof it == 'number' && globalIsFinite(it);
	};

	// `Number.isFinite` method
	// https://tc39.github.io/ecma262/#sec-number.isfinite
	_export({ target: 'Number', stat: true }, { isFinite: numberIsFinite });

	const EPSILON = Math.pow(2, -52);
	const EDGE_STACK = new Uint32Array(512);

	class Delaunator {

	    static from(points, getX = defaultGetX, getY = defaultGetY) {
	        const n = points.length;
	        const coords = new Float64Array(n * 2);

	        for (let i = 0; i < n; i++) {
	            const p = points[i];
	            coords[2 * i] = getX(p);
	            coords[2 * i + 1] = getY(p);
	        }

	        return new Delaunator(coords);
	    }

	    constructor(coords) {
	        const n = coords.length >> 1;
	        if (n > 0 && typeof coords[0] !== 'number') throw new Error('Expected coords to contain numbers.');

	        this.coords = coords;

	        // arrays that will store the triangulation graph
	        const maxTriangles = Math.max(2 * n - 5, 0);
	        this._triangles = new Uint32Array(maxTriangles * 3);
	        this._halfedges = new Int32Array(maxTriangles * 3);

	        // temporary arrays for tracking the edges of the advancing convex hull
	        this._hashSize = Math.ceil(Math.sqrt(n));
	        this._hullPrev = new Uint32Array(n); // edge to prev edge
	        this._hullNext = new Uint32Array(n); // edge to next edge
	        this._hullTri = new Uint32Array(n); // edge to adjacent triangle
	        this._hullHash = new Int32Array(this._hashSize).fill(-1); // angular edge hash

	        // temporary arrays for sorting points
	        this._ids = new Uint32Array(n);
	        this._dists = new Float64Array(n);

	        this.update();
	    }

	    update() {
	        const {coords, _hullPrev: hullPrev, _hullNext: hullNext, _hullTri: hullTri, _hullHash: hullHash} =  this;
	        const n = coords.length >> 1;

	        // populate an array of point indices; calculate input data bbox
	        let minX = Infinity;
	        let minY = Infinity;
	        let maxX = -Infinity;
	        let maxY = -Infinity;

	        for (let i = 0; i < n; i++) {
	            const x = coords[2 * i];
	            const y = coords[2 * i + 1];
	            if (x < minX) minX = x;
	            if (y < minY) minY = y;
	            if (x > maxX) maxX = x;
	            if (y > maxY) maxY = y;
	            this._ids[i] = i;
	        }
	        const cx = (minX + maxX) / 2;
	        const cy = (minY + maxY) / 2;

	        let minDist = Infinity;
	        let i0, i1, i2;

	        // pick a seed point close to the center
	        for (let i = 0; i < n; i++) {
	            const d = dist(cx, cy, coords[2 * i], coords[2 * i + 1]);
	            if (d < minDist) {
	                i0 = i;
	                minDist = d;
	            }
	        }
	        const i0x = coords[2 * i0];
	        const i0y = coords[2 * i0 + 1];

	        minDist = Infinity;

	        // find the point closest to the seed
	        for (let i = 0; i < n; i++) {
	            if (i === i0) continue;
	            const d = dist(i0x, i0y, coords[2 * i], coords[2 * i + 1]);
	            if (d < minDist && d > 0) {
	                i1 = i;
	                minDist = d;
	            }
	        }
	        let i1x = coords[2 * i1];
	        let i1y = coords[2 * i1 + 1];

	        let minRadius = Infinity;

	        // find the third point which forms the smallest circumcircle with the first two
	        for (let i = 0; i < n; i++) {
	            if (i === i0 || i === i1) continue;
	            const r = circumradius(i0x, i0y, i1x, i1y, coords[2 * i], coords[2 * i + 1]);
	            if (r < minRadius) {
	                i2 = i;
	                minRadius = r;
	            }
	        }
	        let i2x = coords[2 * i2];
	        let i2y = coords[2 * i2 + 1];

	        if (minRadius === Infinity) {
	            // order collinear points by dx (or dy if all x are identical)
	            // and return the list as a hull
	            for (let i = 0; i < n; i++) {
	                this._dists[i] = (coords[2 * i] - coords[0]) || (coords[2 * i + 1] - coords[1]);
	            }
	            quicksort(this._ids, this._dists, 0, n - 1);
	            const hull = new Uint32Array(n);
	            let j = 0;
	            for (let i = 0, d0 = -Infinity; i < n; i++) {
	                const id = this._ids[i];
	                if (this._dists[id] > d0) {
	                    hull[j++] = id;
	                    d0 = this._dists[id];
	                }
	            }
	            this.hull = hull.subarray(0, j);
	            this.triangles = new Uint32Array(0);
	            this.halfedges = new Uint32Array(0);
	            return;
	        }

	        // swap the order of the seed points for counter-clockwise orientation
	        if (orient(i0x, i0y, i1x, i1y, i2x, i2y)) {
	            const i = i1;
	            const x = i1x;
	            const y = i1y;
	            i1 = i2;
	            i1x = i2x;
	            i1y = i2y;
	            i2 = i;
	            i2x = x;
	            i2y = y;
	        }

	        const center = circumcenter(i0x, i0y, i1x, i1y, i2x, i2y);
	        this._cx = center.x;
	        this._cy = center.y;

	        for (let i = 0; i < n; i++) {
	            this._dists[i] = dist(coords[2 * i], coords[2 * i + 1], center.x, center.y);
	        }

	        // sort the points by distance from the seed triangle circumcenter
	        quicksort(this._ids, this._dists, 0, n - 1);

	        // set up the seed triangle as the starting hull
	        this._hullStart = i0;
	        let hullSize = 3;

	        hullNext[i0] = hullPrev[i2] = i1;
	        hullNext[i1] = hullPrev[i0] = i2;
	        hullNext[i2] = hullPrev[i1] = i0;

	        hullTri[i0] = 0;
	        hullTri[i1] = 1;
	        hullTri[i2] = 2;

	        hullHash.fill(-1);
	        hullHash[this._hashKey(i0x, i0y)] = i0;
	        hullHash[this._hashKey(i1x, i1y)] = i1;
	        hullHash[this._hashKey(i2x, i2y)] = i2;

	        this.trianglesLen = 0;
	        this._addTriangle(i0, i1, i2, -1, -1, -1);

	        for (let k = 0, xp, yp; k < this._ids.length; k++) {
	            const i = this._ids[k];
	            const x = coords[2 * i];
	            const y = coords[2 * i + 1];

	            // skip near-duplicate points
	            if (k > 0 && Math.abs(x - xp) <= EPSILON && Math.abs(y - yp) <= EPSILON) continue;
	            xp = x;
	            yp = y;

	            // skip seed triangle points
	            if (i === i0 || i === i1 || i === i2) continue;

	            // find a visible edge on the convex hull using edge hash
	            let start = 0;
	            for (let j = 0, key = this._hashKey(x, y); j < this._hashSize; j++) {
	                start = hullHash[(key + j) % this._hashSize];
	                if (start !== -1 && start !== hullNext[start]) break;
	            }

	            start = hullPrev[start];
	            let e = start, q;
	            while (q = hullNext[e], !orient(x, y, coords[2 * e], coords[2 * e + 1], coords[2 * q], coords[2 * q + 1])) {
	                e = q;
	                if (e === start) {
	                    e = -1;
	                    break;
	                }
	            }
	            if (e === -1) continue; // likely a near-duplicate point; skip it

	            // add the first triangle from the point
	            let t = this._addTriangle(e, i, hullNext[e], -1, -1, hullTri[e]);

	            // recursively flip triangles from the point until they satisfy the Delaunay condition
	            hullTri[i] = this._legalize(t + 2);
	            hullTri[e] = t; // keep track of boundary triangles on the hull
	            hullSize++;

	            // walk forward through the hull, adding more triangles and flipping recursively
	            let n = hullNext[e];
	            while (q = hullNext[n], orient(x, y, coords[2 * n], coords[2 * n + 1], coords[2 * q], coords[2 * q + 1])) {
	                t = this._addTriangle(n, i, q, hullTri[i], -1, hullTri[n]);
	                hullTri[i] = this._legalize(t + 2);
	                hullNext[n] = n; // mark as removed
	                hullSize--;
	                n = q;
	            }

	            // walk backward from the other side, adding more triangles and flipping
	            if (e === start) {
	                while (q = hullPrev[e], orient(x, y, coords[2 * q], coords[2 * q + 1], coords[2 * e], coords[2 * e + 1])) {
	                    t = this._addTriangle(q, i, e, -1, hullTri[e], hullTri[q]);
	                    this._legalize(t + 2);
	                    hullTri[q] = t;
	                    hullNext[e] = e; // mark as removed
	                    hullSize--;
	                    e = q;
	                }
	            }

	            // update the hull indices
	            this._hullStart = hullPrev[i] = e;
	            hullNext[e] = hullPrev[n] = i;
	            hullNext[i] = n;

	            // save the two new edges in the hash table
	            hullHash[this._hashKey(x, y)] = i;
	            hullHash[this._hashKey(coords[2 * e], coords[2 * e + 1])] = e;
	        }

	        this.hull = new Uint32Array(hullSize);
	        for (let i = 0, e = this._hullStart; i < hullSize; i++) {
	            this.hull[i] = e;
	            e = hullNext[e];
	        }

	        // trim typed triangle mesh arrays
	        this.triangles = this._triangles.subarray(0, this.trianglesLen);
	        this.halfedges = this._halfedges.subarray(0, this.trianglesLen);
	    }

	    _hashKey(x, y) {
	        return Math.floor(pseudoAngle(x - this._cx, y - this._cy) * this._hashSize) % this._hashSize;
	    }

	    _legalize(a) {
	        const {_triangles: triangles, _halfedges: halfedges, coords} = this;

	        let i = 0;
	        let ar = 0;

	        // recursion eliminated with a fixed-size stack
	        while (true) {
	            const b = halfedges[a];

	            /* if the pair of triangles doesn't satisfy the Delaunay condition
	             * (p1 is inside the circumcircle of [p0, pl, pr]), flip them,
	             * then do the same check/flip recursively for the new pair of triangles
	             *
	             *           pl                    pl
	             *          /||\                  /  \
	             *       al/ || \bl            al/    \a
	             *        /  ||  \              /      \
	             *       /  a||b  \    flip    /___ar___\
	             *     p0\   ||   /p1   =>   p0\---bl---/p1
	             *        \  ||  /              \      /
	             *       ar\ || /br             b\    /br
	             *          \||/                  \  /
	             *           pr                    pr
	             */
	            const a0 = a - a % 3;
	            ar = a0 + (a + 2) % 3;

	            if (b === -1) { // convex hull edge
	                if (i === 0) break;
	                a = EDGE_STACK[--i];
	                continue;
	            }

	            const b0 = b - b % 3;
	            const al = a0 + (a + 1) % 3;
	            const bl = b0 + (b + 2) % 3;

	            const p0 = triangles[ar];
	            const pr = triangles[a];
	            const pl = triangles[al];
	            const p1 = triangles[bl];

	            const illegal = inCircle(
	                coords[2 * p0], coords[2 * p0 + 1],
	                coords[2 * pr], coords[2 * pr + 1],
	                coords[2 * pl], coords[2 * pl + 1],
	                coords[2 * p1], coords[2 * p1 + 1]);

	            if (illegal) {
	                triangles[a] = p1;
	                triangles[b] = p0;

	                const hbl = halfedges[bl];

	                // edge swapped on the other side of the hull (rare); fix the halfedge reference
	                if (hbl === -1) {
	                    let e = this._hullStart;
	                    do {
	                        if (this._hullTri[e] === bl) {
	                            this._hullTri[e] = a;
	                            break;
	                        }
	                        e = this._hullPrev[e];
	                    } while (e !== this._hullStart);
	                }
	                this._link(a, hbl);
	                this._link(b, halfedges[ar]);
	                this._link(ar, bl);

	                const br = b0 + (b + 1) % 3;

	                // don't worry about hitting the cap: it can only happen on extremely degenerate input
	                if (i < EDGE_STACK.length) {
	                    EDGE_STACK[i++] = br;
	                }
	            } else {
	                if (i === 0) break;
	                a = EDGE_STACK[--i];
	            }
	        }

	        return ar;
	    }

	    _link(a, b) {
	        this._halfedges[a] = b;
	        if (b !== -1) this._halfedges[b] = a;
	    }

	    // add a new triangle given vertex indices and adjacent half-edge ids
	    _addTriangle(i0, i1, i2, a, b, c) {
	        const t = this.trianglesLen;

	        this._triangles[t] = i0;
	        this._triangles[t + 1] = i1;
	        this._triangles[t + 2] = i2;

	        this._link(t, a);
	        this._link(t + 1, b);
	        this._link(t + 2, c);

	        this.trianglesLen += 3;

	        return t;
	    }
	}

	// monotonically increases with real angle, but doesn't need expensive trigonometry
	function pseudoAngle(dx, dy) {
	    const p = dx / (Math.abs(dx) + Math.abs(dy));
	    return (dy > 0 ? 3 - p : 1 + p) / 4; // [0..1]
	}

	function dist(ax, ay, bx, by) {
	    const dx = ax - bx;
	    const dy = ay - by;
	    return dx * dx + dy * dy;
	}

	// return 2d orientation sign if we're confident in it through J. Shewchuk's error bound check
	function orientIfSure(px, py, rx, ry, qx, qy) {
	    const l = (ry - py) * (qx - px);
	    const r = (rx - px) * (qy - py);
	    return Math.abs(l - r) >= 3.3306690738754716e-16 * Math.abs(l + r) ? l - r : 0;
	}

	// a more robust orientation test that's stable in a given triangle (to fix robustness issues)
	function orient(rx, ry, qx, qy, px, py) {
	    const sign = orientIfSure(px, py, rx, ry, qx, qy) ||
	    orientIfSure(rx, ry, qx, qy, px, py) ||
	    orientIfSure(qx, qy, px, py, rx, ry);
	    return sign < 0;
	}

	function inCircle(ax, ay, bx, by, cx, cy, px, py) {
	    const dx = ax - px;
	    const dy = ay - py;
	    const ex = bx - px;
	    const ey = by - py;
	    const fx = cx - px;
	    const fy = cy - py;

	    const ap = dx * dx + dy * dy;
	    const bp = ex * ex + ey * ey;
	    const cp = fx * fx + fy * fy;

	    return dx * (ey * cp - bp * fy) -
	           dy * (ex * cp - bp * fx) +
	           ap * (ex * fy - ey * fx) < 0;
	}

	function circumradius(ax, ay, bx, by, cx, cy) {
	    const dx = bx - ax;
	    const dy = by - ay;
	    const ex = cx - ax;
	    const ey = cy - ay;

	    const bl = dx * dx + dy * dy;
	    const cl = ex * ex + ey * ey;
	    const d = 0.5 / (dx * ey - dy * ex);

	    const x = (ey * bl - dy * cl) * d;
	    const y = (dx * cl - ex * bl) * d;

	    return x * x + y * y;
	}

	function circumcenter(ax, ay, bx, by, cx, cy) {
	    const dx = bx - ax;
	    const dy = by - ay;
	    const ex = cx - ax;
	    const ey = cy - ay;

	    const bl = dx * dx + dy * dy;
	    const cl = ex * ex + ey * ey;
	    const d = 0.5 / (dx * ey - dy * ex);

	    const x = ax + (ey * bl - dy * cl) * d;
	    const y = ay + (dx * cl - ex * bl) * d;

	    return {x, y};
	}

	function quicksort(ids, dists, left, right) {
	    if (right - left <= 20) {
	        for (let i = left + 1; i <= right; i++) {
	            const temp = ids[i];
	            const tempDist = dists[temp];
	            let j = i - 1;
	            while (j >= left && dists[ids[j]] > tempDist) ids[j + 1] = ids[j--];
	            ids[j + 1] = temp;
	        }
	    } else {
	        const median = (left + right) >> 1;
	        let i = left + 1;
	        let j = right;
	        swap(ids, median, i);
	        if (dists[ids[left]] > dists[ids[right]]) swap(ids, left, right);
	        if (dists[ids[i]] > dists[ids[right]]) swap(ids, i, right);
	        if (dists[ids[left]] > dists[ids[i]]) swap(ids, left, i);

	        const temp = ids[i];
	        const tempDist = dists[temp];
	        while (true) {
	            do i++; while (dists[ids[i]] < tempDist);
	            do j--; while (dists[ids[j]] > tempDist);
	            if (j < i) break;
	            swap(ids, i, j);
	        }
	        ids[left + 1] = ids[j];
	        ids[j] = temp;

	        if (right - i + 1 >= j - left) {
	            quicksort(ids, dists, i, right);
	            quicksort(ids, dists, left, j - 1);
	        } else {
	            quicksort(ids, dists, left, j - 1);
	            quicksort(ids, dists, i, right);
	        }
	    }
	}

	function swap(arr, i, j) {
	    const tmp = arr[i];
	    arr[i] = arr[j];
	    arr[j] = tmp;
	}

	function defaultGetX(p) {
	    return p[0];
	}
	function defaultGetY(p) {
	    return p[1];
	}

	const epsilon = 1e-6;

	class Path {
	  constructor() {
	    this._x0 = this._y0 = // start of current subpath
	    this._x1 = this._y1 = null; // end of current subpath
	    this._ = "";
	  }
	  moveTo(x, y) {
	    this._ += `M${this._x0 = this._x1 = +x},${this._y0 = this._y1 = +y}`;
	  }
	  closePath() {
	    if (this._x1 !== null) {
	      this._x1 = this._x0, this._y1 = this._y0;
	      this._ += "Z";
	    }
	  }
	  lineTo(x, y) {
	    this._ += `L${this._x1 = +x},${this._y1 = +y}`;
	  }
	  arc(x, y, r) {
	    x = +x, y = +y, r = +r;
	    const x0 = x + r;
	    const y0 = y;
	    if (r < 0) throw new Error("negative radius");
	    if (this._x1 === null) this._ += `M${x0},${y0}`;
	    else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) this._ += "L" + x0 + "," + y0;
	    if (!r) return;
	    this._ += `A${r},${r},0,1,1,${x - r},${y}A${r},${r},0,1,1,${this._x1 = x0},${this._y1 = y0}`;
	  }
	  rect(x, y, w, h) {
	    this._ += `M${this._x0 = this._x1 = +x},${this._y0 = this._y1 = +y}h${+w}v${+h}h${-w}Z`;
	  }
	  value() {
	    return this._ || null;
	  }
	}

	class Polygon {
	  constructor() {
	    this._ = [];
	  }
	  moveTo(x, y) {
	    this._.push([x, y]);
	  }
	  closePath() {
	    this._.push(this._[0].slice());
	  }
	  lineTo(x, y) {
	    this._.push([x, y]);
	  }
	  value() {
	    return this._.length ? this._ : null;
	  }
	}

	class Voronoi {
	  constructor(delaunay, [xmin, ymin, xmax, ymax] = [0, 0, 960, 500]) {
	    if (!((xmax = +xmax) >= (xmin = +xmin)) || !((ymax = +ymax) >= (ymin = +ymin))) throw new Error("invalid bounds");
	    this.delaunay = delaunay;
	    this._circumcenters = new Float64Array(delaunay.points.length * 2);
	    this.vectors = new Float64Array(delaunay.points.length * 2);
	    this.xmax = xmax, this.xmin = xmin;
	    this.ymax = ymax, this.ymin = ymin;
	    this._init();
	  }
	  update() {
	    this.delaunay.update();
	    this._init();
	    return this;
	  }
	  _init() {
	    const {delaunay: {points, hull, triangles}, vectors} = this;

	    // Compute circumcenters.
	    const circumcenters = this.circumcenters = this._circumcenters.subarray(0, triangles.length / 3 * 2);
	    for (let i = 0, j = 0, n = triangles.length, x, y; i < n; i += 3, j += 2) {
	      const t1 = triangles[i] * 2;
	      const t2 = triangles[i + 1] * 2;
	      const t3 = triangles[i + 2] * 2;
	      const x1 = points[t1];
	      const y1 = points[t1 + 1];
	      const x2 = points[t2];
	      const y2 = points[t2 + 1];
	      const x3 = points[t3];
	      const y3 = points[t3 + 1];

	      const dx = x2 - x1;
	      const dy = y2 - y1;
	      const ex = x3 - x1;
	      const ey = y3 - y1;
	      const bl = dx * dx + dy * dy;
	      const cl = ex * ex + ey * ey;
	      const ab = (dx * ey - dy * ex) * 2;

	      if (!ab) {
	        // degenerate case (collinear diagram)
	        x = (x1 + x3) / 2 - 1e8 * ey;
	        y = (y1 + y3) / 2 + 1e8 * ex;
	      }
	      else if (Math.abs(ab) < 1e-8) {
	        // almost equal points (degenerate triangle)
	        x = (x1 + x3) / 2;
	        y = (y1 + y3) / 2;
	      } else {
	        const d = 1 / ab;
	        x = x1 + (ey * bl - dy * cl) * d;
	        y = y1 + (dx * cl - ex * bl) * d;
	      }
	      circumcenters[j] = x;
	      circumcenters[j + 1] = y;
	    }

	    // Compute exterior cell rays.
	    let h = hull[hull.length - 1];
	    let p0, p1 = h * 4;
	    let x0, x1 = points[2 * h];
	    let y0, y1 = points[2 * h + 1];
	    vectors.fill(0);
	    for (let i = 0; i < hull.length; ++i) {
	      h = hull[i];
	      p0 = p1, x0 = x1, y0 = y1;
	      p1 = h * 4, x1 = points[2 * h], y1 = points[2 * h + 1];
	      vectors[p0 + 2] = vectors[p1] = y0 - y1;
	      vectors[p0 + 3] = vectors[p1 + 1] = x1 - x0;
	    }
	  }
	  render(context) {
	    const buffer = context == null ? context = new Path : undefined;
	    const {delaunay: {halfedges, inedges, hull}, circumcenters, vectors} = this;
	    if (hull.length <= 1) return null;
	    for (let i = 0, n = halfedges.length; i < n; ++i) {
	      const j = halfedges[i];
	      if (j < i) continue;
	      const ti = Math.floor(i / 3) * 2;
	      const tj = Math.floor(j / 3) * 2;
	      const xi = circumcenters[ti];
	      const yi = circumcenters[ti + 1];
	      const xj = circumcenters[tj];
	      const yj = circumcenters[tj + 1];
	      this._renderSegment(xi, yi, xj, yj, context);
	    }
	    let h0, h1 = hull[hull.length - 1];
	    for (let i = 0; i < hull.length; ++i) {
	      h0 = h1, h1 = hull[i];
	      const t = Math.floor(inedges[h1] / 3) * 2;
	      const x = circumcenters[t];
	      const y = circumcenters[t + 1];
	      const v = h0 * 4;
	      const p = this._project(x, y, vectors[v + 2], vectors[v + 3]);
	      if (p) this._renderSegment(x, y, p[0], p[1], context);
	    }
	    return buffer && buffer.value();
	  }
	  renderBounds(context) {
	    const buffer = context == null ? context = new Path : undefined;
	    context.rect(this.xmin, this.ymin, this.xmax - this.xmin, this.ymax - this.ymin);
	    return buffer && buffer.value();
	  }
	  renderCell(i, context) {
	    const buffer = context == null ? context = new Path : undefined;
	    const points = this._clip(i);
	    if (points === null || !points.length) return;
	    context.moveTo(points[0], points[1]);
	    let n = points.length;
	    while (points[0] === points[n-2] && points[1] === points[n-1] && n > 1) n -= 2;
	    for (let i = 2; i < n; i += 2) {
	      if (points[i] !== points[i-2] || points[i+1] !== points[i-1])
	        context.lineTo(points[i], points[i + 1]);
	    }
	    context.closePath();
	    return buffer && buffer.value();
	  }
	  *cellPolygons() {
	    const {delaunay: {points}} = this;
	    for (let i = 0, n = points.length / 2; i < n; ++i) {
	      const cell = this.cellPolygon(i);
	      if (cell) cell.index = i, yield cell;
	    }
	  }
	  cellPolygon(i) {
	    const polygon = new Polygon;
	    this.renderCell(i, polygon);
	    return polygon.value();
	  }
	  _renderSegment(x0, y0, x1, y1, context) {
	    let S;
	    const c0 = this._regioncode(x0, y0);
	    const c1 = this._regioncode(x1, y1);
	    if (c0 === 0 && c1 === 0) {
	      context.moveTo(x0, y0);
	      context.lineTo(x1, y1);
	    } else if (S = this._clipSegment(x0, y0, x1, y1, c0, c1)) {
	      context.moveTo(S[0], S[1]);
	      context.lineTo(S[2], S[3]);
	    }
	  }
	  contains(i, x, y) {
	    if ((x = +x, x !== x) || (y = +y, y !== y)) return false;
	    return this.delaunay._step(i, x, y) === i;
	  }
	  *neighbors(i) {
	    const ci = this._clip(i);
	    if (ci) for (const j of this.delaunay.neighbors(i)) {
	      const cj = this._clip(j);
	      // find the common edge
	      if (cj) loop: for (let ai = 0, li = ci.length; ai < li; ai += 2) {
	        for (let aj = 0, lj = cj.length; aj < lj; aj += 2) {
	          if (ci[ai] == cj[aj]
	          && ci[ai + 1] == cj[aj + 1]
	          && ci[(ai + 2) % li] == cj[(aj + lj - 2) % lj]
	          && ci[(ai + 3) % li] == cj[(aj + lj - 1) % lj]
	          ) {
	            yield j;
	            break loop;
	          }
	        }
	      }
	    }
	  }
	  _cell(i) {
	    const {circumcenters, delaunay: {inedges, halfedges, triangles}} = this;
	    const e0 = inedges[i];
	    if (e0 === -1) return null; // coincident point
	    const points = [];
	    let e = e0;
	    do {
	      const t = Math.floor(e / 3);
	      points.push(circumcenters[t * 2], circumcenters[t * 2 + 1]);
	      e = e % 3 === 2 ? e - 2 : e + 1;
	      if (triangles[e] !== i) break; // bad triangulation
	      e = halfedges[e];
	    } while (e !== e0 && e !== -1);
	    return points;
	  }
	  _clip(i) {
	    // degenerate case (1 valid point: return the box)
	    if (i === 0 && this.delaunay.hull.length === 1) {
	      return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
	    }
	    const points = this._cell(i);
	    if (points === null) return null;
	    const {vectors: V} = this;
	    const v = i * 4;
	    return V[v] || V[v + 1]
	        ? this._clipInfinite(i, points, V[v], V[v + 1], V[v + 2], V[v + 3])
	        : this._clipFinite(i, points);
	  }
	  _clipFinite(i, points) {
	    const n = points.length;
	    let P = null;
	    let x0, y0, x1 = points[n - 2], y1 = points[n - 1];
	    let c0, c1 = this._regioncode(x1, y1);
	    let e0, e1;
	    for (let j = 0; j < n; j += 2) {
	      x0 = x1, y0 = y1, x1 = points[j], y1 = points[j + 1];
	      c0 = c1, c1 = this._regioncode(x1, y1);
	      if (c0 === 0 && c1 === 0) {
	        e0 = e1, e1 = 0;
	        if (P) P.push(x1, y1);
	        else P = [x1, y1];
	      } else {
	        let S, sx0, sy0, sx1, sy1;
	        if (c0 === 0) {
	          if ((S = this._clipSegment(x0, y0, x1, y1, c0, c1)) === null) continue;
	          [sx0, sy0, sx1, sy1] = S;
	        } else {
	          if ((S = this._clipSegment(x1, y1, x0, y0, c1, c0)) === null) continue;
	          [sx1, sy1, sx0, sy0] = S;
	          e0 = e1, e1 = this._edgecode(sx0, sy0);
	          if (e0 && e1) this._edge(i, e0, e1, P, P.length);
	          if (P) P.push(sx0, sy0);
	          else P = [sx0, sy0];
	        }
	        e0 = e1, e1 = this._edgecode(sx1, sy1);
	        if (e0 && e1) this._edge(i, e0, e1, P, P.length);
	        if (P) P.push(sx1, sy1);
	        else P = [sx1, sy1];
	      }
	    }
	    if (P) {
	      e0 = e1, e1 = this._edgecode(P[0], P[1]);
	      if (e0 && e1) this._edge(i, e0, e1, P, P.length);
	    } else if (this.contains(i, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {
	      return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
	    }
	    return P;
	  }
	  _clipSegment(x0, y0, x1, y1, c0, c1) {
	    while (true) {
	      if (c0 === 0 && c1 === 0) return [x0, y0, x1, y1];
	      if (c0 & c1) return null;
	      let x, y, c = c0 || c1;
	      if (c & 0b1000) x = x0 + (x1 - x0) * (this.ymax - y0) / (y1 - y0), y = this.ymax;
	      else if (c & 0b0100) x = x0 + (x1 - x0) * (this.ymin - y0) / (y1 - y0), y = this.ymin;
	      else if (c & 0b0010) y = y0 + (y1 - y0) * (this.xmax - x0) / (x1 - x0), x = this.xmax;
	      else y = y0 + (y1 - y0) * (this.xmin - x0) / (x1 - x0), x = this.xmin;
	      if (c0) x0 = x, y0 = y, c0 = this._regioncode(x0, y0);
	      else x1 = x, y1 = y, c1 = this._regioncode(x1, y1);
	    }
	  }
	  _clipInfinite(i, points, vx0, vy0, vxn, vyn) {
	    let P = Array.from(points), p;
	    if (p = this._project(P[0], P[1], vx0, vy0)) P.unshift(p[0], p[1]);
	    if (p = this._project(P[P.length - 2], P[P.length - 1], vxn, vyn)) P.push(p[0], p[1]);
	    if (P = this._clipFinite(i, P)) {
	      for (let j = 0, n = P.length, c0, c1 = this._edgecode(P[n - 2], P[n - 1]); j < n; j += 2) {
	        c0 = c1, c1 = this._edgecode(P[j], P[j + 1]);
	        if (c0 && c1) j = this._edge(i, c0, c1, P, j), n = P.length;
	      }
	    } else if (this.contains(i, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {
	      P = [this.xmin, this.ymin, this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax];
	    }
	    return P;
	  }
	  _edge(i, e0, e1, P, j) {
	    while (e0 !== e1) {
	      let x, y;
	      switch (e0) {
	        case 0b0101: e0 = 0b0100; continue; // top-left
	        case 0b0100: e0 = 0b0110, x = this.xmax, y = this.ymin; break; // top
	        case 0b0110: e0 = 0b0010; continue; // top-right
	        case 0b0010: e0 = 0b1010, x = this.xmax, y = this.ymax; break; // right
	        case 0b1010: e0 = 0b1000; continue; // bottom-right
	        case 0b1000: e0 = 0b1001, x = this.xmin, y = this.ymax; break; // bottom
	        case 0b1001: e0 = 0b0001; continue; // bottom-left
	        case 0b0001: e0 = 0b0101, x = this.xmin, y = this.ymin; break; // left
	      }
	      if ((P[j] !== x || P[j + 1] !== y) && this.contains(i, x, y)) {
	        P.splice(j, 0, x, y), j += 2;
	      }
	    }
	    if (P.length > 4) {
	      for (let i = 0; i < P.length; i+= 2) {
	        const j = (i + 2) % P.length, k = (i + 4) % P.length;
	        if (P[i] === P[j] && P[j] === P[k]
	        || P[i + 1] === P[j + 1] && P[j + 1] === P[k + 1])
	          P.splice(j, 2), i -= 2;
	      }
	    }
	    return j;
	  }
	  _project(x0, y0, vx, vy) {
	    let t = Infinity, c, x, y;
	    if (vy < 0) { // top
	      if (y0 <= this.ymin) return null;
	      if ((c = (this.ymin - y0) / vy) < t) y = this.ymin, x = x0 + (t = c) * vx;
	    } else if (vy > 0) { // bottom
	      if (y0 >= this.ymax) return null;
	      if ((c = (this.ymax - y0) / vy) < t) y = this.ymax, x = x0 + (t = c) * vx;
	    }
	    if (vx > 0) { // right
	      if (x0 >= this.xmax) return null;
	      if ((c = (this.xmax - x0) / vx) < t) x = this.xmax, y = y0 + (t = c) * vy;
	    } else if (vx < 0) { // left
	      if (x0 <= this.xmin) return null;
	      if ((c = (this.xmin - x0) / vx) < t) x = this.xmin, y = y0 + (t = c) * vy;
	    }
	    return [x, y];
	  }
	  _edgecode(x, y) {
	    return (x === this.xmin ? 0b0001
	        : x === this.xmax ? 0b0010 : 0b0000)
	        | (y === this.ymin ? 0b0100
	        : y === this.ymax ? 0b1000 : 0b0000);
	  }
	  _regioncode(x, y) {
	    return (x < this.xmin ? 0b0001
	        : x > this.xmax ? 0b0010 : 0b0000)
	        | (y < this.ymin ? 0b0100
	        : y > this.ymax ? 0b1000 : 0b0000);
	  }
	}

	const tau = 2 * Math.PI, pow = Math.pow;

	function pointX(p) {
	  return p[0];
	}

	function pointY(p) {
	  return p[1];
	}

	// A triangulation is collinear if all its triangles have a non-null area
	function collinear(d) {
	  const {triangles, coords} = d;
	  for (let i = 0; i < triangles.length; i += 3) {
	    const a = 2 * triangles[i],
	          b = 2 * triangles[i + 1],
	          c = 2 * triangles[i + 2],
	          cross = (coords[c] - coords[a]) * (coords[b + 1] - coords[a + 1])
	                - (coords[b] - coords[a]) * (coords[c + 1] - coords[a + 1]);
	    if (cross > 1e-10) return false;
	  }
	  return true;
	}

	function jitter(x, y, r) {
	  return [x + Math.sin(x + y) * r, y + Math.cos(x - y) * r];
	}

	class Delaunay {
	  static from(points, fx = pointX, fy = pointY, that) {
	    return new Delaunay("length" in points
	        ? flatArray(points, fx, fy, that)
	        : Float64Array.from(flatIterable(points, fx, fy, that)));
	  }
	  constructor(points) {
	    this._delaunator = new Delaunator(points);
	    this.inedges = new Int32Array(points.length / 2);
	    this._hullIndex = new Int32Array(points.length / 2);
	    this.points = this._delaunator.coords;
	    this._init();
	  }
	  update() {
	    this._delaunator.update();
	    this._init();
	    return this;
	  }
	  _init() {
	    const d = this._delaunator, points = this.points;

	    // check for collinear
	    if (d.hull && d.hull.length > 2 && collinear(d)) {
	      this.collinear = Int32Array.from({length: points.length/2}, (_,i) => i)
	        .sort((i, j) => points[2 * i] - points[2 * j] || points[2 * i + 1] - points[2 * j + 1]); // for exact neighbors
	      const e = this.collinear[0], f = this.collinear[this.collinear.length - 1],
	        bounds = [ points[2 * e], points[2 * e + 1], points[2 * f], points[2 * f + 1] ],
	        r = 1e-8 * Math.hypot(bounds[3] - bounds[1], bounds[2] - bounds[0]);
	      for (let i = 0, n = points.length / 2; i < n; ++i) {
	        const p = jitter(points[2 * i], points[2 * i + 1], r);
	        points[2 * i] = p[0];
	        points[2 * i + 1] = p[1];
	      }
	      this._delaunator = new Delaunator(points);
	    } else {
	      delete this.collinear;
	    }

	    const halfedges = this.halfedges = this._delaunator.halfedges;
	    const hull = this.hull = this._delaunator.hull;
	    const triangles = this.triangles = this._delaunator.triangles;
	    const inedges = this.inedges.fill(-1);
	    const hullIndex = this._hullIndex.fill(-1);

	    // Compute an index from each point to an (arbitrary) incoming halfedge
	    // Used to give the first neighbor of each point; for this reason,
	    // on the hull we give priority to exterior halfedges
	    for (let e = 0, n = halfedges.length; e < n; ++e) {
	      const p = triangles[e % 3 === 2 ? e - 2 : e + 1];
	      if (halfedges[e] === -1 || inedges[p] === -1) inedges[p] = e;
	    }
	    for (let i = 0, n = hull.length; i < n; ++i) {
	      hullIndex[hull[i]] = i;
	    }

	    // degenerate case: 1 or 2 (distinct) points
	    if (hull.length <= 2 && hull.length > 0) {
	      this.triangles = new Int32Array(3).fill(-1);
	      this.halfedges = new Int32Array(3).fill(-1);
	      this.triangles[0] = hull[0];
	      this.triangles[1] = hull[1];
	      this.triangles[2] = hull[1];
	      inedges[hull[0]] = 1;
	      if (hull.length === 2) inedges[hull[1]] = 0;
	    }
	  }
	  voronoi(bounds) {
	    return new Voronoi(this, bounds);
	  }
	  *neighbors(i) {
	    const {inedges, hull, _hullIndex, halfedges, triangles, collinear} = this;

	    // degenerate case with several collinear points
	    if (collinear) {
	      const l = collinear.indexOf(i);
	      if (l > 0) yield collinear[l - 1];
	      if (l < collinear.length - 1) yield collinear[l + 1];
	      return;
	    }

	    const e0 = inedges[i];
	    if (e0 === -1) return; // coincident point
	    let e = e0, p0 = -1;
	    do {
	      yield p0 = triangles[e];
	      e = e % 3 === 2 ? e - 2 : e + 1;
	      if (triangles[e] !== i) return; // bad triangulation
	      e = halfedges[e];
	      if (e === -1) {
	        const p = hull[(_hullIndex[i] + 1) % hull.length];
	        if (p !== p0) yield p;
	        return;
	      }
	    } while (e !== e0);
	  }
	  find(x, y, i = 0) {
	    if ((x = +x, x !== x) || (y = +y, y !== y)) return -1;
	    const i0 = i;
	    let c;
	    while ((c = this._step(i, x, y)) >= 0 && c !== i && c !== i0) i = c;
	    return c;
	  }
	  _step(i, x, y) {
	    const {inedges, hull, _hullIndex, halfedges, triangles, points} = this;
	    if (inedges[i] === -1 || !points.length) return (i + 1) % (points.length >> 1);
	    let c = i;
	    let dc = pow(x - points[i * 2], 2) + pow(y - points[i * 2 + 1], 2);
	    const e0 = inedges[i];
	    let e = e0;
	    do {
	      let t = triangles[e];
	      const dt = pow(x - points[t * 2], 2) + pow(y - points[t * 2 + 1], 2);
	      if (dt < dc) dc = dt, c = t;
	      e = e % 3 === 2 ? e - 2 : e + 1;
	      if (triangles[e] !== i) break; // bad triangulation
	      e = halfedges[e];
	      if (e === -1) {
	        e = hull[(_hullIndex[i] + 1) % hull.length];
	        if (e !== t) {
	          if (pow(x - points[e * 2], 2) + pow(y - points[e * 2 + 1], 2) < dc) return e;
	        }
	        break;
	      }
	    } while (e !== e0);
	    return c;
	  }
	  render(context) {
	    const buffer = context == null ? context = new Path : undefined;
	    const {points, halfedges, triangles} = this;
	    for (let i = 0, n = halfedges.length; i < n; ++i) {
	      const j = halfedges[i];
	      if (j < i) continue;
	      const ti = triangles[i] * 2;
	      const tj = triangles[j] * 2;
	      context.moveTo(points[ti], points[ti + 1]);
	      context.lineTo(points[tj], points[tj + 1]);
	    }
	    this.renderHull(context);
	    return buffer && buffer.value();
	  }
	  renderPoints(context, r = 2) {
	    const buffer = context == null ? context = new Path : undefined;
	    const {points} = this;
	    for (let i = 0, n = points.length; i < n; i += 2) {
	      const x = points[i], y = points[i + 1];
	      context.moveTo(x + r, y);
	      context.arc(x, y, r, 0, tau);
	    }
	    return buffer && buffer.value();
	  }
	  renderHull(context) {
	    const buffer = context == null ? context = new Path : undefined;
	    const {hull, points} = this;
	    const h = hull[0] * 2, n = hull.length;
	    context.moveTo(points[h], points[h + 1]);
	    for (let i = 1; i < n; ++i) {
	      const h = 2 * hull[i];
	      context.lineTo(points[h], points[h + 1]);
	    }
	    context.closePath();
	    return buffer && buffer.value();
	  }
	  hullPolygon() {
	    const polygon = new Polygon;
	    this.renderHull(polygon);
	    return polygon.value();
	  }
	  renderTriangle(i, context) {
	    const buffer = context == null ? context = new Path : undefined;
	    const {points, triangles} = this;
	    const t0 = triangles[i *= 3] * 2;
	    const t1 = triangles[i + 1] * 2;
	    const t2 = triangles[i + 2] * 2;
	    context.moveTo(points[t0], points[t0 + 1]);
	    context.lineTo(points[t1], points[t1 + 1]);
	    context.lineTo(points[t2], points[t2 + 1]);
	    context.closePath();
	    return buffer && buffer.value();
	  }
	  *trianglePolygons() {
	    const {triangles} = this;
	    for (let i = 0, n = triangles.length / 3; i < n; ++i) {
	      yield this.trianglePolygon(i);
	    }
	  }
	  trianglePolygon(i) {
	    const polygon = new Polygon;
	    this.renderTriangle(i, polygon);
	    return polygon.value();
	  }
	}

	function flatArray(points, fx, fy, that) {
	  const n = points.length;
	  const array = new Float64Array(n * 2);
	  for (let i = 0; i < n; ++i) {
	    const p = points[i];
	    array[i * 2] = fx.call(that, p, i, points);
	    array[i * 2 + 1] = fy.call(that, p, i, points);
	  }
	  return array;
	}

	function* flatIterable(points, fx, fy, that) {
	  let i = 0;
	  for (const p of points) {
	    yield fx.call(that, p, i, points);
	    yield fy.call(that, p, i, points);
	    ++i;
	  }
	}

	function add_css$2(target) {
	  append_styles(target, "svelte-1awo5n0", ".tooltip-screen.svelte-1awo5n0{pointer-events:all;position:absolute;top:0;left:0;width:100%;height:100%}");
	}

	var get_default_slot_changes = function get_default_slot_changes(dirty) {
	  return {
	    data: dirty &
	    /*data*/
	    1,
	    x: dirty &
	    /*x*/
	    2,
	    y: dirty &
	    /*y*/
	    4
	  };
	};

	var get_default_slot_context = function get_default_slot_context(ctx) {
	  return {
	    data:
	    /*data*/
	    ctx[0],
	    x:
	    /*x*/
	    ctx[1],
	    y:
	    /*y*/
	    ctx[2]
	  };
	}; // (90:0) {#if data && x && y}


	function create_if_block$2(ctx) {
	  var current;
	  var default_slot_template =
	  /*#slots*/
	  ctx[12].default;
	  var default_slot = create_slot(default_slot_template, ctx,
	  /*$$scope*/
	  ctx[11], get_default_slot_context);
	  return {
	    c: function c() {
	      if (default_slot) default_slot.c();
	    },
	    m: function m(target, anchor) {
	      if (default_slot) {
	        default_slot.m(target, anchor);
	      }

	      current = true;
	    },
	    p: function p(ctx, dirty) {
	      if (default_slot) {
	        if (default_slot.p && (!current || dirty &
	        /*$$scope, data, x, y*/
	        2055)) {
	          update_slot_base(default_slot, default_slot_template, ctx,
	          /*$$scope*/
	          ctx[11], !current ? get_all_dirty_from_scope(
	          /*$$scope*/
	          ctx[11]) : get_slot_changes(default_slot_template,
	          /*$$scope*/
	          ctx[11], dirty, get_default_slot_changes), get_default_slot_context);
	        }
	      }
	    },
	    i: function i(local) {
	      if (current) return;
	      transition_in(default_slot, local);
	      current = true;
	    },
	    o: function o(local) {
	      transition_out(default_slot, local);
	      current = false;
	    },
	    d: function d(detaching) {
	      if (default_slot) default_slot.d(detaching);
	    }
	  };
	}

	function create_fragment$3(ctx) {
	  var div;
	  var t;
	  var if_block_anchor;
	  var current;
	  var mounted;
	  var dispose;
	  var if_block =
	  /*data*/
	  ctx[0] &&
	  /*x*/
	  ctx[1] &&
	  /*y*/
	  ctx[2] && create_if_block$2(ctx);
	  return {
	    c: function c() {
	      div = element("div");
	      t = space();
	      if (if_block) if_block.c();
	      if_block_anchor = empty();
	      attr(div, "class", "tooltip-screen svelte-1awo5n0");
	    },
	    m: function m(target, anchor) {
	      insert(target, div, anchor);
	      insert(target, t, anchor);
	      if (if_block) if_block.m(target, anchor);
	      insert(target, if_block_anchor, anchor);
	      current = true;

	      if (!mounted) {
	        dispose = [action_destroyer(/*mouseAction*/
	        ctx[4].call(null, div)), action_destroyer(/*resizeAction*/
	        ctx[3].call(null, div)), listen(div, "click",
	        /*click_handler*/
	        ctx[13])];
	        mounted = true;
	      }
	    },
	    p: function p(ctx, _ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	          dirty = _ref2[0];

	      if (
	      /*data*/
	      ctx[0] &&
	      /*x*/
	      ctx[1] &&
	      /*y*/
	      ctx[2]) {
	        if (if_block) {
	          if_block.p(ctx, dirty);

	          if (dirty &
	          /*data, x, y*/
	          7) {
	            transition_in(if_block, 1);
	          }
	        } else {
	          if_block = create_if_block$2(ctx);
	          if_block.c();
	          transition_in(if_block, 1);
	          if_block.m(if_block_anchor.parentNode, if_block_anchor);
	        }
	      } else if (if_block) {
	        group_outros();
	        transition_out(if_block, 1, 1, function () {
	          if_block = null;
	        });
	        check_outros();
	      }
	    },
	    i: function i(local) {
	      if (current) return;
	      transition_in(if_block);
	      current = true;
	    },
	    o: function o(local) {
	      transition_out(if_block);
	      current = false;
	    },
	    d: function d(detaching) {
	      if (detaching) detach(div);
	      if (detaching) detach(t);
	      if (if_block) if_block.d(detaching);
	      if (detaching) detach(if_block_anchor);
	      mounted = false;
	      run_all(dispose);
	    }
	  };
	}

	function instance$3($$self, $$props, $$invalidate) {
	  var delaunay;
	  var mouseEvent;
	  var $mouseEventStore;
	  var _$$props = $$props,
	      _$$props$$$slots = _$$props.$$slots,
	      slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots,
	      $$scope = _$$props.$$scope;
	  var _$$props2 = $$props,
	      _$$props2$delaunayPoi = _$$props2.delaunayPoints,
	      delaunayPoints = _$$props2$delaunayPoi === void 0 ? [] : _$$props2$delaunayPoi;
	  var _$$props3 = $$props,
	      data = _$$props3.data;
	  var _$$props4 = $$props,
	      x = _$$props4.x;
	  var _$$props5 = $$props,
	      y = _$$props5.y;
	  var _$$props6 = $$props,
	      _$$props6$debug = _$$props6.debug,
	      debug = _$$props6$debug === void 0 ? false : _$$props6$debug;
	  var dispatch = createEventDispatcher();

	  function resizeAction(element) {
	    var measure = function measure() {
	      var rect = element.getBoundingClientRect();
	      rect.width;
	      rect.height;
	    };

	    measure();
	    var observer = new window.ResizeObserver(function () {
	      measure();
	    });
	    observer.observe(element);
	    return {
	      destroy: function destroy() {
	        observer.disconnect();
	      }
	    };
	  }

	  var _mouseEvents = mouseEvents(),
	      mouseAction = _mouseEvents.action,
	      mouseEventStore = _mouseEvents.store;

	  component_subscribe($$self, mouseEventStore, function (value) {
	    return $$invalidate(10, $mouseEventStore = value);
	  });

	  function click_handler(event) {
	    bubble.call(this, $$self, event);
	  }

	  $$self.$$set = function ($$new_props) {
	    $$invalidate(17, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
	    if ('delaunayPoints' in $$new_props) $$invalidate(6, delaunayPoints = $$new_props.delaunayPoints);
	    if ('data' in $$new_props) $$invalidate(0, data = $$new_props.data);
	    if ('x' in $$new_props) $$invalidate(1, x = $$new_props.x);
	    if ('y' in $$new_props) $$invalidate(2, y = $$new_props.y);
	    if ('debug' in $$new_props) $$invalidate(7, debug = $$new_props.debug);
	    if ('$$scope' in $$new_props) $$invalidate(11, $$scope = $$new_props.$$scope);
	  };

	  $$self.$$.update = function () {
	    if (debug) console.log('tooltip:', $$props);

	    if ($$self.$$.dirty &
	    /*delaunayPoints*/
	    64) {
	      /**
	      * The actual points array passed to Delaunay is scaled by the size of the
	      * tooltip screen
	      */
	      // $: delaunayPoints_ = delaunayPoints.map((d) => ({
	      //   ...d,
	      //   x: (d.x / 101) * containerWidth,
	      //   y: horizontalOnly === true ? 0.5 * containerHeight : (d.y / 100) * containerHeight
	      // }))
	      $$invalidate(8, delaunay = Delaunay.from(delaunayPoints, function (d) {
	        return d.x;
	      }, function (d) {
	        return d.y;
	      }));
	    }

	    if ($$self.$$.dirty &
	    /*$mouseEventStore*/
	    1024) {
	      $$invalidate(9, mouseEvent = $mouseEventStore);
	    }

	    if ($$self.$$.dirty &
	    /*debug, mouseEvent*/
	    640) {
	      if (debug) console.log('tooltip:', {
	        mouseEvent: mouseEvent
	      });
	    }

	    if ($$self.$$.dirty &
	    /*mouseEvent, delaunay, debug, delaunayPoints*/
	    960) {
	      {
	        if (mouseEvent) {
	          var _mouseEvent = mouseEvent,
	              clientX = _mouseEvent.clientX,
	              clientY = _mouseEvent.clientY;

	          if (Array.isArray(mouseEvent.touches)) {
	            var _mouseEvent$touches$ = mouseEvent.touches[0];
	            clientX = _mouseEvent$touches$.clientX;
	            clientY = _mouseEvent$touches$.clientY;
	          }

	          var _ref3 = mouseEvent.target.getBoundingClientRect() || {
	            left: 0,
	            top: 0
	          },
	              left = _ref3.left,
	              top = _ref3.top;

	          var layerX = clientX - left;
	          var layerY = clientY - top;
	          var foundIndex = delaunay.find(layerX, layerY);

	          if (debug) {
	            console.log('tooltip:', {
	              layerX: layerX,
	              layerY: layerY,
	              foundIndex: foundIndex,
	              delaunayPoints: delaunayPoints
	            });
	          }

	          if (!Number.isFinite(foundIndex) && delaunayPoints.length) {
	            console.log("Delaunay foundIndex is ".concat(foundIndex));
	          }

	          var foundData = delaunayPoints[foundIndex];

	          if (foundData) {
	            $$invalidate(0, data = foundData);
	            $$invalidate(1, x = foundData.x);
	            $$invalidate(2, y = foundData.y);
	          } else {
	            $$invalidate(0, data = null);
	          }
	        } else {
	          $$invalidate(0, data = null);
	        }
	      }
	    }

	    if ($$self.$$.dirty &
	    /*data*/
	    1) {
	      {
	        dispatch('data', data, {
	          cancelable: false
	        });
	      }
	    }
	  };

	  $$props = exclude_internal_props($$props);
	  return [data, x, y, resizeAction, mouseAction, mouseEventStore, delaunayPoints, debug, delaunay, mouseEvent, $mouseEventStore, $$scope, slots, click_handler];
	}

	var TooltipScreen = /*#__PURE__*/function (_SvelteComponent) {
	  _inherits(TooltipScreen, _SvelteComponent);

	  var _super = _createSuper(TooltipScreen);

	  function TooltipScreen(options) {
	    var _this;

	    _classCallCheck(this, TooltipScreen);

	    _this = _super.call(this);
	    init(_assertThisInitialized(_this), options, instance$3, create_fragment$3, safe_not_equal, {
	      delaunayPoints: 6,
	      data: 0,
	      x: 1,
	      y: 2,
	      debug: 7
	    }, add_css$2);
	    return _this;
	  }

	  _createClass(TooltipScreen, [{
	    key: "delaunayPoints",
	    get: function get() {
	      return this.$$.ctx[6];
	    },
	    set: function set(delaunayPoints) {
	      this.$$set({
	        delaunayPoints: delaunayPoints
	      });
	      flush();
	    }
	  }, {
	    key: "data",
	    get: function get() {
	      return this.$$.ctx[0];
	    },
	    set: function set(data) {
	      this.$$set({
	        data: data
	      });
	      flush();
	    }
	  }, {
	    key: "x",
	    get: function get() {
	      return this.$$.ctx[1];
	    },
	    set: function set(x) {
	      this.$$set({
	        x: x
	      });
	      flush();
	    }
	  }, {
	    key: "y",
	    get: function get() {
	      return this.$$.ctx[2];
	    },
	    set: function set(y) {
	      this.$$set({
	        y: y
	      });
	      flush();
	    }
	  }, {
	    key: "debug",
	    get: function get() {
	      return this.$$.ctx[7];
	    },
	    set: function set(debug) {
	      this.$$set({
	        debug: debug
	      });
	      flush();
	    }
	  }]);

	  return TooltipScreen;
	}(SvelteComponent);

	function add_css$1(target) {
	  append_styles(target, "svelte-p4qd19", ".tt-row.svelte-p4qd19.svelte-p4qd19{margin-top:8px}.big-number.svelte-p4qd19.svelte-p4qd19{font-size:28px;line-height:28px}.small-label.svelte-p4qd19.svelte-p4qd19{font-size:14px;line-height:16px;margin-bottom:6px;margin-top:0px}.tt-row.mobile.svelte-p4qd19 .big-number.svelte-p4qd19{font-size:22px;line-height:26px}.tt-row.mobile.svelte-p4qd19 .small-label.svelte-p4qd19{font-size:12px;line-height:12px}");
	} // (51:2) {#if labelDisplay}


	function create_if_block$1(ctx) {
	  var div;
	  var t_value =
	  /*labelDisplay*/
	  ctx[2].trim() + "";
	  var t;
	  return {
	    c: function c() {
	      div = element("div");
	      t = text(t_value);
	      attr(div, "class", "small-label svelte-p4qd19");
	    },
	    m: function m(target, anchor) {
	      insert(target, div, anchor);
	      append(div, t);
	    },
	    p: function p(ctx, dirty) {
	      if (dirty &
	      /*labelDisplay*/
	      4 && t_value !== (t_value =
	      /*labelDisplay*/
	      ctx[2].trim() + "")) set_data(t, t_value);
	    },
	    d: function d(detaching) {
	      if (detaching) detach(div);
	    }
	  };
	}

	function create_fragment$2(ctx) {
	  var div1;
	  var div0;
	  var t0_value =
	  /*formatter*/
	  ctx[3](
	  /*value*/
	  ctx[0]) + "";
	  var t0;
	  var t1;
	  var div1_class_value;
	  var if_block =
	  /*labelDisplay*/
	  ctx[2] && create_if_block$1(ctx);
	  return {
	    c: function c() {
	      div1 = element("div");
	      div0 = element("div");
	      t0 = text(t0_value);
	      t1 = space();
	      if (if_block) if_block.c();
	      attr(div0, "class", "big-number svelte-p4qd19");
	      attr(div1, "class", div1_class_value = "tt-row " + (
	      /*isMobile*/
	      ctx[1] ? 'mobile' : '') + " svelte-p4qd19");
	    },
	    m: function m(target, anchor) {
	      insert(target, div1, anchor);
	      append(div1, div0);
	      append(div0, t0);
	      append(div1, t1);
	      if (if_block) if_block.m(div1, null);
	    },
	    p: function p(ctx, _ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	          dirty = _ref2[0];

	      if (dirty &
	      /*formatter, value*/
	      9 && t0_value !== (t0_value =
	      /*formatter*/
	      ctx[3](
	      /*value*/
	      ctx[0]) + "")) set_data(t0, t0_value);

	      if (
	      /*labelDisplay*/
	      ctx[2]) {
	        if (if_block) {
	          if_block.p(ctx, dirty);
	        } else {
	          if_block = create_if_block$1(ctx);
	          if_block.c();
	          if_block.m(div1, null);
	        }
	      } else if (if_block) {
	        if_block.d(1);
	        if_block = null;
	      }

	      if (dirty &
	      /*isMobile*/
	      2 && div1_class_value !== (div1_class_value = "tt-row " + (
	      /*isMobile*/
	      ctx[1] ? 'mobile' : '') + " svelte-p4qd19")) {
	        attr(div1, "class", div1_class_value);
	      }
	    },
	    i: noop,
	    o: noop,
	    d: function d(detaching) {
	      if (detaching) detach(div1);
	      if (if_block) if_block.d();
	    }
	  };
	}

	function instance$2($$self, $$props, $$invalidate) {
	  var formatter;
	  var fieldLabel;
	  var pre;
	  var post;
	  var labelDisplay;
	  var env = $$props.env;
	  var _$$props$field = $$props.field,
	      field = _$$props$field === void 0 ? {} : _$$props$field;
	  var value = $$props.value;
	  var label = $$props.label;
	  var _$$props$formatOption = $$props.formatOptions,
	      formatOptions = _$$props$formatOption === void 0 ? {} : _$$props$formatOption;
	  var _$$props$isMobile = $$props.isMobile,
	      isMobile = _$$props$isMobile === void 0 ? false : _$$props$isMobile;

	  $$self.$$set = function ($$props) {
	    if ('env' in $$props) $$invalidate(4, env = $$props.env);
	    if ('field' in $$props) $$invalidate(5, field = $$props.field);
	    if ('value' in $$props) $$invalidate(0, value = $$props.value);
	    if ('label' in $$props) $$invalidate(6, label = $$props.label);
	    if ('formatOptions' in $$props) $$invalidate(7, formatOptions = $$props.formatOptions);
	    if ('isMobile' in $$props) $$invalidate(1, isMobile = $$props.isMobile);
	  };

	  $$self.$$.update = function () {
	    if ($$self.$$.dirty &
	    /*field, env, formatOptions*/
	    176) {
	      $$invalidate(3, formatter = fieldFormatter$1(field, env, _objectSpread2({
	        preventLongPrePost: true
	      }, formatOptions)));
	    }

	    if ($$self.$$.dirty &
	    /*field*/
	    32) {
	      $$invalidate(10, fieldLabel = field.label || field.caption);
	    }

	    if ($$self.$$.dirty &
	    /*field*/
	    32) {
	      $$invalidate(9, pre = field.unitBefore || '');
	    }

	    if ($$self.$$.dirty &
	    /*field*/
	    32) {
	      $$invalidate(8, post = field.unitAfter || '');
	    }

	    if ($$self.$$.dirty &
	    /*label, fieldLabel, pre, post*/
	    1856) {
	      $$invalidate(2, labelDisplay = label || fieldLabel || (pre.length > 3 ? pre : '') || (post.length > 3 ? post : ''));
	    }
	  };

	  return [value, isMobile, labelDisplay, formatter, env, field, label, formatOptions, post, pre, fieldLabel];
	}

	var TooltipField = /*#__PURE__*/function (_SvelteComponent) {
	  _inherits(TooltipField, _SvelteComponent);

	  var _super = _createSuper(TooltipField);

	  function TooltipField(options) {
	    var _this;

	    _classCallCheck(this, TooltipField);

	    _this = _super.call(this);
	    init(_assertThisInitialized(_this), options, instance$2, create_fragment$2, safe_not_equal, {
	      env: 4,
	      field: 5,
	      value: 0,
	      label: 6,
	      formatOptions: 7,
	      isMobile: 1
	    }, add_css$1);
	    return _this;
	  }

	  _createClass(TooltipField, [{
	    key: "env",
	    get: function get() {
	      return this.$$.ctx[4];
	    },
	    set: function set(env) {
	      this.$$set({
	        env: env
	      });
	      flush();
	    }
	  }, {
	    key: "field",
	    get: function get() {
	      return this.$$.ctx[5];
	    },
	    set: function set(field) {
	      this.$$set({
	        field: field
	      });
	      flush();
	    }
	  }, {
	    key: "value",
	    get: function get() {
	      return this.$$.ctx[0];
	    },
	    set: function set(value) {
	      this.$$set({
	        value: value
	      });
	      flush();
	    }
	  }, {
	    key: "label",
	    get: function get() {
	      return this.$$.ctx[6];
	    },
	    set: function set(label) {
	      this.$$set({
	        label: label
	      });
	      flush();
	    }
	  }, {
	    key: "formatOptions",
	    get: function get() {
	      return this.$$.ctx[7];
	    },
	    set: function set(formatOptions) {
	      this.$$set({
	        formatOptions: formatOptions
	      });
	      flush();
	    }
	  }, {
	    key: "isMobile",
	    get: function get() {
	      return this.$$.ctx[1];
	    },
	    set: function set(isMobile) {
	      this.$$set({
	        isMobile: isMobile
	      });
	      flush();
	    }
	  }]);

	  return TooltipField;
	}(SvelteComponent);

	function create_fragment$1(ctx) {
	  var g;
	  return {
	    c: function c() {
	      g = svg_element("g");
	      attr(g, "class", "threshold-lines");
	      attr(g, "data-dimensions",
	      /*dimensions*/
	      ctx[0]);
	    },
	    m: function m(target, anchor) {
	      insert(target, g, anchor);
	      /*g_binding*/

	      ctx[4](g);
	    },
	    p: function p(ctx, _ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	          dirty = _ref2[0];

	      if (dirty &
	      /*dimensions*/
	      1) {
	        attr(g, "data-dimensions",
	        /*dimensions*/
	        ctx[0]);
	      }
	    },
	    i: noop,
	    o: noop,
	    d: function d(detaching) {
	      if (detaching) detach(g);
	      /*g_binding*/

	      ctx[4](null);
	    }
	  };
	}

	function instance$1($$self, $$props, $$invalidate) {
	  var env = $$props.env;
	  var dimensions = $$props.dimensions;
	  var lastDimensions;
	  var targetNode;

	  function g_binding($$value) {
	    binding_callbacks[$$value ? 'unshift' : 'push'](function () {
	      targetNode = $$value;
	      $$invalidate(1, targetNode);
	    });
	  }

	  $$self.$$set = function ($$props) {
	    if ('env' in $$props) $$invalidate(2, env = $$props.env);
	    if ('dimensions' in $$props) $$invalidate(0, dimensions = $$props.dimensions);
	  };

	  $$self.$$.update = function () {
	    if ($$self.$$.dirty &
	    /*env, targetNode, dimensions, lastDimensions*/
	    15) {
	      {
	        var renderer = thresholdLines(_objectSpread2(_objectSpread2({}, env.options), {}, {
	          thresholds: env.data.config.thresholds
	        }));

	        if (targetNode && dimensionsChanged(dimensions, lastDimensions)) {
	          renderer(select(targetNode), env);
	          $$invalidate(3, lastDimensions = dimensions);
	        }
	      }
	    }
	  };

	  return [dimensions, targetNode, env, lastDimensions, g_binding];
	}

	var ThresholdLines = /*#__PURE__*/function (_SvelteComponent) {
	  _inherits(ThresholdLines, _SvelteComponent);

	  var _super = _createSuper(ThresholdLines);

	  function ThresholdLines(options) {
	    var _this;

	    _classCallCheck(this, ThresholdLines);

	    _this = _super.call(this);
	    init(_assertThisInitialized(_this), options, instance$1, create_fragment$1, safe_not_equal, {
	      env: 2,
	      dimensions: 0
	    });
	    return _this;
	  }

	  _createClass(ThresholdLines, [{
	    key: "env",
	    get: function get() {
	      return this.$$.ctx[2];
	    },
	    set: function set(env) {
	      this.$$set({
	        env: env
	      });
	      flush();
	    }
	  }, {
	    key: "dimensions",
	    get: function get() {
	      return this.$$.ctx[0];
	    },
	    set: function set(dimensions) {
	      this.$$set({
	        dimensions: dimensions
	      });
	      flush();
	    }
	  }]);

	  return ThresholdLines;
	}(SvelteComponent);

	function add_css(target) {
	  append_styles(target, "svelte-rooqy0", "b.small-label.svelte-rooqy0{font-size:14px;display:block;margin:4px 0 0px}.empty-margin.svelte-rooqy0{display:block;margin-bottom:8px}");
	} // (156:2) 


	function create_x_axis_slot(ctx) {
	  var g;
	  var axiswrapper;
	  var current;
	  axiswrapper = new AxisWrapper({
	    props: {
	      id: "x",
	      env:
	      /*env*/
	      ctx[0],
	      type: "linear",
	      field:
	      /*chartData*/
	      ctx[1].fields[INDEX_X],
	      orientation: "horizontal",
	      position: "bottom",
	      range:
	      /*xRange*/
	      ctx[32],
	      afterRender:
	      /*afterRenderX*/
	      ctx[34],
	      props: {
	        isPrimaryAxis: true,
	        domainFromZero: false,
	        verticalTickLength: 16,
	        leftAlignStartTick: true,
	        showZeroLineAtBase: false
	      }
	    }
	  });
	  return {
	    c: function c() {
	      g = svg_element("g");
	      create_component(axiswrapper.$$.fragment);
	      attr(g, "slot", "x-axis");
	    },
	    m: function m(target, anchor) {
	      insert(target, g, anchor);
	      mount_component(axiswrapper, g, null);
	      current = true;
	    },
	    p: function p(ctx, dirty) {
	      var axiswrapper_changes = {};
	      if (dirty[0] &
	      /*env*/
	      1) axiswrapper_changes.env =
	      /*env*/
	      ctx[0];
	      if (dirty[0] &
	      /*chartData*/
	      2) axiswrapper_changes.field =
	      /*chartData*/
	      ctx[1].fields[INDEX_X];
	      if (dirty[1] &
	      /*xRange*/
	      2) axiswrapper_changes.range =
	      /*xRange*/
	      ctx[32];
	      if (dirty[1] &
	      /*afterRenderX*/
	      8) axiswrapper_changes.afterRender =
	      /*afterRenderX*/
	      ctx[34];
	      axiswrapper.$set(axiswrapper_changes);
	    },
	    i: function i(local) {
	      if (current) return;
	      transition_in(axiswrapper.$$.fragment, local);
	      current = true;
	    },
	    o: function o(local) {
	      transition_out(axiswrapper.$$.fragment, local);
	      current = false;
	    },
	    d: function d(detaching) {
	      if (detaching) detach(g);
	      destroy_component(axiswrapper);
	    }
	  };
	} // (177:2) 


	function create_y_axis_slot(ctx) {
	  var g;
	  var axiswrapper;
	  var current;
	  axiswrapper = new AxisWrapper({
	    props: {
	      id: "y",
	      env:
	      /*env*/
	      ctx[0],
	      type: "linear",
	      field:
	      /*chartData*/
	      ctx[1].fields[INDEX_Y],
	      orientation: "vertical",
	      position: "right",
	      range:
	      /*yRange*/
	      ctx[33],
	      afterRender:
	      /*afterRenderY*/
	      ctx[35],
	      props: {
	        isPrimaryAxis: false,
	        domainFromZero: false,
	        showZeroLineAtBase: false
	      }
	    }
	  });
	  return {
	    c: function c() {
	      g = svg_element("g");
	      create_component(axiswrapper.$$.fragment);
	      attr(g, "slot", "y-axis");
	    },
	    m: function m(target, anchor) {
	      insert(target, g, anchor);
	      mount_component(axiswrapper, g, null);
	      current = true;
	    },
	    p: function p(ctx, dirty) {
	      var axiswrapper_changes = {};
	      if (dirty[0] &
	      /*env*/
	      1) axiswrapper_changes.env =
	      /*env*/
	      ctx[0];
	      if (dirty[0] &
	      /*chartData*/
	      2) axiswrapper_changes.field =
	      /*chartData*/
	      ctx[1].fields[INDEX_Y];
	      if (dirty[1] &
	      /*yRange*/
	      4) axiswrapper_changes.range =
	      /*yRange*/
	      ctx[33];
	      if (dirty[1] &
	      /*afterRenderY*/
	      16) axiswrapper_changes.afterRender =
	      /*afterRenderY*/
	      ctx[35];
	      axiswrapper.$set(axiswrapper_changes);
	    },
	    i: function i(local) {
	      if (current) return;
	      transition_in(axiswrapper.$$.fragment, local);
	      current = true;
	    },
	    o: function o(local) {
	      transition_out(axiswrapper.$$.fragment, local);
	      current = false;
	    },
	    d: function d(detaching) {
	      if (detaching) detach(g);
	      destroy_component(axiswrapper);
	    }
	  };
	} // (196:4) {#if layoutReady}


	function create_if_block_7(ctx) {
	  var _ctx$;

	  var gridlines0;
	  var gridlines1;
	  var if_block0_anchor;
	  var rendermarkers;
	  var if_block1_anchor;
	  var current;
	  gridlines0 = new GridLines({
	    props: {
	      env:
	      /*env*/
	      ctx[0],
	      orientation: "horizontal",
	      dimensions:
	      /*$dimensions*/
	      ctx[6],
	      options: {
	        hideBottomValueTick: !
	        /*displayZeroDomain*/
	        ctx[14],
	        hideAllLinesButZero: !shouldDisplayGridY(
	        /*env*/
	        ctx[0])
	      }
	    }
	  });
	  gridlines1 = new GridLines({
	    props: {
	      env:
	      /*env*/
	      ctx[0],
	      orientation: "vertical",
	      dimensions:
	      /*$dimensions*/
	      ctx[6],
	      options: {
	        hideAllLinesButZero: !shouldDisplayGridX(
	        /*env*/
	        ctx[0])
	      }
	    }
	  });
	  var if_block0 =
	  /*chartData*/
	  ctx[1].config.scatterPlotIncludesLineGraph && create_if_block_9(ctx);
	  rendermarkers = new RenderMarkers({
	    props: {
	      env:
	      /*env*/
	      ctx[0],
	      fields:
	      /*taxonomy*/
	      ctx[15],
	      activeTooltipIndex:
	      /*activeTooltip*/
	      (_ctx$ = ctx[7]) === null || _ctx$ === void 0 ? void 0 : _ctx$.index,
	      xScale:
	      /*$xAxis*/
	      ctx[5].scale,
	      yScale:
	      /*$yAxis*/
	      ctx[4].scale
	    }
	  });
	  var if_block1 =
	  /*chartData*/
	  ctx[1].config.thresholds && create_if_block_8(ctx);
	  return {
	    c: function c() {
	      create_component(gridlines0.$$.fragment);
	      create_component(gridlines1.$$.fragment);
	      if (if_block0) if_block0.c();
	      if_block0_anchor = empty();
	      create_component(rendermarkers.$$.fragment);
	      if (if_block1) if_block1.c();
	      if_block1_anchor = empty();
	    },
	    m: function m(target, anchor) {
	      mount_component(gridlines0, target, anchor);
	      mount_component(gridlines1, target, anchor);
	      if (if_block0) if_block0.m(target, anchor);
	      insert(target, if_block0_anchor, anchor);
	      mount_component(rendermarkers, target, anchor);
	      if (if_block1) if_block1.m(target, anchor);
	      insert(target, if_block1_anchor, anchor);
	      current = true;
	    },
	    p: function p(ctx, dirty) {
	      var _ctx$2;

	      var gridlines0_changes = {};
	      if (dirty[0] &
	      /*env*/
	      1) gridlines0_changes.env =
	      /*env*/
	      ctx[0];
	      if (dirty[0] &
	      /*$dimensions*/
	      64) gridlines0_changes.dimensions =
	      /*$dimensions*/
	      ctx[6];
	      if (dirty[0] &
	      /*env*/
	      1) gridlines0_changes.options = {
	        hideBottomValueTick: !
	        /*displayZeroDomain*/
	        ctx[14],
	        hideAllLinesButZero: !shouldDisplayGridY(
	        /*env*/
	        ctx[0])
	      };
	      gridlines0.$set(gridlines0_changes);
	      var gridlines1_changes = {};
	      if (dirty[0] &
	      /*env*/
	      1) gridlines1_changes.env =
	      /*env*/
	      ctx[0];
	      if (dirty[0] &
	      /*$dimensions*/
	      64) gridlines1_changes.dimensions =
	      /*$dimensions*/
	      ctx[6];
	      if (dirty[0] &
	      /*env*/
	      1) gridlines1_changes.options = {
	        hideAllLinesButZero: !shouldDisplayGridX(
	        /*env*/
	        ctx[0])
	      };
	      gridlines1.$set(gridlines1_changes);

	      if (
	      /*chartData*/
	      ctx[1].config.scatterPlotIncludesLineGraph) {
	        if (if_block0) {
	          if_block0.p(ctx, dirty);

	          if (dirty[0] &
	          /*chartData*/
	          2) {
	            transition_in(if_block0, 1);
	          }
	        } else {
	          if_block0 = create_if_block_9(ctx);
	          if_block0.c();
	          transition_in(if_block0, 1);
	          if_block0.m(if_block0_anchor.parentNode, if_block0_anchor);
	        }
	      } else if (if_block0) {
	        group_outros();
	        transition_out(if_block0, 1, 1, function () {
	          if_block0 = null;
	        });
	        check_outros();
	      }

	      var rendermarkers_changes = {};
	      if (dirty[0] &
	      /*env*/
	      1) rendermarkers_changes.env =
	      /*env*/
	      ctx[0];
	      if (dirty[0] &
	      /*activeTooltip*/
	      128) rendermarkers_changes.activeTooltipIndex =
	      /*activeTooltip*/
	      (_ctx$2 = ctx[7]) === null || _ctx$2 === void 0 ? void 0 : _ctx$2.index;
	      if (dirty[0] &
	      /*$xAxis*/
	      32) rendermarkers_changes.xScale =
	      /*$xAxis*/
	      ctx[5].scale;
	      if (dirty[0] &
	      /*$yAxis*/
	      16) rendermarkers_changes.yScale =
	      /*$yAxis*/
	      ctx[4].scale;
	      rendermarkers.$set(rendermarkers_changes);

	      if (
	      /*chartData*/
	      ctx[1].config.thresholds) {
	        if (if_block1) {
	          if_block1.p(ctx, dirty);

	          if (dirty[0] &
	          /*chartData*/
	          2) {
	            transition_in(if_block1, 1);
	          }
	        } else {
	          if_block1 = create_if_block_8(ctx);
	          if_block1.c();
	          transition_in(if_block1, 1);
	          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
	        }
	      } else if (if_block1) {
	        group_outros();
	        transition_out(if_block1, 1, 1, function () {
	          if_block1 = null;
	        });
	        check_outros();
	      }
	    },
	    i: function i(local) {
	      if (current) return;
	      transition_in(gridlines0.$$.fragment, local);
	      transition_in(gridlines1.$$.fragment, local);
	      transition_in(if_block0);
	      transition_in(rendermarkers.$$.fragment, local);
	      transition_in(if_block1);
	      current = true;
	    },
	    o: function o(local) {
	      transition_out(gridlines0.$$.fragment, local);
	      transition_out(gridlines1.$$.fragment, local);
	      transition_out(if_block0);
	      transition_out(rendermarkers.$$.fragment, local);
	      transition_out(if_block1);
	      current = false;
	    },
	    d: function d(detaching) {
	      destroy_component(gridlines0, detaching);
	      destroy_component(gridlines1, detaching);
	      if (if_block0) if_block0.d(detaching);
	      if (detaching) detach(if_block0_anchor);
	      destroy_component(rendermarkers, detaching);
	      if (if_block1) if_block1.d(detaching);
	      if (detaching) detach(if_block1_anchor);
	    }
	  };
	} // (214:6) {#if chartData.config.scatterPlotIncludesLineGraph}


	function create_if_block_9(ctx) {
	  var linegraph;
	  var current;
	  linegraph = new LineGraph({
	    props: {
	      env:
	      /*env*/
	      ctx[0],
	      fields:
	      /*taxonomy*/
	      ctx[15],
	      xScale:
	      /*$xAxis*/
	      ctx[5].scale,
	      yScale:
	      /*$yAxis*/
	      ctx[4].scale
	    }
	  });
	  return {
	    c: function c() {
	      create_component(linegraph.$$.fragment);
	    },
	    m: function m(target, anchor) {
	      mount_component(linegraph, target, anchor);
	      current = true;
	    },
	    p: function p(ctx, dirty) {
	      var linegraph_changes = {};
	      if (dirty[0] &
	      /*env*/
	      1) linegraph_changes.env =
	      /*env*/
	      ctx[0];
	      if (dirty[0] &
	      /*$xAxis*/
	      32) linegraph_changes.xScale =
	      /*$xAxis*/
	      ctx[5].scale;
	      if (dirty[0] &
	      /*$yAxis*/
	      16) linegraph_changes.yScale =
	      /*$yAxis*/
	      ctx[4].scale;
	      linegraph.$set(linegraph_changes);
	    },
	    i: function i(local) {
	      if (current) return;
	      transition_in(linegraph.$$.fragment, local);
	      current = true;
	    },
	    o: function o(local) {
	      transition_out(linegraph.$$.fragment, local);
	      current = false;
	    },
	    d: function d(detaching) {
	      destroy_component(linegraph, detaching);
	    }
	  };
	} // (229:6) {#if chartData.config.thresholds}


	function create_if_block_8(ctx) {
	  var thresholdlines;
	  var current;
	  thresholdlines = new ThresholdLines({
	    props: {
	      env:
	      /*env*/
	      ctx[0],
	      dimensions:
	      /*$dimensions*/
	      ctx[6]
	    }
	  });
	  return {
	    c: function c() {
	      create_component(thresholdlines.$$.fragment);
	    },
	    m: function m(target, anchor) {
	      mount_component(thresholdlines, target, anchor);
	      current = true;
	    },
	    p: function p(ctx, dirty) {
	      var thresholdlines_changes = {};
	      if (dirty[0] &
	      /*env*/
	      1) thresholdlines_changes.env =
	      /*env*/
	      ctx[0];
	      if (dirty[0] &
	      /*$dimensions*/
	      64) thresholdlines_changes.dimensions =
	      /*$dimensions*/
	      ctx[6];
	      thresholdlines.$set(thresholdlines_changes);
	    },
	    i: function i(local) {
	      if (current) return;
	      transition_in(thresholdlines.$$.fragment, local);
	      current = true;
	    },
	    o: function o(local) {
	      transition_out(thresholdlines.$$.fragment, local);
	      current = false;
	    },
	    d: function d(detaching) {
	      destroy_component(thresholdlines, detaching);
	    }
	  };
	} // (195:2) 


	function create_renderer_slot(ctx) {
	  var g;
	  var current;
	  var if_block =
	  /*layoutReady*/
	  ctx[3] && create_if_block_7(ctx);
	  return {
	    c: function c() {
	      g = svg_element("g");
	      if (if_block) if_block.c();
	      attr(g, "slot", "renderer");
	    },
	    m: function m(target, anchor) {
	      insert(target, g, anchor);
	      if (if_block) if_block.m(g, null);
	      current = true;
	    },
	    p: function p(ctx, dirty) {
	      if (
	      /*layoutReady*/
	      ctx[3]) {
	        if (if_block) {
	          if_block.p(ctx, dirty);

	          if (dirty[0] &
	          /*layoutReady*/
	          8) {
	            transition_in(if_block, 1);
	          }
	        } else {
	          if_block = create_if_block_7(ctx);
	          if_block.c();
	          transition_in(if_block, 1);
	          if_block.m(g, null);
	        }
	      } else if (if_block) {
	        group_outros();
	        transition_out(if_block, 1, 1, function () {
	          if_block = null;
	        });
	        check_outros();
	      }
	    },
	    i: function i(local) {
	      if (current) return;
	      transition_in(if_block);
	      current = true;
	    },
	    o: function o(local) {
	      transition_out(if_block);
	      current = false;
	    },
	    d: function d(detaching) {
	      if (detaching) detach(g);
	      if (if_block) if_block.d();
	    }
	  };
	} // (240:2) {#if layoutReady}


	function create_if_block(ctx) {
	  var draggableswrapper;
	  var t0;
	  var t1;
	  var if_block1_anchor;
	  var current;
	  draggableswrapper = new DraggablesWrapper({
	    props: {
	      env:
	      /*env*/
	      ctx[0],
	      annotations:
	      /*chartData*/
	      ctx[1].config.draggableAnnotations
	    }
	  });
	  var if_block0 =
	  /*tooltipsSupported*/
	  ctx[12] && create_if_block_6(ctx);
	  var if_block1 =
	  /*activeTooltip*/
	  ctx[7] && create_if_block_1(ctx);
	  return {
	    c: function c() {
	      create_component(draggableswrapper.$$.fragment);
	      t0 = space();
	      if (if_block0) if_block0.c();
	      t1 = space();
	      if (if_block1) if_block1.c();
	      if_block1_anchor = empty();
	    },
	    m: function m(target, anchor) {
	      mount_component(draggableswrapper, target, anchor);
	      insert(target, t0, anchor);
	      if (if_block0) if_block0.m(target, anchor);
	      insert(target, t1, anchor);
	      if (if_block1) if_block1.m(target, anchor);
	      insert(target, if_block1_anchor, anchor);
	      current = true;
	    },
	    p: function p(ctx, dirty) {
	      var draggableswrapper_changes = {};
	      if (dirty[0] &
	      /*env*/
	      1) draggableswrapper_changes.env =
	      /*env*/
	      ctx[0];
	      if (dirty[0] &
	      /*chartData*/
	      2) draggableswrapper_changes.annotations =
	      /*chartData*/
	      ctx[1].config.draggableAnnotations;
	      draggableswrapper.$set(draggableswrapper_changes);

	      if (
	      /*tooltipsSupported*/
	      ctx[12]) {
	        if (if_block0) {
	          if_block0.p(ctx, dirty);

	          if (dirty[0] &
	          /*tooltipsSupported*/
	          4096) {
	            transition_in(if_block0, 1);
	          }
	        } else {
	          if_block0 = create_if_block_6(ctx);
	          if_block0.c();
	          transition_in(if_block0, 1);
	          if_block0.m(t1.parentNode, t1);
	        }
	      } else if (if_block0) {
	        group_outros();
	        transition_out(if_block0, 1, 1, function () {
	          if_block0 = null;
	        });
	        check_outros();
	      }

	      if (
	      /*activeTooltip*/
	      ctx[7]) {
	        if (if_block1) {
	          if_block1.p(ctx, dirty);

	          if (dirty[0] &
	          /*activeTooltip*/
	          128) {
	            transition_in(if_block1, 1);
	          }
	        } else {
	          if_block1 = create_if_block_1(ctx);
	          if_block1.c();
	          transition_in(if_block1, 1);
	          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
	        }
	      } else if (if_block1) {
	        group_outros();
	        transition_out(if_block1, 1, 1, function () {
	          if_block1 = null;
	        });
	        check_outros();
	      }
	    },
	    i: function i(local) {
	      if (current) return;
	      transition_in(draggableswrapper.$$.fragment, local);
	      transition_in(if_block0);
	      transition_in(if_block1);
	      current = true;
	    },
	    o: function o(local) {
	      transition_out(draggableswrapper.$$.fragment, local);
	      transition_out(if_block0);
	      transition_out(if_block1);
	      current = false;
	    },
	    d: function d(detaching) {
	      destroy_component(draggableswrapper, detaching);
	      if (detaching) detach(t0);
	      if (if_block0) if_block0.d(detaching);
	      if (detaching) detach(t1);
	      if (if_block1) if_block1.d(detaching);
	      if (detaching) detach(if_block1_anchor);
	    }
	  };
	} // (245:4) {#if tooltipsSupported}


	function create_if_block_6(ctx) {
	  var tooltipscreen;
	  var current;
	  tooltipscreen = new TooltipScreen({
	    props: {
	      delaunayPoints:
	      /*tooltipValues*/
	      ctx[8] || []
	    }
	  });
	  tooltipscreen.$on("data",
	  /*data_handler*/
	  ctx[24]);
	  return {
	    c: function c() {
	      create_component(tooltipscreen.$$.fragment);
	    },
	    m: function m(target, anchor) {
	      mount_component(tooltipscreen, target, anchor);
	      current = true;
	    },
	    p: function p(ctx, dirty) {
	      var tooltipscreen_changes = {};
	      if (dirty[0] &
	      /*tooltipValues*/
	      256) tooltipscreen_changes.delaunayPoints =
	      /*tooltipValues*/
	      ctx[8] || [];
	      tooltipscreen.$set(tooltipscreen_changes);
	    },
	    i: function i(local) {
	      if (current) return;
	      transition_in(tooltipscreen.$$.fragment, local);
	      current = true;
	    },
	    o: function o(local) {
	      transition_out(tooltipscreen.$$.fragment, local);
	      current = false;
	    },
	    d: function d(detaching) {
	      destroy_component(tooltipscreen, detaching);
	    }
	  };
	} // (257:4) {#if activeTooltip}


	function create_if_block_1(ctx) {
	  var tooltip;
	  var current;
	  tooltip = new Tooltip({
	    props: {
	      darkTheme: isDarkTheme(
	      /*env*/
	      ctx[0].data,
	      /*env*/
	      ctx[0].options),
	      circleRadius:
	      /*activeTooltip*/
	      ctx[7].radius,
	      circleBuffer: 0,
	      left: "" + (
	      /*activeTooltip*/
	      ctx[7].x + "px"),
	      top: "" + (
	      /*activeTooltip*/
	      ctx[7].y + "px"),
	      minWidth:
	      /*isMobile*/
	      ctx[13] ? '110px' : '140px',
	      containerEl:
	      /*env*/
	      ctx[0].el,
	      $$slots: {
	        default: [create_default_slot]
	      },
	      $$scope: {
	        ctx: ctx
	      }
	    }
	  });
	  return {
	    c: function c() {
	      create_component(tooltip.$$.fragment);
	    },
	    m: function m(target, anchor) {
	      mount_component(tooltip, target, anchor);
	      current = true;
	    },
	    p: function p(ctx, dirty) {
	      var tooltip_changes = {};
	      if (dirty[0] &
	      /*env*/
	      1) tooltip_changes.darkTheme = isDarkTheme(
	      /*env*/
	      ctx[0].data,
	      /*env*/
	      ctx[0].options);
	      if (dirty[0] &
	      /*activeTooltip*/
	      128) tooltip_changes.circleRadius =
	      /*activeTooltip*/
	      ctx[7].radius;
	      if (dirty[0] &
	      /*activeTooltip*/
	      128) tooltip_changes.left = "" + (
	      /*activeTooltip*/
	      ctx[7].x + "px");
	      if (dirty[0] &
	      /*activeTooltip*/
	      128) tooltip_changes.top = "" + (
	      /*activeTooltip*/
	      ctx[7].y + "px");
	      if (dirty[0] &
	      /*isMobile*/
	      8192) tooltip_changes.minWidth =
	      /*isMobile*/
	      ctx[13] ? '110px' : '140px';
	      if (dirty[0] &
	      /*env*/
	      1) tooltip_changes.containerEl =
	      /*env*/
	      ctx[0].el;

	      if (dirty[0] &
	      /*activeTooltip, env, isMobile, chartData, topLabel, bottomLabel*/
	      11395 | dirty[1] &
	      /*$$scope*/
	      32) {
	        tooltip_changes.$$scope = {
	          dirty: dirty,
	          ctx: ctx
	        };
	      }

	      tooltip.$set(tooltip_changes);
	    },
	    i: function i(local) {
	      if (current) return;
	      transition_in(tooltip.$$.fragment, local);
	      current = true;
	    },
	    o: function o(local) {
	      transition_out(tooltip.$$.fragment, local);
	      current = false;
	    },
	    d: function d(detaching) {
	      destroy_component(tooltip, detaching);
	    }
	  };
	} // (268:8) {#if tooltipConfig.primary.enabled}


	function create_if_block_5(ctx) {
	  var tooltipfield;
	  var current;
	  tooltipfield = new TooltipField({
	    props: {
	      value:
	      /*primaryField*/
	      ctx[16].data[
	      /*activeTooltip*/
	      ctx[7].index],
	      label:
	      /*tooltipConfig*/
	      ctx[20].primary.label ||
	      /*bottomLabel*/
	      ctx[11],
	      field:
	      /*primaryField*/
	      ctx[16],
	      env:
	      /*env*/
	      ctx[0],
	      isMobile:
	      /*isMobile*/
	      ctx[13],
	      formatOptions: {
	        decimalPlaces: getConfigValue(
	        /*chartData*/
	        ctx[1], 'tooltipDecimalsPrimary', 'decimalsPrimary')
	      }
	    }
	  });
	  return {
	    c: function c() {
	      create_component(tooltipfield.$$.fragment);
	    },
	    m: function m(target, anchor) {
	      mount_component(tooltipfield, target, anchor);
	      current = true;
	    },
	    p: function p(ctx, dirty) {
	      var tooltipfield_changes = {};
	      if (dirty[0] &
	      /*activeTooltip*/
	      128) tooltipfield_changes.value =
	      /*primaryField*/
	      ctx[16].data[
	      /*activeTooltip*/
	      ctx[7].index];
	      if (dirty[0] &
	      /*bottomLabel*/
	      2048) tooltipfield_changes.label =
	      /*tooltipConfig*/
	      ctx[20].primary.label ||
	      /*bottomLabel*/
	      ctx[11];
	      if (dirty[0] &
	      /*env*/
	      1) tooltipfield_changes.env =
	      /*env*/
	      ctx[0];
	      if (dirty[0] &
	      /*isMobile*/
	      8192) tooltipfield_changes.isMobile =
	      /*isMobile*/
	      ctx[13];
	      if (dirty[0] &
	      /*chartData*/
	      2) tooltipfield_changes.formatOptions = {
	        decimalPlaces: getConfigValue(
	        /*chartData*/
	        ctx[1], 'tooltipDecimalsPrimary', 'decimalsPrimary')
	      };
	      tooltipfield.$set(tooltipfield_changes);
	    },
	    i: function i(local) {
	      if (current) return;
	      transition_in(tooltipfield.$$.fragment, local);
	      current = true;
	    },
	    o: function o(local) {
	      transition_out(tooltipfield.$$.fragment, local);
	      current = false;
	    },
	    d: function d(detaching) {
	      destroy_component(tooltipfield, detaching);
	    }
	  };
	} // (280:8) {#if tooltipConfig.secondary.enabled}


	function create_if_block_4(ctx) {
	  var tooltipfield;
	  var current;
	  tooltipfield = new TooltipField({
	    props: {
	      value:
	      /*secondaryField*/
	      ctx[17].data[
	      /*activeTooltip*/
	      ctx[7].index],
	      label:
	      /*tooltipConfig*/
	      ctx[20].secondary.label ||
	      /*topLabel*/
	      ctx[10],
	      field:
	      /*secondaryField*/
	      ctx[17],
	      env:
	      /*env*/
	      ctx[0],
	      isMobile:
	      /*isMobile*/
	      ctx[13],
	      formatOptions: {
	        decimalPlaces: getConfigValue(
	        /*chartData*/
	        ctx[1], 'tooltipDecimalsSecondary', 'decimalsSecondary')
	      }
	    }
	  });
	  return {
	    c: function c() {
	      create_component(tooltipfield.$$.fragment);
	    },
	    m: function m(target, anchor) {
	      mount_component(tooltipfield, target, anchor);
	      current = true;
	    },
	    p: function p(ctx, dirty) {
	      var tooltipfield_changes = {};
	      if (dirty[0] &
	      /*activeTooltip*/
	      128) tooltipfield_changes.value =
	      /*secondaryField*/
	      ctx[17].data[
	      /*activeTooltip*/
	      ctx[7].index];
	      if (dirty[0] &
	      /*topLabel*/
	      1024) tooltipfield_changes.label =
	      /*tooltipConfig*/
	      ctx[20].secondary.label ||
	      /*topLabel*/
	      ctx[10];
	      if (dirty[0] &
	      /*env*/
	      1) tooltipfield_changes.env =
	      /*env*/
	      ctx[0];
	      if (dirty[0] &
	      /*isMobile*/
	      8192) tooltipfield_changes.isMobile =
	      /*isMobile*/
	      ctx[13];
	      if (dirty[0] &
	      /*chartData*/
	      2) tooltipfield_changes.formatOptions = {
	        decimalPlaces: getConfigValue(
	        /*chartData*/
	        ctx[1], 'tooltipDecimalsSecondary', 'decimalsSecondary')
	      };
	      tooltipfield.$set(tooltipfield_changes);
	    },
	    i: function i(local) {
	      if (current) return;
	      transition_in(tooltipfield.$$.fragment, local);
	      current = true;
	    },
	    o: function o(local) {
	      transition_out(tooltipfield.$$.fragment, local);
	      current = false;
	    },
	    d: function d(detaching) {
	      destroy_component(tooltipfield, detaching);
	    }
	  };
	} // (293:8) {#if scaleField && tooltipConfig.scale.enabled}


	function create_if_block_3(ctx) {
	  var tooltipfield;
	  var current;
	  tooltipfield = new TooltipField({
	    props: {
	      value:
	      /*scaleField*/
	      ctx[18].data[
	      /*activeTooltip*/
	      ctx[7].index],
	      field:
	      /*scaleField*/
	      ctx[18],
	      label:
	      /*tooltipConfig*/
	      ctx[20].scale.label || getConfigValue(
	      /*chartData*/
	      ctx[1], 'scaleLegendLabel'),
	      env:
	      /*env*/
	      ctx[0],
	      isMobile:
	      /*isMobile*/
	      ctx[13],
	      formatOptions: {
	        decimalPlaces: getConfigValue(
	        /*chartData*/
	        ctx[1], 'scaleTooltipPrecision', 'scalePrecision'),
	        unitBefore: getConfigValue(
	        /*chartData*/
	        ctx[1], 'scalePrefix'),
	        unitAfter: getConfigValue(
	        /*chartData*/
	        ctx[1], 'scalePostfix')
	      }
	    }
	  });
	  return {
	    c: function c() {
	      create_component(tooltipfield.$$.fragment);
	    },
	    m: function m(target, anchor) {
	      mount_component(tooltipfield, target, anchor);
	      current = true;
	    },
	    p: function p(ctx, dirty) {
	      var tooltipfield_changes = {};
	      if (dirty[0] &
	      /*activeTooltip*/
	      128) tooltipfield_changes.value =
	      /*scaleField*/
	      ctx[18].data[
	      /*activeTooltip*/
	      ctx[7].index];
	      if (dirty[0] &
	      /*chartData*/
	      2) tooltipfield_changes.label =
	      /*tooltipConfig*/
	      ctx[20].scale.label || getConfigValue(
	      /*chartData*/
	      ctx[1], 'scaleLegendLabel');
	      if (dirty[0] &
	      /*env*/
	      1) tooltipfield_changes.env =
	      /*env*/
	      ctx[0];
	      if (dirty[0] &
	      /*isMobile*/
	      8192) tooltipfield_changes.isMobile =
	      /*isMobile*/
	      ctx[13];
	      if (dirty[0] &
	      /*chartData*/
	      2) tooltipfield_changes.formatOptions = {
	        decimalPlaces: getConfigValue(
	        /*chartData*/
	        ctx[1], 'scaleTooltipPrecision', 'scalePrecision'),
	        unitBefore: getConfigValue(
	        /*chartData*/
	        ctx[1], 'scalePrefix'),
	        unitAfter: getConfigValue(
	        /*chartData*/
	        ctx[1], 'scalePostfix')
	      };
	      tooltipfield.$set(tooltipfield_changes);
	    },
	    i: function i(local) {
	      if (current) return;
	      transition_in(tooltipfield.$$.fragment, local);
	      current = true;
	    },
	    o: function o(local) {
	      transition_out(tooltipfield.$$.fragment, local);
	      current = false;
	    },
	    d: function d(detaching) {
	      destroy_component(tooltipfield, detaching);
	    }
	  };
	} // (308:8) {#if gradientField && tooltipConfig.gradient.enabled}


	function create_if_block_2(ctx) {
	  var tooltipfield;
	  var current;
	  tooltipfield = new TooltipField({
	    props: {
	      value:
	      /*gradientField*/
	      ctx[19].data[
	      /*activeTooltip*/
	      ctx[7].index],
	      field:
	      /*gradientField*/
	      ctx[19],
	      label:
	      /*tooltipConfig*/
	      ctx[20].gradient.label,
	      env:
	      /*env*/
	      ctx[0],
	      isMobile:
	      /*isMobile*/
	      ctx[13],
	      formatOptions: {
	        decimalPlaces: getConfigValue(
	        /*chartData*/
	        ctx[1], 'gradientTooltipDecimals', 'gradientDecimals'),
	        unitBefore: getConfigValue(
	        /*chartData*/
	        ctx[1], 'gradientPrefix'),
	        unitAfter: getConfigValue(
	        /*chartData*/
	        ctx[1], 'gradientPostfix')
	      }
	    }
	  });
	  return {
	    c: function c() {
	      create_component(tooltipfield.$$.fragment);
	    },
	    m: function m(target, anchor) {
	      mount_component(tooltipfield, target, anchor);
	      current = true;
	    },
	    p: function p(ctx, dirty) {
	      var tooltipfield_changes = {};
	      if (dirty[0] &
	      /*activeTooltip*/
	      128) tooltipfield_changes.value =
	      /*gradientField*/
	      ctx[19].data[
	      /*activeTooltip*/
	      ctx[7].index];
	      if (dirty[0] &
	      /*env*/
	      1) tooltipfield_changes.env =
	      /*env*/
	      ctx[0];
	      if (dirty[0] &
	      /*isMobile*/
	      8192) tooltipfield_changes.isMobile =
	      /*isMobile*/
	      ctx[13];
	      if (dirty[0] &
	      /*chartData*/
	      2) tooltipfield_changes.formatOptions = {
	        decimalPlaces: getConfigValue(
	        /*chartData*/
	        ctx[1], 'gradientTooltipDecimals', 'gradientDecimals'),
	        unitBefore: getConfigValue(
	        /*chartData*/
	        ctx[1], 'gradientPrefix'),
	        unitAfter: getConfigValue(
	        /*chartData*/
	        ctx[1], 'gradientPostfix')
	      };
	      tooltipfield.$set(tooltipfield_changes);
	    },
	    i: function i(local) {
	      if (current) return;
	      transition_in(tooltipfield.$$.fragment, local);
	      current = true;
	    },
	    o: function o(local) {
	      transition_out(tooltipfield.$$.fragment, local);
	      current = false;
	    },
	    d: function d(detaching) {
	      destroy_component(tooltipfield, detaching);
	    }
	  };
	} // (258:6) <Tooltip         darkTheme={isDarkTheme(env.data, env.options)}         circleRadius={activeTooltip.radius}         circleBuffer={0}         left="{activeTooltip.x}px"         top="{activeTooltip.y}px"         minWidth={isMobile ? '110px' : '140px'}         containerEl={env.el}       >


	function create_default_slot(ctx) {
	  var b;
	  var t0_value =
	  /*activeTooltip*/
	  ctx[7].label + "";
	  var t0;
	  var t1;
	  var t2;
	  var t3;
	  var t4;
	  var if_block3_anchor;
	  var current;
	  var if_block0 =
	  /*tooltipConfig*/
	  ctx[20].primary.enabled && create_if_block_5(ctx);
	  var if_block1 =
	  /*tooltipConfig*/
	  ctx[20].secondary.enabled && create_if_block_4(ctx);
	  var if_block2 =
	  /*scaleField*/
	  ctx[18] &&
	  /*tooltipConfig*/
	  ctx[20].scale.enabled && create_if_block_3(ctx);
	  var if_block3 =
	  /*gradientField*/
	  ctx[19] &&
	  /*tooltipConfig*/
	  ctx[20].gradient.enabled && create_if_block_2(ctx);
	  return {
	    c: function c() {
	      b = element("b");
	      t0 = text(t0_value);
	      t1 = space();
	      if (if_block0) if_block0.c();
	      t2 = space();
	      if (if_block1) if_block1.c();
	      t3 = space();
	      if (if_block2) if_block2.c();
	      t4 = space();
	      if (if_block3) if_block3.c();
	      if_block3_anchor = empty();
	      attr(b, "class", "small-label svelte-rooqy0");
	    },
	    m: function m(target, anchor) {
	      insert(target, b, anchor);
	      append(b, t0);
	      insert(target, t1, anchor);
	      if (if_block0) if_block0.m(target, anchor);
	      insert(target, t2, anchor);
	      if (if_block1) if_block1.m(target, anchor);
	      insert(target, t3, anchor);
	      if (if_block2) if_block2.m(target, anchor);
	      insert(target, t4, anchor);
	      if (if_block3) if_block3.m(target, anchor);
	      insert(target, if_block3_anchor, anchor);
	      current = true;
	    },
	    p: function p(ctx, dirty) {
	      if ((!current || dirty[0] &
	      /*activeTooltip*/
	      128) && t0_value !== (t0_value =
	      /*activeTooltip*/
	      ctx[7].label + "")) set_data(t0, t0_value);
	      if (
	      /*tooltipConfig*/
	      ctx[20].primary.enabled) if_block0.p(ctx, dirty);
	      if (
	      /*tooltipConfig*/
	      ctx[20].secondary.enabled) if_block1.p(ctx, dirty);
	      if (
	      /*scaleField*/
	      ctx[18] &&
	      /*tooltipConfig*/
	      ctx[20].scale.enabled) if_block2.p(ctx, dirty);
	      if (
	      /*gradientField*/
	      ctx[19] &&
	      /*tooltipConfig*/
	      ctx[20].gradient.enabled) if_block3.p(ctx, dirty);
	    },
	    i: function i(local) {
	      if (current) return;
	      transition_in(if_block0);
	      transition_in(if_block1);
	      transition_in(if_block2);
	      transition_in(if_block3);
	      current = true;
	    },
	    o: function o(local) {
	      transition_out(if_block0);
	      transition_out(if_block1);
	      transition_out(if_block2);
	      transition_out(if_block3);
	      current = false;
	    },
	    d: function d(detaching) {
	      if (detaching) detach(b);
	      if (detaching) detach(t1);
	      if (if_block0) if_block0.d(detaching);
	      if (detaching) detach(t2);
	      if (if_block1) if_block1.d(detaching);
	      if (detaching) detach(t3);
	      if (if_block2) if_block2.d(detaching);
	      if (detaching) detach(t4);
	      if (if_block3) if_block3.d(detaching);
	      if (detaching) detach(if_block3_anchor);
	    }
	  };
	}

	function create_fragment(ctx) {
	  var dualaxislayout;
	  var t0;
	  var div0;
	  var t1;
	  var div1;
	  var div1_resize_listener;
	  var current;
	  dualaxislayout = new DualAxisLayout({
	    props: {
	      env:
	      /*env*/
	      ctx[0],
	      aspectRatio: getAspectRatio(
	      /*chartData*/
	      ctx[1], '4:3', undefined,
	      /*env*/
	      ctx[0].options),
	      yAxisInnerPadding: 0,
	      yAxisPosition: "right",
	      xAxisPosition: "bottom",
	      xAxisLabel:
	      /*bottomLabel*/
	      ctx[11],
	      yAxisLabel:
	      /*topLabel*/
	      ctx[10],
	      $$slots: {
	        renderer: [create_renderer_slot, function (_ref) {
	          var xRange = _ref.xRange,
	              yRange = _ref.yRange,
	              afterRenderX = _ref.afterRenderX,
	              afterRenderY = _ref.afterRenderY;
	          return {
	            32: xRange,
	            33: yRange,
	            34: afterRenderX,
	            35: afterRenderY
	          };
	        }, function (_ref2) {
	          var xRange = _ref2.xRange,
	              yRange = _ref2.yRange,
	              afterRenderX = _ref2.afterRenderX,
	              afterRenderY = _ref2.afterRenderY;
	          return [0, (xRange ? 2 : 0) | (yRange ? 4 : 0) | (afterRenderX ? 8 : 0) | (afterRenderY ? 16 : 0)];
	        }],
	        "y-axis": [create_y_axis_slot, function (_ref3) {
	          var xRange = _ref3.xRange,
	              yRange = _ref3.yRange,
	              afterRenderX = _ref3.afterRenderX,
	              afterRenderY = _ref3.afterRenderY;
	          return {
	            32: xRange,
	            33: yRange,
	            34: afterRenderX,
	            35: afterRenderY
	          };
	        }, function (_ref4) {
	          var xRange = _ref4.xRange,
	              yRange = _ref4.yRange,
	              afterRenderX = _ref4.afterRenderX,
	              afterRenderY = _ref4.afterRenderY;
	          return [0, (xRange ? 2 : 0) | (yRange ? 4 : 0) | (afterRenderX ? 8 : 0) | (afterRenderY ? 16 : 0)];
	        }],
	        "x-axis": [create_x_axis_slot, function (_ref5) {
	          var xRange = _ref5.xRange,
	              yRange = _ref5.yRange,
	              afterRenderX = _ref5.afterRenderX,
	              afterRenderY = _ref5.afterRenderY;
	          return {
	            32: xRange,
	            33: yRange,
	            34: afterRenderX,
	            35: afterRenderY
	          };
	        }, function (_ref6) {
	          var xRange = _ref6.xRange,
	              yRange = _ref6.yRange,
	              afterRenderX = _ref6.afterRenderX,
	              afterRenderY = _ref6.afterRenderY;
	          return [0, (xRange ? 2 : 0) | (yRange ? 4 : 0) | (afterRenderX ? 8 : 0) | (afterRenderY ? 16 : 0)];
	        }]
	      },
	      $$scope: {
	        ctx: ctx
	      }
	    }
	  });
	  var if_block =
	  /*layoutReady*/
	  ctx[3] && create_if_block(ctx);
	  return {
	    c: function c() {
	      create_component(dualaxislayout.$$.fragment);
	      t0 = space();
	      div0 = element("div");
	      if (if_block) if_block.c();
	      t1 = space();
	      div1 = element("div");
	      attr(div0, "class", "annotation-layer");
	      attr(div0, "style",
	      /*topLayerStyle*/
	      ctx[9]);
	      attr(div1, "class", "empty-margin svelte-rooqy0");
	      add_render_callback(function () {
	        return (
	          /*div1_elementresize_handler*/
	          ctx[25].call(div1)
	        );
	      });
	    },
	    m: function m(target, anchor) {
	      mount_component(dualaxislayout, target, anchor);
	      insert(target, t0, anchor);
	      insert(target, div0, anchor);
	      if (if_block) if_block.m(div0, null);
	      insert(target, t1, anchor);
	      insert(target, div1, anchor);
	      div1_resize_listener = add_resize_listener(div1,
	      /*div1_elementresize_handler*/
	      ctx[25].bind(div1));
	      current = true;
	    },
	    p: function p(ctx, dirty) {
	      var dualaxislayout_changes = {};
	      if (dirty[0] &
	      /*env*/
	      1) dualaxislayout_changes.env =
	      /*env*/
	      ctx[0];
	      if (dirty[0] &
	      /*chartData, env*/
	      3) dualaxislayout_changes.aspectRatio = getAspectRatio(
	      /*chartData*/
	      ctx[1], '4:3', undefined,
	      /*env*/
	      ctx[0].options);
	      if (dirty[0] &
	      /*bottomLabel*/
	      2048) dualaxislayout_changes.xAxisLabel =
	      /*bottomLabel*/
	      ctx[11];
	      if (dirty[0] &
	      /*topLabel*/
	      1024) dualaxislayout_changes.yAxisLabel =
	      /*topLabel*/
	      ctx[10];

	      if (dirty[0] &
	      /*env, $dimensions, chartData, activeTooltip, $xAxis, $yAxis, layoutReady*/
	      251 | dirty[1] &
	      /*$$scope, yRange, afterRenderY, xRange, afterRenderX*/
	      62) {
	        dualaxislayout_changes.$$scope = {
	          dirty: dirty,
	          ctx: ctx
	        };
	      }

	      dualaxislayout.$set(dualaxislayout_changes);

	      if (
	      /*layoutReady*/
	      ctx[3]) {
	        if (if_block) {
	          if_block.p(ctx, dirty);

	          if (dirty[0] &
	          /*layoutReady*/
	          8) {
	            transition_in(if_block, 1);
	          }
	        } else {
	          if_block = create_if_block(ctx);
	          if_block.c();
	          transition_in(if_block, 1);
	          if_block.m(div0, null);
	        }
	      } else if (if_block) {
	        group_outros();
	        transition_out(if_block, 1, 1, function () {
	          if_block = null;
	        });
	        check_outros();
	      }

	      if (!current || dirty[0] &
	      /*topLayerStyle*/
	      512) {
	        attr(div0, "style",
	        /*topLayerStyle*/
	        ctx[9]);
	      }
	    },
	    i: function i(local) {
	      if (current) return;
	      transition_in(dualaxislayout.$$.fragment, local);
	      transition_in(if_block);
	      current = true;
	    },
	    o: function o(local) {
	      transition_out(dualaxislayout.$$.fragment, local);
	      transition_out(if_block);
	      current = false;
	    },
	    d: function d(detaching) {
	      destroy_component(dualaxislayout, detaching);
	      if (detaching) detach(t0);
	      if (detaching) detach(div0);
	      if (if_block) if_block.d();
	      if (detaching) detach(t1);
	      if (detaching) detach(div1);
	      div1_resize_listener();
	    }
	  };
	}

	var INDEX_LABEL = 0;
	var INDEX_X = 1;
	var INDEX_Y = 2;

	function instance($$self, $$props, $$invalidate) {
	  var _env$el$classList;

	  var isMobile;
	  var tooltipsSupported;
	  var layoutReady;
	  var bottomLabel;
	  var topLabel;
	  var topLayerStyle;
	  var tooltipValues;
	  var $yAxis;
	  var $xAxis;
	  var $dimensions;
	  var $layout;
	  component_subscribe($$self, yAxis, function ($$value) {
	    return $$invalidate(4, $yAxis = $$value);
	  });
	  component_subscribe($$self, xAxis, function ($$value) {
	    return $$invalidate(5, $xAxis = $$value);
	  });
	  component_subscribe($$self, dimensions, function ($$value) {
	    return $$invalidate(6, $dimensions = $$value);
	  });
	  component_subscribe($$self, layout, function ($$value) {
	    return $$invalidate(23, $layout = $$value);
	  });
	  var env = $$props.env;
	  var chartData = $$props.chartData;
	  var onRender = $$props.onRender;
	  var clientWidth;
	  var activeTooltip;
	  var lastDimensions;
	  var displayZeroDomain = shouldDisplayDomain(env); // these are all options that can be set via toaster advanced options

	  var DEFAULTS = {
	    // radius of scatterplot dot
	    dotRadius: 5
	  };
	  env.options = _objectSpread2(_objectSpread2({}, DEFAULTS), env.options); // set our classes on el

	  var classes = ['toaster-chart-scatterplot', displayZeroDomain ? undefined : 'no-domain'];

	  (_env$el$classList = env.el.classList).add.apply(_env$el$classList, classes);

	  var taxonomy = scatterPlotTaxonomy(chartData); // scatterPlot transform for fields

	  transformMultiNumericAxisFields(chartData, taxonomy);

	  var _propertyScales = propertyScales(env, taxonomy),
	      radiusScale = _propertyScales.radiusScale;

	  var primaryField = taxonomy.primaryField,
	      secondaryField = taxonomy.secondaryField,
	      scaleField = taxonomy.scaleField,
	      gradientField = taxonomy.gradientField;
	  var tooltipConfig = chartData.config.tooltipFields || {
	    primary: {
	      enabled: true,
	      label: primaryField.name
	    },
	    secondary: {
	      enabled: true,
	      label: secondaryField.name
	    },
	    scale: {
	      enabled: true,
	      label: scaleField === null || scaleField === void 0 ? void 0 : scaleField.name
	    },
	    gradient: {
	      enabled: true,
	      label: gradientField === null || gradientField === void 0 ? void 0 : gradientField.name
	    }
	  };

	  var data_handler = function data_handler(event) {
	    if (event && event.detail) {
	      $$invalidate(7, activeTooltip = event === null || event === void 0 ? void 0 : event.detail);
	    } else {
	      $$invalidate(7, activeTooltip = null);
	    }
	  };

	  function div1_elementresize_handler() {
	    clientWidth = this.offsetWidth;
	    $$invalidate(2, clientWidth);
	  }

	  $$self.$$set = function ($$props) {
	    if ('env' in $$props) $$invalidate(0, env = $$props.env);
	    if ('chartData' in $$props) $$invalidate(1, chartData = $$props.chartData);
	    if ('onRender' in $$props) $$invalidate(21, onRender = $$props.onRender);
	  };

	  $$self.$$.update = function () {
	    if ($$self.$$.dirty[0] &
	    /*clientWidth, env*/
	    5) {
	      $$invalidate(13, isMobile = isMobileWidth(clientWidth, env.options));
	    }

	    if ($$self.$$.dirty[0] &
	    /*env, chartData*/
	    3) {
	      $$invalidate(12, tooltipsSupported = !(env.options.disableTooltip || chartData.config.disableTooltip));
	    }

	    if ($$self.$$.dirty[0] &
	    /*$xAxis, $yAxis, $layout, $dimensions*/
	    8388720) {
	      $$invalidate(3, layoutReady = $xAxis && $yAxis && $layout && $dimensions);
	    }

	    if ($$self.$$.dirty[0] &
	    /*chartData*/
	    2) {
	      chartData.fields[INDEX_LABEL];
	    }

	    if ($$self.$$.dirty[0] &
	    /*chartData*/
	    2) {
	      chartData.fields[INDEX_X];
	    }

	    if ($$self.$$.dirty[0] &
	    /*chartData*/
	    2) {
	      chartData.fields[INDEX_Y];
	    }

	    if ($$self.$$.dirty[0] &
	    /*chartData*/
	    2) {
	      $$invalidate(11, bottomLabel = chartData.config.labelPrimary);
	    }

	    if ($$self.$$.dirty[0] &
	    /*chartData*/
	    2) {
	      $$invalidate(10, topLabel = chartData.config.labelSecondary);
	    }

	    if ($$self.$$.dirty[0] &
	    /*layoutReady, $dimensions, env, $layout, lastDimensions, onRender*/
	    14680137) {
	      {
	        if (layoutReady && $dimensions) {
	          placeVerticalAxisLabel(env, false, {
	            noLabelPadding: true
	          }, $dimensions);
	          placeHorizontalAxisLabel(env);
	          extendXAxisDomainBaseline(env);
	          $layout.updateAllBounds();

	          if (dimensionsChanged($dimensions, lastDimensions)) {
	            $$invalidate(22, lastDimensions = {
	              width: $dimensions.width,
	              height: $dimensions.height
	            });

	            if (onRender) {
	              setTimeout(onRender, 1);
	            }
	          }
	        }
	      }
	    }

	    if ($$self.$$.dirty[0] &
	    /*layoutReady, $dimensions*/
	    72) {
	      $$invalidate(9, topLayerStyle = layoutReady && "\n    position: absolute;\n    top: ".concat($dimensions.top, "px;\n    left: ").concat($dimensions.left, "px;\n    width: ").concat($dimensions.width, "px;\n    height: ").concat($dimensions.height, "px;\n  "));
	    }

	    if ($$self.$$.dirty[0] &
	    /*layoutReady, chartData, $xAxis, $yAxis*/
	    58) {
	      $$invalidate(8, tooltipValues = layoutReady && chartData.data.map(function (row, i) {
	        return {
	          index: i,
	          label: row[INDEX_LABEL],
	          x: $xAxis.scale(row[INDEX_X]),
	          y: $yAxis.scale(row[INDEX_Y]),
	          radius: radiusScale(i)
	        };
	      }));
	    }
	  };

	  return [env, chartData, clientWidth, layoutReady, $yAxis, $xAxis, $dimensions, activeTooltip, tooltipValues, topLayerStyle, topLabel, bottomLabel, tooltipsSupported, isMobile, displayZeroDomain, taxonomy, primaryField, secondaryField, scaleField, gradientField, tooltipConfig, onRender, lastDimensions, $layout, data_handler, div1_elementresize_handler];
	}

	var ScatterPlot = /*#__PURE__*/function (_SvelteComponent) {
	  _inherits(ScatterPlot, _SvelteComponent);

	  var _super = _createSuper(ScatterPlot);

	  function ScatterPlot(options) {
	    var _this;

	    _classCallCheck(this, ScatterPlot);

	    _this = _super.call(this);
	    init(_assertThisInitialized(_this), options, instance, create_fragment, safe_not_equal, {
	      env: 0,
	      chartData: 1,
	      onRender: 21
	    }, add_css, [-1, -1]);
	    return _this;
	  }

	  _createClass(ScatterPlot, [{
	    key: "env",
	    get: function get() {
	      return this.$$.ctx[0];
	    },
	    set: function set(env) {
	      this.$$set({
	        env: env
	      });
	      flush();
	    }
	  }, {
	    key: "chartData",
	    get: function get() {
	      return this.$$.ctx[1];
	    },
	    set: function set(chartData) {
	      this.$$set({
	        chartData: chartData
	      });
	      flush();
	    }
	  }, {
	    key: "onRender",
	    get: function get() {
	      return this.$$.ctx[21];
	    },
	    set: function set(onRender) {
	      this.$$set({
	        onRender: onRender
	      });
	      flush();
	    }
	  }]);

	  return ScatterPlot;
	}(SvelteComponent);

	// a simple interface

	function axisFrame(target, options) {
	  var defaults = {
	    theme: 'business',
	    orientation: HORIZONTAL,
	    // set to ensure a band axis is used
	    forceDiscrete: false,
	    // ensure zero is included in domain
	    domainFromZero: false,
	    // treat year values as continuous rather than discrete
	    yearsAsContinuous: true,
	    // no padding around the chart frame
	    noPadding: true,
	    // show the horizontal grid
	    showGrid: false,
	    prefixSecondary: undefined,
	    postfixSecondary: undefined,
	    // TO IMPLEMENT !!
	    aspectRatio: '5:2',
	    unitBefore: 'asdf',
	    min: 0,
	    // allow an onComplete event to be passed in to return the env
	    onComplete: function onComplete() {
	      return null;
	    },
	    // pass in the domain for x, y
	    // if categorical values you must include the full array
	    x: [],
	    // ['a', 'b', 'c']
	    y: [],
	    // [0, 100]
	    // configuration options for layout manager
	    layoutManager: {
	      yAxisInnerPadding: 10
	    },
	    // configuration for the chart axes
	    dateAxis: {},
	    bandAxis: {
	      outerPadding: 0.0
	    },
	    linearAxis: {// tickStepVertical: 80,
	      // tickLabelAlternate: false
	    }
	  };

	  var opts = _merge(defaults, options);

	  var orientVertical = opts.orientation !== HORIZONTAL;
	  var el = select(target).classed('toaster-chart', true).classed("toaster-theme-".concat(opts.theme), true);
	  var mockData = [];

	  if (!orientVertical) {
	    mockData = opts.x.map(function (val, i) {
	      return [val, opts.y[i]];
	    });
	  } else {
	    mockData = opts.y.map(function (val, i) {
	      return [val, opts.x[i]];
	    });
	  }

	  var chartData = {
	    theme: opts.theme,
	    fields: [{
	      name: ''
	    }, {
	      name: ''
	    }],
	    data: mockData,
	    config: _objectSpread2({}, opts),
	    chartOptions: {}
	  }; // ensure we have a taxonomy specified on the data

	  configTransformsAll(chartData);
	  makeData(chartData, options);
	  opts.forceDiscrete ? columnTaxonomy(chartData) : buildTaxonomy(chartData, false, opts);
	  var env = makeEnv(el, chartData, opts); // depending on the data we either render dateAxis or
	  // bandAxis (for Quarters)

	  var field = chartData.fields[0];
	  var isBandAxis = opts.forceDiscrete || renderWithBandScale(field);
	  var orientation = HORIZONTAL;
	  var yAxisPosition = RIGHT$1;
	  var isDateAxis = false;
	  var isContinuousAxis = false;

	  if (!orientVertical) {
	    isDateAxis = renderChartAsTimeSeries(el, chartData, env.options);
	    isContinuousAxis = renderAxisAsContinuous(el, chartData, env.options);
	  }

	  if (orientVertical) {
	    if (chartData.data.length <= 5) {
	      env.options.bandAxis.horizontalBarHeight = env.options.bandAxis.horizontalBarHeightLarge;
	    } else if (chartData.data.length > 15) {
	      env.options.bandAxis.horizontalBarHeight = env.options.bandAxis.horizontalBarHeightCondensed;
	    }

	    orientation = VERTICAL;
	    yAxisPosition = LEFT$1;
	    env.options.disableGrid = false;
	    env.options.layoutManager.margin.top = 0;
	    env.options.layoutManager.margin.bottom = 20;
	    env.options.layoutManager.margin.right = 30;
	    env.options.layoutManager.margin.left = 0;
	    env.options.layoutManager.yAxisInnerPadding = env.options.horizontalLayoutPadding;
	    env.options.layoutManager.verticalAxisShift = -5;
	  }

	  el.classed('vertical-flow', orientVertical);

	  var bandAxisConfig = _objectSpread2({
	    isPrimaryAxis: true,
	    stackedBand: true,
	    isDateAxis: isDateAxis,
	    isContinuousAxis: isContinuousAxis
	  }, env.options.bandAxis);

	  var dateAxisConfig = {
	    isPrimaryAxis: true
	  };

	  var linearAxisConfig = _objectSpread2({
	    isPrimaryAxis: false,
	    domainFromZero: opts.domainFromZero,
	    stackedDomain: false
	  }, env.options.linearAxis);

	  var layoutConfig = _objectSpread2({
	    primaryAxis: isBandAxis ? bandAxisProvider(bandAxisConfig) : dateAxisProvider(dateAxisConfig),
	    secondaryAxis: linearAxisProvider(linearAxisConfig),
	    orientation: orientation,
	    yAxisPosition: yAxisPosition
	  }, env.options.layoutManager);

	  var chartLayout = layoutManager(layoutConfig);
	  var chart = el.selectAppend('div.chart');
	  chart.selectAll('*').remove();
	  chart.call(chartLayout, env);
	  var drawArea = chartLayout.draw().classed('dumbbell', true);
	  var gridLength = env.x.rangeLength() + chartLayout.xAxisExtendRight() + 2 * chartLayout.yAxisInnerPadding(); // grid is now a render layer

	  el.classed('no-grid', !opts.showGrid).classed('no-domain', !shouldDisplayDomain(env)).classed('no-axis', env.options.disableGrid); // draw grid

	  if (orientation === HORIZONTAL) {
	    drawArea.selectAppend('g.grid').call(gridlines({
	      length: gridLength
	    }), env);
	  } else {
	    gridLength = env.y.rangeLength() + 2 * chartLayout.xAxisInnerPadding();
	    drawArea.selectAppend('g.grid').call(gridlines({
	      length: gridLength,
	      orientation: Y,
	      hideBottomValueTick: false,
	      extendVerticalZeroTick: true,
	      gridTransform: [0, 0]
	    }), env);
	  }

	  if (!orientVertical) {
	    // allow a layer for highlighting ranges below the chart
	    if (chartData.config.highlightRanges) {
	      var _chartData$config$hig = chartData.config.highlightRanges,
	          ranges = _chartData$config$hig.ranges,
	          rangeStyle = _chartData$config$hig.rangeStyle;
	      drawArea.selectAppend('g.highlight-ranges').call(highlightRanges({
	        ranges: ranges,
	        rangeStyle: rangeStyle,
	        isColumnType: true
	      }), env);
	    }
	  }

	  placeVerticalAxisLabel(env, orientVertical);

	  if (!orientVertical) {
	    // allow horizontal line thresholds
	    if (chartData.config.thresholds) {
	      drawArea.selectAppend('g.threshold-lines').call(thresholdLines(_objectSpread2(_objectSpread2({}, env.options), {}, {
	        thresholds: chartData.config.thresholds
	      })), env);
	    }
	  } // create bottom label if needed


	  chart.call(bottomLabel(), env, chartData); // overflow layout call

	  chartLayout.overflowScale();
	  debugEnv(env);

	  if (opts.onComplete) {
	    opts.onComplete(env);
	  }

	  return env;
	}

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED = '__lodash_hash_undefined__';

	/**
	 * Adds `value` to the array cache.
	 *
	 * @private
	 * @name add
	 * @memberOf SetCache
	 * @alias push
	 * @param {*} value The value to cache.
	 * @returns {Object} Returns the cache instance.
	 */
	function setCacheAdd(value) {
	  this.__data__.set(value, HASH_UNDEFINED);
	  return this;
	}

	/**
	 * Checks if `value` is in the array cache.
	 *
	 * @private
	 * @name has
	 * @memberOf SetCache
	 * @param {*} value The value to search for.
	 * @returns {number} Returns `true` if `value` is found, else `false`.
	 */
	function setCacheHas(value) {
	  return this.__data__.has(value);
	}

	/**
	 *
	 * Creates an array cache object to store unique values.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [values] The values to cache.
	 */
	function SetCache(values) {
	  var index = -1,
	      length = values == null ? 0 : values.length;

	  this.__data__ = new MapCache$1;
	  while (++index < length) {
	    this.add(values[index]);
	  }
	}

	// Add methods to `SetCache`.
	SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
	SetCache.prototype.has = setCacheHas;

	/**
	 * A specialized version of `_.some` for arrays without support for iteratee
	 * shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {boolean} Returns `true` if any element passes the predicate check,
	 *  else `false`.
	 */
	function arraySome(array, predicate) {
	  var index = -1,
	      length = array == null ? 0 : array.length;

	  while (++index < length) {
	    if (predicate(array[index], index, array)) {
	      return true;
	    }
	  }
	  return false;
	}

	/**
	 * Checks if a `cache` value for `key` exists.
	 *
	 * @private
	 * @param {Object} cache The cache to query.
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function cacheHas(cache, key) {
	  return cache.has(key);
	}

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG$3 = 1,
	    COMPARE_UNORDERED_FLAG$1 = 2;

	/**
	 * A specialized version of `baseIsEqualDeep` for arrays with support for
	 * partial deep comparisons.
	 *
	 * @private
	 * @param {Array} array The array to compare.
	 * @param {Array} other The other array to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} stack Tracks traversed `array` and `other` objects.
	 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
	 */
	function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
	  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3,
	      arrLength = array.length,
	      othLength = other.length;

	  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
	    return false;
	  }
	  // Assume cyclic values are equal.
	  var stacked = stack.get(array);
	  if (stacked && stack.get(other)) {
	    return stacked == other;
	  }
	  var index = -1,
	      result = true,
	      seen = (bitmask & COMPARE_UNORDERED_FLAG$1) ? new SetCache : undefined;

	  stack.set(array, other);
	  stack.set(other, array);

	  // Ignore non-index properties.
	  while (++index < arrLength) {
	    var arrValue = array[index],
	        othValue = other[index];

	    if (customizer) {
	      var compared = isPartial
	        ? customizer(othValue, arrValue, index, other, array, stack)
	        : customizer(arrValue, othValue, index, array, other, stack);
	    }
	    if (compared !== undefined) {
	      if (compared) {
	        continue;
	      }
	      result = false;
	      break;
	    }
	    // Recursively compare arrays (susceptible to call stack limits).
	    if (seen) {
	      if (!arraySome(other, function(othValue, othIndex) {
	            if (!cacheHas(seen, othIndex) &&
	                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
	              return seen.push(othIndex);
	            }
	          })) {
	        result = false;
	        break;
	      }
	    } else if (!(
	          arrValue === othValue ||
	            equalFunc(arrValue, othValue, bitmask, customizer, stack)
	        )) {
	      result = false;
	      break;
	    }
	  }
	  stack['delete'](array);
	  stack['delete'](other);
	  return result;
	}

	/**
	 * Converts `map` to its key-value pairs.
	 *
	 * @private
	 * @param {Object} map The map to convert.
	 * @returns {Array} Returns the key-value pairs.
	 */
	function mapToArray(map) {
	  var index = -1,
	      result = Array(map.size);

	  map.forEach(function(value, key) {
	    result[++index] = [key, value];
	  });
	  return result;
	}

	/**
	 * Converts `set` to an array of its values.
	 *
	 * @private
	 * @param {Object} set The set to convert.
	 * @returns {Array} Returns the values.
	 */
	function setToArray(set) {
	  var index = -1,
	      result = Array(set.size);

	  set.forEach(function(value) {
	    result[++index] = value;
	  });
	  return result;
	}

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG$2 = 1,
	    COMPARE_UNORDERED_FLAG = 2;

	/** `Object#toString` result references. */
	var boolTag = '[object Boolean]',
	    dateTag = '[object Date]',
	    errorTag = '[object Error]',
	    mapTag = '[object Map]',
	    numberTag = '[object Number]',
	    regexpTag = '[object RegExp]',
	    setTag = '[object Set]',
	    stringTag = '[object String]',
	    symbolTag = '[object Symbol]';

	var arrayBufferTag = '[object ArrayBuffer]',
	    dataViewTag = '[object DataView]';

	/** Used to convert symbols to primitives and strings. */
	var symbolProto = Symbol$3 ? Symbol$3.prototype : undefined,
	    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

	/**
	 * A specialized version of `baseIsEqualDeep` for comparing objects of
	 * the same `toStringTag`.
	 *
	 * **Note:** This function only supports comparing values with tags of
	 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {string} tag The `toStringTag` of the objects to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} stack Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
	  switch (tag) {
	    case dataViewTag:
	      if ((object.byteLength != other.byteLength) ||
	          (object.byteOffset != other.byteOffset)) {
	        return false;
	      }
	      object = object.buffer;
	      other = other.buffer;

	    case arrayBufferTag:
	      if ((object.byteLength != other.byteLength) ||
	          !equalFunc(new Uint8Array$2(object), new Uint8Array$2(other))) {
	        return false;
	      }
	      return true;

	    case boolTag:
	    case dateTag:
	    case numberTag:
	      // Coerce booleans to `1` or `0` and dates to milliseconds.
	      // Invalid dates are coerced to `NaN`.
	      return eq$1(+object, +other);

	    case errorTag:
	      return object.name == other.name && object.message == other.message;

	    case regexpTag:
	    case stringTag:
	      // Coerce regexes to strings and treat strings, primitives and objects,
	      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
	      // for more details.
	      return object == (other + '');

	    case mapTag:
	      var convert = mapToArray;

	    case setTag:
	      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$2;
	      convert || (convert = setToArray);

	      if (object.size != other.size && !isPartial) {
	        return false;
	      }
	      // Assume cyclic values are equal.
	      var stacked = stack.get(object);
	      if (stacked) {
	        return stacked == other;
	      }
	      bitmask |= COMPARE_UNORDERED_FLAG;

	      // Recursively compare objects (susceptible to call stack limits).
	      stack.set(object, other);
	      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
	      stack['delete'](object);
	      return result;

	    case symbolTag:
	      if (symbolValueOf) {
	        return symbolValueOf.call(object) == symbolValueOf.call(other);
	      }
	  }
	  return false;
	}

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG$1 = 1;

	/** Used for built-in method references. */
	var objectProto$1 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$1 = objectProto$1.hasOwnProperty;

	/**
	 * A specialized version of `baseIsEqualDeep` for objects with support for
	 * partial deep comparisons.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} stack Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
	  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$1,
	      objProps = getAllKeys(object),
	      objLength = objProps.length,
	      othProps = getAllKeys(other),
	      othLength = othProps.length;

	  if (objLength != othLength && !isPartial) {
	    return false;
	  }
	  var index = objLength;
	  while (index--) {
	    var key = objProps[index];
	    if (!(isPartial ? key in other : hasOwnProperty$1.call(other, key))) {
	      return false;
	    }
	  }
	  // Assume cyclic values are equal.
	  var stacked = stack.get(object);
	  if (stacked && stack.get(other)) {
	    return stacked == other;
	  }
	  var result = true;
	  stack.set(object, other);
	  stack.set(other, object);

	  var skipCtor = isPartial;
	  while (++index < objLength) {
	    key = objProps[index];
	    var objValue = object[key],
	        othValue = other[key];

	    if (customizer) {
	      var compared = isPartial
	        ? customizer(othValue, objValue, key, other, object, stack)
	        : customizer(objValue, othValue, key, object, other, stack);
	    }
	    // Recursively compare objects (susceptible to call stack limits).
	    if (!(compared === undefined
	          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
	          : compared
	        )) {
	      result = false;
	      break;
	    }
	    skipCtor || (skipCtor = key == 'constructor');
	  }
	  if (result && !skipCtor) {
	    var objCtor = object.constructor,
	        othCtor = other.constructor;

	    // Non `Object` object instances with different constructors are not equal.
	    if (objCtor != othCtor &&
	        ('constructor' in object && 'constructor' in other) &&
	        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
	          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
	      result = false;
	    }
	  }
	  stack['delete'](object);
	  stack['delete'](other);
	  return result;
	}

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG = 1;

	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]',
	    arrayTag = '[object Array]',
	    objectTag = '[object Object]';

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * A specialized version of `baseIsEqual` for arrays and objects which performs
	 * deep comparisons and tracks traversed objects enabling objects with circular
	 * references to be compared.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
	  var objIsArr = isArray$2(object),
	      othIsArr = isArray$2(other),
	      objTag = objIsArr ? arrayTag : getTag$1(object),
	      othTag = othIsArr ? arrayTag : getTag$1(other);

	  objTag = objTag == argsTag ? objectTag : objTag;
	  othTag = othTag == argsTag ? objectTag : othTag;

	  var objIsObj = objTag == objectTag,
	      othIsObj = othTag == objectTag,
	      isSameTag = objTag == othTag;

	  if (isSameTag && isBuffer$2(object)) {
	    if (!isBuffer$2(other)) {
	      return false;
	    }
	    objIsArr = true;
	    objIsObj = false;
	  }
	  if (isSameTag && !objIsObj) {
	    stack || (stack = new Stack);
	    return (objIsArr || isTypedArray$1(object))
	      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
	      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
	  }
	  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
	    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
	        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

	    if (objIsWrapped || othIsWrapped) {
	      var objUnwrapped = objIsWrapped ? object.value() : object,
	          othUnwrapped = othIsWrapped ? other.value() : other;

	      stack || (stack = new Stack);
	      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
	    }
	  }
	  if (!isSameTag) {
	    return false;
	  }
	  stack || (stack = new Stack);
	  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
	}

	/**
	 * The base implementation of `_.isEqual` which supports partial comparisons
	 * and tracks traversed objects.
	 *
	 * @private
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @param {boolean} bitmask The bitmask flags.
	 *  1 - Unordered comparison
	 *  2 - Partial comparison
	 * @param {Function} [customizer] The function to customize comparisons.
	 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 */
	function baseIsEqual(value, other, bitmask, customizer, stack) {
	  if (value === other) {
	    return true;
	  }
	  if (value == null || other == null || (!isObjectLike$2(value) && !isObjectLike$2(other))) {
	    return value !== value && other !== other;
	  }
	  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
	}

	/**
	 * Performs a deep comparison between two values to determine if they are
	 * equivalent.
	 *
	 * **Note:** This method supports comparing arrays, array buffers, booleans,
	 * date objects, error objects, maps, numbers, `Object` objects, regexes,
	 * sets, strings, symbols, and typed arrays. `Object` objects are compared
	 * by their own, not inherited, enumerable properties. Functions and DOM
	 * nodes are compared by strict equality, i.e. `===`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 * var other = { 'a': 1 };
	 *
	 * _.isEqual(object, other);
	 * // => true
	 *
	 * object === other;
	 * // => false
	 */
	function isEqual(value, other) {
	  return baseIsEqual(value, other);
	}

	/**
	 * Gets the timestamp of the number of milliseconds that have elapsed since
	 * the Unix epoch (1 January 1970 00:00:00 UTC).
	 *
	 * @static
	 * @memberOf _
	 * @since 2.4.0
	 * @category Date
	 * @returns {number} Returns the timestamp.
	 * @example
	 *
	 * _.defer(function(stamp) {
	 *   console.log(_.now() - stamp);
	 * }, _.now());
	 * // => Logs the number of milliseconds it took for the deferred invocation.
	 */
	var now = function() {
	  return root$4.Date.now();
	};

	var now$1 = now;

	/** Error message constants. */
	var FUNC_ERROR_TEXT$1 = 'Expected a function';

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMax = Math.max,
	    nativeMin = Math.min;

	/**
	 * Creates a debounced function that delays invoking `func` until after `wait`
	 * milliseconds have elapsed since the last time the debounced function was
	 * invoked. The debounced function comes with a `cancel` method to cancel
	 * delayed `func` invocations and a `flush` method to immediately invoke them.
	 * Provide `options` to indicate whether `func` should be invoked on the
	 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
	 * with the last arguments provided to the debounced function. Subsequent
	 * calls to the debounced function return the result of the last `func`
	 * invocation.
	 *
	 * **Note:** If `leading` and `trailing` options are `true`, `func` is
	 * invoked on the trailing edge of the timeout only if the debounced function
	 * is invoked more than once during the `wait` timeout.
	 *
	 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
	 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
	 *
	 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
	 * for details over the differences between `_.debounce` and `_.throttle`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Function
	 * @param {Function} func The function to debounce.
	 * @param {number} [wait=0] The number of milliseconds to delay.
	 * @param {Object} [options={}] The options object.
	 * @param {boolean} [options.leading=false]
	 *  Specify invoking on the leading edge of the timeout.
	 * @param {number} [options.maxWait]
	 *  The maximum time `func` is allowed to be delayed before it's invoked.
	 * @param {boolean} [options.trailing=true]
	 *  Specify invoking on the trailing edge of the timeout.
	 * @returns {Function} Returns the new debounced function.
	 * @example
	 *
	 * // Avoid costly calculations while the window size is in flux.
	 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
	 *
	 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
	 * jQuery(element).on('click', _.debounce(sendMail, 300, {
	 *   'leading': true,
	 *   'trailing': false
	 * }));
	 *
	 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
	 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
	 * var source = new EventSource('/stream');
	 * jQuery(source).on('message', debounced);
	 *
	 * // Cancel the trailing debounced invocation.
	 * jQuery(window).on('popstate', debounced.cancel);
	 */
	function debounce(func, wait, options) {
	  var lastArgs,
	      lastThis,
	      maxWait,
	      result,
	      timerId,
	      lastCallTime,
	      lastInvokeTime = 0,
	      leading = false,
	      maxing = false,
	      trailing = true;

	  if (typeof func != 'function') {
	    throw new TypeError(FUNC_ERROR_TEXT$1);
	  }
	  wait = toNumber$1(wait) || 0;
	  if (isObject$2(options)) {
	    leading = !!options.leading;
	    maxing = 'maxWait' in options;
	    maxWait = maxing ? nativeMax(toNumber$1(options.maxWait) || 0, wait) : maxWait;
	    trailing = 'trailing' in options ? !!options.trailing : trailing;
	  }

	  function invokeFunc(time) {
	    var args = lastArgs,
	        thisArg = lastThis;

	    lastArgs = lastThis = undefined;
	    lastInvokeTime = time;
	    result = func.apply(thisArg, args);
	    return result;
	  }

	  function leadingEdge(time) {
	    // Reset any `maxWait` timer.
	    lastInvokeTime = time;
	    // Start the timer for the trailing edge.
	    timerId = setTimeout(timerExpired, wait);
	    // Invoke the leading edge.
	    return leading ? invokeFunc(time) : result;
	  }

	  function remainingWait(time) {
	    var timeSinceLastCall = time - lastCallTime,
	        timeSinceLastInvoke = time - lastInvokeTime,
	        timeWaiting = wait - timeSinceLastCall;

	    return maxing
	      ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
	      : timeWaiting;
	  }

	  function shouldInvoke(time) {
	    var timeSinceLastCall = time - lastCallTime,
	        timeSinceLastInvoke = time - lastInvokeTime;

	    // Either this is the first call, activity has stopped and we're at the
	    // trailing edge, the system time has gone backwards and we're treating
	    // it as the trailing edge, or we've hit the `maxWait` limit.
	    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
	      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
	  }

	  function timerExpired() {
	    var time = now$1();
	    if (shouldInvoke(time)) {
	      return trailingEdge(time);
	    }
	    // Restart the timer.
	    timerId = setTimeout(timerExpired, remainingWait(time));
	  }

	  function trailingEdge(time) {
	    timerId = undefined;

	    // Only invoke if we have `lastArgs` which means `func` has been
	    // debounced at least once.
	    if (trailing && lastArgs) {
	      return invokeFunc(time);
	    }
	    lastArgs = lastThis = undefined;
	    return result;
	  }

	  function cancel() {
	    if (timerId !== undefined) {
	      clearTimeout(timerId);
	    }
	    lastInvokeTime = 0;
	    lastArgs = lastCallTime = lastThis = timerId = undefined;
	  }

	  function flush() {
	    return timerId === undefined ? result : trailingEdge(now$1());
	  }

	  function debounced() {
	    var time = now$1(),
	        isInvoking = shouldInvoke(time);

	    lastArgs = arguments;
	    lastThis = this;
	    lastCallTime = time;

	    if (isInvoking) {
	      if (timerId === undefined) {
	        return leadingEdge(lastCallTime);
	      }
	      if (maxing) {
	        // Handle invocations in a tight loop.
	        clearTimeout(timerId);
	        timerId = setTimeout(timerExpired, wait);
	        return invokeFunc(lastCallTime);
	      }
	    }
	    if (timerId === undefined) {
	      timerId = setTimeout(timerExpired, wait);
	    }
	    return result;
	  }
	  debounced.cancel = cancel;
	  debounced.flush = flush;
	  return debounced;
	}

	/** Error message constants. */
	var FUNC_ERROR_TEXT = 'Expected a function';

	/**
	 * Creates a throttled function that only invokes `func` at most once per
	 * every `wait` milliseconds. The throttled function comes with a `cancel`
	 * method to cancel delayed `func` invocations and a `flush` method to
	 * immediately invoke them. Provide `options` to indicate whether `func`
	 * should be invoked on the leading and/or trailing edge of the `wait`
	 * timeout. The `func` is invoked with the last arguments provided to the
	 * throttled function. Subsequent calls to the throttled function return the
	 * result of the last `func` invocation.
	 *
	 * **Note:** If `leading` and `trailing` options are `true`, `func` is
	 * invoked on the trailing edge of the timeout only if the throttled function
	 * is invoked more than once during the `wait` timeout.
	 *
	 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
	 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
	 *
	 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
	 * for details over the differences between `_.throttle` and `_.debounce`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Function
	 * @param {Function} func The function to throttle.
	 * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
	 * @param {Object} [options={}] The options object.
	 * @param {boolean} [options.leading=true]
	 *  Specify invoking on the leading edge of the timeout.
	 * @param {boolean} [options.trailing=true]
	 *  Specify invoking on the trailing edge of the timeout.
	 * @returns {Function} Returns the new throttled function.
	 * @example
	 *
	 * // Avoid excessively updating the position while scrolling.
	 * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
	 *
	 * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
	 * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
	 * jQuery(element).on('click', throttled);
	 *
	 * // Cancel the trailing throttled invocation.
	 * jQuery(window).on('popstate', throttled.cancel);
	 */
	function throttle(func, wait, options) {
	  var leading = true,
	      trailing = true;

	  if (typeof func != 'function') {
	    throw new TypeError(FUNC_ERROR_TEXT);
	  }
	  if (isObject$2(options)) {
	    leading = 'leading' in options ? !!options.leading : leading;
	    trailing = 'trailing' in options ? !!options.trailing : trailing;
	  }
	  return debounce(func, wait, {
	    'leading': leading,
	    'maxWait': wait,
	    'trailing': trailing
	  });
	}

	var throttledTypeCheck = throttle(typeCheck, 5000);

	var throttledTypeReport = throttle(typeReport, 5000);

	function postTypeCheck(messages) {
	  if (messages && withinIframe()) {
	    console.warn('TYPE CHECK FAIL', messages);
	    window.parent.postMessage({
	      type: 'type-check',
	      messages: messages
	    }, '*');
	  }
	}

	function postTypeReport(report) {
	  if (report && withinIframe()) {
	    window.parent.postMessage({
	      type: 'type-report',
	      report: report
	    }, '*');
	  }
	} // instead of throttling we store current color series
	// on the window and then check if it's different
	// before sending to parent


	function postEditorColorSeries(newSeries, active) {
	  var currentSeries = globalState('currentColorSeries');

	  if (!currentSeries || !isEqual(currentSeries, newSeries)) {
	    globalState('currentColorSeries', newSeries);
	    var message = {
	      type: 'color-series',
	      colorSeries: {
	        active: active,
	        colors: newSeries
	      }
	    };

	    if (newSeries) {
	      if (withinIframe()) {
	        window.parent.postMessage(message, '*');
	      }

	      window.postMessage(message, '*');
	    }
	  }
	}

	function typeChecks(chartType, types, data, options) {
	  throttledTypeCheck(chartType, data, options, postTypeCheck);
	  throttledTypeReport(types, data, options, postTypeReport);
	}
	function editorHooks(chartType, data, options) {
	  // allow exposing customColors to the editor
	  options.editorHooks = {
	    colorSeries: postEditorColorSeries
	  };
	}

	var version = '0.1.0';
	// with defaults

	var scatterPlot = factoryWrapper(ScatterPlot, // svelte Type
	scatterPlotSetup, // an init function for prep/setup
	getScatterPlotConfig // an init function for generating options
	); // map Toaster type string to constructor
	// DH: added more column type aliases because I hate
	// the stackedVbar type name

	var CHART_TYPES = {
	  column: column,
	  columnStacked: columnStacked,
	  horizontalColumn: column,
	  horizontalColumnStacked: columnStacked,
	  bar: column,
	  hbar: column,
	  horizontalBar: column,
	  stackedVbar: columnStacked,
	  stackedHbar: columnStacked,
	  line: line,
	  area: area,
	  table: table,
	  barline: barline,
	  pie: pie,
	  performanceChart: spread,
	  multiples: spread$1,
	  dumbbell: dumbbell,
	  horizontalDumbbell: dumbbell,
	  comparison: comparisonChart,
	  scatterPlot: scatterPlot
	};

	function seriesChartFactory(el, data) {
	  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
	  var env = {
	    el: el,
	    data: data,
	    options: options,
	    svelteWrapper: true
	  }; // clear out any existing svelte contexts for

	  destroyState(data.id, 'svelteTypeFactory'); // buildTaxonomy has been moved into each type so that
	  // types can override/define a taxonomy with options

	  makeData(data, options); // if no chart type now we run buildTaxonomy, but this is rare

	  var chartType = CHART_TYPES[data.chartType];

	  if (!chartType) {
	    buildTaxonomy(data, false, options);
	    chartType = determineType(CHART_TYPES, data, options);
	  }

	  if (chartType.isSvelteFactory) {
	    chartType.svelteFactorySetup(env, data, options);
	    options = chartType.svelteFactoryOptions(env, data, options);
	  } // if isEditor is enabled we perform a type check on the
	  // data to return messages back to the editor
	  // also register editor hooks


	  if (options.isEditor) {
	    editorHooks(chartType, data, options);

	    if (!options.suppressTypeCheck) {
	      typeChecks(chartType, CHART_TYPES, data, options);
	    }
	  }

	  return factory$1(el, chartType, data, options);
	} // trying something new :: allow an exportable interface
	// for creating a blank x/y axis in the most basic
	// form possible


	function renderAxisFrame(el, config) {
	  return axisFrame(el, config);
	} // generate toaster.types that map each type to this factory

	var seriesChartTypes = Object.keys(CHART_TYPES).reduce(function (state, key) {
	  state[key] = seriesChartFactory;
	  return state;
	}, {}); // generate a global factory that doesn't collide with any others

	var _globalFactory = globalFactory(seriesChartFactory, seriesChartTypes),
	    types = _globalFactory.types,
	    factory = _globalFactory.factory; // provide an entry point for the terminal client that will
	// asynchronously load data


	function terminalClient(el, config, options) {
	  return terminalClient$1(el, config, factory, options);
	}

	exports.area = area;
	exports.barline = barline;
	exports.chartFactory = factory$1;
	exports.column = column;
	exports.columnStacked = columnStacked;
	exports.comparison = comparisonChart;
	exports.factory = factory;
	exports.line = line;
	exports.performanceChart = spread;
	exports.pie = pie;
	exports.renderAxisFrame = renderAxisFrame;
	exports.scatterPlot = scatterPlot;
	exports.table = table;
	exports.terminalClient = terminalClient;
	exports.tooltip = tooltip;
	exports.types = types;
	exports.version = version;

	Object.defineProperty(exports, '__esModule', { value: true });

	return exports;

})({});
